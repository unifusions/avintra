var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lodashExports = {};
var lodash = {
  get exports() {
    return lodashExports;
  },
  set exports(v) {
    lodashExports = v;
  }
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset2 = array.length;
      while (++index < length) {
        array[offset2 + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data2, result = [];
      while (!(data2 = iterator.next()).done) {
        result.push(data2.value);
      }
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root2._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty2 = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "escape": reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "evaluate": reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        "interpolate": reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        "variable": "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        "imports": {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start2 = view.start, end2 = view.end, length = end2 - start2, index = isRight ? end2 : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data2 = iteratees[iterIndex], iteratee2 = data2.iteratee, type = data2.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result2 = data2[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data2, key) ? data2[key] : undefined$1;
      }
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key] !== undefined$1 : hasOwnProperty2.call(data2, key);
      }
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        return index < 0 ? undefined$1 : data2[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index = assocIndexOf(data2, key);
        if (index < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size2 = data2.size;
        data2.set(key, value);
        this.size += data2.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result2 = data2["delete"](key);
        this.size = data2.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined$1 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start2, end2) {
        var length = array.length;
        start2 = toInteger(start2);
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 === undefined$1 || end2 > length ? length : toInteger(end2);
        if (end2 < 0) {
          end2 += length;
        }
        end2 = start2 > end2 ? 0 : toLength(end2);
        while (start2 < end2) {
          array[start2++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start2, end2) {
        return number >= nativeMin(start2, end2) && number < nativeMax(start2, end2);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data2 = matchData[index];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data2 = matchData[index];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start2, end2, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start2;
          start2 += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start2) {
        return setToString(overRest(func, start2, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data2) {
        metaMap.set(func, data2);
        return func;
      };
      var baseSetToString = !defineProperty2 ? identity : function(func, string) {
        return defineProperty2(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start2, end2) {
        var index = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start2];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions2) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions2, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      var castRest = baseRest;
      function castSlice(array, start2, end2) {
        var length = array.length;
        end2 = end2 === undefined$1 ? length : end2;
        return !start2 && end2 >= length ? array : baseSlice(array, start2, end2);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root2.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order2 = orders[index];
            return result2 * (order2 == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset2 = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset2 + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return fn3.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          return apply(fn3, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data2 = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data2 && isLaziable(data2[0]) && data2[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data2[4].length && data2[9] == 1) {
              wrapper = wrapper[getFuncName(data2[0])].apply(wrapper, data2[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn3 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root2 && this instanceof wrapper) {
            fn3 = Ctor || createCtor(fn3);
          }
          return fn3.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn3 = this && this !== root2 && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn3, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start2, end2, step) {
          if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
            end2 = step = undefined$1;
          }
          start2 = toFinite(start2);
          if (end2 === undefined$1) {
            end2 = start2;
            start2 = 0;
          } else {
            end2 = toFinite(end2);
          }
          step = step === undefined$1 ? start2 < end2 ? 1 : -1 : toFinite(step);
          return baseRange(start2, end2, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data2 = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data2) {
          mergeData(newData, data2);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data2 ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data2 = array[length], otherFunc = data2.func;
          if (otherFunc == null || otherFunc == func) {
            return data2.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data2 = map3.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start2, end2, transforms2) {
        var index = -1, length = transforms2.length;
        while (++index < length) {
          var data2 = transforms2[index], size2 = data2.size;
          switch (data2.type) {
            case "drop":
              start2 += size2;
              break;
            case "dropRight":
              end2 -= size2;
              break;
            case "take":
              end2 = nativeMin(end2, start2 + size2);
              break;
            case "takeRight":
              start2 = nativeMax(start2, end2 - size2);
              break;
          }
        }
        return { "start": start2, "end": end2 };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data2 = getData(other);
        return !!data2 && func === data2[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data2, source) {
        var bitmask = data2[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data2[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data2;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data2[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data2[3];
          data2[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data2[4] = partials ? replaceHolders(data2[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data2[5];
          data2[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data2[6] = partials ? replaceHolders(data2[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data2[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data2[8] = data2[8] == null ? source[8] : nativeMin(data2[8], source[8]);
        }
        if (data2[9] == null) {
          data2[9] = source[9];
        }
        data2[0] = source[0];
        data2[1] = newBitmask;
        return data2;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start2, transform2) {
        start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start2, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start2 + index];
          }
          index = -1;
          var otherArgs = Array2(start2 + 1);
          while (++index < start2) {
            otherArgs[index] = args[index];
          }
          otherArgs[start2] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root2.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference2, bitmask) {
        var source = reference2 + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop2(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start2 && typeof start2 != "number" && isIterateeCall(array, value, start2)) {
          start2 = 0;
          end2 = length;
        }
        return baseFill(array, value, start2, end2);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined$1) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start2, end2) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end2 && typeof end2 != "number" && isIterateeCall(array, start2, end2)) {
          start2 = 0;
          end2 = length;
        } else {
          start2 = start2 == null ? 0 : toInteger(start2);
          end2 = end2 === undefined$1 ? length : toInteger(end2);
        }
        return baseSlice(array, start2, end2);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain2(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start2 = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
          return this.thru(interceptor);
        }
        value = value.slice(start2, +start2 + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain2(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find2 = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root2.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms2) {
        transforms2 = transforms2.length == 1 && isArray2(transforms2[0]) ? arrayMap(transforms2[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms2, 1), baseUnary(getIteratee()));
        var funcsLength = transforms2.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms2[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 === undefined$1 ? start2 : toInteger(start2);
        return baseRest(func, start2);
      }
      function spread2(func, start2) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
        return baseRest(function(args) {
          var array = args[start2], otherArgs = castSlice(args, 0, start2);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement2(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty2(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull2(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create2(prototype2, properties) {
        var result2 = baseCreate(prototype2);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          if (value === undefined$1) {
            index = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start2, end2) {
        start2 = toFinite(start2);
        if (end2 === undefined$1) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        number = toNumber2(number);
        return baseInRange(number, start2, end2);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string, target, position) {
        string = toString3(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end2 = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end2) == target;
      }
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString3(string), n);
      }
      function replace() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit2) {
        if (limit2 && typeof limit2 != "number" && isIterateeCall(string, separator, limit2)) {
          separator = limit2 = undefined$1;
        }
        limit2 = limit2 === undefined$1 ? MAX_ARRAY_LENGTH : limit2 >>> 0;
        if (!limit2) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit2);
          }
        }
        return string.split(separator, limit2);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString3(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString3(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset2 + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start2, end2).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end2).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start2).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end2 = length - stringSize(omission);
        if (end2 < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end2 += result2.length - end2;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end2).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end2 : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end2) != end2) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain3 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain3 || chainAll) {
                var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray(this.__actions__);
                actions2.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root2._ === this) {
          root2._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString3(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max2(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min2(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round2 = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain2;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create2;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop2;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map2;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find2;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement2;
      lodash2.isEmpty = isEmpty2;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull2;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max2;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min2;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round2;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start2, end2) {
        start2 = toInteger(start2);
        var result2 = this;
        if (result2.__filtered__ && (start2 > 0 || end2 < 0)) {
          return new LazyWrapper(result2);
        }
        if (start2 < 0) {
          result2 = result2.takeRight(-start2);
        } else if (start2) {
          result2 = result2.drop(start2);
        }
        if (end2 !== undefined$1) {
          end2 = toInteger(end2);
          result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start2);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root2._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodashExports);
const _ = lodashExports;
var jqueryExports = {};
var jquery = {
  get exports() {
    return jqueryExports;
  },
  set exports(v) {
    jqueryExports = v;
  }
};
/*!
 * jQuery JavaScript Library v3.6.4
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-03-08T15:28Z
 */
(function(module) {
  (function(global2, factory) {
    {
      module.exports = global2.document ? factory(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString3 = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction2 = function isFunction3(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow2(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc) {
      doc = doc || document2;
      var i, val, script = doc.createElement("script");
      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {
          val = node[i] || node.getAttribute && node.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType2(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
    }
    var version = "3.6.4", jQuery2 = function(selector, context) {
      return new jQuery2.fn.init(selector, context);
    };
    jQuery2.fn = jQuery2.prototype = {
      // The current version of jQuery being used
      jquery: version,
      constructor: jQuery2,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        if (num == null) {
          return slice.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery2.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery2.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery2.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery2.grep(this, function(_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery2.grep(this, function(_elem, i) {
          return i % 2;
        }));
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery2.extend = jQuery2.fn.extend = function() {
      var options, name2, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction2(target)) {
        target = {};
      }
      if (i === length) {
        target = this;
        i--;
      }
      for (; i < length; i++) {
        if ((options = arguments[i]) != null) {
          for (name2 in options) {
            copy = options[name2];
            if (name2 === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name2];
              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }
              copyIsArray = false;
              target[name2] = jQuery2.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name2] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery2.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString3.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name2;
        for (name2 in obj) {
          return false;
        }
        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(code, options, doc) {
        DOMEval(code, { nonce: options && options.nonce }, doc);
      },
      each: function(obj, callback) {
        var length, i = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // results is for internal usage only
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike(Object(arr2))) {
            jQuery2.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i) {
        return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function(first, second) {
        var len = +second.length, j = 0, i = first.length;
        for (; j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i < length; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery2.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name2) {
        class2type["[object " + name2 + "]"] = name2.toLowerCase();
      }
    );
    function isArrayLike(obj) {
      var length = !!obj && "length" in obj && obj.length, type = toType2(obj);
      if (isFunction2(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = (
      /*!
       * Sizzle CSS Selector Engine v2.3.10
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://js.foundation/
       *
       * Date: 2023-02-14
       */
      function(window3) {
        var i, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains2, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list2, elem) {
          var i2 = 0, len = list2.length;
          for (; i2 < len; i2++) {
            if (list2[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape2, nonHex) {
          var high = "0x" + escape2.slice(1) - 65536;
          return nonHex ? (
            // Strip the backslash prefix from a non-hex escape sequence
            nonHex
          ) : (
            // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
          );
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "�";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
          },
          { dir: "parentNode", next: "legend" }
        );
        try {
          push2.apply(
            arr2 = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: arr2.length ? (
              // Leverage slice if possible
              function(target, els) {
                pushNative.apply(target, slice2.call(els));
              }
            ) : (
              // Support: IE<9
              // Otherwise append directly
              function(target, els) {
                var j = target.length, i2 = 0;
                while (target[j++] = els[i2++]) {
                }
                target.length = j - 1;
              }
            )
          };
        }
        function Sizzle2(selector, context, results, seed) {
          var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains2(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
              // Exclude object elements
              (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext !== context || !support2.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = nid.replace(rcssescape, fcssescape);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim2, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn3) {
          fn3[expando] = true;
          return fn3;
        }
        function assert(fn3) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn3(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr3 = attrs.split("|"), i2 = arr3.length;
          while (i2--) {
            Expr.attrHandle[arr3[i2]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
          if (diff) {
            return diff;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return name2 === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name2 = elem.nodeName.toLowerCase();
            return (name2 === "input" || name2 === "button") && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                /* jshint -W018 */
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn3) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn3([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j = matchIndexes[i2]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support2 = Sizzle2.support = {};
        isXML = Sizzle2.isXML = function(elem) {
          var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
        };
        setDocument = Sizzle2.setDocument = function(node) {
          var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          docElem = document3.documentElement;
          documentIsHTML = !isXML(document3);
          if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            if (subWindow.addEventListener) {
              subWindow.addEventListener("unload", unloadHandler, false);
            } else if (subWindow.attachEvent) {
              subWindow.attachEvent("onunload", unloadHandler);
            }
          }
          support2.scope = assert(function(el) {
            docElem.appendChild(el).appendChild(document3.createElement("div"));
            return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
          });
          support2.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          });
          support2.attributes = assert(function(el) {
            el.className = "i";
            return !el.getAttribute("className");
          });
          support2.getElementsByTagName = assert(function(el) {
            el.appendChild(document3.createComment(""));
            return !el.getElementsByTagName("*").length;
          });
          support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
          support2.getById = assert(function(el) {
            docElem.appendChild(el).id = expando;
            return !document3.getElementsByName || !document3.getElementsByName(expando).length;
          });
          if (support2.getById) {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i2, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support2.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if (support2.qsa = rnative.test(document3.querySelectorAll)) {
            assert(function(el) {
              var input;
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
              if (el.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              el.querySelectorAll("\\\f");
              rbuggyQSA.push("[\\r\\n\\f]");
            });
            assert(function(el) {
              el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              if (el.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
              }
              if (el.querySelectorAll(":enabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              docElem.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              el.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function(el) {
              support2.disconnectedMatch = matches.call(el, "*");
              matches.call(el, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          if (!support2.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains2 = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a == document3 || a.ownerDocument == preferredDoc && contains2(preferredDoc, a)) {
                return -1;
              }
              if (b == document3 || b.ownerDocument == preferredDoc && contains2(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
            if (!aup || !bup) {
              return a == document3 ? -1 : b == document3 ? 1 : (
                /* eslint-enable eqeqeq */
                aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0
              );
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? (
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck(ap[i2], bp[i2])
            ) : (
              // Otherwise nodes in our document sort first
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              /* eslint-disable eqeqeq */
              ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : (
                /* eslint-enable eqeqeq */
                0
              )
            );
          };
          return document3;
        };
        Sizzle2.matches = function(expr, elements) {
          return Sizzle2(expr, null, null, elements);
        };
        Sizzle2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return Sizzle2(expr, document3, null, [elem]).length > 0;
        };
        Sizzle2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return contains2(context, elem);
        };
        Sizzle2.attr = function(elem, name2) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn3 = Expr.attrHandle[name2.toLowerCase()], val = fn3 && hasOwn2.call(Expr.attrHandle, name2.toLowerCase()) ? fn3(elem, name2, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
        };
        Sizzle2.escape = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support2.detectDuplicates;
          sortInput = !support2.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle2.getText = function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle2.selectors = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                Sizzle2.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(
                className,
                function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                }
              );
            },
            "ATTR": function(name2, operator, check) {
              return function(elem) {
                var result = Sizzle2.attr(elem, name2);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start2.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start2.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args, fn3 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
              if (fn3[expando]) {
                return fn3(argument);
              }
              if (fn3.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn3(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf2(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn3(elem, 0, args);
                };
              }
              return fn3;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle2(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text2) {
              text2 = text2.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || getText(elem)).indexOf(text2) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            "target": function(elem) {
              var hash2 = window3.location && window3.location.hash;
              return hash2 && hash2.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            "enabled": createDisabledPseudo(false),
            "disabled": createDisabledPseudo(true),
            "checked": function(elem) {
              var nodeName2 = elem.nodeName.toLowerCase();
              return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            // Element/input types
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name2 = elem.nodeName.toLowerCase();
              return name2 === "input" && elem.type === "button" || name2 === "button";
            },
            "text": function(elem) {
              var attr2;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr2 = elem.getAttribute("type")) == null || attr2.toLowerCase() === "text");
            },
            // Position-in-collection
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrim2, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle2(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter2, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
              postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              )
            ) : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf2(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i2 > 1 && elementMatcher(matchers),
                  i2 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                  ).replace(rtrim2, "$1"),
                  matcher,
                  i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                  j < len && matcherFromTokens(tokens = tokens.slice(j)),
                  j < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle2.compile = function(selector, match) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i2 = match.length;
            while (i2--) {
              cached = matcherFromTokens(match[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle2.select = function(selector, context, results, seed) {
          var i2, tokens, token, type, find2, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find2 = Expr.find[type]) {
                if (seed = find2(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        };
        support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support2.detectDuplicates = !!hasDuplicate;
        setDocument();
        support2.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        if (!assert(function(el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name2, isXML2) {
            if (!isXML2) {
              return elem.getAttribute(name2, name2.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support2.attributes || !assert(function(el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, _name, isXML2) {
            if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(el) {
          return el.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name2, isXML2) {
            var val;
            if (!isXML2) {
              return elem[name2] === true ? name2.toLowerCase() : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle2;
      }(window2)
    );
    jQuery2.find = Sizzle;
    jQuery2.expr = Sizzle.selectors;
    jQuery2.expr[":"] = jQuery2.expr.pseudos;
    jQuery2.uniqueSort = jQuery2.unique = Sizzle.uniqueSort;
    jQuery2.text = Sizzle.getText;
    jQuery2.isXMLDoc = Sizzle.isXML;
    jQuery2.contains = Sizzle.contains;
    jQuery2.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery2(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery2.expr.match.needsContext;
    function nodeName(elem, name2) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction2(qualifier)) {
        return jQuery2.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery2.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery2.grep(elements, function(elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery2.filter(qualifier, elements, not);
    }
    jQuery2.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery2.fn.extend({
      find: function(selector) {
        var i, ret, len = this.length, self2 = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery2(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery2.contains(self2[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery2.find(selector, self2[i], ret);
        }
        return len > 1 ? jQuery2.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery2.fn.init = function(selector, context, root2) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root2 = root2 || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery2 ? context[0] : context;
            jQuery2.merge(this, jQuery2.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document2,
              true
            ));
            if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
              for (match in context) {
                if (isFunction2(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root2).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction2(selector)) {
        return root2.ready !== void 0 ? root2.ready(selector) : (
          // Execute immediately if ready is not present
          selector(jQuery2)
        );
      }
      return jQuery2.makeArray(selector, this);
    };
    init.prototype = jQuery2.fn;
    rootjQuery = jQuery2(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery2.fn.extend({
      has: function(target) {
        var targets = jQuery2(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery2.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
              ))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf.call(jQuery2(elem), this[0]);
        }
        return indexOf.call(
          this,
          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem
        );
      },
      add: function(selector, context) {
        return this.pushStack(
          jQuery2.uniqueSort(
            jQuery2.merge(this.get(), jQuery2(selector, context))
          )
        );
      },
      addBack: function(selector) {
        return this.add(
          selector == null ? this.prevObject : this.prevObject.filter(selector)
        );
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery2.each({
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery2.merge([], elem.childNodes);
      }
    }, function(name2, fn3) {
      jQuery2.fn[name2] = function(until, selector) {
        var matched = jQuery2.map(this, fn3, until);
        if (name2.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery2.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name2]) {
            jQuery2.uniqueSort(matched);
          }
          if (rparentsprev.test(name2)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions2(options) {
      var object = {};
      jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery2.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions2(options) : jQuery2.extend({}, options);
      var firing, memory, fired, locked, list2 = [], queue = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();
          while (++firingIndex < list2.length) {
            if (list2[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list2.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list2 = [];
          } else {
            list2 = "";
          }
        }
      }, self2 = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list2) {
            if (memory && !firing) {
              firingIndex = list2.length - 1;
              queue.push(memory);
            }
            (function add(args) {
              jQuery2.each(args, function(_2, arg) {
                if (isFunction2(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list2.push(arg);
                  }
                } else if (arg && arg.length && toType2(arg) !== "string") {
                  add(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          jQuery2.each(arguments, function(_2, arg) {
            var index;
            while ((index = jQuery2.inArray(arg, list2, index)) > -1) {
              list2.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn3) {
          return fn3 ? jQuery2.inArray(fn3, list2) > -1 : list2.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          if (list2) {
            list2 = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue = [];
          list2 = memory = "";
          return this;
        },
        disabled: function() {
          return !list2;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue = [];
          if (!memory && !firing) {
            list2 = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
      var method;
      try {
        if (value && isFunction2(method = value.promise)) {
          method.call(value).done(resolve).fail(reject);
        } else if (value && isFunction2(method = value.then)) {
          method.call(value, resolve, reject);
        } else {
          resolve.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject.apply(void 0, [value2]);
      }
    }
    jQuery2.extend({
      Deferred: function(func) {
        var tuples = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            jQuery2.Callbacks("memory"),
            jQuery2.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery2.Callbacks("once memory"),
            jQuery2.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery2.Callbacks("once memory"),
            jQuery2.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state2 = "pending", promise = {
          state: function() {
            return state2;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn3) {
            return promise.then(null, fn3);
          },
          // Keep pipe for back-compat
          pipe: function() {
            var fns = arguments;
            return jQuery2.Deferred(function(newDefer) {
              jQuery2.each(tuples, function(_i, tuple) {
                var fn3 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn3 && fn3.apply(this, arguments);
                  if (returned && isFunction2(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](
                      this,
                      fn3 ? [returned] : arguments
                    );
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred2, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction2(then)) {
                    if (special) {
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special)
                      );
                    } else {
                      maxDepth++;
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special),
                        resolve(
                          maxDepth,
                          deferred2,
                          Identity,
                          deferred2.notifyWith
                        )
                      );
                    }
                  } else {
                    if (handler !== Identity) {
                      that = void 0;
                      args = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args);
                  }
                }, process = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery2.Deferred.exceptionHook) {
                      jQuery2.Deferred.exceptionHook(
                        e,
                        process.stackTrace
                      );
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = void 0;
                        args = [e];
                      }
                      deferred2.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process();
                } else {
                  if (jQuery2.Deferred.getStackHook) {
                    process.stackTrace = jQuery2.Deferred.getStackHook();
                  }
                  window2.setTimeout(process);
                }
              };
            }
            return jQuery2.Deferred(function(newDefer) {
              tuples[0][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onProgress) ? onProgress : Identity,
                  newDefer.notifyWith
                )
              );
              tuples[1][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onFulfilled) ? onFulfilled : Identity
                )
              );
              tuples[2][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onRejected) ? onRejected : Thrower
                )
              );
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery2.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery2.each(tuples, function(i, tuple) {
          var list2 = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list2.add;
          if (stateString) {
            list2.add(
              function() {
                state2 = stateString;
              },
              // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable,
              // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable,
              // progress_callbacks.lock
              tuples[0][2].lock,
              // progress_handlers.lock
              tuples[0][3].lock
            );
          }
          list2.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list2.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      // Deferred helper
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i2) {
          return function(value) {
            resolveContexts[i2] = this;
            resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(
            singleValue,
            primary.done(updateFunc(i)).resolve,
            primary.reject,
            !remaining
          );
          if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery2.Deferred.exceptionHook = function(error2, stack) {
      if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
        window2.console.warn("jQuery.Deferred exception: " + error2.message, error2.stack, stack);
      }
    };
    jQuery2.readyException = function(error2) {
      window2.setTimeout(function() {
        throw error2;
      });
    };
    var readyList = jQuery2.Deferred();
    jQuery2.fn.ready = function(fn3) {
      readyList.then(fn3).catch(function(error2) {
        jQuery2.readyException(error2);
      });
      return this;
    };
    jQuery2.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function(wait) {
        if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
          return;
        }
        jQuery2.isReady = true;
        if (wait !== true && --jQuery2.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery2]);
      }
    });
    jQuery2.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery2.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery2.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn3, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType2(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn3, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction2(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn3.call(elems, value);
            fn3 = null;
          } else {
            bulk = fn3;
            fn3 = function(elem, _key, value2) {
              return bulk.call(jQuery2(elem), value2);
            };
          }
        }
        if (fn3) {
          for (; i < len; i++) {
            fn3(
              elems[i],
              key,
              raw ? value : value.call(elems[i], i, fn3(elems[i], key))
            );
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn3.call(elems);
      }
      return len ? fn3(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data2() {
      this.expando = jQuery2.expando + Data2.uid++;
    }
    Data2.uid = 1;
    Data2.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data2, value) {
        var prop, cache = this.cache(owner);
        if (typeof data2 === "string") {
          cache[camelCase(data2)] = value;
        } else {
          for (prop in data2) {
            cache[camelCase(prop)] = data2[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === void 0 ? this.cache(owner) : (
          // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)]
        );
      },
      access: function(owner, key, value) {
        if (key === void 0 || key && typeof key === "string" && value === void 0) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== void 0 ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key !== void 0) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === void 0 || jQuery2.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery2.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data2();
    var dataUser = new Data2();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data2) {
      if (data2 === "true") {
        return true;
      }
      if (data2 === "false") {
        return false;
      }
      if (data2 === "null") {
        return null;
      }
      if (data2 === +data2 + "") {
        return +data2;
      }
      if (rbrace.test(data2)) {
        return JSON.parse(data2);
      }
      return data2;
    }
    function dataAttr(elem, key, data2) {
      var name2;
      if (data2 === void 0 && elem.nodeType === 1) {
        name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data2 = elem.getAttribute(name2);
        if (typeof data2 === "string") {
          try {
            data2 = getData(data2);
          } catch (e) {
          }
          dataUser.set(elem, key, data2);
        } else {
          data2 = void 0;
        }
      }
      return data2;
    }
    jQuery2.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name2, data2) {
        return dataUser.access(elem, name2, data2);
      },
      removeData: function(elem, name2) {
        dataUser.remove(elem, name2);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function(elem, name2, data2) {
        return dataPriv.access(elem, name2, data2);
      },
      _removeData: function(elem, name2) {
        dataPriv.remove(elem, name2);
      }
    });
    jQuery2.fn.extend({
      data: function(key, value) {
        var i, name2, data2, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data2 = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name2 = attrs[i].name;
                  if (name2.indexOf("data-") === 0) {
                    name2 = camelCase(name2.slice(5));
                    dataAttr(elem, name2, data2[name2]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data2;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value2) {
          var data3;
          if (elem && value2 === void 0) {
            data3 = dataUser.get(elem, key);
            if (data3 !== void 0) {
              return data3;
            }
            data3 = dataAttr(elem, key);
            if (data3 !== void 0) {
              return data3;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery2.extend({
      queue: function(elem, type, data2) {
        var queue;
        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type);
          if (data2) {
            if (!queue || Array.isArray(data2)) {
              queue = dataPriv.access(elem, type, jQuery2.makeArray(data2));
            } else {
              queue.push(data2);
            }
          }
          return queue || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue = jQuery2.queue(elem, type), startLength = queue.length, fn3 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
          jQuery2.dequeue(elem, type);
        };
        if (fn3 === "inprogress") {
          fn3 = queue.shift();
          startLength--;
        }
        if (fn3) {
          if (type === "fx") {
            queue.unshift("inprogress");
          }
          delete hooks.stop;
          fn3.call(elem, next, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery2.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery2.fn.extend({
      queue: function(type, data2) {
        var setter = 2;
        if (typeof type !== "string") {
          data2 = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery2.queue(this[0], type);
        }
        return data2 === void 0 ? this : this.each(function() {
          var queue = jQuery2.queue(this, type, data2);
          jQuery2._queueHooks(this, type);
          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery2.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery2.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(type, obj) {
        var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached = function(elem) {
      return jQuery2.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached(elem) && jQuery2.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween2) {
      var adjusted, scale, maxIterations = 20, currentValue = tween2 ? function() {
        return tween2.cur();
      } : function() {
        return jQuery2.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery2.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery2.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween2) {
          tween2.unit = unit;
          tween2.start = initialInUnit;
          tween2.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc.body.appendChild(doc.createElement(nodeName2));
      display = jQuery2.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values = [], index = 0, length = elements.length;
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;
            if (!values[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }
      return elements;
    }
    jQuery2.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state2) {
        if (typeof state2 === "boolean") {
          return state2 ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery2(this).show();
          } else {
            jQuery2(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context, tag)) {
        return jQuery2.merge([context], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (; i < l; i++) {
        dataPriv.set(
          elems[i],
          "globalEval",
          !refElements || dataPriv.get(refElements[i], "globalEval")
        );
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType2(elem) === "object") {
            jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery2.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery2.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function expectSync(elem, type) {
      return elem === safeActiveElement() === (type === "focus");
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on2(elem, types, selector, data2, fn3, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data2 = data2 || selector;
          selector = void 0;
        }
        for (type in types) {
          on2(elem, type, selector, data2, types[type], one);
        }
        return elem;
      }
      if (data2 == null && fn3 == null) {
        fn3 = selector;
        data2 = selector = void 0;
      } else if (fn3 == null) {
        if (typeof selector === "string") {
          fn3 = data2;
          data2 = void 0;
        } else {
          fn3 = data2;
          data2 = selector;
          selector = void 0;
        }
      }
      if (fn3 === false) {
        fn3 = returnFalse;
      } else if (!fn3) {
        return elem;
      }
      if (one === 1) {
        origFn = fn3;
        fn3 = function(event) {
          jQuery2().off(event);
          return origFn.apply(this, arguments);
        };
        fn3.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
      }
      return elem.each(function() {
        jQuery2.event.add(this, types, fn3, data2, selector);
      });
    }
    jQuery2.event = {
      global: {},
      add: function(elem, types, handler, data2, selector) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery2.find.matchesSelector(documentElement, selector);
        }
        if (!handler.guid) {
          handler.guid = jQuery2.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery2.event.special[type] || {};
          handleObj = jQuery2.extend({
            type,
            origType,
            data: data2,
            handler,
            guid: handler.guid,
            selector,
            needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data2, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery2.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery2.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery2.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery2.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery2.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name2, hook) {
        Object.defineProperty(jQuery2.Event.prototype, name2, {
          enumerable: true,
          configurable: true,
          get: isFunction2(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name2];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name2, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function(data2) {
            var el = this || data2;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", returnTrue);
            }
            return false;
          },
          trigger: function(data2) {
            var el = this || data2;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function(event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type, expectSync2) {
      if (!expectSync2) {
        if (dataPriv.get(el, type) === void 0) {
          jQuery2.event.add(el, type, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type, false);
      jQuery2.event.add(el, type, {
        namespace: false,
        handler: function(event) {
          var notAsync, result, saved = dataPriv.get(this, type);
          if (event.isTrigger & 1 && this[type]) {
            if (!saved.length) {
              saved = slice.call(arguments);
              dataPriv.set(this, type, saved);
              notAsync = expectSync2(this, type);
              this[type]();
              result = dataPriv.get(this, type);
              if (saved !== result || notAsync) {
                dataPriv.set(this, type, false);
              } else {
                result = {};
              }
              if (saved !== result) {
                event.stopImmediatePropagation();
                event.preventDefault();
                return result && result.value;
              }
            } else if ((jQuery2.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }
          } else if (saved.length) {
            dataPriv.set(this, type, {
              value: jQuery2.event.trigger(
                // Support: IE <=9 - 11+
                // Extend with the prototype to reset the above stopImmediatePropagation()
                jQuery2.extend(saved[0], jQuery2.Event.prototype),
                saved.slice(1),
                this
              )
            });
            event.stopImmediatePropagation();
          }
        }
      });
    }
    jQuery2.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery2.Event = function(src, props) {
      if (!(this instanceof jQuery2.Event)) {
        return new jQuery2.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery2.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery2.expando] = true;
    };
    jQuery2.Event.prototype = {
      constructor: jQuery2.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery2.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery2.event.addProp);
    jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
      jQuery2.event.special[type] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function() {
          leverageNative(this, type, expectSync);
          return false;
        },
        trigger: function() {
          leverageNative(this, type);
          return true;
        },
        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function(event) {
          return dataPriv.get(event.target, type);
        },
        delegateType
      };
    });
    jQuery2.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery2.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery2.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery2.fn.extend({
      on: function(types, selector, data2, fn3) {
        return on2(this, types, selector, data2, fn3);
      },
      one: function(types, selector, data2, fn3) {
        return on2(this, types, selector, data2, fn3, 1);
      },
      off: function(types, selector, fn3) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery2(types.delegateTarget).off(
            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn3 = selector;
          selector = void 0;
        }
        if (fn3 === false) {
          fn3 = returnFalse;
        }
        return this.each(function() {
          jQuery2.event.remove(this, types, fn3, selector);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery2(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;
        if (events) {
          dataPriv.remove(dest, "handle events");
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery2.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery2.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = flat(args);
      var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction2(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self2 = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery2.clone(node, true, true);
              if (hasScripts) {
                jQuery2.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            jQuery2.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery2._evalUrl && !node.noModule) {
                    jQuery2._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove(elem, selector, keepData) {
      var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i = 0;
      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery2.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery2.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
          destElements = getAll(clone);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        }
        destElements = getAll(clone, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone;
      },
      cleanData: function(elems) {
        var data2, elem, type, special = jQuery2.event.special, i = 0;
        for (; (elem = elems[i]) !== void 0; i++) {
          if (acceptData(elem)) {
            if (data2 = elem[dataPriv.expando]) {
              if (data2.events) {
                for (type in data2.events) {
                  if (special[type]) {
                    jQuery2.event.remove(elem, type);
                  } else {
                    jQuery2.removeEvent(elem, type, data2.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery2.fn.extend({
      detach: function(selector) {
        return remove(this, selector, true);
      },
      remove: function(selector) {
        return remove(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery2.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery2.htmlPrefilter(value2);
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery2.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent = this.parentNode;
          if (jQuery2.inArray(this, ignored) < 0) {
            jQuery2.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery2.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name2, original) {
      jQuery2.fn[name2] = function(selector) {
        var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i = 0;
        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery2(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
      var ret, name2, old = {};
      for (name2 in options) {
        old[name2] = elem.style[name2];
        elem.style[name2] = options[name2];
      }
      ret = callback.call(elem);
      for (name2 in options) {
        elem.style[name2] = old[name2];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery2.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name2, computed) {
      var width2, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name2), style = elem.style;
      computed = computed || getStyles(elem);
      if (computed) {
        ret = computed.getPropertyValue(name2) || computed[name2];
        if (isCustomProp && ret) {
          ret = ret.replace(rtrimCSS, "$1") || void 0;
        }
        if (ret === "" && !isAttached(elem)) {
          ret = jQuery2.style(elem, name2);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
          width2 = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width2;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== void 0 ? (
        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + ""
      ) : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name2) {
      var capName = name2[0].toUpperCase() + name2.slice(1), i = cssPrefixes.length;
      while (i--) {
        name2 = cssPrefixes[i] + capName;
        if (name2 in emptyStyle) {
          return name2;
        }
      }
    }
    function finalPropName(name2) {
      var final = jQuery2.cssProps[name2] || vendorProps[name2];
      if (final) {
        return final;
      }
      if (name2 in emptyStyle) {
        return name2;
      }
      return vendorProps[name2] = vendorPropName(name2) || name2;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
      var matches = rcssNum.exec(value);
      return matches ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
      ) : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles2, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i < 4; i += 2) {
        if (box === "margin") {
          delta += jQuery2.css(elem, box + cssExpand[i], true, styles2);
        }
        if (!isBorderBox) {
          delta += jQuery2.css(elem, "padding" + cssExpand[i], true, styles2);
          if (box !== "padding") {
            delta += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
          } else {
            extra += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
          }
        } else {
          if (box === "content") {
            delta -= jQuery2.css(elem, "padding" + cssExpand[i], true, styles2);
          }
          if (box !== "margin") {
            delta -= jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }
      return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles2 = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles2) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles2), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(val) && jQuery2.css(elem, "display", false, styles2) === "inline") && // Make sure the element is visible & connected
      elem.getClientRects().length) {
        isBorderBox = jQuery2.css(elem, "boxSizing", false, styles2) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(
        elem,
        dimension,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles2,
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
      ) + "px";
    }
    jQuery2.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(elem, computed) {
            if (computed) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function(elem, name2, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name2, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
            style[name2] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style.setProperty(name2, value);
            } else {
              style[name2] = value;
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name2];
        }
      },
      css: function(elem, name2, extra, styles2) {
        var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
        if (!isCustomProp) {
          name2 = finalPropName(origName);
        }
        hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name2, styles2);
        }
        if (val === "normal" && name2 in cssNormalTransform) {
          val = cssNormalTransform[name2];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery2.each(["height", "width"], function(_i, dimension) {
      jQuery2.cssHooks[dimension] = {
        get: function(elem, computed, extra) {
          if (computed) {
            return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles2 = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles2.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles2) === "border-box", subtract = extra ? boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles2
          ) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles2[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles2) - 0.5
            );
          }
          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery2.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery2.cssHooks.marginLeft = addGetHookIf(
      support.reliableMarginLeft,
      function(elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }
    );
    jQuery2.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery2.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery2.fn.extend({
      css: function(name2, value) {
        return access(this, function(elem, name3, value2) {
          var styles2, len, map2 = {}, i = 0;
          if (Array.isArray(name3)) {
            styles2 = getStyles(elem);
            len = name3.length;
            for (; i < len; i++) {
              map2[name3[i]] = jQuery2.css(elem, name3[i], false, styles2);
            }
            return map2;
          }
          return value2 !== void 0 ? jQuery2.style(elem, name3, value2) : jQuery2.css(elem, name3);
        }, name2, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end2, easing) {
      return new Tween.prototype.init(elem, options, prop, end2, easing);
    }
    jQuery2.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end2, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery2.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end2;
        this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery2.easing[this.easing](
            percent,
            this.options.duration * percent,
            0,
            1,
            this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween2) {
          var result;
          if (tween2.elem.nodeType !== 1 || tween2.elem[tween2.prop] != null && tween2.elem.style[tween2.prop] == null) {
            return tween2.elem[tween2.prop];
          }
          result = jQuery2.css(tween2.elem, tween2.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween2) {
          if (jQuery2.fx.step[tween2.prop]) {
            jQuery2.fx.step[tween2.prop](tween2);
          } else if (tween2.elem.nodeType === 1 && (jQuery2.cssHooks[tween2.prop] || tween2.elem.style[finalPropName(tween2.prop)] != null)) {
            jQuery2.style(tween2.elem, tween2.prop, tween2.now + tween2.unit);
          } else {
            tween2.elem[tween2.prop] = tween2.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween2) {
        if (tween2.elem.nodeType && tween2.elem.parentNode) {
          tween2.elem[tween2.prop] = tween2.now;
        }
      }
    };
    jQuery2.easing = {
      linear: function(p) {
        return p;
      },
      swing: function(p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery2.fx = Tween.prototype.init;
    jQuery2.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery2.fx.interval);
        }
        jQuery2.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = { height: type };
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween2, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (; index < length; index++) {
        if (tween2 = collection[index].call(animation, prop, value)) {
          return tween2;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery2._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery2.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
        }
      }
      propTween = !jQuery2.isEmptyObject(props);
      if (!propTween && jQuery2.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery2.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery2.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery2.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery2.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index, name2, easing, value, hooks;
      for (index in props) {
        name2 = camelCase(index);
        easing = specialEasing[name2];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }
        if (index !== name2) {
          props[name2] = value;
          delete props[index];
        }
        hooks = jQuery2.cssHooks[name2];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name2];
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name2] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
        for (; index2 < length2; index2++) {
          animation.tweens[index2].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        }
        if (!length2) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery2.extend({}, properties),
        opts: jQuery2.extend(true, {
          specialEasing: {},
          easing: jQuery2.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end2) {
          var tween2 = jQuery2.Tween(
            elem,
            animation.opts,
            prop,
            end2,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween2);
          return tween2;
        },
        stop: function(gotoEnd) {
          var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction2(result.stop)) {
            jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery2.map(props, createTween, animation);
      if (isFunction2(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery2.fx.timer(
        jQuery2.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );
      return animation;
    }
    jQuery2.Animation = jQuery2.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween2 = this.createTween(prop, value);
          adjustCSS(tween2.elem, prop, rcssNum.exec(value), tween2);
          return tween2;
        }]
      },
      tweener: function(props, callback) {
        if (isFunction2(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index = 0, length = props.length;
        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery2.speed = function(speed, easing, fn3) {
      var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
        complete: fn3 || !fn3 && easing || isFunction2(speed) && speed,
        duration: speed,
        easing: fn3 && easing || easing && !isFunction2(easing) && easing
      };
      if (jQuery2.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery2.fx.speeds) {
            opt.duration = jQuery2.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery2.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction2(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery2.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery2.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery2.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data2 = dataPriv.get(this);
          if (index) {
            if (data2[index] && data2[index].stop) {
              stopQueue(data2[index]);
            }
          } else {
            for (index in data2) {
              if (data2[index] && data2[index].stop && rrun.test(index)) {
                stopQueue(data2[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery2.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data2 = dataPriv.get(this), queue = data2[type + "queue"], hooks = data2[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
          data2.finish = true;
          jQuery2.queue(this, type, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          }
          delete data2.finish;
        });
      }
    });
    jQuery2.each(["toggle", "show", "hide"], function(_i, name2) {
      var cssFn = jQuery2.fn[name2];
      jQuery2.fn[name2] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
      };
    });
    jQuery2.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name2, props) {
      jQuery2.fn[name2] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery2.timers = [];
    jQuery2.fx.tick = function() {
      var timer, i = 0, timers = jQuery2.timers;
      fxNow = Date.now();
      for (; i < timers.length; i++) {
        timer = timers[i];
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery2.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery2.fx.timer = function(timer) {
      jQuery2.timers.push(timer);
      jQuery2.fx.start();
    };
    jQuery2.fx.interval = 13;
    jQuery2.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery2.fx.stop = function() {
      inProgress = null;
    };
    jQuery2.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    };
    jQuery2.fn.delay = function(time, type) {
      time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks) {
        var timeout = window2.setTimeout(next, time);
        hooks.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery2.expr.attrHandle;
    jQuery2.fn.extend({
      attr: function(name2, value) {
        return access(this, jQuery2.attr, name2, value, arguments.length > 1);
      },
      removeAttr: function(name2) {
        return this.each(function() {
          jQuery2.removeAttr(this, name2);
        });
      }
    });
    jQuery2.extend({
      attr: function(elem, name2, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery2.prop(elem, name2, value);
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          hooks = jQuery2.attrHooks[name2.toLowerCase()] || (jQuery2.expr.match.bool.test(name2) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery2.removeAttr(elem, name2);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name2, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
          return ret;
        }
        ret = jQuery2.find.attr(elem, name2);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name2, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name2 = attrNames[i++]) {
            elem.removeAttribute(name2);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name2) {
        if (value === false) {
          jQuery2.removeAttr(elem, name2);
        } else {
          elem.setAttribute(name2, name2);
        }
        return name2;
      }
    };
    jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i, name2) {
      var getter = attrHandle[name2] || jQuery2.find.attr;
      attrHandle[name2] = function(elem, name3, isXML) {
        var ret, handle, lowercaseName = name3.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery2.fn.extend({
      prop: function(name2, value) {
        return access(this, jQuery2.prop, name2, value, arguments.length > 1);
      },
      removeProp: function(name2) {
        return this.each(function() {
          delete this[jQuery2.propFix[name2] || name2];
        });
      }
    });
    jQuery2.extend({
      prop: function(elem, name2, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
          name2 = jQuery2.propFix[name2] || name2;
          hooks = jQuery2.propHooks[name2];
        }
        if (value !== void 0) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
            return ret;
          }
          return elem[name2] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
          return ret;
        }
        return elem[name2];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery2.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery2.propHooks.selected = {
        get: function(elem) {
          var parent = elem.parentNode;
          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery2.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery2.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery2.fn.extend({
      addClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery2(this).addClass(value.call(this, j, getClass(this)));
          });
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      removeClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery2(this).removeClass(value.call(this, j, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (isFunction2(value)) {
          return this.each(function(i2) {
            jQuery2(this).toggleClass(
              value.call(this, i2, getClass(this), stateVal),
              stateVal
            );
          });
        }
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        classNames = classesToArray(value);
        return this.each(function() {
          if (isValidValue) {
            self2 = jQuery2(this);
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute(
                "class",
                className || value === false ? "" : dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i = 0;
        className = " " + selector + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery2.fn.extend({
      val: function(value) {
        var hooks, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction2(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery2(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery2.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery2.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery2.find.attr(elem, "value");
            return val != null ? val : (
              // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery2.text(elem))
            );
          }
        },
        select: {
          get: function(elem) {
            var value, option2, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max2 = one ? index + 1 : options.length;
            if (index < 0) {
              i = max2;
            } else {
              i = one ? index : 0;
            }
            for (; i < max2; i++) {
              option2 = options[i];
              if ((option2.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option2.disabled && (!option2.parentNode.disabled || !nodeName(option2.parentNode, "optgroup"))) {
                value = jQuery2(option2).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option2, options = elem.options, values = jQuery2.makeArray(value), i = options.length;
            while (i--) {
              option2 = options[i];
              if (option2.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option2), values) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });
    jQuery2.each(["radio", "checkbox"], function() {
      jQuery2.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery2.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window2;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery2.extend(jQuery2.event, {
      trigger: function(event, data2, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery2.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data2 = data2 == null ? [event] : jQuery2.makeArray(data2, [event]);
        special = jQuery2.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data2) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data2);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data2);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data2) === false) && acceptData(elem)) {
            if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery2.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery2.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function(type, elem, event) {
        var e = jQuery2.extend(
          new jQuery2.Event(),
          event,
          {
            type,
            isSimulated: true
          }
        );
        jQuery2.event.trigger(e, null, elem);
      }
    });
    jQuery2.fn.extend({
      trigger: function(type, data2) {
        return this.each(function() {
          jQuery2.event.trigger(type, data2, this);
        });
      },
      triggerHandler: function(type, data2) {
        var elem = this[0];
        if (elem) {
          return jQuery2.event.trigger(type, data2, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery2.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
        var handler = function(event) {
          jQuery2.event.simulate(fix, event.target, jQuery2.event.fix(event));
        };
        jQuery2.event.special[fix] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }
            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }
    var location2 = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery2.parseXML = function(data2) {
      var xml, parserErrorElem;
      if (!data2 || typeof data2 !== "string") {
        return null;
      }
      try {
        xml = new window2.DOMParser().parseFromString(data2, "text/xml");
      } catch (e) {
      }
      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data2));
      }
      return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add) {
      var name2;
      if (Array.isArray(obj)) {
        jQuery2.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix)) {
            add(prefix, v);
          } else {
            buildParams(
              prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
              v,
              traditional,
              add
            );
          }
        });
      } else if (!traditional && toType2(obj) === "object") {
        for (name2 in obj) {
          buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add);
        }
      } else {
        add(prefix, obj);
      }
    }
    jQuery2.param = function(a, traditional) {
      var prefix, s = [], add = function(key, valueOrFunction) {
        var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a == null) {
        return "";
      }
      if (Array.isArray(a) || a.jquery && !jQuery2.isPlainObject(a)) {
        jQuery2.each(a, function() {
          add(this.name, this.value);
        });
      } else {
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      }
      return s.join("&");
    };
    jQuery2.fn.extend({
      serialize: function() {
        return jQuery2.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery2.prop(this, "elements");
          return elements ? jQuery2.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(_i, elem) {
          var val = jQuery2(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery2.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location2.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction2(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery2.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery2.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location2.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location2.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery2.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(target, settings) {
        return settings ? (
          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
        ) : (
          // Extending ajaxSettings
          ajaxExtend(jQuery2.ajaxSettings, target)
        );
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function(url, options) {
        if (typeof url === "object") {
          options = url;
          url = void 0;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery2.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                }
              }
              match = responseHeaders[key.toLowerCase() + " "];
            }
            return match == null ? null : match.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function(name2, value) {
            if (completed2 == null) {
              name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
              requestHeaders[name2] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (completed2 == null) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function(map2) {
            var code;
            if (map2) {
              if (completed2) {
                jqXHR.always(map2[jqXHR.status]);
              } else {
                for (code in map2) {
                  statusCode[code] = [statusCode[code], map2[code]];
                }
              }
            }
            return this;
          },
          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url || s.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery2.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery2.event && s.global;
        if (fireGlobals && jQuery2.active++ === 0) {
          jQuery2.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery2.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
          }
          if (jQuery2.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader(
          "Accept",
          s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
        );
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed2 = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (completed2) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error2, response, modified, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          if (!isSuccess && jQuery2.inArray("script", s.dataTypes) > -1 && jQuery2.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery2.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery2.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error2 = response.error;
              isSuccess = !error2;
            }
          } else {
            error2 = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(
              isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s, isSuccess ? success : error2]
            );
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery2.active) {
              jQuery2.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data2, callback) {
        return jQuery2.get(url, data2, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery2.get(url, void 0, callback, "script");
      }
    });
    jQuery2.each(["get", "post"], function(_i, method) {
      jQuery2[method] = function(url, data2, callback, type) {
        if (isFunction2(data2)) {
          type = type || callback;
          callback = data2;
          data2 = void 0;
        }
        return jQuery2.ajax(jQuery2.extend({
          url,
          type: method,
          dataType: type,
          data: data2,
          success: callback
        }, jQuery2.isPlainObject(url) && url));
      };
    });
    jQuery2.ajaxPrefilter(function(s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });
    jQuery2._evalUrl = function(url, options, doc) {
      return jQuery2.ajax({
        url,
        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery2.globalEval(response, options, doc);
        }
      });
    };
    jQuery2.fn.extend({
      wrapAll: function(html) {
        var wrap;
        if (this[0]) {
          if (isFunction2(html)) {
            html = html.call(this[0]);
          }
          wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction2(html)) {
          return this.each(function(i) {
            jQuery2(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self2 = jQuery2(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction2(html);
        return this.each(function(i) {
          jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery2(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery2.expr.pseudos.hidden = function(elem) {
      return !jQuery2.expr.pseudos.visible(elem);
    };
    jQuery2.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery2.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    };
    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    }, xhrSupported = jQuery2.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery2.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(
                        // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status,
                        xhr.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr.status] || xhr.status,
                      xhr.statusText,
                      // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                      xhr.getAllResponseHeaders()
                    );
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== void 0) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery2.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery2.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text2) {
          jQuery2.globalEval(text2);
          return text2;
        }
      }
    });
    jQuery2.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery2.ajaxTransport("script", function(s) {
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function(_2, complete) {
            script = jQuery2("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery2.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery2.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction2(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery2.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery2(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction2(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery2.parseHTML = function(data2, context, keepScripts) {
      if (typeof data2 !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document2.implementation.createHTMLDocument("");
          base = context.createElement("base");
          base.href = document2.location.href;
          context.head.appendChild(base);
        } else {
          context = document2;
        }
      }
      parsed = rsingleTag.exec(data2);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data2], context, scripts);
      if (scripts && scripts.length) {
        jQuery2(scripts).remove();
      }
      return jQuery2.merge([], parsed.childNodes);
    };
    jQuery2.fn.load = function(url, params, callback) {
      var selector, type, response, self2 = this, off = url.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }
      if (isFunction2(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery2.ajax({
          url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? (
            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
          ) : (
            // Otherwise use the full result
            responseText
          ));
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery2.expr.pseudos.animated = function(elem) {
      return jQuery2.grep(jQuery2.timers, function(fn3) {
        return elem === fn3.elem;
      }).length;
    };
    jQuery2.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery2.css(elem, "top");
        curCSSLeft = jQuery2.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction2(options)) {
          options = options.call(elem, i, jQuery2.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery2.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i) {
            jQuery2.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery2.css(elem, "position") === "fixed") {
          offset2 = elem.getBoundingClientRect();
        } else {
          offset2 = this.offset();
          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;
          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery2(offsetParent).offset();
            parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset2.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
          left: offset2.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
      var top2 = "pageYOffset" === prop;
      jQuery2.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method2];
          }
          if (win) {
            win.scrollTo(
              !top2 ? val2 : win.pageXOffset,
              top2 ? val2 : win.pageYOffset
            );
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery2.each(["top", "left"], function(_i, prop) {
      jQuery2.cssHooks[prop] = addGetHookIf(
        support.pixelPosition,
        function(elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);
            return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
          }
        }
      );
    });
    jQuery2.each({ Height: "height", Width: "width" }, function(name2, type) {
      jQuery2.each({
        padding: "inner" + name2,
        content: type,
        "": "outer" + name2
      }, function(defaultExtra, funcName) {
        jQuery2.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
            }
            if (elem.nodeType === 9) {
              doc = elem.documentElement;
              return Math.max(
                elem.body["scroll" + name2],
                doc["scroll" + name2],
                elem.body["offset" + name2],
                doc["offset" + name2],
                doc["client" + name2]
              );
            }
            return value2 === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery2.css(elem, type2, extra)
            ) : (
              // Set width or height on the element
              jQuery2.style(elem, type2, value2, extra)
            );
          }, type, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery2.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type) {
      jQuery2.fn[type] = function(fn3) {
        return this.on(type, fn3);
      };
    });
    jQuery2.fn.extend({
      bind: function(types, data2, fn3) {
        return this.on(types, null, data2, fn3);
      },
      unbind: function(types, fn3) {
        return this.off(types, null, fn3);
      },
      delegate: function(selector, types, data2, fn3) {
        return this.on(types, selector, data2, fn3);
      },
      undelegate: function(selector, types, fn3) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn3);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery2.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(_i, name2) {
        jQuery2.fn[name2] = function(data2, fn3) {
          return arguments.length > 0 ? this.on(name2, null, data2, fn3) : this.trigger(name2);
        };
      }
    );
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    jQuery2.proxy = function(fn3, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn3[context];
        context = fn3;
        fn3 = tmp;
      }
      if (!isFunction2(fn3)) {
        return void 0;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn3.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn3.guid = fn3.guid || jQuery2.guid++;
      return proxy;
    };
    jQuery2.holdReady = function(hold) {
      if (hold) {
        jQuery2.readyWait++;
      } else {
        jQuery2.ready(true);
      }
    };
    jQuery2.isArray = Array.isArray;
    jQuery2.parseJSON = JSON.parse;
    jQuery2.nodeName = nodeName;
    jQuery2.isFunction = isFunction2;
    jQuery2.isWindow = isWindow;
    jQuery2.camelCase = camelCase;
    jQuery2.type = toType2;
    jQuery2.now = Date.now;
    jQuery2.isNumeric = function(obj) {
      var type = jQuery2.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };
    jQuery2.trim = function(text2) {
      return text2 == null ? "" : (text2 + "").replace(rtrim, "$1");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery2.noConflict = function(deep) {
      if (window2.$ === jQuery2) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery2) {
        window2.jQuery = _jQuery;
      }
      return jQuery2;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery2;
    }
    return jQuery2;
  });
})(jquery);
const $$1 = jqueryExports;
var tinymceExports = {};
var tinymce$2 = {
  get exports() {
    return tinymceExports;
  },
  set exports(v) {
    tinymceExports = v;
  }
};
(function(module) {
  (function() {
    var typeOf$1 = function(x) {
      if (x === null) {
        return "null";
      }
      if (x === void 0) {
        return "undefined";
      }
      var t = typeof x;
      if (t === "object" && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "Array")) {
        return "array";
      }
      if (t === "object" && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === "String")) {
        return "string";
      }
      return t;
    };
    var isEquatableType = function(x) {
      return [
        "undefined",
        "boolean",
        "number",
        "string",
        "function",
        "xml",
        "null"
      ].indexOf(x) !== -1;
    };
    var sort$1 = function(xs, compareFn) {
      var clone2 = Array.prototype.slice.call(xs);
      return clone2.sort(compareFn);
    };
    var contramap = function(eqa, f) {
      return eq$2(function(x, y) {
        return eqa.eq(f(x), f(y));
      });
    };
    var eq$2 = function(f) {
      return { eq: f };
    };
    var tripleEq = eq$2(function(x, y) {
      return x === y;
    });
    var eqString = tripleEq;
    var eqArray = function(eqa) {
      return eq$2(function(x, y) {
        if (x.length !== y.length) {
          return false;
        }
        var len = x.length;
        for (var i = 0; i < len; i++) {
          if (!eqa.eq(x[i], y[i])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqSortedArray = function(eqa, compareFn) {
      return contramap(eqArray(eqa), function(xs) {
        return sort$1(xs, compareFn);
      });
    };
    var eqRecord = function(eqa) {
      return eq$2(function(x, y) {
        var kx = Object.keys(x);
        var ky = Object.keys(y);
        if (!eqSortedArray(eqString).eq(kx, ky)) {
          return false;
        }
        var len = kx.length;
        for (var i = 0; i < len; i++) {
          var q = kx[i];
          if (!eqa.eq(x[q], y[q])) {
            return false;
          }
        }
        return true;
      });
    };
    var eqAny = eq$2(function(x, y) {
      if (x === y) {
        return true;
      }
      var tx = typeOf$1(x);
      var ty = typeOf$1(y);
      if (tx !== ty) {
        return false;
      }
      if (isEquatableType(tx)) {
        return x === y;
      } else if (tx === "array") {
        return eqArray(eqAny).eq(x, y);
      } else if (tx === "object") {
        return eqRecord(eqAny).eq(x, y);
      }
      return false;
    });
    const getPrototypeOf$2 = Object.getPrototypeOf;
    const hasProto = (v, constructor, predicate) => {
      var _a;
      if (predicate(v, constructor.prototype)) {
        return true;
      } else {
        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
      }
    };
    const typeOf = (x) => {
      const t = typeof x;
      if (x === null) {
        return "null";
      } else if (t === "object" && Array.isArray(x)) {
        return "array";
      } else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
        return "string";
      } else {
        return t;
      }
    };
    const isType$1 = (type2) => (value2) => typeOf(value2) === type2;
    const isSimpleType = (type2) => (value2) => typeof value2 === type2;
    const eq$1 = (t) => (a) => t === a;
    const is$4 = (value2, constructor) => isObject2(value2) && hasProto(value2, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
    const isString2 = isType$1("string");
    const isObject2 = isType$1("object");
    const isPlainObject2 = (value2) => is$4(value2, Object);
    const isArray$12 = isType$1("array");
    const isNull2 = eq$1(null);
    const isBoolean2 = isSimpleType("boolean");
    const isUndefined2 = eq$1(void 0);
    const isNullable = (a) => a === null || a === void 0;
    const isNonNullable = (a) => !isNullable(a);
    const isFunction2 = isSimpleType("function");
    const isNumber2 = isSimpleType("number");
    const isArrayOf = (value2, pred) => {
      if (isArray$12(value2)) {
        for (let i = 0, len = value2.length; i < len; ++i) {
          if (!pred(value2[i])) {
            return false;
          }
        }
        return true;
      }
      return false;
    };
    const noop2 = () => {
    };
    const compose = (fa, fb) => {
      return (...args) => {
        return fa(fb.apply(null, args));
      };
    };
    const compose1 = (fbc, fab) => (a) => fbc(fab(a));
    const constant = (value2) => {
      return () => {
        return value2;
      };
    };
    const identity = (x) => {
      return x;
    };
    const tripleEquals = (a, b) => {
      return a === b;
    };
    function curry(fn3, ...initialArgs) {
      return (...restArgs) => {
        const all3 = initialArgs.concat(restArgs);
        return fn3.apply(null, all3);
      };
    }
    const not = (f) => (t) => !f(t);
    const die = (msg) => {
      return () => {
        throw new Error(msg);
      };
    };
    const apply$1 = (f) => {
      return f();
    };
    const call = (f) => {
      f();
    };
    const never = constant(false);
    const always = constant(true);
    class Optional {
      constructor(tag, value2) {
        this.tag = tag;
        this.value = value2;
      }
      static some(value2) {
        return new Optional(true, value2);
      }
      static none() {
        return Optional.singletonNone;
      }
      fold(onNone, onSome) {
        if (this.tag) {
          return onSome(this.value);
        } else {
          return onNone();
        }
      }
      isSome() {
        return this.tag;
      }
      isNone() {
        return !this.tag;
      }
      map(mapper) {
        if (this.tag) {
          return Optional.some(mapper(this.value));
        } else {
          return Optional.none();
        }
      }
      bind(binder2) {
        if (this.tag) {
          return binder2(this.value);
        } else {
          return Optional.none();
        }
      }
      exists(predicate) {
        return this.tag && predicate(this.value);
      }
      forall(predicate) {
        return !this.tag || predicate(this.value);
      }
      filter(predicate) {
        if (!this.tag || predicate(this.value)) {
          return this;
        } else {
          return Optional.none();
        }
      }
      getOr(replacement) {
        return this.tag ? this.value : replacement;
      }
      or(replacement) {
        return this.tag ? this : replacement;
      }
      getOrThunk(thunk) {
        return this.tag ? this.value : thunk();
      }
      orThunk(thunk) {
        return this.tag ? this : thunk();
      }
      getOrDie(message) {
        if (!this.tag) {
          throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
        } else {
          return this.value;
        }
      }
      static from(value2) {
        return isNonNullable(value2) ? Optional.some(value2) : Optional.none();
      }
      getOrNull() {
        return this.tag ? this.value : null;
      }
      getOrUndefined() {
        return this.value;
      }
      each(worker) {
        if (this.tag) {
          worker(this.value);
        }
      }
      toArray() {
        return this.tag ? [this.value] : [];
      }
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    Optional.singletonNone = new Optional(false);
    const nativeSlice = Array.prototype.slice;
    const nativeIndexOf = Array.prototype.indexOf;
    const nativePush = Array.prototype.push;
    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
    const indexOf$1 = (xs, x) => {
      const r2 = rawIndexOf(xs, x);
      return r2 === -1 ? Optional.none() : Optional.some(r2);
    };
    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
    const exists = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return true;
        }
      }
      return false;
    };
    const map$3 = (xs, f) => {
      const len = xs.length;
      const r2 = new Array(len);
      for (let i = 0; i < len; i++) {
        const x = xs[i];
        r2[i] = f(x, i);
      }
      return r2;
    };
    const each$e = (xs, f) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        f(x, i);
      }
    };
    const eachr = (xs, f) => {
      for (let i = xs.length - 1; i >= 0; i--) {
        const x = xs[i];
        f(x, i);
      }
    };
    const partition$2 = (xs, pred) => {
      const pass = [];
      const fail = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        const arr = pred(x, i) ? pass : fail;
        arr.push(x);
      }
      return {
        pass,
        fail
      };
    };
    const filter$5 = (xs, pred) => {
      const r2 = [];
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          r2.push(x);
        }
      }
      return r2;
    };
    const foldr = (xs, f, acc) => {
      eachr(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const foldl = (xs, f, acc) => {
      each$e(xs, (x, i) => {
        acc = f(acc, x, i);
      });
      return acc;
    };
    const findUntil$1 = (xs, pred, until) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(x);
        } else if (until(x, i)) {
          break;
        }
      }
      return Optional.none();
    };
    const find$2 = (xs, pred) => {
      return findUntil$1(xs, pred, never);
    };
    const findIndex$2 = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (pred(x, i)) {
          return Optional.some(i);
        }
      }
      return Optional.none();
    };
    const flatten = (xs) => {
      const r2 = [];
      for (let i = 0, len = xs.length; i < len; ++i) {
        if (!isArray$12(xs[i])) {
          throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
        }
        nativePush.apply(r2, xs[i]);
      }
      return r2;
    };
    const bind$3 = (xs, f) => flatten(map$3(xs, f));
    const forall = (xs, pred) => {
      for (let i = 0, len = xs.length; i < len; ++i) {
        const x = xs[i];
        if (pred(x, i) !== true) {
          return false;
        }
      }
      return true;
    };
    const reverse = (xs) => {
      const r2 = nativeSlice.call(xs, 0);
      r2.reverse();
      return r2;
    };
    const difference = (a1, a2) => filter$5(a1, (x) => !contains$2(a2, x));
    const mapToObject = (xs, f) => {
      const r2 = {};
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        r2[String(x)] = f(x, i);
      }
      return r2;
    };
    const sort = (xs, comparator) => {
      const copy2 = nativeSlice.call(xs, 0);
      copy2.sort(comparator);
      return copy2;
    };
    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
    const head = (xs) => get$b(xs, 0);
    const last$3 = (xs) => get$b(xs, xs.length - 1);
    const from = isFunction2(Array.from) ? Array.from : (x) => nativeSlice.call(x);
    const findMap = (arr, f) => {
      for (let i = 0; i < arr.length; i++) {
        const r2 = f(arr[i], i);
        if (r2.isSome()) {
          return r2;
        }
      }
      return Optional.none();
    };
    const unique$1 = (xs, comparator) => {
      const r2 = [];
      const isDuplicated = isFunction2(comparator) ? (x) => exists(r2, (i) => comparator(i, x)) : (x) => contains$2(r2, x);
      for (let i = 0, len = xs.length; i < len; i++) {
        const x = xs[i];
        if (!isDuplicated(x)) {
          r2.push(x);
        }
      }
      return r2;
    };
    const keys = Object.keys;
    const hasOwnProperty$2 = Object.hasOwnProperty;
    const each$d = (obj, f) => {
      const props = keys(obj);
      for (let k = 0, len = props.length; k < len; k++) {
        const i = props[k];
        const x = obj[i];
        f(x, i);
      }
    };
    const map$2 = (obj, f) => {
      return tupleMap(obj, (x, i) => ({
        k: i,
        v: f(x, i)
      }));
    };
    const tupleMap = (obj, f) => {
      const r2 = {};
      each$d(obj, (x, i) => {
        const tuple = f(x, i);
        r2[tuple.k] = tuple.v;
      });
      return r2;
    };
    const objAcc = (r2) => (x, i) => {
      r2[i] = x;
    };
    const internalFilter = (obj, pred, onTrue, onFalse) => {
      each$d(obj, (x, i) => {
        (pred(x, i) ? onTrue : onFalse)(x, i);
      });
    };
    const bifilter = (obj, pred) => {
      const t = {};
      const f = {};
      internalFilter(obj, pred, objAcc(t), objAcc(f));
      return {
        t,
        f
      };
    };
    const filter$4 = (obj, pred) => {
      const t = {};
      internalFilter(obj, pred, objAcc(t), noop2);
      return t;
    };
    const mapToArray = (obj, f) => {
      const r2 = [];
      each$d(obj, (value2, name3) => {
        r2.push(f(value2, name3));
      });
      return r2;
    };
    const values = (obj) => {
      return mapToArray(obj, identity);
    };
    const get$a = (obj, key) => {
      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
    };
    const has$2 = (obj, key) => hasOwnProperty$2.call(obj, key);
    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== void 0 && obj[key] !== null;
    const equal$1 = (a1, a2, eq2 = eqAny) => eqRecord(eq2).eq(a1, a2);
    const stringArray = (a) => {
      const all3 = {};
      each$e(a, (key) => {
        all3[key] = {};
      });
      return keys(all3);
    };
    const isArrayLike = (o) => o.length !== void 0;
    const isArray2 = Array.isArray;
    const toArray$12 = (obj) => {
      if (!isArray2(obj)) {
        const array = [];
        for (let i = 0, l = obj.length; i < l; i++) {
          array[i] = obj[i];
        }
        return array;
      } else {
        return obj;
      }
    };
    const each$c = (o, cb, s) => {
      if (!o) {
        return false;
      }
      s = s || o;
      if (isArrayLike(o)) {
        for (let n = 0, l = o.length; n < l; n++) {
          if (cb.call(s, o[n], n, o) === false) {
            return false;
          }
        }
      } else {
        for (const n in o) {
          if (has$2(o, n)) {
            if (cb.call(s, o[n], n, o) === false) {
              return false;
            }
          }
        }
      }
      return true;
    };
    const map$1 = (array, callback) => {
      const out = [];
      each$c(array, (item2, index) => {
        out.push(callback(item2, index, array));
      });
      return out;
    };
    const filter$3 = (a, f) => {
      const o = [];
      each$c(a, (v, index) => {
        if (!f || f(v, index, a)) {
          o.push(v);
        }
      });
      return o;
    };
    const indexOf = (a, v) => {
      if (a) {
        for (let i = 0, l = a.length; i < l; i++) {
          if (a[i] === v) {
            return i;
          }
        }
      }
      return -1;
    };
    const reduce = (collection, iteratee, accumulator, thisArg) => {
      let acc = isUndefined2(accumulator) ? collection[0] : accumulator;
      for (let i = 0; i < collection.length; i++) {
        acc = iteratee.call(thisArg, acc, collection[i], i);
      }
      return acc;
    };
    const findIndex$1 = (array, predicate, thisArg) => {
      for (let i = 0, l = array.length; i < l; i++) {
        if (predicate.call(thisArg, array[i], i, array)) {
          return i;
        }
      }
      return -1;
    };
    const last$2 = (collection) => collection[collection.length - 1];
    const cached = (f) => {
      let called = false;
      let r2;
      return (...args) => {
        if (!called) {
          called = true;
          r2 = f.apply(null, args);
        }
        return r2;
      };
    };
    const DeviceType = (os2, browser3, userAgent2, mediaMatch2) => {
      const isiPad = os2.isiOS() && /ipad/i.test(userAgent2) === true;
      const isiPhone = os2.isiOS() && !isiPad;
      const isMobile = os2.isiOS() || os2.isAndroid();
      const isTouch2 = isMobile || mediaMatch2("(pointer:coarse)");
      const isTablet2 = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
      const isPhone2 = isiPhone || isMobile && !isTablet2;
      const iOSwebview = browser3.isSafari() && os2.isiOS() && /safari/i.test(userAgent2) === false;
      const isDesktop = !isPhone2 && !isTablet2 && !iOSwebview;
      return {
        isiPad: constant(isiPad),
        isiPhone: constant(isiPhone),
        isTablet: constant(isTablet2),
        isPhone: constant(isPhone2),
        isTouch: constant(isTouch2),
        isAndroid: os2.isAndroid,
        isiOS: os2.isiOS,
        isWebView: constant(iOSwebview),
        isDesktop: constant(isDesktop)
      };
    };
    const firstMatch = (regexes, s) => {
      for (let i = 0; i < regexes.length; i++) {
        const x = regexes[i];
        if (x.test(s)) {
          return x;
        }
      }
      return void 0;
    };
    const find$1 = (regexes, agent) => {
      const r2 = firstMatch(regexes, agent);
      if (!r2) {
        return {
          major: 0,
          minor: 0
        };
      }
      const group = (i) => {
        return Number(agent.replace(r2, "$" + i));
      };
      return nu$3(group(1), group(2));
    };
    const detect$5 = (versionRegexes, agent) => {
      const cleanedAgent = String(agent).toLowerCase();
      if (versionRegexes.length === 0) {
        return unknown$2();
      }
      return find$1(versionRegexes, cleanedAgent);
    };
    const unknown$2 = () => {
      return nu$3(0, 0);
    };
    const nu$3 = (major, minor) => {
      return {
        major,
        minor
      };
    };
    const Version = {
      nu: nu$3,
      detect: detect$5,
      unknown: unknown$2
    };
    const detectBrowser$1 = (browsers2, userAgentData) => {
      return findMap(userAgentData.brands, (uaBrand) => {
        const lcBrand = uaBrand.brand.toLowerCase();
        return find$2(browsers2, (browser3) => {
          var _a;
          return lcBrand === ((_a = browser3.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        }).map((info) => ({
          current: info.name,
          version: Version.nu(parseInt(uaBrand.version, 10), 0)
        }));
      });
    };
    const detect$4 = (candidates, userAgent2) => {
      const agent = String(userAgent2).toLowerCase();
      return find$2(candidates, (candidate) => {
        return candidate.search(agent);
      });
    };
    const detectBrowser = (browsers2, userAgent2) => {
      return detect$4(browsers2, userAgent2).map((browser3) => {
        const version = Version.detect(browser3.versionRegexes, userAgent2);
        return {
          current: browser3.name,
          version
        };
      });
    };
    const detectOs = (oses2, userAgent2) => {
      return detect$4(oses2, userAgent2).map((os2) => {
        const version = Version.detect(os2.versionRegexes, userAgent2);
        return {
          current: os2.name,
          version
        };
      });
    };
    const removeFromStart = (str, numChars) => {
      return str.substring(numChars);
    };
    const checkRange = (str, substr, start3) => substr === "" || str.length >= substr.length && str.substr(start3, start3 + substr.length) === substr;
    const removeLeading = (str, prefix) => {
      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;
    };
    const contains$1 = (str, substr, start3 = 0, end3) => {
      const idx = str.indexOf(substr, start3);
      if (idx !== -1) {
        return isUndefined2(end3) ? true : idx + substr.length <= end3;
      } else {
        return false;
      }
    };
    const startsWith = (str, prefix) => {
      return checkRange(str, prefix, 0);
    };
    const endsWith2 = (str, suffix) => {
      return checkRange(str, suffix, str.length - suffix.length);
    };
    const blank = (r2) => (s) => s.replace(r2, "");
    const trim$3 = blank(/^\s+|\s+$/g);
    const lTrim = blank(/^\s+/g);
    const rTrim = blank(/\s+$/g);
    const isNotEmpty = (s) => s.length > 0;
    const isEmpty$3 = (s) => !isNotEmpty(s);
    const repeat = (s, count2) => count2 <= 0 ? "" : new Array(count2 + 1).join(s);
    const toInt2 = (value2, radix = 10) => {
      const num = parseInt(value2, radix);
      return isNaN(num) ? Optional.none() : Optional.some(num);
    };
    const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
    const checkContains = (target) => {
      return (uastring) => {
        return contains$1(uastring, target);
      };
    };
    const browsers = [
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (uastring) => {
          return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
        }
      },
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [
          /.*?chrome\/([0-9]+)\.([0-9]+).*/,
          normalVersionRegex
        ],
        search: (uastring) => {
          return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
        }
      },
      {
        name: "IE",
        versionRegexes: [
          /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
          /.*?rv:([0-9]+)\.([0-9]+).*/
        ],
        search: (uastring) => {
          return contains$1(uastring, "msie") || contains$1(uastring, "trident");
        }
      },
      {
        name: "Opera",
        versionRegexes: [
          normalVersionRegex,
          /.*?opera\/([0-9]+)\.([0-9]+).*/
        ],
        search: checkContains("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: checkContains("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [
          normalVersionRegex,
          /.*?cpu os ([0-9]+)_([0-9]+).*/
        ],
        search: (uastring) => {
          return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
        }
      }
    ];
    const oses = [
      {
        name: "Windows",
        search: checkContains("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (uastring) => {
          return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
        },
        versionRegexes: [
          /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
          /.*cpu os ([0-9]+)_([0-9]+).*/,
          /.*cpu iphone os ([0-9]+)_([0-9]+).*/
        ]
      },
      {
        name: "Android",
        search: checkContains("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: checkContains("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: checkContains("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: checkContains("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: checkContains("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: checkContains("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ];
    const PlatformInfo = {
      browsers: constant(browsers),
      oses: constant(oses)
    };
    const edge = "Edge";
    const chromium = "Chromium";
    const ie = "IE";
    const opera = "Opera";
    const firefox = "Firefox";
    const safari = "Safari";
    const unknown$1 = () => {
      return nu$2({
        current: void 0,
        version: Version.unknown()
      });
    };
    const nu$2 = (info) => {
      const current = info.current;
      const version = info.version;
      const isBrowser2 = (name3) => () => current === name3;
      return {
        current,
        version,
        isEdge: isBrowser2(edge),
        isChromium: isBrowser2(chromium),
        isIE: isBrowser2(ie),
        isOpera: isBrowser2(opera),
        isFirefox: isBrowser2(firefox),
        isSafari: isBrowser2(safari)
      };
    };
    const Browser = {
      unknown: unknown$1,
      nu: nu$2,
      edge: constant(edge),
      chromium: constant(chromium),
      ie: constant(ie),
      opera: constant(opera),
      firefox: constant(firefox),
      safari: constant(safari)
    };
    const windows = "Windows";
    const ios = "iOS";
    const android = "Android";
    const linux = "Linux";
    const macos = "macOS";
    const solaris = "Solaris";
    const freebsd = "FreeBSD";
    const chromeos = "ChromeOS";
    const unknown = () => {
      return nu$1({
        current: void 0,
        version: Version.unknown()
      });
    };
    const nu$1 = (info) => {
      const current = info.current;
      const version = info.version;
      const isOS = (name3) => () => current === name3;
      return {
        current,
        version,
        isWindows: isOS(windows),
        isiOS: isOS(ios),
        isAndroid: isOS(android),
        isMacOS: isOS(macos),
        isLinux: isOS(linux),
        isSolaris: isOS(solaris),
        isFreeBSD: isOS(freebsd),
        isChromeOS: isOS(chromeos)
      };
    };
    const OperatingSystem = {
      unknown,
      nu: nu$1,
      windows: constant(windows),
      ios: constant(ios),
      android: constant(android),
      linux: constant(linux),
      macos: constant(macos),
      solaris: constant(solaris),
      freebsd: constant(freebsd),
      chromeos: constant(chromeos)
    };
    const detect$3 = (userAgent2, userAgentDataOpt, mediaMatch2) => {
      const browsers2 = PlatformInfo.browsers();
      const oses2 = PlatformInfo.oses();
      const browser3 = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers2, userAgentData)).orThunk(() => detectBrowser(browsers2, userAgent2)).fold(Browser.unknown, Browser.nu);
      const os2 = detectOs(oses2, userAgent2).fold(OperatingSystem.unknown, OperatingSystem.nu);
      const deviceType2 = DeviceType(os2, browser3, userAgent2, mediaMatch2);
      return {
        browser: browser3,
        os: os2,
        deviceType: deviceType2
      };
    };
    const PlatformDetection = { detect: detect$3 };
    const mediaMatch = (query) => window.matchMedia(query).matches;
    let platform$2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
    const detect$2 = () => platform$2();
    const userAgent = navigator.userAgent;
    const platform$1 = detect$2();
    const browser$1 = platform$1.browser;
    const os = platform$1.os;
    const deviceType = platform$1.deviceType;
    const windowsPhone = userAgent.indexOf("Windows Phone") !== -1;
    const Env = {
      transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      documentMode: browser$1.isIE() ? document.documentMode || 7 : 10,
      cacheSuffix: null,
      container: null,
      canHaveCSP: !browser$1.isIE(),
      windowsPhone,
      browser: {
        current: browser$1.current,
        version: browser$1.version,
        isChromium: browser$1.isChromium,
        isEdge: browser$1.isEdge,
        isFirefox: browser$1.isFirefox,
        isIE: browser$1.isIE,
        isOpera: browser$1.isOpera,
        isSafari: browser$1.isSafari
      },
      os: {
        current: os.current,
        version: os.version,
        isAndroid: os.isAndroid,
        isChromeOS: os.isChromeOS,
        isFreeBSD: os.isFreeBSD,
        isiOS: os.isiOS,
        isLinux: os.isLinux,
        isMacOS: os.isMacOS,
        isSolaris: os.isSolaris,
        isWindows: os.isWindows
      },
      deviceType: {
        isDesktop: deviceType.isDesktop,
        isiPad: deviceType.isiPad,
        isiPhone: deviceType.isiPhone,
        isPhone: deviceType.isPhone,
        isTablet: deviceType.isTablet,
        isTouch: deviceType.isTouch,
        isWebView: deviceType.isWebView
      }
    };
    const whiteSpaceRegExp$1 = /^\s*|\s*$/g;
    const trim$2 = (str) => {
      return isNullable(str) ? "" : ("" + str).replace(whiteSpaceRegExp$1, "");
    };
    const is$3 = (obj, type2) => {
      if (!type2) {
        return obj !== void 0;
      }
      if (type2 === "array" && isArray2(obj)) {
        return true;
      }
      return typeof obj === type2;
    };
    const makeMap$4 = (items, delim, map3 = {}) => {
      const resolvedItems = isString2(items) ? items.split(delim || ",") : items || [];
      let i = resolvedItems.length;
      while (i--) {
        map3[resolvedItems[i]] = {};
      }
      return map3;
    };
    const hasOwnProperty$1 = has$2;
    const extend$3 = (obj, ...exts) => {
      for (let i = 0; i < exts.length; i++) {
        const ext = exts[i];
        for (const name3 in ext) {
          if (has$2(ext, name3)) {
            const value2 = ext[name3];
            if (value2 !== void 0) {
              obj[name3] = value2;
            }
          }
        }
      }
      return obj;
    };
    const walk$4 = function(o, f, n, s) {
      s = s || this;
      if (o) {
        if (n) {
          o = o[n];
        }
        each$c(o, (o2, i) => {
          if (f.call(s, o2, i, n) === false) {
            return false;
          } else {
            walk$4(o2, f, n, s);
            return true;
          }
        });
      }
    };
    const resolve$3 = (n, o = window) => {
      const path2 = n.split(".");
      for (let i = 0, l = path2.length; i < l; i++) {
        o = o[path2[i]];
        if (!o) {
          break;
        }
      }
      return o;
    };
    const explode$3 = (s, d) => {
      if (isArray$12(s)) {
        return s;
      } else if (s === "") {
        return [];
      } else {
        return map$1(s.split(d || ","), trim$2);
      }
    };
    const _addCacheSuffix = (url) => {
      const cacheSuffix = Env.cacheSuffix;
      if (cacheSuffix) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + cacheSuffix;
      }
      return url;
    };
    const Tools = {
      trim: trim$2,
      isArray: isArray2,
      is: is$3,
      toArray: toArray$12,
      makeMap: makeMap$4,
      each: each$c,
      map: map$1,
      grep: filter$3,
      inArray: indexOf,
      hasOwn: hasOwnProperty$1,
      extend: extend$3,
      walk: walk$4,
      resolve: resolve$3,
      explode: explode$3,
      _addCacheSuffix
    };
    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left2) => comparator(left2, rhs));
    const cat = (arr) => {
      const r2 = [];
      const push = (x) => {
        r2.push(x);
      };
      for (let i = 0; i < arr.length; i++) {
        arr[i].each(push);
      }
      return r2;
    };
    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();
    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
    const Global = typeof window !== "undefined" ? window : Function("return this;")();
    const path = (parts, scope) => {
      let o = scope !== void 0 && scope !== null ? scope : Global;
      for (let i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
        o = o[parts[i]];
      }
      return o;
    };
    const resolve$2 = (p, scope) => {
      const parts = p.split(".");
      return path(parts, scope);
    };
    const unsafe = (name3, scope) => {
      return resolve$2(name3, scope);
    };
    const getOrDie = (name3, scope) => {
      const actual = unsafe(name3, scope);
      if (actual === void 0 || actual === null) {
        throw new Error(name3 + " not available on this browser");
      }
      return actual;
    };
    const getPrototypeOf$1 = Object.getPrototypeOf;
    const sandHTMLElement = (scope) => {
      return getOrDie("HTMLElement", scope);
    };
    const isPrototypeOf = (x) => {
      const scope = resolve$2("ownerDocument.defaultView", x);
      return isObject2(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
    };
    const COMMENT = 8;
    const DOCUMENT = 9;
    const DOCUMENT_FRAGMENT = 11;
    const ELEMENT = 1;
    const TEXT = 3;
    const name2 = (element) => {
      const r2 = element.dom.nodeName;
      return r2.toLowerCase();
    };
    const type$1 = (element) => element.dom.nodeType;
    const isType = (t) => (element) => type$1(element) === t;
    const isComment$1 = (element) => type$1(element) === COMMENT || name2(element) === "#comment";
    const isHTMLElement2 = (element) => isElement$7(element) && isPrototypeOf(element.dom);
    const isElement$7 = isType(ELEMENT);
    const isText$b = isType(TEXT);
    const isDocument$2 = isType(DOCUMENT);
    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);
    const isTag = (tag) => (e) => isElement$7(e) && name2(e) === tag;
    const rawSet = (dom2, key, value2) => {
      if (isString2(value2) || isBoolean2(value2) || isNumber2(value2)) {
        dom2.setAttribute(key, value2 + "");
      } else {
        console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
        throw new Error("Attribute value was not simple");
      }
    };
    const set$3 = (element, key, value2) => {
      rawSet(element.dom, key, value2);
    };
    const setAll$1 = (element, attrs) => {
      const dom2 = element.dom;
      each$d(attrs, (v, k) => {
        rawSet(dom2, k, v);
      });
    };
    const get$9 = (element, key) => {
      const v = element.dom.getAttribute(key);
      return v === null ? void 0 : v;
    };
    const getOpt = (element, key) => Optional.from(get$9(element, key));
    const has$1 = (element, key) => {
      const dom2 = element.dom;
      return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
    };
    const remove$b = (element, key) => {
      element.dom.removeAttribute(key);
    };
    const hasNone = (element) => {
      const attrs = element.dom.attributes;
      return attrs === void 0 || attrs === null || attrs.length === 0;
    };
    const clone$4 = (element) => foldl(element.dom.attributes, (acc, attr2) => {
      acc[attr2.name] = attr2.value;
      return acc;
    }, {});
    const read$4 = (element, attr2) => {
      const value2 = get$9(element, attr2);
      return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
    };
    const add$4 = (element, attr2, id) => {
      const old = read$4(element, attr2);
      const nu2 = old.concat([id]);
      set$3(element, attr2, nu2.join(" "));
      return true;
    };
    const remove$a = (element, attr2, id) => {
      const nu2 = filter$5(read$4(element, attr2), (v) => v !== id);
      if (nu2.length > 0) {
        set$3(element, attr2, nu2.join(" "));
      } else {
        remove$b(element, attr2);
      }
      return false;
    };
    const supports = (element) => element.dom.classList !== void 0;
    const get$8 = (element) => read$4(element, "class");
    const add$3 = (element, clazz) => add$4(element, "class", clazz);
    const remove$9 = (element, clazz) => remove$a(element, "class", clazz);
    const toggle$2 = (element, clazz) => {
      if (contains$2(get$8(element), clazz)) {
        return remove$9(element, clazz);
      } else {
        return add$3(element, clazz);
      }
    };
    const add$2 = (element, clazz) => {
      if (supports(element)) {
        element.dom.classList.add(clazz);
      } else {
        add$3(element, clazz);
      }
    };
    const cleanClass = (element) => {
      const classList = supports(element) ? element.dom.classList : get$8(element);
      if (classList.length === 0) {
        remove$b(element, "class");
      }
    };
    const remove$8 = (element, clazz) => {
      if (supports(element)) {
        const classList = element.dom.classList;
        classList.remove(clazz);
      } else {
        remove$9(element, clazz);
      }
      cleanClass(element);
    };
    const toggle$1 = (element, clazz) => {
      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);
      cleanClass(element);
      return result;
    };
    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);
    const fromHtml$1 = (html2, scope) => {
      const doc = scope || document;
      const div = doc.createElement("div");
      div.innerHTML = html2;
      if (!div.hasChildNodes() || div.childNodes.length > 1) {
        const message = "HTML does not have a single root node";
        console.error(message, html2);
        throw new Error(message);
      }
      return fromDom$2(div.childNodes[0]);
    };
    const fromTag = (tag, scope) => {
      const doc = scope || document;
      const node = doc.createElement(tag);
      return fromDom$2(node);
    };
    const fromText = (text3, scope) => {
      const doc = scope || document;
      const node = doc.createTextNode(text3);
      return fromDom$2(node);
    };
    const fromDom$2 = (node) => {
      if (node === null || node === void 0) {
        throw new Error("Node cannot be null or undefined");
      }
      return { dom: node };
    };
    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);
    const SugarElement = {
      fromHtml: fromHtml$1,
      fromTag,
      fromText,
      fromDom: fromDom$2,
      fromPoint: fromPoint$2
    };
    const toArray2 = (target, f) => {
      const r2 = [];
      const recurse = (e) => {
        r2.push(e);
        return f(e);
      };
      let cur = f(target);
      do {
        cur = cur.bind(recurse);
      } while (cur.isSome());
      return r2;
    };
    const is$1 = (element, selector) => {
      const dom2 = element.dom;
      if (dom2.nodeType !== ELEMENT) {
        return false;
      } else {
        const elem = dom2;
        if (elem.matches !== void 0) {
          return elem.matches(selector);
        } else if (elem.msMatchesSelector !== void 0) {
          return elem.msMatchesSelector(selector);
        } else if (elem.webkitMatchesSelector !== void 0) {
          return elem.webkitMatchesSelector(selector);
        } else if (elem.mozMatchesSelector !== void 0) {
          return elem.mozMatchesSelector(selector);
        } else {
          throw new Error("Browser lacks native selectors");
        }
      }
    };
    const bypassSelector = (dom2) => dom2.nodeType !== ELEMENT && dom2.nodeType !== DOCUMENT && dom2.nodeType !== DOCUMENT_FRAGMENT || dom2.childElementCount === 0;
    const all2 = (selector, scope) => {
      const base = scope === void 0 ? document : scope.dom;
      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);
    };
    const one = (selector, scope) => {
      const base = scope === void 0 ? document : scope.dom;
      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);
    };
    const eq = (e1, e2) => e1.dom === e2.dom;
    const contains2 = (e1, e2) => {
      const d1 = e1.dom;
      const d2 = e2.dom;
      return d1 === d2 ? false : d1.contains(d2);
    };
    const owner$1 = (element) => SugarElement.fromDom(element.dom.ownerDocument);
    const documentOrOwner = (dos) => isDocument$2(dos) ? dos : owner$1(dos);
    const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
    const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
    const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
    const parents$1 = (element, isRoot2) => {
      const stop2 = isFunction2(isRoot2) ? isRoot2 : never;
      let dom2 = element.dom;
      const ret = [];
      while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
        const rawParent = dom2.parentNode;
        const p = SugarElement.fromDom(rawParent);
        ret.push(p);
        if (stop2(p) === true) {
          break;
        } else {
          dom2 = rawParent;
        }
      }
      return ret;
    };
    const siblings = (element) => {
      const filterSelf = (elements) => filter$5(elements, (x) => !eq(element, x));
      return parent(element).map(children$1).map(filterSelf).getOr([]);
    };
    const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
    const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
    const prevSiblings = (element) => reverse(toArray2(element, prevSibling));
    const nextSiblings = (element) => toArray2(element, nextSibling);
    const children$1 = (element) => map$3(element.dom.childNodes, SugarElement.fromDom);
    const child$1 = (element, index) => {
      const cs = element.dom.childNodes;
      return Optional.from(cs[index]).map(SugarElement.fromDom);
    };
    const firstChild = (element) => child$1(element, 0);
    const lastChild = (element) => child$1(element, element.dom.childNodes.length - 1);
    const childNodesCount = (element) => element.dom.childNodes.length;
    const getHead = (doc) => {
      const b = doc.dom.head;
      if (b === null || b === void 0) {
        throw new Error("Head is not available yet");
      }
      return SugarElement.fromDom(b);
    };
    const isShadowRoot2 = (dos) => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);
    const supported2 = isFunction2(Element.prototype.attachShadow) && isFunction2(Node.prototype.getRootNode);
    const isSupported$1 = constant(supported2);
    const getRootNode2 = supported2 ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
    const getStyleContainer = (dos) => isShadowRoot2(dos) ? dos : getHead(documentOrOwner(dos));
    const getContentContainer = (dos) => isShadowRoot2(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
    const getShadowRoot = (e) => {
      const r2 = getRootNode2(e);
      return isShadowRoot2(r2) ? Optional.some(r2) : Optional.none();
    };
    const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
    const getOriginalEventTarget = (event) => {
      if (isSupported$1() && isNonNullable(event.target)) {
        const el = SugarElement.fromDom(event.target);
        if (isElement$7(el) && isOpenShadowHost(el)) {
          if (event.composed && event.composedPath) {
            const composedPath = event.composedPath();
            if (composedPath) {
              return head(composedPath);
            }
          }
        }
      }
      return Optional.from(event.target);
    };
    const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);
    const inBody = (element) => {
      const dom2 = isText$b(element) ? element.dom.parentNode : element.dom;
      if (dom2 === void 0 || dom2 === null || dom2.ownerDocument === null) {
        return false;
      }
      const doc = dom2.ownerDocument;
      return getShadowRoot(SugarElement.fromDom(dom2)).fold(() => doc.body.contains(dom2), compose1(inBody, getShadowHost));
    };
    var ClosestOrAncestor = (is2, ancestor2, scope, a, isRoot2) => {
      if (is2(scope, a)) {
        return Optional.some(scope);
      } else if (isFunction2(isRoot2) && isRoot2(scope)) {
        return Optional.none();
      } else {
        return ancestor2(scope, a, isRoot2);
      }
    };
    const ancestor$4 = (scope, predicate, isRoot2) => {
      let element = scope.dom;
      const stop2 = isFunction2(isRoot2) ? isRoot2 : never;
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        if (predicate(el)) {
          return Optional.some(el);
        } else if (stop2(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$4 = (scope, predicate, isRoot2) => {
      const is2 = (s, test) => test(s);
      return ClosestOrAncestor(is2, ancestor$4, scope, predicate, isRoot2);
    };
    const sibling$1 = (scope, predicate) => {
      const element = scope.dom;
      if (!element.parentNode) {
        return Optional.none();
      }
      return child(SugarElement.fromDom(element.parentNode), (x) => !eq(scope, x) && predicate(x));
    };
    const child = (scope, predicate) => {
      const pred = (node) => predicate(SugarElement.fromDom(node));
      const result = find$2(scope.dom.childNodes, pred);
      return result.map(SugarElement.fromDom);
    };
    const descendant$1 = (scope, predicate) => {
      const descend2 = (node) => {
        for (let i = 0; i < node.childNodes.length; i++) {
          const child2 = SugarElement.fromDom(node.childNodes[i]);
          if (predicate(child2)) {
            return Optional.some(child2);
          }
          const res2 = descend2(node.childNodes[i]);
          if (res2.isSome()) {
            return res2;
          }
        }
        return Optional.none();
      };
      return descend2(scope.dom);
    };
    const ancestor$3 = (scope, selector, isRoot2) => ancestor$4(scope, (e) => is$1(e, selector), isRoot2);
    const descendant = (scope, selector) => one(selector, scope);
    const closest$3 = (scope, selector, isRoot2) => {
      const is2 = (element, selector2) => is$1(element, selector2);
      return ClosestOrAncestor(is2, ancestor$3, scope, selector, isRoot2);
    };
    const closest$2 = (target) => closest$3(target, "[contenteditable]");
    const isEditable$3 = (element, assumeEditable = false) => {
      if (inBody(element)) {
        return element.dom.isContentEditable;
      } else {
        return closest$2(element).fold(constant(assumeEditable), (editable) => getRaw$1(editable) === "true");
      }
    };
    const getRaw$1 = (element) => element.dom.contentEditable;
    const isSupported = (dom2) => dom2.style !== void 0 && isFunction2(dom2.style.getPropertyValue);
    const internalSet = (dom2, property, value2) => {
      if (!isString2(value2)) {
        console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
        throw new Error("CSS value must be a string: " + value2);
      }
      if (isSupported(dom2)) {
        dom2.style.setProperty(property, value2);
      }
    };
    const internalRemove = (dom2, property) => {
      if (isSupported(dom2)) {
        dom2.style.removeProperty(property);
      }
    };
    const set$2 = (element, property, value2) => {
      const dom2 = element.dom;
      internalSet(dom2, property, value2);
    };
    const setAll = (element, css) => {
      const dom2 = element.dom;
      each$d(css, (v, k) => {
        internalSet(dom2, k, v);
      });
    };
    const get$7 = (element, property) => {
      const dom2 = element.dom;
      const styles2 = window.getComputedStyle(dom2);
      const r2 = styles2.getPropertyValue(property);
      return r2 === "" && !inBody(element) ? getUnsafeProperty(dom2, property) : r2;
    };
    const getUnsafeProperty = (dom2, property) => isSupported(dom2) ? dom2.style.getPropertyValue(property) : "";
    const getRaw = (element, property) => {
      const dom2 = element.dom;
      const raw = getUnsafeProperty(dom2, property);
      return Optional.from(raw).filter((r2) => r2.length > 0);
    };
    const getAllRaw = (element) => {
      const css = {};
      const dom2 = element.dom;
      if (isSupported(dom2)) {
        for (let i = 0; i < dom2.style.length; i++) {
          const ruleName = dom2.style.item(i);
          css[ruleName] = dom2.style[ruleName];
        }
      }
      return css;
    };
    const remove$7 = (element, property) => {
      const dom2 = element.dom;
      internalRemove(dom2, property);
      if (is$2(getOpt(element, "style").map(trim$3), "")) {
        remove$b(element, "style");
      }
    };
    const reflow2 = (e) => e.dom.offsetWidth;
    const before$3 = (marker, element) => {
      const parent$1 = parent(marker);
      parent$1.each((v) => {
        v.dom.insertBefore(element.dom, marker.dom);
      });
    };
    const after$4 = (marker, element) => {
      const sibling2 = nextSibling(marker);
      sibling2.fold(() => {
        const parent$1 = parent(marker);
        parent$1.each((v) => {
          append$1(v, element);
        });
      }, (v) => {
        before$3(v, element);
      });
    };
    const prepend = (parent2, element) => {
      const firstChild$1 = firstChild(parent2);
      firstChild$1.fold(() => {
        append$1(parent2, element);
      }, (v) => {
        parent2.dom.insertBefore(element.dom, v.dom);
      });
    };
    const append$1 = (parent2, element) => {
      parent2.dom.appendChild(element.dom);
    };
    const wrap$2 = (element, wrapper) => {
      before$3(element, wrapper);
      append$1(wrapper, element);
    };
    const after$3 = (marker, elements) => {
      each$e(elements, (x, i) => {
        const e = i === 0 ? marker : elements[i - 1];
        after$4(e, x);
      });
    };
    const append2 = (parent2, elements) => {
      each$e(elements, (x) => {
        append$1(parent2, x);
      });
    };
    const empty = (element) => {
      element.dom.textContent = "";
      each$e(children$1(element), (rogue) => {
        remove$6(rogue);
      });
    };
    const remove$6 = (element) => {
      const dom2 = element.dom;
      if (dom2.parentNode !== null) {
        dom2.parentNode.removeChild(dom2);
      }
    };
    const unwrap = (wrapper) => {
      const children2 = children$1(wrapper);
      if (children2.length > 0) {
        after$3(wrapper, children2);
      }
      remove$6(wrapper);
    };
    const fromHtml = (html2, scope) => {
      const doc = scope || document;
      const div = doc.createElement("div");
      div.innerHTML = html2;
      return children$1(SugarElement.fromDom(div));
    };
    const fromDom$1 = (nodes) => map$3(nodes, SugarElement.fromDom);
    const get$6 = (element) => element.dom.innerHTML;
    const set$1 = (element, content) => {
      const owner2 = owner$1(element);
      const docDom = owner2.dom;
      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
      const contentElements = fromHtml(content, docDom);
      append2(fragment, contentElements);
      empty(element);
      append$1(element, fragment);
    };
    const getOuter = (element) => {
      const container = SugarElement.fromTag("div");
      const clone2 = SugarElement.fromDom(element.dom.cloneNode(true));
      append$1(container, clone2);
      return get$6(container);
    };
    const mkEvent = (target, x, y, stop2, prevent2, kill, raw) => ({
      target,
      x,
      y,
      stop: stop2,
      prevent: prevent2,
      kill,
      raw
    });
    const fromRawEvent = (rawEvent) => {
      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
      const stop2 = () => rawEvent.stopPropagation();
      const prevent2 = () => rawEvent.preventDefault();
      const kill = compose(prevent2, stop2);
      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop2, prevent2, kill, rawEvent);
    };
    const handle$1 = (filter3, handler) => (rawEvent) => {
      if (filter3(rawEvent)) {
        handler(fromRawEvent(rawEvent));
      }
    };
    const binder = (element, event, filter3, handler, useCapture) => {
      const wrapped = handle$1(filter3, handler);
      element.dom.addEventListener(event, wrapped, useCapture);
      return { unbind: curry(unbind, element, event, wrapped, useCapture) };
    };
    const bind$2 = (element, event, filter3, handler) => binder(element, event, filter3, handler, false);
    const unbind = (element, event, handler, useCapture) => {
      element.dom.removeEventListener(event, handler, useCapture);
    };
    const r = (left2, top2) => {
      const translate2 = (x, y) => r(left2 + x, top2 + y);
      return {
        left: left2,
        top: top2,
        translate: translate2
      };
    };
    const SugarPosition = r;
    const boxPosition = (dom2) => {
      const box = dom2.getBoundingClientRect();
      return SugarPosition(box.left, box.top);
    };
    const firstDefinedOrZero = (a, b) => {
      if (a !== void 0) {
        return a;
      } else {
        return b !== void 0 ? b : 0;
      }
    };
    const absolute = (element) => {
      const doc = element.dom.ownerDocument;
      const body = doc.body;
      const win = doc.defaultView;
      const html2 = doc.documentElement;
      if (body === element.dom) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html2.scrollTop);
      const scrollLeft2 = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html2.scrollLeft);
      const clientTop = firstDefinedOrZero(html2.clientTop, body.clientTop);
      const clientLeft = firstDefinedOrZero(html2.clientLeft, body.clientLeft);
      return viewport2(element).translate(scrollLeft2 - clientLeft, scrollTop - clientTop);
    };
    const viewport2 = (element) => {
      const dom2 = element.dom;
      const doc = dom2.ownerDocument;
      const body = doc.body;
      if (body === dom2) {
        return SugarPosition(body.offsetLeft, body.offsetTop);
      }
      if (!inBody(element)) {
        return SugarPosition(0, 0);
      }
      return boxPosition(dom2);
    };
    const get$5 = (_DOC) => {
      const doc = _DOC !== void 0 ? _DOC.dom : document;
      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
      const y = doc.body.scrollTop || doc.documentElement.scrollTop;
      return SugarPosition(x, y);
    };
    const to = (x, y, _DOC) => {
      const doc = _DOC !== void 0 ? _DOC.dom : document;
      const win = doc.defaultView;
      if (win) {
        win.scrollTo(x, y);
      }
    };
    const intoView = (element, alignToTop) => {
      const isSafari = detect$2().browser.isSafari();
      if (isSafari && isFunction2(element.dom.scrollIntoViewIfNeeded)) {
        element.dom.scrollIntoViewIfNeeded(false);
      } else {
        element.dom.scrollIntoView(alignToTop);
      }
    };
    const get$4 = (_win) => {
      const win = _win === void 0 ? window : _win;
      if (detect$2().browser.isFirefox()) {
        return Optional.none();
      } else {
        return Optional.from(win.visualViewport);
      }
    };
    const bounds = (x, y, width2, height2) => ({
      x,
      y,
      width: width2,
      height: height2,
      right: x + width2,
      bottom: y + height2
    });
    const getBounds = (_win) => {
      const win = _win === void 0 ? window : _win;
      const doc = win.document;
      const scroll = get$5(SugarElement.fromDom(doc));
      return get$4(win).fold(() => {
        const html2 = win.document.documentElement;
        const width2 = html2.clientWidth;
        const height2 = html2.clientHeight;
        return bounds(scroll.left, scroll.top, width2, height2);
      }, (visualViewport) => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
    };
    const children = (scope, predicate) => filter$5(children$1(scope), predicate);
    const descendants$1 = (scope, predicate) => {
      let result = [];
      each$e(children$1(scope), (x) => {
        if (predicate(x)) {
          result = result.concat([x]);
        }
        result = result.concat(descendants$1(x, predicate));
      });
      return result;
    };
    const descendants = (scope, selector) => all2(selector, scope);
    const ancestor$2 = (scope, selector, isRoot2) => ancestor$3(scope, selector, isRoot2).isSome();
    class DomTreeWalker {
      constructor(startNode, rootNode) {
        this.node = startNode;
        this.rootNode = rootNode;
        this.current = this.current.bind(this);
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.prev2 = this.prev2.bind(this);
      }
      current() {
        return this.node;
      }
      next(shallow2) {
        this.node = this.findSibling(this.node, "firstChild", "nextSibling", shallow2);
        return this.node;
      }
      prev(shallow2) {
        this.node = this.findSibling(this.node, "lastChild", "previousSibling", shallow2);
        return this.node;
      }
      prev2(shallow2) {
        this.node = this.findPreviousNode(this.node, shallow2);
        return this.node;
      }
      findSibling(node, startName, siblingName, shallow2) {
        if (node) {
          if (!shallow2 && node[startName]) {
            return node[startName];
          }
          if (node !== this.rootNode) {
            let sibling2 = node[siblingName];
            if (sibling2) {
              return sibling2;
            }
            for (let parent2 = node.parentNode; parent2 && parent2 !== this.rootNode; parent2 = parent2.parentNode) {
              sibling2 = parent2[siblingName];
              if (sibling2) {
                return sibling2;
              }
            }
          }
        }
        return void 0;
      }
      findPreviousNode(node, shallow2) {
        if (node) {
          const sibling2 = node.previousSibling;
          if (this.rootNode && sibling2 === this.rootNode) {
            return;
          }
          if (sibling2) {
            if (!shallow2) {
              for (let child2 = sibling2.lastChild; child2; child2 = child2.lastChild) {
                if (!child2.lastChild) {
                  return child2;
                }
              }
            }
            return sibling2;
          }
          const parent2 = node.parentNode;
          if (parent2 && parent2 !== this.rootNode) {
            return parent2;
          }
        }
        return void 0;
      }
    }
    const isNodeType = (type2) => {
      return (node) => {
        return !!node && node.nodeType === type2;
      };
    };
    const isRestrictedNode = (node) => !!node && !Object.getPrototypeOf(node);
    const isElement$6 = isNodeType(1);
    const matchNodeName = (name3) => {
      const lowerCasedName = name3.toLowerCase();
      return (node) => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;
    };
    const matchNodeNames = (names) => {
      const lowerCasedNames = names.map((s) => s.toLowerCase());
      return (node) => {
        if (node && node.nodeName) {
          const nodeName = node.nodeName.toLowerCase();
          return contains$2(lowerCasedNames, nodeName);
        }
        return false;
      };
    };
    const matchStyleValues = (name3, values2) => {
      const items = values2.toLowerCase().split(" ");
      return (node) => {
        if (isElement$6(node)) {
          const win = node.ownerDocument.defaultView;
          if (win) {
            for (let i = 0; i < items.length; i++) {
              const computed = win.getComputedStyle(node, null);
              const cssValue = computed ? computed.getPropertyValue(name3) : null;
              if (cssValue === items[i]) {
                return true;
              }
            }
          }
        }
        return false;
      };
    };
    const hasAttribute = (attrName) => {
      return (node) => {
        return isElement$6(node) && node.hasAttribute(attrName);
      };
    };
    const hasAttributeValue = (attrName, attrValue) => {
      return (node) => {
        return isElement$6(node) && node.getAttribute(attrName) === attrValue;
      };
    };
    const isBogus$2 = (node) => isElement$6(node) && node.hasAttribute("data-mce-bogus");
    const isBogusAll$1 = (node) => isElement$6(node) && node.getAttribute("data-mce-bogus") === "all";
    const isTable$2 = (node) => isElement$6(node) && node.tagName === "TABLE";
    const hasContentEditableState = (value2) => {
      return (node) => {
        if (isElement$6(node)) {
          if (node.contentEditable === value2) {
            return true;
          }
          if (node.getAttribute("data-mce-contenteditable") === value2) {
            return true;
          }
        }
        return false;
      };
    };
    const isTextareaOrInput = matchNodeNames([
      "textarea",
      "input"
    ]);
    const isText$a = isNodeType(3);
    const isCData = isNodeType(4);
    const isPi = isNodeType(7);
    const isComment = isNodeType(8);
    const isDocument$1 = isNodeType(9);
    const isDocumentFragment = isNodeType(11);
    const isBr$6 = matchNodeName("br");
    const isImg = matchNodeName("img");
    const isContentEditableTrue$3 = hasContentEditableState("true");
    const isContentEditableFalse$b = hasContentEditableState("false");
    const isTableCell$3 = matchNodeNames([
      "td",
      "th"
    ]);
    const isTableCellOrCaption = matchNodeNames([
      "td",
      "th",
      "caption"
    ]);
    const isMedia$2 = matchNodeNames([
      "video",
      "audio",
      "object",
      "embed"
    ]);
    const isListItem$2 = matchNodeName("li");
    const zeroWidth = "\uFEFF";
    const nbsp = " ";
    const isZwsp$1 = (char) => char === zeroWidth;
    const removeZwsp = (s) => s.replace(/\uFEFF/g, "");
    const NodeValue = (is2, name3) => {
      const get2 = (element) => {
        if (!is2(element)) {
          throw new Error("Can only get " + name3 + " value of a " + name3 + " node");
        }
        return getOption2(element).getOr("");
      };
      const getOption2 = (element) => is2(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
      const set2 = (element, value2) => {
        if (!is2(element)) {
          throw new Error("Can only set raw " + name3 + " value of a " + name3 + " node");
        }
        element.dom.nodeValue = value2;
      };
      return {
        get: get2,
        getOption: getOption2,
        set: set2
      };
    };
    const api$1 = NodeValue(isText$b, "text");
    const get$3 = (element) => api$1.get(element);
    const getOption = (element) => api$1.getOption(element);
    const set = (element, value2) => api$1.set(element, value2);
    const blocks = [
      "article",
      "aside",
      "details",
      "div",
      "dt",
      "figcaption",
      "footer",
      "form",
      "fieldset",
      "header",
      "hgroup",
      "html",
      "main",
      "nav",
      "section",
      "summary",
      "body",
      "p",
      "dl",
      "multicol",
      "dd",
      "figure",
      "address",
      "center",
      "blockquote",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "listing",
      "xmp",
      "pre",
      "plaintext",
      "menu",
      "dir",
      "ul",
      "ol",
      "li",
      "hr",
      "table",
      "tbody",
      "thead",
      "tfoot",
      "th",
      "tr",
      "td",
      "caption"
    ];
    const tableCells = [
      "td",
      "th"
    ];
    const tableSections = [
      "thead",
      "tbody",
      "tfoot"
    ];
    const textBlocks = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "p",
      "div",
      "address",
      "pre",
      "form",
      "blockquote",
      "center",
      "dir",
      "fieldset",
      "header",
      "footer",
      "article",
      "section",
      "hgroup",
      "aside",
      "nav",
      "figure"
    ];
    const headings = [
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6"
    ];
    const listItems$1 = [
      "li",
      "dd",
      "dt"
    ];
    const lists = [
      "ul",
      "ol",
      "dl"
    ];
    const wsElements = [
      "pre",
      "script",
      "textarea",
      "style"
    ];
    const wrapBlockElements = ["pre"].concat(headings);
    const lazyLookup = (items) => {
      let lookup2;
      return (node) => {
        lookup2 = lookup2 ? lookup2 : mapToObject(items, always);
        return has$2(lookup2, name2(node));
      };
    };
    const isBlock$2 = lazyLookup(blocks);
    const isTable$1 = (node) => name2(node) === "table";
    const isInline$1 = (node) => isElement$7(node) && !isBlock$2(node);
    const isBr$5 = (node) => isElement$7(node) && name2(node) === "br";
    const isTextBlock$2 = lazyLookup(textBlocks);
    const isList = lazyLookup(lists);
    const isListItem$1 = lazyLookup(listItems$1);
    const isTableSection = lazyLookup(tableSections);
    const isTableCell$2 = lazyLookup(tableCells);
    const isWsPreserveElement = lazyLookup(wsElements);
    const isWrapBlockElement = lazyLookup(wrapBlockElements);
    const isWrapElement = (node) => isWrapBlockElement(node) || isInline$1(node);
    const getLastChildren$1 = (elm) => {
      const children2 = [];
      let rawNode = elm.dom;
      while (rawNode) {
        children2.push(SugarElement.fromDom(rawNode));
        rawNode = rawNode.lastChild;
      }
      return children2;
    };
    const removeTrailingBr = (elm) => {
      const allBrs = descendants(elm, "br");
      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);
      if (allBrs.length === brs.length) {
        each$e(brs, remove$6);
      }
    };
    const createPaddingBr = () => {
      const br = SugarElement.fromTag("br");
      set$3(br, "data-mce-bogus", "1");
      return br;
    };
    const fillWithPaddingBr = (elm) => {
      empty(elm);
      append$1(elm, createPaddingBr());
    };
    const trimBlockTrailingBr = (elm) => {
      lastChild(elm).each((lastChild2) => {
        prevSibling(lastChild2).each((lastChildPrevSibling) => {
          if (isBlock$2(elm) && isBr$5(lastChild2) && isBlock$2(lastChildPrevSibling)) {
            remove$6(lastChild2);
          }
        });
      });
    };
    const ZWSP$1 = zeroWidth;
    const isZwsp = isZwsp$1;
    const trim$12 = removeZwsp;
    const isElement$5 = isElement$6;
    const isText$9 = isText$a;
    const isCaretContainerBlock$1 = (node) => {
      if (isText$9(node)) {
        node = node.parentNode;
      }
      return isElement$5(node) && node.hasAttribute("data-mce-caret");
    };
    const isCaretContainerInline = (node) => isText$9(node) && isZwsp(node.data);
    const isCaretContainer$2 = (node) => isCaretContainerBlock$1(node) || isCaretContainerInline(node);
    const hasContent = (node) => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);
    const insertInline$1 = (node, before2) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      const parentNode = node.parentNode;
      if (!before2) {
        const sibling2 = node.nextSibling;
        if (isText$9(sibling2)) {
          if (isCaretContainer$2(sibling2)) {
            return sibling2;
          }
          if (startsWithCaretContainer$1(sibling2)) {
            sibling2.splitText(1);
            return sibling2;
          }
        }
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);
        }
      } else {
        const sibling2 = node.previousSibling;
        if (isText$9(sibling2)) {
          if (isCaretContainer$2(sibling2)) {
            return sibling2;
          }
          if (endsWithCaretContainer$1(sibling2)) {
            return sibling2.splitText(sibling2.data.length - 1);
          }
        }
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);
      }
      return textNode;
    };
    const isBeforeInline = (pos) => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);
    };
    const isAfterInline = (pos) => {
      const container = pos.container();
      if (!isText$a(container)) {
        return false;
      }
      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);
    };
    const insertBlock = (blockName, node, before2) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const blockNode = doc.createElement(blockName);
      blockNode.setAttribute("data-mce-caret", before2 ? "before" : "after");
      blockNode.setAttribute("data-mce-bogus", "all");
      blockNode.appendChild(createPaddingBr().dom);
      const parentNode = node.parentNode;
      if (!before2) {
        if (node.nextSibling) {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);
        } else {
          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);
        }
      } else {
        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);
      }
      return blockNode;
    };
    const startsWithCaretContainer$1 = (node) => isText$9(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer$1 = (node) => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;
    const trimBogusBr = (elm) => {
      var _a;
      const brs = elm.getElementsByTagName("br");
      const lastBr = brs[brs.length - 1];
      if (isBogus$2(lastBr)) {
        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);
      }
    };
    const showCaretContainerBlock = (caretContainer) => {
      if (caretContainer && caretContainer.hasAttribute("data-mce-caret")) {
        trimBogusBr(caretContainer);
        caretContainer.removeAttribute("data-mce-caret");
        caretContainer.removeAttribute("data-mce-bogus");
        caretContainer.removeAttribute("style");
        caretContainer.removeAttribute("data-mce-style");
        caretContainer.removeAttribute("_moz_abspos");
        return caretContainer;
      }
      return null;
    };
    const isRangeInCaretContainerBlock = (range2) => isCaretContainerBlock$1(range2.startContainer);
    const isContentEditableTrue$2 = isContentEditableTrue$3;
    const isContentEditableFalse$a = isContentEditableFalse$b;
    const isBr$4 = isBr$6;
    const isText$8 = isText$a;
    const isInvalidTextElement = matchNodeNames([
      "script",
      "style",
      "textarea"
    ]);
    const isAtomicInline = matchNodeNames([
      "img",
      "input",
      "textarea",
      "hr",
      "iframe",
      "video",
      "audio",
      "object",
      "embed"
    ]);
    const isTable = matchNodeNames(["table"]);
    const isCaretContainer$1 = isCaretContainer$2;
    const isCaretCandidate$3 = (node) => {
      if (isCaretContainer$1(node)) {
        return false;
      }
      if (isText$8(node)) {
        return !isInvalidTextElement(node.parentNode);
      }
      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);
    };
    const isUnselectable = (node) => isElement$6(node) && node.getAttribute("unselectable") === "true";
    const isNonUiContentEditableFalse = (node) => !isUnselectable(node) && isContentEditableFalse$a(node);
    const isInEditable = (node, root2) => {
      for (let tempNode = node.parentNode; tempNode && tempNode !== root2; tempNode = tempNode.parentNode) {
        if (isNonUiContentEditableFalse(tempNode)) {
          return false;
        }
        if (isContentEditableTrue$2(tempNode)) {
          return true;
        }
      }
      return true;
    };
    const isAtomicContentEditableFalse = (node) => {
      if (!isNonUiContentEditableFalse(node)) {
        return false;
      }
      return !foldl(from(node.getElementsByTagName("*")), (result, elm) => {
        return result || isContentEditableTrue$2(elm);
      }, false);
    };
    const isAtomic$1 = (node) => isAtomicInline(node) || isAtomicContentEditableFalse(node);
    const isEditableCaretCandidate$1 = (node, root2) => isCaretCandidate$3(node) && isInEditable(node, root2);
    const whiteSpaceRegExp = /^[ \t\r\n]*$/;
    const isWhitespaceText = (text3) => whiteSpaceRegExp.test(text3);
    const isCollapsibleWhitespace$1 = (c) => " \f	\v".indexOf(c) !== -1;
    const isNewLineChar = (c) => c === "\n" || c === "\r";
    const isNewline = (text3, idx) => idx < text3.length && idx >= 0 ? isNewLineChar(text3[idx]) : false;
    const normalize$4 = (text3, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {
      const tabSpace = repeat(" ", tabSpaces);
      const normalizedText = text3.replace(/\t/g, tabSpace);
      const result = foldl(normalizedText, (acc, c) => {
        if (isCollapsibleWhitespace$1(c) || c === nbsp) {
          if (acc.pcIsSpace || acc.str === "" && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {
            return {
              pcIsSpace: false,
              str: acc.str + nbsp
            };
          } else {
            return {
              pcIsSpace: true,
              str: acc.str + " "
            };
          }
        } else {
          return {
            pcIsSpace: isNewLineChar(c),
            str: acc.str + c
          };
        }
      }, {
        pcIsSpace: false,
        str: ""
      });
      return result.str;
    };
    const hasWhitespacePreserveParent = (node, rootNode) => {
      const rootElement = SugarElement.fromDom(rootNode);
      const startNode = SugarElement.fromDom(node);
      return ancestor$2(startNode, "pre,code", curry(eq, rootElement));
    };
    const isWhitespace$1 = (node, rootNode) => {
      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);
    };
    const isNamedAnchor = (node) => {
      return isElement$6(node) && node.nodeName === "A" && !node.hasAttribute("href") && (node.hasAttribute("name") || node.hasAttribute("id"));
    };
    const isContent$1 = (node, rootNode) => {
      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);
    };
    const isBookmark = hasAttribute("data-mce-bookmark");
    const isBogus$1 = hasAttribute("data-mce-bogus");
    const isBogusAll = hasAttributeValue("data-mce-bogus", "all");
    const isEmptyNode = (targetNode, skipBogus) => {
      let brCount = 0;
      if (isContent$1(targetNode, targetNode)) {
        return false;
      } else {
        let node = targetNode.firstChild;
        if (!node) {
          return true;
        }
        const walker = new DomTreeWalker(node, targetNode);
        do {
          if (skipBogus) {
            if (isBogusAll(node)) {
              node = walker.next(true);
              continue;
            }
            if (isBogus$1(node)) {
              node = walker.next();
              continue;
            }
          }
          if (isBr$6(node)) {
            brCount++;
            node = walker.next();
            continue;
          }
          if (isContent$1(node, targetNode)) {
            return false;
          }
          node = walker.next();
        } while (node);
        return brCount <= 1;
      }
    };
    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);
    const transparentBlockAttr = "data-mce-block";
    const elementNames = (map3) => filter$5(keys(map3), (key) => !/[A-Z]/.test(key));
    const makeSelectorFromSchemaMap = (map3) => elementNames(map3).join(",");
    const updateTransparent = (blocksSelector, transparent) => {
      if (isNonNullable(transparent.querySelector(blocksSelector))) {
        transparent.setAttribute(transparentBlockAttr, "true");
        if (transparent.getAttribute("data-mce-selected") === "inline-boundary") {
          transparent.removeAttribute("data-mce-selected");
        }
        return true;
      } else {
        transparent.removeAttribute(transparentBlockAttr);
        return false;
      }
    };
    const updateBlockStateOnChildren = (schema, scope) => {
      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());
      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
      return filter$5(scope.querySelectorAll(transparentSelector), (transparent) => updateTransparent(blocksSelector, transparent));
    };
    const trimEdge = (el, leftSide) => {
      var _a;
      const childPropertyName = leftSide ? "lastChild" : "firstChild";
      for (let child2 = el[childPropertyName]; child2; child2 = child2[childPropertyName]) {
        if (isEmpty$2(SugarElement.fromDom(child2))) {
          (_a = child2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child2);
          return;
        }
      }
    };
    const split$2 = (parentElm, splitElm) => {
      const range2 = document.createRange();
      const parentNode = parentElm.parentNode;
      if (parentNode) {
        range2.setStartBefore(parentElm);
        range2.setEndBefore(splitElm);
        const beforeFragment = range2.extractContents();
        trimEdge(beforeFragment, true);
        range2.setStartAfter(splitElm);
        range2.setEndAfter(parentElm);
        const afterFragment = range2.extractContents();
        trimEdge(afterFragment, false);
        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {
          parentNode.insertBefore(beforeFragment, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {
          parentNode.insertBefore(splitElm, parentElm);
        }
        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {
          parentNode.insertBefore(afterFragment, parentElm);
        }
        parentNode.removeChild(parentElm);
      }
    };
    const splitInvalidChildren = (schema, scope, transparentBlocks) => {
      const blocksElements = schema.getBlockElements();
      const rootNode = SugarElement.fromDom(scope);
      const isBlock2 = (el) => name2(el) in blocksElements;
      const isRoot2 = (el) => eq(el, rootNode);
      each$e(fromDom$1(transparentBlocks), (transparentBlock) => {
        ancestor$4(transparentBlock, isBlock2, isRoot2).each((parentBlock) => {
          const invalidChildren = children(transparentBlock, (el) => isBlock2(el) && !schema.isValidChild(name2(parentBlock), name2(el)));
          if (invalidChildren.length > 0) {
            const stateScope = parentElement(parentBlock);
            each$e(invalidChildren, (child2) => {
              ancestor$4(child2, isBlock2, isRoot2).each((parentBlock2) => {
                split$2(parentBlock2.dom, child2.dom);
              });
            });
            stateScope.each((scope2) => updateBlockStateOnChildren(schema, scope2.dom));
          }
        });
      });
    };
    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {
      each$e([
        ...transparentBlocks,
        ...isTransparentBlock(schema, scope) ? [scope] : []
      ], (block) => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), (elm) => {
        if (isTransparentInline(schema, elm.dom)) {
          unwrap(elm);
        }
      }));
    };
    const updateChildren = (schema, scope) => {
      const transparentBlocks = updateBlockStateOnChildren(schema, scope);
      splitInvalidChildren(schema, scope, transparentBlocks);
      unwrapInvalidChildren(schema, scope, transparentBlocks);
    };
    const updateElement = (schema, target) => {
      if (isTransparentElement(schema, target)) {
        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());
        updateTransparent(blocksSelector, target);
      }
    };
    const updateCaret = (schema, root2, caretParent) => {
      const isRoot2 = (el) => eq(el, SugarElement.fromDom(root2));
      const parents2 = parents$1(SugarElement.fromDom(caretParent), isRoot2);
      get$b(parents2, parents2.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root2), (scope) => updateChildren(schema, scope.dom));
    };
    const hasBlockAttr = (el) => el.hasAttribute(transparentBlockAttr);
    const isTransparentElementName = (schema, name3) => has$2(schema.getTransparentElements(), name3);
    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);
    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);
    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);
    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString2(node.attr(transparentBlockAttr));
    const isTransparentAstInline = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isUndefined2(node.attr(transparentBlockAttr));
    const browser2 = detect$2().browser;
    const firstElement = (nodes) => find$2(nodes, isElement$7);
    const getTableCaptionDeltaY = (elm) => {
      if (browser2.isFirefox() && name2(elm) === "table") {
        return firstElement(children$1(elm)).filter((elm2) => {
          return name2(elm2) === "caption";
        }).bind((caption) => {
          return firstElement(nextSiblings(caption)).map((body) => {
            const bodyTop = body.dom.offsetTop;
            const captionTop = caption.dom.offsetTop;
            const captionHeight = caption.dom.offsetHeight;
            return bodyTop <= captionTop ? -captionHeight : 0;
          });
        }).getOr(0);
      } else {
        return 0;
      }
    };
    const hasChild = (elm, child2) => elm.children && contains$2(elm.children, child2);
    const getPos = (body, elm, rootElm) => {
      let x = 0, y = 0;
      const doc = body.ownerDocument;
      rootElm = rootElm ? rootElm : body;
      if (elm) {
        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), "position") === "static") {
          const pos = elm.getBoundingClientRect();
          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;
          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;
          return {
            x,
            y
          };
        }
        let offsetParent = elm;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          const castOffsetParent = offsetParent;
          x += castOffsetParent.offsetLeft || 0;
          y += castOffsetParent.offsetTop || 0;
          offsetParent = castOffsetParent.offsetParent;
        }
        offsetParent = elm.parentNode;
        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {
          x -= offsetParent.scrollLeft || 0;
          y -= offsetParent.scrollTop || 0;
          offsetParent = offsetParent.parentNode;
        }
        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));
      }
      return {
        x,
        y
      };
    };
    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {
      let idCount = 0;
      const loadedStates = {};
      const edos = SugarElement.fromDom(documentOrShadowRoot);
      const doc = documentOrOwner(edos);
      const _setReferrerPolicy = (referrerPolicy) => {
        settings.referrerPolicy = referrerPolicy;
      };
      const _setContentCssCors = (contentCssCors) => {
        settings.contentCssCors = contentCssCors;
      };
      const addStyle = (element) => {
        append$1(getStyleContainer(edos), element);
      };
      const removeStyle = (id) => {
        const styleContainer = getStyleContainer(edos);
        descendant(styleContainer, "#" + id).each(remove$6);
      };
      const getOrCreateState = (url) => get$a(loadedStates, url).getOrThunk(() => ({
        id: "mce-u" + idCount++,
        passed: [],
        failed: [],
        count: 0
      }));
      const load = (url) => new Promise((success, failure) => {
        let link;
        const urlWithSuffix = Tools._addCacheSuffix(url);
        const state2 = getOrCreateState(urlWithSuffix);
        loadedStates[urlWithSuffix] = state2;
        state2.count++;
        const resolve2 = (callbacks, status) => {
          each$e(callbacks, call);
          state2.status = status;
          state2.passed = [];
          state2.failed = [];
          if (link) {
            link.onload = null;
            link.onerror = null;
            link = null;
          }
        };
        const passed = () => resolve2(state2.passed, 2);
        const failed = () => resolve2(state2.failed, 3);
        if (success) {
          state2.passed.push(success);
        }
        if (failure) {
          state2.failed.push(failure);
        }
        if (state2.status === 1) {
          return;
        }
        if (state2.status === 2) {
          passed();
          return;
        }
        if (state2.status === 3) {
          failed();
          return;
        }
        state2.status = 1;
        const linkElem = SugarElement.fromTag("link", doc.dom);
        setAll$1(linkElem, {
          rel: "stylesheet",
          type: "text/css",
          id: state2.id
        });
        if (settings.contentCssCors) {
          set$3(linkElem, "crossOrigin", "anonymous");
        }
        if (settings.referrerPolicy) {
          set$3(linkElem, "referrerpolicy", settings.referrerPolicy);
        }
        link = linkElem.dom;
        link.onload = passed;
        link.onerror = failed;
        addStyle(linkElem);
        set$3(linkElem, "href", urlWithSuffix);
      });
      const loadAll = (urls) => {
        const loadedUrls = Promise.allSettled(map$3(urls, (url) => load(url).then(constant(url))));
        return loadedUrls.then((results) => {
          const parts = partition$2(results, (r2) => r2.status === "fulfilled");
          if (parts.fail.length > 0) {
            return Promise.reject(map$3(parts.fail, (result) => result.reason));
          } else {
            return map$3(parts.pass, (result) => result.value);
          }
        });
      };
      const unload = (url) => {
        const urlWithSuffix = Tools._addCacheSuffix(url);
        get$a(loadedStates, urlWithSuffix).each((state2) => {
          const count2 = --state2.count;
          if (count2 === 0) {
            delete loadedStates[urlWithSuffix];
            removeStyle(state2.id);
          }
        });
      };
      const unloadAll = (urls) => {
        each$e(urls, (url) => {
          unload(url);
        });
      };
      return {
        load,
        loadAll,
        unload,
        unloadAll,
        _setReferrerPolicy,
        _setContentCssCors
      };
    };
    const create$d2 = () => {
      const map3 = /* @__PURE__ */ new WeakMap();
      const forElement = (referenceElement, settings) => {
        const root2 = getRootNode2(referenceElement);
        const rootDom = root2.dom;
        return Optional.from(map3.get(rootDom)).getOrThunk(() => {
          const sl = StyleSheetLoader(rootDom, settings);
          map3.set(rootDom, sl);
          return sl;
        });
      };
      return { forElement };
    };
    const instance = create$d2();
    const isSpan = (node) => node.nodeName.toLowerCase() === "span";
    const isInlineContent = (node, root2) => isNonNullable(node) && (isContent$1(node, root2) || isInline$1(SugarElement.fromDom(node)));
    const surroundedByInlineContent = (node, root2) => {
      const prev2 = new DomTreeWalker(node, root2).prev(false);
      const next2 = new DomTreeWalker(node, root2).next(false);
      const prevIsInline = isUndefined2(prev2) || isInlineContent(prev2, root2);
      const nextIsInline = isUndefined2(next2) || isInlineContent(next2, root2);
      return prevIsInline && nextIsInline;
    };
    const isBookmarkNode$2 = (node) => isSpan(node) && node.getAttribute("data-mce-type") === "bookmark";
    const isKeepTextNode = (node, root2) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root2);
    const isKeepElement = (node) => isElement$6(node) ? node.childNodes.length > 0 : false;
    const isDocument = (node) => isDocumentFragment(node) || isDocument$1(node);
    const trimNode = (dom2, node, root2) => {
      var _a;
      const rootNode = root2 || node;
      if (isElement$6(node) && isBookmarkNode$2(node)) {
        return node;
      }
      const children2 = node.childNodes;
      for (let i = children2.length - 1; i >= 0; i--) {
        trimNode(dom2, children2[i], rootNode);
      }
      if (isElement$6(node)) {
        const currentChildren = node.childNodes;
        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);
        }
      }
      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode)) {
        dom2.remove(node);
      }
      return node;
    };
    const makeMap$3 = Tools.makeMap;
    const attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    const rawCharsRegExp = /[<>&\"\']/g;
    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
    const asciiMap = {
      128: "€",
      130: "‚",
      131: "ƒ",
      132: "„",
      133: "…",
      134: "†",
      135: "‡",
      136: "ˆ",
      137: "‰",
      138: "Š",
      139: "‹",
      140: "Œ",
      142: "Ž",
      145: "‘",
      146: "’",
      147: "“",
      148: "”",
      149: "•",
      150: "–",
      151: "—",
      152: "˜",
      153: "™",
      154: "š",
      155: "›",
      156: "œ",
      158: "ž",
      159: "Ÿ"
    };
    const baseEntities = {
      '"': "&quot;",
      "'": "&#39;",
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      "`": "&#96;"
    };
    const reverseEntities = {
      "&lt;": "<",
      "&gt;": ">",
      "&amp;": "&",
      "&quot;": '"',
      "&apos;": `'`
    };
    const nativeDecode = (text3) => {
      const elm = SugarElement.fromTag("div").dom;
      elm.innerHTML = text3;
      return elm.textContent || elm.innerText || text3;
    };
    const buildEntitiesLookup = (items, radix) => {
      const lookup2 = {};
      if (items) {
        const itemList = items.split(",");
        radix = radix || 10;
        for (let i = 0; i < itemList.length; i += 2) {
          const chr = String.fromCharCode(parseInt(itemList[i], radix));
          if (!baseEntities[chr]) {
            const entity = "&" + itemList[i + 1] + ";";
            lookup2[chr] = entity;
            lookup2[entity] = chr;
          }
        }
        return lookup2;
      } else {
        return void 0;
      }
    };
    const namedEntities = buildEntitiesLookup("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32);
    const encodeRaw = (text3, attr2) => text3.replace(attr2 ? attrsCharsRegExp : textCharsRegExp, (chr) => {
      return baseEntities[chr] || chr;
    });
    const encodeAllRaw = (text3) => ("" + text3).replace(rawCharsRegExp, (chr) => {
      return baseEntities[chr] || chr;
    });
    const encodeNumeric = (text3, attr2) => text3.replace(attr2 ? attrsCharsRegExp : textCharsRegExp, (chr) => {
      if (chr.length > 1) {
        return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
      }
      return baseEntities[chr] || "&#" + chr.charCodeAt(0) + ";";
    });
    const encodeNamed = (text3, attr2, entities) => {
      const resolveEntities = entities || namedEntities;
      return text3.replace(attr2 ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        return baseEntities[chr] || resolveEntities[chr] || chr;
      });
    };
    const getEncodeFunc = (name3, entities) => {
      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;
      const encodeNamedAndNumeric = (text3, attr2) => text3.replace(attr2 ? attrsCharsRegExp : textCharsRegExp, (chr) => {
        if (baseEntities[chr] !== void 0) {
          return baseEntities[chr];
        }
        if (entitiesMap[chr] !== void 0) {
          return entitiesMap[chr];
        }
        if (chr.length > 1) {
          return "&#" + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ";";
        }
        return "&#" + chr.charCodeAt(0) + ";";
      });
      const encodeCustomNamed = (text3, attr2) => {
        return encodeNamed(text3, attr2, entitiesMap);
      };
      const nameMap = makeMap$3(name3.replace(/\+/g, ","));
      if (nameMap.named && nameMap.numeric) {
        return encodeNamedAndNumeric;
      }
      if (nameMap.named) {
        if (entities) {
          return encodeCustomNamed;
        }
        return encodeNamed;
      }
      if (nameMap.numeric) {
        return encodeNumeric;
      }
      return encodeRaw;
    };
    const decode = (text3) => text3.replace(entityRegExp, (all3, numeric) => {
      if (numeric) {
        if (numeric.charAt(0).toLowerCase() === "x") {
          numeric = parseInt(numeric.substr(1), 16);
        } else {
          numeric = parseInt(numeric, 10);
        }
        if (numeric > 65535) {
          numeric -= 65536;
          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
        }
        return asciiMap[numeric] || String.fromCharCode(numeric);
      }
      return reverseEntities[all3] || namedEntities[all3] || nativeDecode(all3);
    });
    const Entities = {
      encodeRaw,
      encodeAllRaw,
      encodeNumeric,
      encodeNamed,
      getEncodeFunc,
      decode
    };
    const lookupCache = {};
    const mapCache = {};
    const dummyObj = {};
    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode, inArray = Tools.inArray;
    const split$1 = (items, delim) => {
      items = Tools.trim(items);
      return items ? items.split(delim || " ") : [];
    };
    const createMap = (defaultValue, extendWith = {}) => {
      const value2 = makeMap$2(defaultValue, " ", makeMap$2(defaultValue.toUpperCase(), " "));
      return extend$2(value2, extendWith);
    };
    const getTextRootBlockElements = (schema) => createMap("td th li dt dd figcaption caption details summary", schema.getTextBlockElements());
    const compileSchema = (type2) => {
      const schema = {};
      let globalAttributes, blockContent;
      let phrasingContent, flowContent;
      const add2 = (name3, attributes = "", children2 = "") => {
        const childNames = split$1(children2);
        const names = split$1(name3);
        let ni = names.length;
        while (ni--) {
          const attributesOrder = split$1([
            globalAttributes,
            attributes
          ].join(" "));
          schema[names[ni]] = {
            attributes: mapToObject(attributesOrder, () => ({})),
            attributesOrder,
            children: mapToObject(childNames, constant(dummyObj))
          };
        }
      };
      const addAttrs = (name3, attributes) => {
        const names = split$1(name3);
        const attrs = split$1(attributes);
        let ni = names.length;
        while (ni--) {
          const schemaItem = schema[names[ni]];
          for (let i = 0, l = attrs.length; i < l; i++) {
            schemaItem.attributes[attrs[i]] = {};
            schemaItem.attributesOrder.push(attrs[i]);
          }
        }
      };
      if (lookupCache[type2]) {
        return lookupCache[type2];
      }
      globalAttributes = "id accesskey class dir lang style tabindex title role";
      blockContent = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul";
      phrasingContent = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment";
      if (type2 !== "html4") {
        const transparentContent = "a ins del canvas map";
        globalAttributes += " contenteditable contextmenu draggable dropzone hidden spellcheck translate";
        blockContent += " article aside details dialog figure main header footer hgroup section nav " + transparentContent;
        phrasingContent += " audio canvas command datalist mark meter output picture progress time wbr video ruby bdi keygen";
      }
      if (type2 !== "html5-strict") {
        globalAttributes += " xml:lang";
        const html4PhrasingContent = "acronym applet basefont big font strike tt";
        phrasingContent = [
          phrasingContent,
          html4PhrasingContent
        ].join(" ");
        each$b(split$1(html4PhrasingContent), (name3) => {
          add2(name3, "", phrasingContent);
        });
        const html4BlockContent = "center dir isindex noframes";
        blockContent = [
          blockContent,
          html4BlockContent
        ].join(" ");
        flowContent = [
          blockContent,
          phrasingContent
        ].join(" ");
        each$b(split$1(html4BlockContent), (name3) => {
          add2(name3, "", flowContent);
        });
      }
      flowContent = flowContent || [
        blockContent,
        phrasingContent
      ].join(" ");
      add2("html", "manifest", "head body");
      add2("head", "", "base command link meta noscript script style title");
      add2("title hr noscript br");
      add2("base", "href target");
      add2("link", "href rel media hreflang type sizes hreflang");
      add2("meta", "name http-equiv content charset");
      add2("style", "media type scoped");
      add2("script", "src async defer type charset");
      add2("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", flowContent);
      add2("address dt dd div caption", "", flowContent);
      add2("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", phrasingContent);
      add2("blockquote", "cite", flowContent);
      add2("ol", "reversed start type", "li");
      add2("ul", "", "li");
      add2("li", "value", flowContent);
      add2("dl", "", "dt dd");
      add2("a", "href target rel media hreflang type", flowContent);
      add2("q", "cite", phrasingContent);
      add2("ins del", "cite datetime", flowContent);
      add2("img", "src sizes srcset alt usemap ismap width height");
      add2("iframe", "src name width height", flowContent);
      add2("embed", "src type width height");
      add2("object", "data type typemustmatch name usemap form width height", [
        flowContent,
        "param"
      ].join(" "));
      add2("param", "name value");
      add2("map", "name", [
        flowContent,
        "area"
      ].join(" "));
      add2("area", "alt coords shape href target rel media hreflang type");
      add2("table", "border", "caption colgroup thead tfoot tbody tr" + (type2 === "html4" ? " col" : ""));
      add2("colgroup", "span", "col");
      add2("col", "span");
      add2("tbody thead tfoot", "", "tr");
      add2("tr", "", "td th");
      add2("td", "colspan rowspan headers", flowContent);
      add2("th", "colspan rowspan headers scope abbr", flowContent);
      add2("form", "accept-charset action autocomplete enctype method name novalidate target", flowContent);
      add2("fieldset", "disabled form name", [
        flowContent,
        "legend"
      ].join(" "));
      add2("label", "form for", phrasingContent);
      add2("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width");
      add2("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", type2 === "html4" ? flowContent : phrasingContent);
      add2("select", "disabled form multiple name required size", "option optgroup");
      add2("optgroup", "disabled label", "option");
      add2("option", "disabled label selected value");
      add2("textarea", "cols dirname disabled form maxlength name readonly required rows wrap");
      add2("menu", "type label", [
        flowContent,
        "li"
      ].join(" "));
      add2("noscript", "", flowContent);
      if (type2 !== "html4") {
        add2("wbr");
        add2("ruby", "", [
          phrasingContent,
          "rt rp"
        ].join(" "));
        add2("figcaption", "", flowContent);
        add2("mark rt rp summary bdi", "", phrasingContent);
        add2("canvas", "width height", flowContent);
        add2("video", "src crossorigin poster preload autoplay mediagroup loop muted controls width height buffered", [
          flowContent,
          "track source"
        ].join(" "));
        add2("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [
          flowContent,
          "track source"
        ].join(" "));
        add2("picture", "", "img source");
        add2("source", "src srcset type media sizes");
        add2("track", "kind src srclang label default");
        add2("datalist", "", [
          phrasingContent,
          "option"
        ].join(" "));
        add2("article section nav aside main header footer", "", flowContent);
        add2("hgroup", "", "h1 h2 h3 h4 h5 h6");
        add2("figure", "", [
          flowContent,
          "figcaption"
        ].join(" "));
        add2("time", "datetime", phrasingContent);
        add2("dialog", "open", flowContent);
        add2("command", "type label icon disabled checked radiogroup command");
        add2("output", "for form name", phrasingContent);
        add2("progress", "value max", phrasingContent);
        add2("meter", "value min max low high optimum", phrasingContent);
        add2("details", "open", [
          flowContent,
          "summary"
        ].join(" "));
        add2("keygen", "autofocus challenge disabled form keytype name");
      }
      if (type2 !== "html5-strict") {
        addAttrs("script", "language xml:space");
        addAttrs("style", "xml:space");
        addAttrs("object", "declare classid code codebase codetype archive standby align border hspace vspace");
        addAttrs("embed", "align name hspace vspace");
        addAttrs("param", "valuetype type");
        addAttrs("a", "charset name rev shape coords");
        addAttrs("br", "clear");
        addAttrs("applet", "codebase archive code object alt name width height align hspace vspace");
        addAttrs("img", "name longdesc align border hspace vspace");
        addAttrs("iframe", "longdesc frameborder marginwidth marginheight scrolling align");
        addAttrs("font basefont", "size color face");
        addAttrs("input", "usemap align");
        addAttrs("select");
        addAttrs("textarea");
        addAttrs("h1 h2 h3 h4 h5 h6 div p legend caption", "align");
        addAttrs("ul", "type compact");
        addAttrs("li", "type");
        addAttrs("ol dl menu dir", "compact");
        addAttrs("pre", "width xml:space");
        addAttrs("hr", "align noshade size width");
        addAttrs("isindex", "prompt");
        addAttrs("table", "summary width frame rules cellspacing cellpadding align bgcolor");
        addAttrs("col", "width align char charoff valign");
        addAttrs("colgroup", "width align char charoff valign");
        addAttrs("thead", "align char charoff valign");
        addAttrs("tr", "align char charoff valign bgcolor");
        addAttrs("th", "axis align char charoff valign nowrap bgcolor width height");
        addAttrs("form", "accept");
        addAttrs("td", "abbr axis scope align char charoff valign nowrap bgcolor width height");
        addAttrs("tfoot", "align char charoff valign");
        addAttrs("tbody", "align char charoff valign");
        addAttrs("area", "nohref");
        addAttrs("body", "background bgcolor text link vlink alink");
      }
      if (type2 !== "html4") {
        addAttrs("input button select textarea", "autofocus");
        addAttrs("input textarea", "placeholder");
        addAttrs("a", "download");
        addAttrs("link script img", "crossorigin");
        addAttrs("img", "loading");
        addAttrs("iframe", "sandbox seamless allow allowfullscreen loading");
      }
      if (type2 !== "html4") {
        each$e([
          schema.video,
          schema.audio
        ], (item2) => {
          delete item2.children.audio;
          delete item2.children.video;
        });
      }
      each$b(split$1("a form meter progress dfn"), (name3) => {
        if (schema[name3]) {
          delete schema[name3].children[name3];
        }
      });
      delete schema.caption.children.table;
      delete schema.script;
      lookupCache[type2] = schema;
      return schema;
    };
    const compileElementMap = (value2, mode) => {
      if (value2) {
        const styles2 = {};
        if (isString2(value2)) {
          value2 = { "*": value2 };
        }
        each$b(value2, (value3, key) => {
          styles2[key] = styles2[key.toUpperCase()] = mode === "map" ? makeMap$2(value3, /[, ]/) : explode$2(value3, /[, ]/);
        });
        return styles2;
      } else {
        return void 0;
      }
    };
    const Schema = (settings = {}) => {
      var _a;
      const elements = {};
      const children2 = {};
      let patternElements = [];
      const customElementsMap = {};
      const specialElements = {};
      const createLookupTable = (option3, defaultValue, extendWith) => {
        const value2 = settings[option3];
        if (!value2) {
          let newValue = mapCache[option3];
          if (!newValue) {
            newValue = createMap(defaultValue, extendWith);
            mapCache[option3] = newValue;
          }
          return newValue;
        } else {
          return makeMap$2(value2, /[, ]/, makeMap$2(value2.toUpperCase(), /[, ]/));
        }
      };
      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : "html5";
      const schemaItems = compileSchema(schemaType);
      if (settings.verify_html === false) {
        settings.valid_elements = "*[*]";
      }
      const validStyles = compileElementMap(settings.valid_styles);
      const invalidStyles = compileElementMap(settings.invalid_styles, "map");
      const validClasses = compileElementMap(settings.valid_classes, "map");
      const whitespaceElementsMap = createLookupTable("whitespace_elements", "pre script noscript style textarea video audio iframe object code");
      const selfClosingElementsMap = createLookupTable("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr");
      const voidElementsMap = createLookupTable("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track");
      const boolAttrMap = createLookupTable("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen");
      const nonEmptyOrMoveCaretBeforeOnEnter = "td th iframe video audio object script code";
      const nonEmptyElementsMap = createLookupTable("non_empty_elements", nonEmptyOrMoveCaretBeforeOnEnter + " pre", voidElementsMap);
      const moveCaretBeforeOnEnterElementsMap = createLookupTable("move_caret_before_on_enter_elements", nonEmptyOrMoveCaretBeforeOnEnter + " table", voidElementsMap);
      const textBlockElementsMap = createLookupTable("text_block_elements", "h1 h2 h3 h4 h5 h6 p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure");
      const blockElementsMap = createLookupTable("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary", textBlockElementsMap);
      const textInlineElementsMap = createLookupTable("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp");
      const transparentElementsMap = createLookupTable("transparent_elements", "a ins del canvas map");
      each$b("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (name3) => {
        specialElements[name3] = new RegExp("</" + name3 + "[^>]*>", "gi");
      });
      const patternToRegExp = (str) => new RegExp("^" + str.replace(/([?+*])/g, ".$1") + "$");
      const addValidElements = (validElements) => {
        const elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        const attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/;
        const hasPatternsRegExp = /[*?+]/;
        if (validElements) {
          const validElementsArr = split$1(validElements, ",");
          let globalAttributes;
          let globalAttributesOrder;
          if (elements["@"]) {
            globalAttributes = elements["@"].attributes;
            globalAttributesOrder = elements["@"].attributesOrder;
          }
          for (let ei = 0, el = validElementsArr.length; ei < el; ei++) {
            let matches = elementRuleRegExp.exec(validElementsArr[ei]);
            if (matches) {
              const prefix = matches[1];
              const elementName = matches[2];
              const outputName = matches[3];
              const attrData = matches[5];
              const attributes = {};
              const attributesOrder = [];
              const element = {
                attributes,
                attributesOrder
              };
              if (prefix === "#") {
                element.paddEmpty = true;
              }
              if (prefix === "-") {
                element.removeEmpty = true;
              }
              if (matches[4] === "!") {
                element.removeEmptyAttrs = true;
              }
              if (globalAttributes) {
                each$d(globalAttributes, (value2, key) => {
                  attributes[key] = value2;
                });
                if (globalAttributesOrder) {
                  attributesOrder.push(...globalAttributesOrder);
                }
              }
              if (attrData) {
                const attrDatas = split$1(attrData, "|");
                for (let ai = 0, al = attrDatas.length; ai < al; ai++) {
                  matches = attrRuleRegExp.exec(attrDatas[ai]);
                  if (matches) {
                    const attr2 = {};
                    const attrType = matches[1];
                    const attrName = matches[2].replace(/[\\:]:/g, ":");
                    const attrPrefix = matches[3];
                    const value2 = matches[4];
                    if (attrType === "!") {
                      element.attributesRequired = element.attributesRequired || [];
                      element.attributesRequired.push(attrName);
                      attr2.required = true;
                    }
                    if (attrType === "-") {
                      delete attributes[attrName];
                      attributesOrder.splice(inArray(attributesOrder, attrName), 1);
                      continue;
                    }
                    if (attrPrefix) {
                      if (attrPrefix === "=") {
                        element.attributesDefault = element.attributesDefault || [];
                        element.attributesDefault.push({
                          name: attrName,
                          value: value2
                        });
                        attr2.defaultValue = value2;
                      }
                      if (attrPrefix === "~") {
                        element.attributesForced = element.attributesForced || [];
                        element.attributesForced.push({
                          name: attrName,
                          value: value2
                        });
                        attr2.forcedValue = value2;
                      }
                      if (attrPrefix === "<") {
                        attr2.validValues = makeMap$2(value2, "?");
                      }
                    }
                    if (hasPatternsRegExp.test(attrName)) {
                      const attrPattern = attr2;
                      element.attributePatterns = element.attributePatterns || [];
                      attrPattern.pattern = patternToRegExp(attrName);
                      element.attributePatterns.push(attrPattern);
                    } else {
                      if (!attributes[attrName]) {
                        attributesOrder.push(attrName);
                      }
                      attributes[attrName] = attr2;
                    }
                  }
                }
              }
              if (!globalAttributes && elementName === "@") {
                globalAttributes = attributes;
                globalAttributesOrder = attributesOrder;
              }
              if (outputName) {
                element.outputName = elementName;
                elements[outputName] = element;
              }
              if (hasPatternsRegExp.test(elementName)) {
                const patternElement = element;
                patternElement.pattern = patternToRegExp(elementName);
                patternElements.push(patternElement);
              } else {
                elements[elementName] = element;
              }
            }
          }
        }
      };
      const setValidElements = (validElements) => {
        patternElements = [];
        each$e(keys(elements), (name3) => {
          delete elements[name3];
        });
        addValidElements(validElements);
        each$b(schemaItems, (element, name3) => {
          children2[name3] = element.children;
        });
      };
      const addCustomElements = (customElements) => {
        const customElementRegExp = /^(~)?(.+)$/;
        if (customElements) {
          delete mapCache.text_block_elements;
          delete mapCache.block_elements;
          each$b(split$1(customElements, ","), (rule) => {
            const matches = customElementRegExp.exec(rule);
            if (matches) {
              const inline = matches[1] === "~";
              const cloneName = inline ? "span" : "div";
              const name3 = matches[2];
              children2[name3] = children2[cloneName];
              customElementsMap[name3] = cloneName;
              nonEmptyElementsMap[name3.toUpperCase()] = {};
              nonEmptyElementsMap[name3] = {};
              if (!inline) {
                blockElementsMap[name3.toUpperCase()] = {};
                blockElementsMap[name3] = {};
              }
              if (!elements[name3]) {
                let customRule = elements[cloneName];
                customRule = extend$2({}, customRule);
                delete customRule.removeEmptyAttrs;
                delete customRule.removeEmpty;
                elements[name3] = customRule;
              }
              each$b(children2, (element, elmName) => {
                if (element[cloneName]) {
                  children2[elmName] = element = extend$2({}, children2[elmName]);
                  element[name3] = element[cloneName];
                }
              });
            }
          });
        }
      };
      const addValidChildren = (validChildren) => {
        const childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        delete lookupCache[schemaType];
        if (validChildren) {
          each$b(split$1(validChildren, ","), (rule) => {
            const matches = childRuleRegExp.exec(rule);
            if (matches) {
              const prefix = matches[1];
              let parent2;
              if (prefix) {
                parent2 = children2[matches[2]];
              } else {
                parent2 = children2[matches[2]] = { "#comment": {} };
              }
              parent2 = children2[matches[2]];
              each$b(split$1(matches[3], "|"), (child2) => {
                if (prefix === "-") {
                  delete parent2[child2];
                } else {
                  parent2[child2] = {};
                }
              });
            }
          });
        }
      };
      const getElementRule = (name3) => {
        const element = elements[name3];
        if (element) {
          return element;
        }
        let i = patternElements.length;
        while (i--) {
          const patternElement = patternElements[i];
          if (patternElement.pattern.test(name3)) {
            return patternElement;
          }
        }
        return void 0;
      };
      if (!settings.valid_elements) {
        each$b(schemaItems, (element, name3) => {
          elements[name3] = {
            attributes: element.attributes,
            attributesOrder: element.attributesOrder
          };
          children2[name3] = element.children;
        });
        each$b(split$1("strong/b em/i"), (item2) => {
          const items = split$1(item2, "/");
          elements[items[1]].outputName = items[0];
        });
        each$b(textInlineElementsMap, (_val, name3) => {
          if (elements[name3]) {
            if (settings.padd_empty_block_inline_children) {
              elements[name3].paddInEmptyBlock = true;
            }
            elements[name3].removeEmpty = true;
          }
        });
        each$b(split$1("ol ul blockquote a table tbody"), (name3) => {
          if (elements[name3]) {
            elements[name3].removeEmpty = true;
          }
        });
        each$b(split$1("p h1 h2 h3 h4 h5 h6 th td pre div address caption li"), (name3) => {
          elements[name3].paddEmpty = true;
        });
        each$b(split$1("span"), (name3) => {
          elements[name3].removeEmptyAttrs = true;
        });
      } else {
        setValidElements(settings.valid_elements);
      }
      addCustomElements(settings.custom_elements);
      addValidChildren(settings.valid_children);
      addValidElements(settings.extended_valid_elements);
      addValidChildren("+ol[ul|ol],+ul[ul|ol]");
      each$b({
        dd: "dl",
        dt: "dl",
        li: "ul ol",
        td: "tr",
        th: "tr",
        tr: "tbody thead tfoot",
        tbody: "table",
        thead: "table",
        tfoot: "table",
        legend: "fieldset",
        area: "map",
        param: "video audio object"
      }, (parents2, item2) => {
        if (elements[item2]) {
          elements[item2].parentsRequired = split$1(parents2);
        }
      });
      if (settings.invalid_elements) {
        each$b(explode$2(settings.invalid_elements), (item2) => {
          if (elements[item2]) {
            delete elements[item2];
          }
        });
      }
      if (!getElementRule("span")) {
        addValidElements("span[!data-mce-type|*]");
      }
      const getValidStyles = constant(validStyles);
      const getInvalidStyles = constant(invalidStyles);
      const getValidClasses = constant(validClasses);
      const getBoolAttrs = constant(boolAttrMap);
      const getBlockElements = constant(blockElementsMap);
      const getTextBlockElements = constant(textBlockElementsMap);
      const getTextInlineElements = constant(textInlineElementsMap);
      const getVoidElements = constant(Object.seal(voidElementsMap));
      const getSelfClosingElements = constant(selfClosingElementsMap);
      const getNonEmptyElements = constant(nonEmptyElementsMap);
      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
      const getWhitespaceElements = constant(whitespaceElementsMap);
      const getTransparentElements = constant(transparentElementsMap);
      const getSpecialElements = constant(Object.seal(specialElements));
      const isValidChild = (name3, child2) => {
        const parent2 = children2[name3.toLowerCase()];
        return !!(parent2 && parent2[child2.toLowerCase()]);
      };
      const isValid2 = (name3, attr2) => {
        const rule = getElementRule(name3);
        if (rule) {
          if (attr2) {
            if (rule.attributes[attr2]) {
              return true;
            }
            const attrPatterns = rule.attributePatterns;
            if (attrPatterns) {
              let i = attrPatterns.length;
              while (i--) {
                if (attrPatterns[i].pattern.test(attr2)) {
                  return true;
                }
              }
            }
          } else {
            return true;
          }
        }
        return false;
      };
      const getCustomElements = constant(customElementsMap);
      return {
        type: schemaType,
        children: children2,
        elements,
        getValidStyles,
        getValidClasses,
        getBlockElements,
        getInvalidStyles,
        getVoidElements,
        getTextBlockElements,
        getTextInlineElements,
        getBoolAttrs,
        getElementRule,
        getSelfClosingElements,
        getNonEmptyElements,
        getMoveCaretBeforeOnEnterElements,
        getWhitespaceElements,
        getTransparentElements,
        getSpecialElements,
        isValidChild,
        isValid: isValid2,
        getCustomElements,
        addValidElements,
        setValidElements,
        addCustomElements,
        addValidChildren
      };
    };
    const Styles = (settings = {}, schema) => {
      const urlOrStrRegExp = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi;
      const styleRegExp = /\s*([^:]+):\s*([^;]+);?/g;
      const trimRightRegExp = /\s+$/;
      const encodingLookup = {};
      let validStyles;
      let invalidStyles;
      const invisibleChar = zeroWidth;
      if (schema) {
        validStyles = schema.getValidStyles();
        invalidStyles = schema.getInvalidStyles();
      }
      const encodingItems = (`\\" \\' \\; \\: ; : ` + invisibleChar).split(" ");
      for (let i = 0; i < encodingItems.length; i++) {
        encodingLookup[encodingItems[i]] = invisibleChar + i;
        encodingLookup[invisibleChar + i] = encodingItems[i];
      }
      const self2 = {
        parse: (css) => {
          const styles2 = {};
          let isEncoded = false;
          const urlConverter = settings.url_converter;
          const urlConverterScope = settings.url_converter_scope || self2;
          const compress = (prefix, suffix, noJoin) => {
            const top2 = styles2[prefix + "-top" + suffix];
            if (!top2) {
              return;
            }
            const right2 = styles2[prefix + "-right" + suffix];
            if (!right2) {
              return;
            }
            const bottom2 = styles2[prefix + "-bottom" + suffix];
            if (!bottom2) {
              return;
            }
            const left2 = styles2[prefix + "-left" + suffix];
            if (!left2) {
              return;
            }
            const box = [
              top2,
              right2,
              bottom2,
              left2
            ];
            let i = box.length - 1;
            while (i--) {
              if (box[i] !== box[i + 1]) {
                break;
              }
            }
            if (i > -1 && noJoin) {
              return;
            }
            styles2[prefix + suffix] = i === -1 ? box[0] : box.join(" ");
            delete styles2[prefix + "-top" + suffix];
            delete styles2[prefix + "-right" + suffix];
            delete styles2[prefix + "-bottom" + suffix];
            delete styles2[prefix + "-left" + suffix];
          };
          const canCompress = (key) => {
            const value2 = styles2[key];
            if (!value2) {
              return;
            }
            const values2 = value2.split(" ");
            let i = values2.length;
            while (i--) {
              if (values2[i] !== values2[0]) {
                return false;
              }
            }
            styles2[key] = values2[0];
            return true;
          };
          const compress2 = (target, a, b, c) => {
            if (!canCompress(a)) {
              return;
            }
            if (!canCompress(b)) {
              return;
            }
            if (!canCompress(c)) {
              return;
            }
            styles2[target] = styles2[a] + " " + styles2[b] + " " + styles2[c];
            delete styles2[a];
            delete styles2[b];
            delete styles2[c];
          };
          const encode2 = (str) => {
            isEncoded = true;
            return encodingLookup[str];
          };
          const decode2 = (str, keepSlashes) => {
            if (isEncoded) {
              str = str.replace(/\uFEFF[0-9]/g, (str2) => {
                return encodingLookup[str2];
              });
            }
            if (!keepSlashes) {
              str = str.replace(/\\([\'\";:])/g, "$1");
            }
            return str;
          };
          const decodeSingleHexSequence = (escSeq) => {
            return String.fromCharCode(parseInt(escSeq.slice(1), 16));
          };
          const decodeHexSequences = (value2) => {
            return value2.replace(/\\[0-9a-f]+/gi, decodeSingleHexSequence);
          };
          const processUrl = (match2, url, url2, url3, str, str2) => {
            str = str || str2;
            if (str) {
              str = decode2(str);
              return `'` + str.replace(/\'/g, `\\'`) + `'`;
            }
            url = decode2(url || url2 || url3 || "");
            if (!settings.allow_script_urls) {
              const scriptUrl = url.replace(/[\s\r\n]+/g, "");
              if (/(java|vb)script:/i.test(scriptUrl)) {
                return "";
              }
              if (!settings.allow_svg_data_urls && /^data:image\/svg/i.test(scriptUrl)) {
                return "";
              }
            }
            if (urlConverter) {
              url = urlConverter.call(urlConverterScope, url, "style");
            }
            return `url('` + url.replace(/\'/g, `\\'`) + `')`;
          };
          if (css) {
            css = css.replace(/[\u0000-\u001F]/g, "");
            css = css.replace(/\\[\"\';:\uFEFF]/g, encode2).replace(/\"[^\"]+\"|\'[^\']+\'/g, (str) => {
              return str.replace(/[;:]/g, encode2);
            });
            let matches;
            while (matches = styleRegExp.exec(css)) {
              styleRegExp.lastIndex = matches.index + matches[0].length;
              let name3 = matches[1].replace(trimRightRegExp, "").toLowerCase();
              let value2 = matches[2].replace(trimRightRegExp, "");
              if (name3 && value2) {
                name3 = decodeHexSequences(name3);
                value2 = decodeHexSequences(value2);
                if (name3.indexOf(invisibleChar) !== -1 || name3.indexOf('"') !== -1) {
                  continue;
                }
                if (!settings.allow_script_urls && (name3 === "behavior" || /expression\s*\(|\/\*|\*\//.test(value2))) {
                  continue;
                }
                if (name3 === "font-weight" && value2 === "700") {
                  value2 = "bold";
                } else if (name3 === "color" || name3 === "background-color") {
                  value2 = value2.toLowerCase();
                }
                value2 = value2.replace(urlOrStrRegExp, processUrl);
                styles2[name3] = isEncoded ? decode2(value2, true) : value2;
              }
            }
            compress("border", "", true);
            compress("border", "-width");
            compress("border", "-color");
            compress("border", "-style");
            compress("padding", "");
            compress("margin", "");
            compress2("border", "border-width", "border-style", "border-color");
            if (styles2.border === "medium none") {
              delete styles2.border;
            }
            if (styles2["border-image"] === "none") {
              delete styles2["border-image"];
            }
          }
          return styles2;
        },
        serialize: (styles2, elementName) => {
          let css = "";
          const serializeStyles = (elemName, validStyleList) => {
            const styleList = validStyleList[elemName];
            if (styleList) {
              for (let i = 0, l = styleList.length; i < l; i++) {
                const name3 = styleList[i];
                const value2 = styles2[name3];
                if (value2) {
                  css += (css.length > 0 ? " " : "") + name3 + ": " + value2 + ";";
                }
              }
            }
          };
          const isValid2 = (name3, elemName) => {
            if (!invalidStyles || !elemName) {
              return true;
            }
            let styleMap = invalidStyles["*"];
            if (styleMap && styleMap[name3]) {
              return false;
            }
            styleMap = invalidStyles[elemName];
            return !(styleMap && styleMap[name3]);
          };
          if (elementName && validStyles) {
            serializeStyles("*", validStyles);
            serializeStyles(elementName, validStyles);
          } else {
            each$d(styles2, (value2, name3) => {
              if (value2 && isValid2(name3, elementName)) {
                css += (css.length > 0 ? " " : "") + name3 + ": " + value2 + ";";
              }
            });
          }
          return css;
        }
      };
      return self2;
    };
    const deprecated = {
      keyLocation: true,
      layerX: true,
      layerY: true,
      returnValue: true,
      webkitMovementX: true,
      webkitMovementY: true,
      keyIdentifier: true,
      mozPressure: true
    };
    const isNativeEvent = (event) => event instanceof Event || isFunction2(event.initEvent);
    const hasIsDefaultPrevented = (event) => event.isDefaultPrevented === always || event.isDefaultPrevented === never;
    const needsNormalizing = (event) => isNullable(event.preventDefault) || isNativeEvent(event);
    const clone$3 = (originalEvent, data3) => {
      const event = data3 !== null && data3 !== void 0 ? data3 : {};
      for (const name3 in originalEvent) {
        if (!has$2(deprecated, name3)) {
          event[name3] = originalEvent[name3];
        }
      }
      if (isNonNullable(originalEvent.composedPath)) {
        event.composedPath = () => originalEvent.composedPath();
      }
      return event;
    };
    const normalize$3 = (type2, originalEvent, fallbackTarget, data3) => {
      var _a;
      const event = clone$3(originalEvent, data3);
      event.type = type2;
      if (isNullable(event.target)) {
        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;
      }
      if (needsNormalizing(originalEvent)) {
        event.preventDefault = () => {
          event.defaultPrevented = true;
          event.isDefaultPrevented = always;
          if (isFunction2(originalEvent.preventDefault)) {
            originalEvent.preventDefault();
          }
        };
        event.stopPropagation = () => {
          event.cancelBubble = true;
          event.isPropagationStopped = always;
          if (isFunction2(originalEvent.stopPropagation)) {
            originalEvent.stopPropagation();
          }
        };
        event.stopImmediatePropagation = () => {
          event.isImmediatePropagationStopped = always;
          event.stopPropagation();
        };
        if (!hasIsDefaultPrevented(event)) {
          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;
          event.isPropagationStopped = event.cancelBubble === true ? always : never;
          event.isImmediatePropagationStopped = never;
        }
      }
      return event;
    };
    const eventExpandoPrefix = "mce-data-";
    const mouseEventRe = /^(?:mouse|contextmenu)|click/;
    const addEvent2 = (target, name3, callback, capture) => {
      target.addEventListener(name3, callback, capture || false);
    };
    const removeEvent2 = (target, name3, callback, capture) => {
      target.removeEventListener(name3, callback, capture || false);
    };
    const isMouseEvent = (event) => isNonNullable(event) && mouseEventRe.test(event.type);
    const fix = (originalEvent, data3) => {
      const event = normalize$3(originalEvent.type, originalEvent, document, data3);
      if (isMouseEvent(originalEvent) && isUndefined2(originalEvent.pageX) && !isUndefined2(originalEvent.clientX)) {
        const eventDoc = event.target.ownerDocument || document;
        const doc = eventDoc.documentElement;
        const body = eventDoc.body;
        const mouseEvent = event;
        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
      }
      return event;
    };
    const bindOnReady = (win, callback, eventUtils) => {
      const doc = win.document, event = { type: "ready" };
      if (eventUtils.domLoaded) {
        callback(event);
        return;
      }
      const isDocReady = () => {
        return doc.readyState === "complete" || doc.readyState === "interactive" && doc.body;
      };
      const readyHandler = () => {
        removeEvent2(win, "DOMContentLoaded", readyHandler);
        removeEvent2(win, "load", readyHandler);
        if (!eventUtils.domLoaded) {
          eventUtils.domLoaded = true;
          callback(event);
        }
        win = null;
      };
      if (isDocReady()) {
        readyHandler();
      } else {
        addEvent2(win, "DOMContentLoaded", readyHandler);
      }
      if (!eventUtils.domLoaded) {
        addEvent2(win, "load", readyHandler);
      }
    };
    class EventUtils {
      constructor() {
        this.domLoaded = false;
        this.events = {};
        this.count = 1;
        this.expando = eventExpandoPrefix + (+/* @__PURE__ */ new Date()).toString(32);
        this.hasFocusIn = "onfocusin" in document.documentElement;
        this.count = 1;
      }
      bind(target, names, callback, scope) {
        const self2 = this;
        let callbackList;
        const win = window;
        const defaultNativeHandler = (evt) => {
          self2.executeHandlers(fix(evt || win.event), id);
        };
        if (!target || isText$a(target) || isComment(target)) {
          return callback;
        }
        let id;
        if (!target[self2.expando]) {
          id = self2.count++;
          target[self2.expando] = id;
          self2.events[id] = {};
        } else {
          id = target[self2.expando];
        }
        scope = scope || target;
        const namesList = names.split(" ");
        let i = namesList.length;
        while (i--) {
          let name3 = namesList[i];
          let nativeHandler = defaultNativeHandler;
          let capture = false;
          let fakeName = false;
          if (name3 === "DOMContentLoaded") {
            name3 = "ready";
          }
          if (self2.domLoaded && name3 === "ready" && target.readyState === "complete") {
            callback.call(scope, fix({ type: name3 }));
            continue;
          }
          if (!self2.hasFocusIn && (name3 === "focusin" || name3 === "focusout")) {
            capture = true;
            fakeName = name3 === "focusin" ? "focus" : "blur";
            nativeHandler = (evt) => {
              const event = fix(evt || win.event);
              event.type = event.type === "focus" ? "focusin" : "focusout";
              self2.executeHandlers(event, id);
            };
          }
          callbackList = self2.events[id][name3];
          if (!callbackList) {
            self2.events[id][name3] = callbackList = [{
              func: callback,
              scope
            }];
            callbackList.fakeName = fakeName;
            callbackList.capture = capture;
            callbackList.nativeHandler = nativeHandler;
            if (name3 === "ready") {
              bindOnReady(target, nativeHandler, self2);
            } else {
              addEvent2(target, fakeName || name3, nativeHandler, capture);
            }
          } else {
            if (name3 === "ready" && self2.domLoaded) {
              callback(fix({ type: name3 }));
            } else {
              callbackList.push({
                func: callback,
                scope
              });
            }
          }
        }
        target = callbackList = null;
        return callback;
      }
      unbind(target, names, callback) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const id = target[this.expando];
        if (id) {
          let eventMap = this.events[id];
          if (names) {
            const namesList = names.split(" ");
            let i = namesList.length;
            while (i--) {
              const name3 = namesList[i];
              const callbackList = eventMap[name3];
              if (callbackList) {
                if (callback) {
                  let ci = callbackList.length;
                  while (ci--) {
                    if (callbackList[ci].func === callback) {
                      const nativeHandler = callbackList.nativeHandler;
                      const fakeName = callbackList.fakeName, capture = callbackList.capture;
                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));
                      newCallbackList.nativeHandler = nativeHandler;
                      newCallbackList.fakeName = fakeName;
                      newCallbackList.capture = capture;
                      eventMap[name3] = newCallbackList;
                    }
                  }
                }
                if (!callback || callbackList.length === 0) {
                  delete eventMap[name3];
                  removeEvent2(target, callbackList.fakeName || name3, callbackList.nativeHandler, callbackList.capture);
                }
              }
            }
          } else {
            each$d(eventMap, (callbackList, name3) => {
              removeEvent2(target, callbackList.fakeName || name3, callbackList.nativeHandler, callbackList.capture);
            });
            eventMap = {};
          }
          for (const name3 in eventMap) {
            if (has$2(eventMap, name3)) {
              return this;
            }
          }
          delete this.events[id];
          try {
            delete target[this.expando];
          } catch (ex) {
            target[this.expando] = null;
          }
        }
        return this;
      }
      fire(target, name3, args) {
        return this.dispatch(target, name3, args);
      }
      dispatch(target, name3, args) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        const event = fix({
          type: name3,
          target
        }, args);
        do {
          const id = target[this.expando];
          if (id) {
            this.executeHandlers(event, id);
          }
          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;
        } while (target && !event.isPropagationStopped());
        return this;
      }
      clean(target) {
        if (!target || isText$a(target) || isComment(target)) {
          return this;
        }
        if (target[this.expando]) {
          this.unbind(target);
        }
        if (!target.getElementsByTagName) {
          target = target.document;
        }
        if (target && target.getElementsByTagName) {
          this.unbind(target);
          const children2 = target.getElementsByTagName("*");
          let i = children2.length;
          while (i--) {
            target = children2[i];
            if (target[this.expando]) {
              this.unbind(target);
            }
          }
        }
        return this;
      }
      destroy() {
        this.events = {};
      }
      cancel(e) {
        if (e) {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
        return false;
      }
      executeHandlers(evt, id) {
        const container = this.events[id];
        const callbackList = container && container[evt.type];
        if (callbackList) {
          for (let i = 0, l = callbackList.length; i < l; i++) {
            const callback = callbackList[i];
            if (callback && callback.func.call(callback.scope, evt) === false) {
              evt.preventDefault();
            }
            if (evt.isImmediatePropagationStopped()) {
              return;
            }
          }
        }
      }
    }
    EventUtils.Event = new EventUtils();
    const each$a = Tools.each;
    const grep = Tools.grep;
    const internalStyleName = "data-mce-style";
    const numericalCssMap = Tools.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " ");
    const legacySetAttribute = (elm, name3, value2) => {
      if (isNullable(value2) || value2 === "") {
        remove$b(elm, name3);
      } else {
        set$3(elm, name3, value2);
      }
    };
    const camelCaseToHyphens = (name3) => name3.replace(/[A-Z]/g, (v) => "-" + v.toLowerCase());
    const findNodeIndex = (node, normalized) => {
      let idx = 0;
      if (node) {
        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {
          const nodeType = tempNode.nodeType;
          if (normalized && isText$a(tempNode)) {
            if (nodeType === lastNodeType || !tempNode.data.length) {
              continue;
            }
          }
          idx++;
          lastNodeType = nodeType;
        }
      }
      return idx;
    };
    const updateInternalStyleAttr = (styles2, elm) => {
      const rawValue = get$9(elm, "style");
      const value2 = styles2.serialize(styles2.parse(rawValue), name2(elm));
      legacySetAttribute(elm, internalStyleName, value2);
    };
    const convertStyleToString = (cssValue, cssName) => {
      if (isNumber2(cssValue)) {
        return has$2(numericalCssMap, cssName) ? cssValue + "" : cssValue + "px";
      } else {
        return cssValue;
      }
    };
    const applyStyle$1 = ($elm, cssName, cssValue) => {
      const normalizedName = camelCaseToHyphens(cssName);
      if (isNullable(cssValue) || cssValue === "") {
        remove$7($elm, normalizedName);
      } else {
        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));
      }
    };
    const setupAttrHooks = (styles2, settings, getContext2) => {
      const keepValues = settings.keep_values;
      const keepUrlHook = {
        set: (elm, value2, name3) => {
          const sugarElm = SugarElement.fromDom(elm);
          if (isFunction2(settings.url_converter) && isNonNullable(value2)) {
            value2 = settings.url_converter.call(settings.url_converter_scope || getContext2(), String(value2), name3, elm);
          }
          const internalName = "data-mce-" + name3;
          legacySetAttribute(sugarElm, internalName, value2);
          legacySetAttribute(sugarElm, name3, value2);
        },
        get: (elm, name3) => {
          const sugarElm = SugarElement.fromDom(elm);
          return get$9(sugarElm, "data-mce-" + name3) || get$9(sugarElm, name3);
        }
      };
      const attrHooks = {
        style: {
          set: (elm, value2) => {
            const sugarElm = SugarElement.fromDom(elm);
            if (keepValues) {
              legacySetAttribute(sugarElm, internalStyleName, value2);
            }
            remove$b(sugarElm, "style");
            if (isString2(value2)) {
              setAll(sugarElm, styles2.parse(value2));
            }
          },
          get: (elm) => {
            const sugarElm = SugarElement.fromDom(elm);
            const value2 = get$9(sugarElm, internalStyleName) || get$9(sugarElm, "style");
            return styles2.serialize(styles2.parse(value2), name2(sugarElm));
          }
        }
      };
      if (keepValues) {
        attrHooks.href = attrHooks.src = keepUrlHook;
      }
      return attrHooks;
    };
    const DOMUtils = (doc, settings = {}) => {
      const addedStyles = {};
      const win = window;
      const files = {};
      let counter = 0;
      const stdMode = true;
      const boxModel = true;
      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {
        contentCssCors: settings.contentCssCors,
        referrerPolicy: settings.referrerPolicy
      });
      const boundEvents = [];
      const schema = settings.schema ? settings.schema : Schema({});
      const styles2 = Styles({
        url_converter: settings.url_converter,
        url_converter_scope: settings.url_converter_scope
      }, settings.schema);
      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;
      const blockElementsMap = schema.getBlockElements();
      const isBlock2 = (node) => {
        if (isString2(node)) {
          return has$2(blockElementsMap, node);
        } else {
          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));
        }
      };
      const get2 = (elm) => elm && doc && isString2(elm) ? doc.getElementById(elm) : elm;
      const _get = (elm) => {
        const value2 = get2(elm);
        return isNonNullable(value2) ? SugarElement.fromDom(value2) : null;
      };
      const getAttrib = (elm, name3, defaultVal = "") => {
        let value2;
        const $elm = _get(elm);
        if (isNonNullable($elm) && isElement$7($elm)) {
          const hook = attrHooks[name3];
          if (hook && hook.get) {
            value2 = hook.get($elm.dom, name3);
          } else {
            value2 = get$9($elm, name3);
          }
        }
        return isNonNullable(value2) ? value2 : defaultVal;
      };
      const getAttribs = (elm) => {
        const node = get2(elm);
        return isNullable(node) ? [] : node.attributes;
      };
      const setAttrib = (elm, name3, value2) => {
        run2(elm, (e) => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const val = value2 === "" ? null : value2;
            const originalValue = get$9($elm, name3);
            const hook = attrHooks[name3];
            if (hook && hook.set) {
              hook.set($elm.dom, val, name3);
            } else {
              legacySetAttribute($elm, name3, val);
            }
            if (originalValue !== val && settings.onSetAttrib) {
              settings.onSetAttrib({
                attrElm: $elm.dom,
                attrName: name3,
                attrValue: val
              });
            }
          }
        });
      };
      const clone2 = (node, deep2) => {
        return node.cloneNode(deep2);
      };
      const getRoot = () => settings.root_element || doc.body;
      const getViewPort = (argWin) => {
        const vp = getBounds(argWin);
        return {
          x: vp.x,
          y: vp.y,
          w: vp.width,
          h: vp.height
        };
      };
      const getPos$1 = (elm, rootElm) => getPos(doc.body, get2(elm), rootElm);
      const setStyle = (elm, name3, value2) => {
        run2(elm, (e) => {
          const $elm = SugarElement.fromDom(e);
          applyStyle$1($elm, name3, value2);
          if (settings.update_styles) {
            updateInternalStyleAttr(styles2, $elm);
          }
        });
      };
      const setStyles = (elm, stylesArg) => {
        run2(elm, (e) => {
          const $elm = SugarElement.fromDom(e);
          each$d(stylesArg, (v, n) => {
            applyStyle$1($elm, n, v);
          });
          if (settings.update_styles) {
            updateInternalStyleAttr(styles2, $elm);
          }
        });
      };
      const getStyle2 = (elm, name3, computed) => {
        const $elm = get2(elm);
        if (isNullable($elm) || !isElement$6($elm)) {
          return void 0;
        }
        if (computed) {
          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name3));
        } else {
          name3 = name3.replace(/-(\D)/g, (a, b) => b.toUpperCase());
          if (name3 === "float") {
            name3 = "cssFloat";
          }
          return $elm.style ? $elm.style[name3] : void 0;
        }
      };
      const getSize = (elm) => {
        const $elm = get2(elm);
        if (!$elm) {
          return {
            w: 0,
            h: 0
          };
        }
        let w = getStyle2($elm, "width");
        let h = getStyle2($elm, "height");
        if (!w || w.indexOf("px") === -1) {
          w = "0";
        }
        if (!h || h.indexOf("px") === -1) {
          h = "0";
        }
        return {
          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,
          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight
        };
      };
      const getRect = (elm) => {
        const $elm = get2(elm);
        const pos = getPos$1($elm);
        const size = getSize($elm);
        return {
          x: pos.x,
          y: pos.y,
          w: size.w,
          h: size.h
        };
      };
      const is2 = (elm, selector) => {
        if (!elm) {
          return false;
        }
        const elms = isArray$12(elm) ? elm : [elm];
        return exists(elms, (e) => {
          return is$1(SugarElement.fromDom(e), selector);
        });
      };
      const getParents2 = (elm, selector, root2, collect) => {
        const result = [];
        let node = get2(elm);
        collect = collect === void 0;
        const resolvedRoot = root2 || (getRoot().nodeName !== "BODY" ? getRoot().parentNode : null);
        if (isString2(selector)) {
          if (selector === "*") {
            selector = isElement$6;
          } else {
            const selectorVal = selector;
            selector = (node2) => is2(node2, selectorVal);
          }
        }
        while (node) {
          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {
            break;
          }
          if (!selector || selector(node)) {
            if (collect) {
              result.push(node);
            } else {
              return [node];
            }
          }
          node = node.parentNode;
        }
        return collect ? result : null;
      };
      const getParent = (node, selector, root2) => {
        const parents2 = getParents2(node, selector, root2, false);
        return parents2 && parents2.length > 0 ? parents2[0] : null;
      };
      const _findSib = (node, selector, name3) => {
        let func = selector;
        if (node) {
          if (isString2(selector)) {
            func = (node2) => {
              return is2(node2, selector);
            };
          }
          for (let tempNode = node[name3]; tempNode; tempNode = tempNode[name3]) {
            if (isFunction2(func) && func(tempNode)) {
              return tempNode;
            }
          }
        }
        return null;
      };
      const getNext = (node, selector) => _findSib(node, selector, "nextSibling");
      const getPrev = (node, selector) => _findSib(node, selector, "previousSibling");
      const isParentNode = (node) => isFunction2(node.querySelectorAll);
      const select2 = (selector, scope) => {
        var _a, _b;
        const elm = (_b = (_a = get2(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;
        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];
      };
      const run2 = function(elm, func, scope) {
        const context2 = scope !== null && scope !== void 0 ? scope : this;
        if (isArray$12(elm)) {
          const result = [];
          each$a(elm, (e, i) => {
            const node = get2(e);
            if (node) {
              result.push(func.call(context2, node, i));
            }
          });
          return result;
        } else {
          const node = get2(elm);
          return !node ? false : func.call(context2, node);
        }
      };
      const setAttribs = (elm, attrs) => {
        run2(elm, ($elm) => {
          each$d(attrs, (value2, name3) => {
            setAttrib($elm, name3, value2);
          });
        });
      };
      const setHTML = (elm, html2) => {
        run2(elm, (e) => {
          const $elm = SugarElement.fromDom(e);
          set$1($elm, html2);
        });
      };
      const add2 = (parentElm, name3, attrs, html2, create4) => run2(parentElm, (parentElm2) => {
        const newElm = isString2(name3) ? doc.createElement(name3) : name3;
        if (isNonNullable(attrs)) {
          setAttribs(newElm, attrs);
        }
        if (html2) {
          if (!isString2(html2) && html2.nodeType) {
            newElm.appendChild(html2);
          } else if (isString2(html2)) {
            setHTML(newElm, html2);
          }
        }
        return !create4 ? parentElm2.appendChild(newElm) : newElm;
      });
      const create3 = (name3, attrs, html2) => add2(doc.createElement(name3), name3, attrs, html2, true);
      const decode2 = Entities.decode;
      const encode2 = Entities.encodeAllRaw;
      const createHTML = (name3, attrs, html2 = "") => {
        let outHtml = "<" + name3;
        for (const key in attrs) {
          if (hasNonNullableKey(attrs, key)) {
            outHtml += " " + key + '="' + encode2(attrs[key]) + '"';
          }
        }
        if (isEmpty$3(html2) && has$2(schema.getVoidElements(), name3)) {
          return outHtml + " />";
        } else {
          return outHtml + ">" + html2 + "</" + name3 + ">";
        }
      };
      const createFragment2 = (html2) => {
        const container = doc.createElement("div");
        const frag = doc.createDocumentFragment();
        frag.appendChild(container);
        if (html2) {
          container.innerHTML = html2;
        }
        let node;
        while (node = container.firstChild) {
          frag.appendChild(node);
        }
        frag.removeChild(container);
        return frag;
      };
      const remove2 = (node, keepChildren) => {
        return run2(node, (n) => {
          const $node = SugarElement.fromDom(n);
          if (keepChildren) {
            each$e(children$1($node), (child2) => {
              if (isText$b(child2) && child2.dom.length === 0) {
                remove$6(child2);
              } else {
                before$3($node, child2);
              }
            });
          }
          remove$6($node);
          return $node.dom;
        });
      };
      const removeAllAttribs = (e) => run2(e, (e2) => {
        const attrs = e2.attributes;
        for (let i = attrs.length - 1; i >= 0; i--) {
          e2.removeAttributeNode(attrs.item(i));
        }
      });
      const parseStyle = (cssText) => styles2.parse(cssText);
      const serializeStyle = (stylesArg, name3) => styles2.serialize(stylesArg, name3);
      const addStyle = (cssText) => {
        if (self2 !== DOMUtils.DOM && doc === document) {
          if (addedStyles[cssText]) {
            return;
          }
          addedStyles[cssText] = true;
        }
        let styleElm = doc.getElementById("mceDefaultStyles");
        if (!styleElm) {
          styleElm = doc.createElement("style");
          styleElm.id = "mceDefaultStyles";
          styleElm.type = "text/css";
          const head2 = doc.head;
          if (head2.firstChild) {
            head2.insertBefore(styleElm, head2.firstChild);
          } else {
            head2.appendChild(styleElm);
          }
        }
        if (styleElm.styleSheet) {
          styleElm.styleSheet.cssText += cssText;
        } else {
          styleElm.appendChild(doc.createTextNode(cssText));
        }
      };
      const loadCSS = (urls) => {
        if (!urls) {
          urls = "";
        }
        each$e(urls.split(","), (url) => {
          files[url] = true;
          styleSheetLoader.load(url).catch(noop2);
        });
      };
      const toggleClass2 = (elm, cls, state2) => {
        run2(elm, (e) => {
          if (isElement$6(e)) {
            const $elm = SugarElement.fromDom(e);
            const classes = cls.split(" ");
            each$e(classes, (c) => {
              if (isNonNullable(state2)) {
                const fn3 = state2 ? add$2 : remove$8;
                fn3($elm, c);
              } else {
                toggle$1($elm, c);
              }
            });
          }
        });
      };
      const addClass = (elm, cls) => {
        toggleClass2(elm, cls, true);
      };
      const removeClass = (elm, cls) => {
        toggleClass2(elm, cls, false);
      };
      const hasClass2 = (elm, cls) => {
        const $elm = _get(elm);
        const classes = cls.split(" ");
        return isNonNullable($elm) && forall(classes, (c) => has($elm, c));
      };
      const show = (elm) => {
        run2(elm, (e) => remove$7(SugarElement.fromDom(e), "display"));
      };
      const hide2 = (elm) => {
        run2(elm, (e) => set$2(SugarElement.fromDom(e), "display", "none"));
      };
      const isHidden = (elm) => {
        const $elm = _get(elm);
        return isNonNullable($elm) && is$2(getRaw($elm, "display"), "none");
      };
      const uniqueId2 = (prefix) => (!prefix ? "mce_" : prefix) + counter++;
      const getOuterHTML = (elm) => {
        const $elm = _get(elm);
        if (isNonNullable($elm)) {
          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);
        } else {
          return "";
        }
      };
      const setOuterHTML = (elm, html2) => {
        run2(elm, ($elm) => {
          if (isElement$6($elm)) {
            $elm.outerHTML = html2;
          }
        });
      };
      const insertAfter3 = (node, reference2) => {
        const referenceNode = get2(reference2);
        return run2(node, (node2) => {
          const parent2 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;
          const nextSibling2 = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;
          if (parent2) {
            if (nextSibling2) {
              parent2.insertBefore(node2, nextSibling2);
            } else {
              parent2.appendChild(node2);
            }
          }
          return node2;
        });
      };
      const replace = (newElm, oldElm, keepChildren) => run2(oldElm, (elm) => {
        var _a;
        const replacee = isArray$12(oldElm) ? newElm.cloneNode(true) : newElm;
        if (keepChildren) {
          each$a(grep(elm.childNodes), (node) => {
            replacee.appendChild(node);
          });
        }
        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);
        return elm;
      });
      const rename = (elm, name3) => {
        if (elm.nodeName !== name3.toUpperCase()) {
          const newElm = create3(name3);
          each$a(getAttribs(elm), (attrNode) => {
            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));
          });
          replace(newElm, elm, true);
          return newElm;
        } else {
          return elm;
        }
      };
      const findCommonAncestor = (a, b) => {
        let ps = a;
        while (ps) {
          let pe = b;
          while (pe && ps !== pe) {
            pe = pe.parentNode;
          }
          if (ps === pe) {
            break;
          }
          ps = ps.parentNode;
        }
        if (!ps && a.ownerDocument) {
          return a.ownerDocument.documentElement;
        } else {
          return ps;
        }
      };
      const isNonEmptyElement2 = (node) => {
        if (isElement$6(node)) {
          const isNamedAnchor2 = node.nodeName.toLowerCase() === "a" && !getAttrib(node, "href") && getAttrib(node, "id");
          if (getAttrib(node, "name") || getAttrib(node, "data-mce-bookmark") || isNamedAnchor2) {
            return true;
          }
        }
        return false;
      };
      const isEmpty3 = (node, elements) => {
        let brCount = 0;
        if (isNonEmptyElement2(node)) {
          return false;
        }
        const firstChild2 = node.firstChild;
        if (firstChild2) {
          const walker = new DomTreeWalker(firstChild2, node);
          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};
          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);
          let tempNode = firstChild2;
          do {
            if (isElement$6(tempNode)) {
              const bogusVal = tempNode.getAttribute("data-mce-bogus");
              if (bogusVal) {
                tempNode = walker.next(bogusVal === "all");
                continue;
              }
              const name3 = tempNode.nodeName.toLowerCase();
              if (nonEmptyElements && nonEmptyElements[name3]) {
                if (name3 === "br") {
                  brCount++;
                  tempNode = walker.next();
                  continue;
                }
                return false;
              }
              if (isNonEmptyElement2(tempNode)) {
                return false;
              }
            }
            if (isComment(tempNode)) {
              return false;
            }
            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data)) {
              return false;
            }
            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {
              return false;
            }
            tempNode = walker.next();
          } while (tempNode);
        }
        return brCount <= 1;
      };
      const createRng = () => doc.createRange();
      const split2 = (parentElm, splitElm, replacementElm) => {
        let range2 = createRng();
        let beforeFragment;
        let afterFragment;
        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {
          const parentNode = parentElm.parentNode;
          range2.setStart(parentNode, findNodeIndex(parentElm));
          range2.setEnd(splitElm.parentNode, findNodeIndex(splitElm));
          beforeFragment = range2.extractContents();
          range2 = createRng();
          range2.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);
          range2.setEnd(parentNode, findNodeIndex(parentElm) + 1);
          afterFragment = range2.extractContents();
          parentNode.insertBefore(trimNode(self2, beforeFragment), parentElm);
          if (replacementElm) {
            parentNode.insertBefore(replacementElm, parentElm);
          } else {
            parentNode.insertBefore(splitElm, parentElm);
          }
          parentNode.insertBefore(trimNode(self2, afterFragment), parentElm);
          remove2(parentElm);
          return replacementElm || splitElm;
        } else {
          return void 0;
        }
      };
      const bind3 = (target, name3, func, scope) => {
        if (isArray$12(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = bind3(target[i], name3, func, scope);
          }
          return rv;
        } else {
          if (settings.collect && (target === doc || target === win)) {
            boundEvents.push([
              target,
              name3,
              func,
              scope
            ]);
          }
          return events.bind(target, name3, func, scope || self2);
        }
      };
      const unbind2 = (target, name3, func) => {
        if (isArray$12(target)) {
          let i = target.length;
          const rv = [];
          while (i--) {
            rv[i] = unbind2(target[i], name3, func);
          }
          return rv;
        } else {
          if (boundEvents.length > 0 && (target === doc || target === win)) {
            let i = boundEvents.length;
            while (i--) {
              const [boundTarget, boundName, boundFunc] = boundEvents[i];
              if (target === boundTarget && (!name3 || name3 === boundName) && (!func || func === boundFunc)) {
                events.unbind(boundTarget, boundName, boundFunc);
              }
            }
          }
          return events.unbind(target, name3, func);
        }
      };
      const dispatch = (target, name3, evt) => events.dispatch(target, name3, evt);
      const fire = (target, name3, evt) => events.dispatch(target, name3, evt);
      const getContentEditable = (node) => {
        if (node && isElement$6(node)) {
          const contentEditable = node.getAttribute("data-mce-contenteditable");
          if (contentEditable && contentEditable !== "inherit") {
            return contentEditable;
          }
          return node.contentEditable !== "inherit" ? node.contentEditable : null;
        } else {
          return null;
        }
      };
      const getContentEditableParent = (node) => {
        const root2 = getRoot();
        let state2 = null;
        for (let tempNode = node; tempNode && tempNode !== root2; tempNode = tempNode.parentNode) {
          state2 = getContentEditable(tempNode);
          if (state2 !== null) {
            break;
          }
        }
        return state2;
      };
      const isEditable2 = (node) => {
        if (isNonNullable(node)) {
          const scope = isElement$6(node) ? node : node.parentElement;
          const isRootEditable = getContentEditable(getRoot()) === "true";
          return isNonNullable(scope) && isEditable$3(SugarElement.fromDom(scope), isRootEditable);
        } else {
          return false;
        }
      };
      const destroy3 = () => {
        if (boundEvents.length > 0) {
          let i = boundEvents.length;
          while (i--) {
            const [boundTarget, boundName, boundFunc] = boundEvents[i];
            events.unbind(boundTarget, boundName, boundFunc);
          }
        }
        each$d(files, (_2, url) => {
          styleSheetLoader.unload(url);
          delete files[url];
        });
      };
      const isChildOf = (node, parent2) => {
        return node === parent2 || parent2.contains(node);
      };
      const dumpRng = (r2) => "startContainer: " + r2.startContainer.nodeName + ", startOffset: " + r2.startOffset + ", endContainer: " + r2.endContainer.nodeName + ", endOffset: " + r2.endOffset;
      const self2 = {
        doc,
        settings,
        win,
        files,
        stdMode,
        boxModel,
        styleSheetLoader,
        boundEvents,
        styles: styles2,
        schema,
        events,
        isBlock: isBlock2,
        root: null,
        clone: clone2,
        getRoot,
        getViewPort,
        getRect,
        getSize,
        getParent,
        getParents: getParents2,
        get: get2,
        getNext,
        getPrev,
        select: select2,
        is: is2,
        add: add2,
        create: create3,
        createHTML,
        createFragment: createFragment2,
        remove: remove2,
        setStyle,
        getStyle: getStyle2,
        setStyles,
        removeAllAttribs,
        setAttrib,
        setAttribs,
        getAttrib,
        getPos: getPos$1,
        parseStyle,
        serializeStyle,
        addStyle,
        loadCSS,
        addClass,
        removeClass,
        hasClass: hasClass2,
        toggleClass: toggleClass2,
        show,
        hide: hide2,
        isHidden,
        uniqueId: uniqueId2,
        setHTML,
        getOuterHTML,
        setOuterHTML,
        decode: decode2,
        encode: encode2,
        insertAfter: insertAfter3,
        replace,
        rename,
        findCommonAncestor,
        run: run2,
        getAttribs,
        isEmpty: isEmpty3,
        createRng,
        nodeIndex: findNodeIndex,
        split: split2,
        bind: bind3,
        unbind: unbind2,
        fire,
        dispatch,
        getContentEditable,
        getContentEditableParent,
        isEditable: isEditable2,
        destroy: destroy3,
        isChildOf,
        dumpRng
      };
      const attrHooks = setupAttrHooks(styles2, settings, constant(self2));
      return self2;
    };
    DOMUtils.DOM = DOMUtils(document);
    DOMUtils.nodeIndex = findNodeIndex;
    const DOM$b = DOMUtils.DOM;
    const QUEUED = 0;
    const LOADING = 1;
    const LOADED = 2;
    const FAILED = 3;
    class ScriptLoader {
      constructor(settings = {}) {
        this.states = {};
        this.queue = [];
        this.scriptLoadedCallbacks = {};
        this.queueLoadedCallbacks = [];
        this.loading = false;
        this.settings = settings;
      }
      _setReferrerPolicy(referrerPolicy) {
        this.settings.referrerPolicy = referrerPolicy;
      }
      loadScript(url) {
        return new Promise((resolve2, reject) => {
          const dom2 = DOM$b;
          let elm;
          const cleanup = () => {
            dom2.remove(id);
            if (elm) {
              elm.onerror = elm.onload = elm = null;
            }
          };
          const done = () => {
            cleanup();
            resolve2();
          };
          const error3 = () => {
            cleanup();
            reject("Failed to load script: " + url);
          };
          const id = dom2.uniqueId();
          elm = document.createElement("script");
          elm.id = id;
          elm.type = "text/javascript";
          elm.src = Tools._addCacheSuffix(url);
          if (this.settings.referrerPolicy) {
            dom2.setAttrib(elm, "referrerpolicy", this.settings.referrerPolicy);
          }
          elm.onload = done;
          elm.onerror = error3;
          (document.getElementsByTagName("head")[0] || document.body).appendChild(elm);
        });
      }
      isDone(url) {
        return this.states[url] === LOADED;
      }
      markDone(url) {
        this.states[url] = LOADED;
      }
      add(url) {
        const self2 = this;
        self2.queue.push(url);
        const state2 = self2.states[url];
        if (state2 === void 0) {
          self2.states[url] = QUEUED;
        }
        return new Promise((resolve2, reject) => {
          if (!self2.scriptLoadedCallbacks[url]) {
            self2.scriptLoadedCallbacks[url] = [];
          }
          self2.scriptLoadedCallbacks[url].push({
            resolve: resolve2,
            reject
          });
        });
      }
      load(url) {
        return this.add(url);
      }
      remove(url) {
        delete this.states[url];
        delete this.scriptLoadedCallbacks[url];
      }
      loadQueue() {
        const queue = this.queue;
        this.queue = [];
        return this.loadScripts(queue);
      }
      loadScripts(scripts) {
        const self2 = this;
        const execCallbacks = (name3, url) => {
          get$a(self2.scriptLoadedCallbacks, url).each((callbacks) => {
            each$e(callbacks, (callback) => callback[name3](url));
          });
          delete self2.scriptLoadedCallbacks[url];
        };
        const processResults = (results) => {
          const failures = filter$5(results, (result) => result.status === "rejected");
          if (failures.length > 0) {
            return Promise.reject(bind$3(failures, ({ reason }) => isArray$12(reason) ? reason : [reason]));
          } else {
            return Promise.resolve();
          }
        };
        const load = (urls) => Promise.allSettled(map$3(urls, (url) => {
          if (self2.states[url] === LOADED) {
            execCallbacks("resolve", url);
            return Promise.resolve();
          } else if (self2.states[url] === FAILED) {
            execCallbacks("reject", url);
            return Promise.reject(url);
          } else {
            self2.states[url] = LOADING;
            return self2.loadScript(url).then(() => {
              self2.states[url] = LOADED;
              execCallbacks("resolve", url);
              const queue = self2.queue;
              if (queue.length > 0) {
                self2.queue = [];
                return load(queue).then(processResults);
              } else {
                return Promise.resolve();
              }
            }, () => {
              self2.states[url] = FAILED;
              execCallbacks("reject", url);
              return Promise.reject(url);
            });
          }
        }));
        const processQueue = (urls) => {
          self2.loading = true;
          return load(urls).then((results) => {
            self2.loading = false;
            const nextQueuedItem = self2.queueLoadedCallbacks.shift();
            Optional.from(nextQueuedItem).each(call);
            return processResults(results);
          });
        };
        const uniqueScripts = stringArray(scripts);
        if (self2.loading) {
          return new Promise((resolve2, reject) => {
            self2.queueLoadedCallbacks.push(() => processQueue(uniqueScripts).then(resolve2, reject));
          });
        } else {
          return processQueue(uniqueScripts);
        }
      }
    }
    ScriptLoader.ScriptLoader = new ScriptLoader();
    const Cell = (initial) => {
      let value2 = initial;
      const get2 = () => {
        return value2;
      };
      const set2 = (v) => {
        value2 = v;
      };
      return {
        get: get2,
        set: set2
      };
    };
    const isRaw = (str) => isObject2(str) && has$2(str, "raw");
    const isTokenised = (str) => isArray$12(str) && str.length > 1;
    const data2 = {};
    const currentCode = Cell("en");
    const getLanguageData = () => get$a(data2, currentCode.get());
    const getData$1 = () => map$2(data2, (value2) => ({ ...value2 }));
    const setCode = (newCode) => {
      if (newCode) {
        currentCode.set(newCode);
      }
    };
    const getCode = () => currentCode.get();
    const add$1 = (code, items) => {
      let langData = data2[code];
      if (!langData) {
        data2[code] = langData = {};
      }
      each$d(items, (translation, name3) => {
        langData[name3.toLowerCase()] = translation;
      });
    };
    const translate = (text3) => {
      const langData = getLanguageData().getOr({});
      const toString3 = (obj) => {
        if (isFunction2(obj)) {
          return Object.prototype.toString.call(obj);
        }
        return !isEmpty3(obj) ? "" + obj : "";
      };
      const isEmpty3 = (text4) => text4 === "" || text4 === null || text4 === void 0;
      const getLangData = (text4) => {
        const textstr = toString3(text4);
        return get$a(langData, textstr.toLowerCase()).map(toString3).getOr(textstr);
      };
      const removeContext = (str) => str.replace(/{context:\w+}$/, "");
      if (isEmpty3(text3)) {
        return "";
      }
      if (isRaw(text3)) {
        return toString3(text3.raw);
      }
      if (isTokenised(text3)) {
        const values2 = text3.slice(1);
        const substitued = getLangData(text3[0]).replace(/\{([0-9]+)\}/g, ($1, $2) => has$2(values2, $2) ? toString3(values2[$2]) : $1);
        return removeContext(substitued);
      }
      return removeContext(getLangData(text3));
    };
    const isRtl$1 = () => getLanguageData().bind((items) => get$a(items, "_dir")).exists((dir) => dir === "rtl");
    const hasCode = (code) => has$2(data2, code);
    const I18n = {
      getData: getData$1,
      setCode,
      getCode,
      add: add$1,
      translate,
      isRtl: isRtl$1,
      hasCode
    };
    const AddOnManager = () => {
      const items = [];
      const urls = {};
      const lookup2 = {};
      const _listeners = [];
      const runListeners = (name3, state2) => {
        const matchedListeners = filter$5(_listeners, (listener) => listener.name === name3 && listener.state === state2);
        each$e(matchedListeners, (listener) => listener.resolve());
      };
      const isLoaded = (name3) => has$2(urls, name3);
      const isAdded = (name3) => has$2(lookup2, name3);
      const get2 = (name3) => {
        if (lookup2[name3]) {
          return lookup2[name3].instance;
        }
        return void 0;
      };
      const loadLanguagePack = (name3, languages) => {
        const language = I18n.getCode();
        const wrappedLanguages = "," + (languages || "") + ",";
        if (!language || languages && wrappedLanguages.indexOf("," + language + ",") === -1) {
          return;
        }
        ScriptLoader.ScriptLoader.add(urls[name3] + "/langs/" + language + ".js");
      };
      const requireLangPack = (name3, languages) => {
        if (AddOnManager.languageLoad !== false) {
          if (isLoaded(name3)) {
            loadLanguagePack(name3, languages);
          } else {
            waitFor(name3, "loaded").then(() => loadLanguagePack(name3, languages));
          }
        }
      };
      const add2 = (id, addOn) => {
        items.push(addOn);
        lookup2[id] = { instance: addOn };
        runListeners(id, "added");
        return addOn;
      };
      const remove2 = (name3) => {
        delete urls[name3];
        delete lookup2[name3];
      };
      const createUrl = (baseUrl, dep) => {
        if (isString2(dep)) {
          return isString2(baseUrl) ? {
            prefix: "",
            resource: dep,
            suffix: ""
          } : {
            prefix: baseUrl.prefix,
            resource: dep,
            suffix: baseUrl.suffix
          };
        } else {
          return dep;
        }
      };
      const load = (name3, addOnUrl) => {
        if (urls[name3]) {
          return Promise.resolve();
        }
        let urlString = isString2(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;
        if (urlString.indexOf("/") !== 0 && urlString.indexOf("://") === -1) {
          urlString = AddOnManager.baseURL + "/" + urlString;
        }
        urls[name3] = urlString.substring(0, urlString.lastIndexOf("/"));
        const done = () => {
          runListeners(name3, "loaded");
          return Promise.resolve();
        };
        if (lookup2[name3]) {
          return done();
        } else {
          return ScriptLoader.ScriptLoader.add(urlString).then(done);
        }
      };
      const waitFor = (name3, state2 = "added") => {
        if (state2 === "added" && isAdded(name3)) {
          return Promise.resolve();
        } else if (state2 === "loaded" && isLoaded(name3)) {
          return Promise.resolve();
        } else {
          return new Promise((resolve2) => {
            _listeners.push({
              name: name3,
              state: state2,
              resolve: resolve2
            });
          });
        }
      };
      return {
        items,
        urls,
        lookup: lookup2,
        get: get2,
        requireLangPack,
        add: add2,
        remove: remove2,
        createUrl,
        load,
        waitFor
      };
    };
    AddOnManager.languageLoad = true;
    AddOnManager.baseURL = "";
    AddOnManager.PluginManager = AddOnManager();
    AddOnManager.ThemeManager = AddOnManager();
    AddOnManager.ModelManager = AddOnManager();
    const singleton = (doRevoke) => {
      const subject = Cell(Optional.none());
      const revoke = () => subject.get().each(doRevoke);
      const clear3 = () => {
        revoke();
        subject.set(Optional.none());
      };
      const isSet = () => subject.get().isSome();
      const get2 = () => subject.get();
      const set2 = (s) => {
        revoke();
        subject.set(Optional.some(s));
      };
      return {
        clear: clear3,
        isSet,
        get: get2,
        set: set2
      };
    };
    const repeatable = (delay) => {
      const intervalId = Cell(Optional.none());
      const revoke = () => intervalId.get().each((id) => clearInterval(id));
      const clear3 = () => {
        revoke();
        intervalId.set(Optional.none());
      };
      const isSet = () => intervalId.get().isSome();
      const get2 = () => intervalId.get();
      const set2 = (functionToRepeat) => {
        revoke();
        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));
      };
      return {
        clear: clear3,
        isSet,
        get: get2,
        set: set2
      };
    };
    const value$2 = () => {
      const subject = singleton(noop2);
      const on3 = (f) => subject.get().each(f);
      return {
        ...subject,
        on: on3
      };
    };
    const first$1 = (fn3, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull2(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        if (isNull2(timer)) {
          timer = setTimeout(() => {
            timer = null;
            fn3.apply(null, args);
          }, rate);
        }
      };
      return {
        cancel,
        throttle
      };
    };
    const last$1 = (fn3, rate) => {
      let timer = null;
      const cancel = () => {
        if (!isNull2(timer)) {
          clearTimeout(timer);
          timer = null;
        }
      };
      const throttle = (...args) => {
        cancel();
        timer = setTimeout(() => {
          timer = null;
          fn3.apply(null, args);
        }, rate);
      };
      return {
        cancel,
        throttle
      };
    };
    const annotation = constant("mce-annotation");
    const dataAnnotation = constant("data-mce-annotation");
    const dataAnnotationId = constant("data-mce-annotation-uid");
    const dataAnnotationActive = constant("data-mce-annotation-active");
    const dataAnnotationClasses = constant("data-mce-annotation-classes");
    const dataAnnotationAttributes = constant("data-mce-annotation-attrs");
    const isRoot$1 = (root2) => (node) => eq(node, root2);
    const identify = (editor, annotationName) => {
      const rng = editor.selection.getRng();
      const start3 = SugarElement.fromDom(rng.startContainer);
      const root2 = SugarElement.fromDom(editor.getBody());
      const selector = annotationName.fold(() => "." + annotation(), (an) => `[${dataAnnotation()}="${an}"]`);
      const newStart = child$1(start3, rng.startOffset).getOr(start3);
      const closest2 = closest$3(newStart, selector, isRoot$1(root2));
      return closest2.bind((c) => getOpt(c, `${dataAnnotationId()}`).bind((uid2) => getOpt(c, `${dataAnnotation()}`).map((name3) => {
        const elements = findMarkers(editor, uid2);
        return {
          uid: uid2,
          name: name3,
          elements
        };
      })));
    };
    const isAnnotation = (elem) => isElement$7(elem) && has(elem, annotation());
    const isBogusElement = (elem, root2) => has$1(elem, "data-mce-bogus") || ancestor$2(elem, '[data-mce-bogus="all"]', isRoot$1(root2));
    const findMarkers = (editor, uid2) => {
      const body = SugarElement.fromDom(editor.getBody());
      const descendants$12 = descendants(body, `[${dataAnnotationId()}="${uid2}"]`);
      return filter$5(descendants$12, (descendant2) => !isBogusElement(descendant2, body));
    };
    const findAll = (editor, name3) => {
      const body = SugarElement.fromDom(editor.getBody());
      const markers = descendants(body, `[${dataAnnotation()}="${name3}"]`);
      const directory = {};
      each$e(markers, (m) => {
        if (!isBogusElement(m, body)) {
          const uid2 = get$9(m, dataAnnotationId());
          const nodesAlready = get$a(directory, uid2).getOr([]);
          directory[uid2] = nodesAlready.concat([m]);
        }
      });
      return directory;
    };
    const setup$x = (editor, registry2) => {
      const changeCallbacks = Cell({});
      const initData = () => ({
        listeners: [],
        previous: value$2()
      });
      const withCallbacks = (name3, f) => {
        updateCallbacks(name3, (data3) => {
          f(data3);
          return data3;
        });
      };
      const updateCallbacks = (name3, f) => {
        const callbackMap = changeCallbacks.get();
        const data3 = get$a(callbackMap, name3).getOrThunk(initData);
        const outputData = f(data3);
        callbackMap[name3] = outputData;
        changeCallbacks.set(callbackMap);
      };
      const fireCallbacks = (name3, uid2, elements) => {
        withCallbacks(name3, (data3) => {
          each$e(data3.listeners, (f) => f(true, name3, {
            uid: uid2,
            nodes: map$3(elements, (elem) => elem.dom)
          }));
        });
      };
      const fireNoAnnotation = (name3) => {
        withCallbacks(name3, (data3) => {
          each$e(data3.listeners, (f) => f(false, name3));
        });
      };
      const toggleActiveAttr = (uid2, state2) => {
        each$e(findMarkers(editor, uid2), (elem) => {
          if (state2) {
            set$3(elem, dataAnnotationActive(), "true");
          } else {
            remove$b(elem, dataAnnotationActive());
          }
        });
      };
      const onNodeChange = last$1(() => {
        const annotations = sort(registry2.getNames());
        each$e(annotations, (name3) => {
          updateCallbacks(name3, (data3) => {
            const prev2 = data3.previous.get();
            identify(editor, Optional.some(name3)).fold(() => {
              prev2.each((uid2) => {
                fireNoAnnotation(name3);
                data3.previous.clear();
                toggleActiveAttr(uid2, false);
              });
            }, ({ uid: uid2, name: name4, elements }) => {
              if (!is$2(prev2, uid2)) {
                prev2.each((uid3) => toggleActiveAttr(uid3, false));
                fireCallbacks(name4, uid2, elements);
                data3.previous.set(uid2);
                toggleActiveAttr(uid2, true);
              }
            });
            return {
              previous: data3.previous,
              listeners: data3.listeners
            };
          });
        });
      }, 30);
      editor.on("remove", () => {
        onNodeChange.cancel();
      });
      editor.on("NodeChange", () => {
        onNodeChange.throttle();
      });
      const addListener = (name3, f) => {
        updateCallbacks(name3, (data3) => ({
          previous: data3.previous,
          listeners: data3.listeners.concat([f])
        }));
      };
      return { addListener };
    };
    const setup$w = (editor, registry2) => {
      const dataAnnotation$1 = dataAnnotation();
      const identifyParserNode = (node) => Optional.from(node.attr(dataAnnotation$1)).bind(registry2.lookup);
      const removeDirectAnnotation2 = (node) => {
        var _a, _b;
        node.attr(dataAnnotationId(), null);
        node.attr(dataAnnotation(), null);
        node.attr(dataAnnotationActive(), null);
        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map((names) => names.split(",")).getOr([]);
        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map((names) => names.split(",")).getOr([]);
        each$e(customAttrNames, (name3) => node.attr(name3, null));
        const classList = (_b = (_a = node.attr("class")) === null || _a === void 0 ? void 0 : _a.split(" ")) !== null && _b !== void 0 ? _b : [];
        const newClassList = difference(classList, [annotation()].concat(customClasses));
        node.attr("class", newClassList.length > 0 ? newClassList.join(" ") : null);
        node.attr(dataAnnotationClasses(), null);
        node.attr(dataAnnotationAttributes(), null);
      };
      editor.serializer.addTempAttr(dataAnnotationActive());
      editor.serializer.addAttributeFilter(dataAnnotation$1, (nodes) => {
        for (const node of nodes) {
          identifyParserNode(node).each((settings) => {
            if (settings.persistent === false) {
              if (node.name === "span") {
                node.unwrap();
              } else {
                removeDirectAnnotation2(node);
              }
            }
          });
        }
      });
    };
    const create$c2 = () => {
      const annotations = {};
      const register2 = (name3, settings) => {
        annotations[name3] = {
          name: name3,
          settings
        };
      };
      const lookup2 = (name3) => get$a(annotations, name3).map((a) => a.settings);
      const getNames = () => keys(annotations);
      return {
        register: register2,
        lookup: lookup2,
        getNames
      };
    };
    let unique = 0;
    const generate$1 = (prefix) => {
      const date = /* @__PURE__ */ new Date();
      const time = date.getTime();
      const random = Math.floor(Math.random() * 1e9);
      unique++;
      return prefix + "_" + random + unique + String(time);
    };
    const add = (element, classes) => {
      each$e(classes, (x) => {
        add$2(element, x);
      });
    };
    const remove$5 = (element, classes) => {
      each$e(classes, (x) => {
        remove$8(element, x);
      });
    };
    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
    const shallow$1 = (original) => clone$2(original, false);
    const deep$1 = (original) => clone$2(original, true);
    const shallowAs = (original, tag) => {
      const nu2 = SugarElement.fromTag(tag);
      const attributes = clone$4(original);
      setAll$1(nu2, attributes);
      return nu2;
    };
    const mutate = (original, tag) => {
      const nu2 = shallowAs(original, tag);
      after$4(original, nu2);
      const children2 = children$1(original);
      append2(nu2, children2);
      remove$6(original);
      return nu2;
    };
    const TextWalker = (startNode, rootNode, isBoundary2 = never) => {
      const walker = new DomTreeWalker(startNode, rootNode);
      const walk2 = (direction) => {
        let next2;
        do {
          next2 = walker[direction]();
        } while (next2 && !isText$a(next2) && !isBoundary2(next2));
        return Optional.from(next2).filter(isText$a);
      };
      return {
        current: () => Optional.from(walker.current()).filter(isText$a),
        next: () => walk2("next"),
        prev: () => walk2("prev"),
        prev2: () => walk2("prev2")
      };
    };
    const TextSeeker = (dom2, isBoundary2) => {
      const isBlockBoundary = isBoundary2 ? isBoundary2 : (node) => dom2.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);
      const walk2 = (node, offset2, walker, process2) => {
        if (isText$a(node)) {
          const newOffset = process2(node, offset2, node.data);
          if (newOffset !== -1) {
            return Optional.some({
              container: node,
              offset: newOffset
            });
          }
        }
        return walker().bind((next2) => walk2(next2.container, next2.offset, walker, process2));
      };
      const backwards = (node, offset2, process2, root2) => {
        const walker = TextWalker(node, root2 !== null && root2 !== void 0 ? root2 : dom2.getRoot(), isBlockBoundary);
        return walk2(node, offset2, () => walker.prev().map((prev2) => ({
          container: prev2,
          offset: prev2.length
        })), process2).getOrNull();
      };
      const forwards = (node, offset2, process2, root2) => {
        const walker = TextWalker(node, root2 !== null && root2 !== void 0 ? root2 : dom2.getRoot(), isBlockBoundary);
        return walk2(node, offset2, () => walker.next().map((next2) => ({
          container: next2,
          offset: 0
        })), process2).getOrNull();
      };
      return {
        backwards,
        forwards
      };
    };
    const round$2 = Math.round;
    const clone$1 = (rect) => {
      if (!rect) {
        return {
          left: 0,
          top: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
      return {
        left: round$2(rect.left),
        top: round$2(rect.top),
        bottom: round$2(rect.bottom),
        right: round$2(rect.right),
        width: round$2(rect.width),
        height: round$2(rect.height)
      };
    };
    const collapse = (rect, toStart) => {
      rect = clone$1(rect);
      if (toStart) {
        rect.right = rect.left;
      } else {
        rect.left = rect.left + rect.width;
        rect.right = rect.left;
      }
      rect.width = 0;
      return rect;
    };
    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;
    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;
    const isAbove$1 = (rect1, rect2) => {
      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);
      if (rect1.bottom - halfHeight < rect2.top) {
        return true;
      }
      if (rect1.top > rect2.bottom) {
        return false;
      }
      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);
    };
    const isBelow$1 = (rect1, rect2) => {
      if (rect1.top > rect2.bottom) {
        return true;
      }
      if (rect1.bottom < rect2.top) {
        return false;
      }
      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);
    };
    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
    const boundingClientRectFromRects = (rects) => {
      return foldl(rects, (acc, rect) => {
        return acc.fold(() => Optional.some(rect), (prevRect) => {
          const left2 = Math.min(rect.left, prevRect.left);
          const top2 = Math.min(rect.top, prevRect.top);
          const right2 = Math.max(rect.right, prevRect.right);
          const bottom2 = Math.max(rect.bottom, prevRect.bottom);
          return Optional.some({
            top: top2,
            right: right2,
            bottom: bottom2,
            left: left2,
            width: right2 - left2,
            height: bottom2 - top2
          });
        });
      }, Optional.none());
    };
    const distanceToRectEdgeFromXY = (rect, x, y) => {
      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);
      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);
      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
    };
    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));
    const clamp$2 = (value2, min3, max3) => Math.min(Math.max(value2, min3), max3);
    const getSelectedNode = (range2) => {
      const startContainer = range2.startContainer, startOffset = range2.startOffset;
      if (startContainer === range2.endContainer && startContainer.hasChildNodes() && range2.endOffset === startOffset + 1) {
        return startContainer.childNodes[startOffset];
      }
      return null;
    };
    const getNode$1 = (container, offset2) => {
      if (isElement$6(container) && container.hasChildNodes()) {
        const childNodes = container.childNodes;
        const safeOffset = clamp$2(offset2, 0, childNodes.length - 1);
        return childNodes[safeOffset];
      } else {
        return container;
      }
    };
    const getNodeUnsafe = (container, offset2) => {
      if (offset2 < 0 && isElement$6(container) && container.hasChildNodes()) {
        return void 0;
      } else {
        return getNode$1(container, offset2);
      }
    };
    const extendingChars = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]");
    const isExtendingChar = (ch) => isString2(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    const or = (...args) => {
      return (x) => {
        for (let i = 0; i < args.length; i++) {
          if (args[i](x)) {
            return true;
          }
        }
        return false;
      };
    };
    const and = (...args) => {
      return (x) => {
        for (let i = 0; i < args.length; i++) {
          if (!args[i](x)) {
            return false;
          }
        }
        return true;
      };
    };
    const isElement$4 = isElement$6;
    const isCaretCandidate$2 = isCaretCandidate$3;
    const isBlock$1 = matchStyleValues("display", "block table");
    const isFloated = matchStyleValues("float", "left right");
    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));
    const isNotPre = not(matchStyleValues("white-space", "pre pre-line pre-wrap"));
    const isText$7 = isText$a;
    const isBr$3 = isBr$6;
    const nodeIndex$1 = DOMUtils.nodeIndex;
    const resolveIndex$1 = getNodeUnsafe;
    const createRange$1 = (doc) => doc ? doc.createRange() : DOMUtils.DOM.createRng();
    const isWhiteSpace$1 = (chr) => isString2(chr) && /[\r\n\t ]/.test(chr);
    const isRange = (rng) => !!rng.setStart && !!rng.setEnd;
    const isHiddenWhiteSpaceRange = (range2) => {
      const container = range2.startContainer;
      const offset2 = range2.startOffset;
      if (isWhiteSpace$1(range2.toString()) && isNotPre(container.parentNode) && isText$a(container)) {
        const text3 = container.data;
        if (isWhiteSpace$1(text3[offset2 - 1]) || isWhiteSpace$1(text3[offset2 + 1])) {
          return true;
        }
      }
      return false;
    };
    const getBrClientRect = (brNode) => {
      const doc = brNode.ownerDocument;
      const rng = createRange$1(doc);
      const nbsp$1 = doc.createTextNode(nbsp);
      const parentNode = brNode.parentNode;
      parentNode.insertBefore(nbsp$1, brNode);
      rng.setStart(nbsp$1, 0);
      rng.setEnd(nbsp$1, 1);
      const clientRect = clone$1(rng.getBoundingClientRect());
      parentNode.removeChild(nbsp$1);
      return clientRect;
    };
    const getBoundingClientRectWebKitText = (rng) => {
      const sc = rng.startContainer;
      const ec = rng.endContainer;
      const so = rng.startOffset;
      const eo = rng.endOffset;
      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {
        const newRng = rng.cloneRange();
        newRng.setEndAfter(ec);
        return getBoundingClientRect$1(newRng);
      } else {
        return null;
      }
    };
    const isZeroRect = (r2) => r2.left === 0 && r2.right === 0 && r2.top === 0 && r2.bottom === 0;
    const getBoundingClientRect$1 = (item2) => {
      var _a;
      let clientRect;
      const clientRects = item2.getClientRects();
      if (clientRects.length > 0) {
        clientRect = clone$1(clientRects[0]);
      } else {
        clientRect = clone$1(item2.getBoundingClientRect());
      }
      if (!isRange(item2) && isBr$3(item2) && isZeroRect(clientRect)) {
        return getBrClientRect(item2);
      }
      if (isZeroRect(clientRect) && isRange(item2)) {
        return (_a = getBoundingClientRectWebKitText(item2)) !== null && _a !== void 0 ? _a : clientRect;
      }
      return clientRect;
    };
    const collapseAndInflateWidth = (clientRect, toStart) => {
      const newClientRect = collapse(clientRect, toStart);
      newClientRect.width = 1;
      newClientRect.right = newClientRect.left + 1;
      return newClientRect;
    };
    const getCaretPositionClientRects = (caretPosition) => {
      const clientRects = [];
      const addUniqueAndValidRect = (clientRect) => {
        if (clientRect.height === 0) {
          return;
        }
        if (clientRects.length > 0) {
          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {
            return;
          }
        }
        clientRects.push(clientRect);
      };
      const addCharacterOffset = (container2, offset3) => {
        const range2 = createRange$1(container2.ownerDocument);
        if (offset3 < container2.data.length) {
          if (isExtendingChar(container2.data[offset3])) {
            return;
          }
          if (isExtendingChar(container2.data[offset3 - 1])) {
            range2.setStart(container2, offset3);
            range2.setEnd(container2, offset3 + 1);
            if (!isHiddenWhiteSpaceRange(range2)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), false));
              return;
            }
          }
        }
        if (offset3 > 0) {
          range2.setStart(container2, offset3 - 1);
          range2.setEnd(container2, offset3);
          if (!isHiddenWhiteSpaceRange(range2)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), false));
          }
        }
        if (offset3 < container2.data.length) {
          range2.setStart(container2, offset3);
          range2.setEnd(container2, offset3 + 1);
          if (!isHiddenWhiteSpaceRange(range2)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range2), true));
          }
        }
      };
      const container = caretPosition.container();
      const offset2 = caretPosition.offset();
      if (isText$7(container)) {
        addCharacterOffset(container, offset2);
        return clientRects;
      }
      if (isElement$4(container)) {
        if (caretPosition.isAtEnd()) {
          const node = resolveIndex$1(container, offset2);
          if (isText$7(node)) {
            addCharacterOffset(node, node.data.length);
          }
          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
          }
        } else {
          const node = resolveIndex$1(container, offset2);
          if (isText$7(node)) {
            addCharacterOffset(node, 0);
          }
          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));
            return clientRects;
          }
          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);
          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {
            if (isBlock$1(beforeNode) || isBlock$1(node) || !isValidElementCaretCandidate(node)) {
              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));
            }
          }
          if (isValidElementCaretCandidate(node)) {
            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));
          }
        }
      }
      return clientRects;
    };
    const CaretPosition = (container, offset2, clientRects) => {
      const isAtStart = () => {
        if (isText$7(container)) {
          return offset2 === 0;
        }
        return offset2 === 0;
      };
      const isAtEnd = () => {
        if (isText$7(container)) {
          return offset2 >= container.data.length;
        }
        return offset2 >= container.childNodes.length;
      };
      const toRange = () => {
        const range2 = createRange$1(container.ownerDocument);
        range2.setStart(container, offset2);
        range2.setEnd(container, offset2);
        return range2;
      };
      const getClientRects2 = () => {
        if (!clientRects) {
          clientRects = getCaretPositionClientRects(CaretPosition(container, offset2));
        }
        return clientRects;
      };
      const isVisible2 = () => getClientRects2().length > 0;
      const isEqual2 = (caretPosition) => caretPosition && container === caretPosition.container() && offset2 === caretPosition.offset();
      const getNode2 = (before2) => resolveIndex$1(container, before2 ? offset2 - 1 : offset2);
      return {
        container: constant(container),
        offset: constant(offset2),
        toRange,
        getClientRects: getClientRects2,
        isVisible: isVisible2,
        isAtStart,
        isAtEnd,
        isEqual: isEqual2,
        getNode: getNode2
      };
    };
    CaretPosition.fromRangeStart = (range2) => CaretPosition(range2.startContainer, range2.startOffset);
    CaretPosition.fromRangeEnd = (range2) => CaretPosition(range2.endContainer, range2.endOffset);
    CaretPosition.after = (node) => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);
    CaretPosition.before = (node) => CaretPosition(node.parentNode, nodeIndex$1(node));
    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);
    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);
    CaretPosition.isAtStart = (pos) => pos ? pos.isAtStart() : false;
    CaretPosition.isAtEnd = (pos) => pos ? pos.isAtEnd() : false;
    CaretPosition.isTextPosition = (pos) => pos ? isText$a(pos.container()) : false;
    CaretPosition.isElementPosition = (pos) => !CaretPosition.isTextPosition(pos);
    const trimEmptyTextNode$1 = (dom2, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom2.remove(node);
      }
    };
    const insertNode = (dom2, rng, node) => {
      rng.insertNode(node);
      trimEmptyTextNode$1(dom2, node.previousSibling);
      trimEmptyTextNode$1(dom2, node.nextSibling);
    };
    const insertFragment = (dom2, rng, frag) => {
      const firstChild2 = Optional.from(frag.firstChild);
      const lastChild2 = Optional.from(frag.lastChild);
      rng.insertNode(frag);
      firstChild2.each((child2) => trimEmptyTextNode$1(dom2, child2.previousSibling));
      lastChild2.each((child2) => trimEmptyTextNode$1(dom2, child2.nextSibling));
    };
    const rangeInsertNode = (dom2, rng, node) => {
      if (isDocumentFragment(node)) {
        insertFragment(dom2, rng, node);
      } else {
        insertNode(dom2, rng, node);
      }
    };
    const isText$6 = isText$a;
    const isBogus = isBogus$2;
    const nodeIndex = DOMUtils.nodeIndex;
    const normalizedParent = (node) => {
      const parentNode = node.parentNode;
      if (isBogus(parentNode)) {
        return normalizedParent(parentNode);
      }
      return parentNode;
    };
    const getChildNodes = (node) => {
      if (!node) {
        return [];
      }
      return reduce(node.childNodes, (result, node2) => {
        if (isBogus(node2) && node2.nodeName !== "BR") {
          result = result.concat(getChildNodes(node2));
        } else {
          result.push(node2);
        }
        return result;
      }, []);
    };
    const normalizedTextOffset = (node, offset2) => {
      let tempNode = node;
      while (tempNode = tempNode.previousSibling) {
        if (!isText$6(tempNode)) {
          break;
        }
        offset2 += tempNode.data.length;
      }
      return offset2;
    };
    const equal = (a) => (b) => a === b;
    const normalizedNodeIndex = (node) => {
      let nodes, index;
      nodes = getChildNodes(normalizedParent(node));
      index = findIndex$1(nodes, equal(node), node);
      nodes = nodes.slice(0, index + 1);
      const numTextFragments = reduce(nodes, (result, node2, i) => {
        if (isText$6(node2) && isText$6(nodes[i - 1])) {
          result++;
        }
        return result;
      }, 0);
      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));
      index = findIndex$1(nodes, equal(node), node);
      return index - numTextFragments;
    };
    const createPathItem = (node) => {
      const name3 = isText$6(node) ? "text()" : node.nodeName.toLowerCase();
      return name3 + "[" + normalizedNodeIndex(node) + "]";
    };
    const parentsUntil$1 = (root2, node, predicate) => {
      const parents2 = [];
      for (let tempNode = node.parentNode; tempNode && tempNode !== root2; tempNode = tempNode.parentNode) {
        if (predicate && predicate(tempNode)) {
          break;
        }
        parents2.push(tempNode);
      }
      return parents2;
    };
    const create$b2 = (root2, caretPosition) => {
      let path2 = [];
      let container = caretPosition.container();
      let offset2 = caretPosition.offset();
      let outputOffset;
      if (isText$6(container)) {
        outputOffset = normalizedTextOffset(container, offset2);
      } else {
        const childNodes = container.childNodes;
        if (offset2 >= childNodes.length) {
          outputOffset = "after";
          offset2 = childNodes.length - 1;
        } else {
          outputOffset = "before";
        }
        container = childNodes[offset2];
      }
      path2.push(createPathItem(container));
      let parents2 = parentsUntil$1(root2, container);
      parents2 = filter$3(parents2, not(isBogus$2));
      path2 = path2.concat(map$1(parents2, (node) => {
        return createPathItem(node);
      }));
      return path2.reverse().join("/") + "," + outputOffset;
    };
    const resolvePathItem = (node, name3, index) => {
      let nodes = getChildNodes(node);
      nodes = filter$3(nodes, (node2, index2) => {
        return !isText$6(node2) || !isText$6(nodes[index2 - 1]);
      });
      nodes = filter$3(nodes, matchNodeNames([name3]));
      return nodes[index];
    };
    const findTextPosition = (container, offset2) => {
      let node = container;
      let targetOffset = 0;
      while (isText$6(node)) {
        const dataLen = node.data.length;
        if (offset2 >= targetOffset && offset2 <= targetOffset + dataLen) {
          container = node;
          offset2 = offset2 - targetOffset;
          break;
        }
        if (!isText$6(node.nextSibling)) {
          container = node;
          offset2 = dataLen;
          break;
        }
        targetOffset += dataLen;
        node = node.nextSibling;
      }
      if (isText$6(container) && offset2 > container.data.length) {
        offset2 = container.data.length;
      }
      return CaretPosition(container, offset2);
    };
    const resolve$1 = (root2, path2) => {
      if (!path2) {
        return null;
      }
      const parts = path2.split(",");
      const paths = parts[0].split("/");
      const offset2 = parts.length > 1 ? parts[1] : "before";
      const container = reduce(paths, (result, value2) => {
        const match2 = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(value2);
        if (!match2) {
          return null;
        }
        if (match2[1] === "text()") {
          match2[1] = "#text";
        }
        return resolvePathItem(result, match2[1], parseInt(match2[2], 10));
      }, root2);
      if (!container) {
        return null;
      }
      if (!isText$6(container) && container.parentNode) {
        let nodeOffset;
        if (offset2 === "after") {
          nodeOffset = nodeIndex(container) + 1;
        } else {
          nodeOffset = nodeIndex(container);
        }
        return CaretPosition(container.parentNode, nodeOffset);
      }
      return findTextPosition(container, parseInt(offset2, 10));
    };
    const isContentEditableFalse$9 = isContentEditableFalse$b;
    const getNormalizedTextOffset$1 = (trim3, container, offset2) => {
      let trimmedOffset = trim3(container.data.slice(0, offset2)).length;
      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {
        trimmedOffset += trim3(node.data).length;
      }
      return trimmedOffset;
    };
    const getPoint = (dom2, trim3, normalized, rng, start3) => {
      const container = start3 ? rng.startContainer : rng.endContainer;
      let offset2 = start3 ? rng.startOffset : rng.endOffset;
      const point2 = [];
      const root2 = dom2.getRoot();
      if (isText$a(container)) {
        point2.push(normalized ? getNormalizedTextOffset$1(trim3, container, offset2) : offset2);
      } else {
        let after2 = 0;
        const childNodes = container.childNodes;
        if (offset2 >= childNodes.length && childNodes.length) {
          after2 = 1;
          offset2 = Math.max(0, childNodes.length - 1);
        }
        point2.push(dom2.nodeIndex(childNodes[offset2], normalized) + after2);
      }
      for (let node = container; node && node !== root2; node = node.parentNode) {
        point2.push(dom2.nodeIndex(node, normalized));
      }
      return point2;
    };
    const getLocation = (trim3, selection, normalized, rng) => {
      const dom2 = selection.dom;
      const start3 = getPoint(dom2, trim3, normalized, rng, true);
      const forward = selection.isForward();
      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};
      if (!selection.isCollapsed()) {
        const end3 = getPoint(dom2, trim3, normalized, rng, false);
        return {
          start: start3,
          end: end3,
          forward,
          ...fakeCaret
        };
      } else {
        return {
          start: start3,
          forward,
          ...fakeCaret
        };
      }
    };
    const findIndex = (dom2, name3, element) => {
      let count2 = 0;
      Tools.each(dom2.select(name3), (node) => {
        if (node.getAttribute("data-mce-bogus") === "all") {
          return;
        } else if (node === element) {
          return false;
        } else {
          count2++;
          return;
        }
      });
      return count2;
    };
    const moveEndPoint$1 = (rng, start3) => {
      let container = start3 ? rng.startContainer : rng.endContainer;
      let offset2 = start3 ? rng.startOffset : rng.endOffset;
      if (isElement$6(container) && container.nodeName === "TR") {
        const childNodes = container.childNodes;
        container = childNodes[Math.min(start3 ? offset2 : offset2 - 1, childNodes.length - 1)];
        if (container) {
          offset2 = start3 ? 0 : container.childNodes.length;
          if (start3) {
            rng.setStart(container, offset2);
          } else {
            rng.setEnd(container, offset2);
          }
        }
      }
    };
    const normalizeTableCellSelection = (rng) => {
      moveEndPoint$1(rng, true);
      moveEndPoint$1(rng, false);
      return rng;
    };
    const findSibling = (node, offset2) => {
      if (isElement$6(node)) {
        node = getNode$1(node, offset2);
        if (isContentEditableFalse$9(node)) {
          return node;
        }
      }
      if (isCaretContainer$2(node)) {
        if (isText$a(node) && isCaretContainerBlock$1(node)) {
          node = node.parentNode;
        }
        let sibling2 = node.previousSibling;
        if (isContentEditableFalse$9(sibling2)) {
          return sibling2;
        }
        sibling2 = node.nextSibling;
        if (isContentEditableFalse$9(sibling2)) {
          return sibling2;
        }
      }
      return void 0;
    };
    const findAdjacentContentEditableFalseElm = (rng) => {
      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);
    };
    const getOffsetBookmark = (trim3, normalized, selection) => {
      const element = selection.getNode();
      const rng = selection.getRng();
      if (element.nodeName === "IMG" || isContentEditableFalse$9(element)) {
        const name3 = element.nodeName;
        return {
          name: name3,
          index: findIndex(selection.dom, name3, element)
        };
      }
      const sibling2 = findAdjacentContentEditableFalseElm(rng);
      if (sibling2) {
        const name3 = sibling2.tagName;
        return {
          name: name3,
          index: findIndex(selection.dom, name3, sibling2)
        };
      }
      return getLocation(trim3, selection, normalized, rng);
    };
    const getCaretBookmark = (selection) => {
      const rng = selection.getRng();
      return {
        start: create$b2(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),
        end: create$b2(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),
        forward: selection.isForward()
      };
    };
    const getRangeBookmark = (selection) => {
      return {
        rng: selection.getRng(),
        forward: selection.isForward()
      };
    };
    const createBookmarkSpan = (dom2, id, filled) => {
      const args = {
        "data-mce-type": "bookmark",
        id,
        "style": "overflow:hidden;line-height:0px"
      };
      return filled ? dom2.create("span", args, "&#xFEFF;") : dom2.create("span", args);
    };
    const getPersistentBookmark = (selection, filled) => {
      const dom2 = selection.dom;
      let rng = selection.getRng();
      const id = dom2.uniqueId();
      const collapsed = selection.isCollapsed();
      const element = selection.getNode();
      const name3 = element.nodeName;
      const forward = selection.isForward();
      if (name3 === "IMG") {
        return {
          name: name3,
          index: findIndex(dom2, name3, element)
        };
      }
      const rng2 = normalizeTableCellSelection(rng.cloneRange());
      if (!collapsed) {
        rng2.collapse(false);
        const endBookmarkNode = createBookmarkSpan(dom2, id + "_end", filled);
        rangeInsertNode(dom2, rng2, endBookmarkNode);
      }
      rng = normalizeTableCellSelection(rng);
      rng.collapse(true);
      const startBookmarkNode = createBookmarkSpan(dom2, id + "_start", filled);
      rangeInsertNode(dom2, rng, startBookmarkNode);
      selection.moveToBookmark({
        id,
        keep: true,
        forward
      });
      return {
        id,
        forward
      };
    };
    const getBookmark$2 = (selection, type2, normalized = false) => {
      if (type2 === 2) {
        return getOffsetBookmark(trim$12, normalized, selection);
      } else if (type2 === 3) {
        return getCaretBookmark(selection);
      } else if (type2) {
        return getRangeBookmark(selection);
      } else {
        return getPersistentBookmark(selection, false);
      }
    };
    const getUndoBookmark = curry(getOffsetBookmark, identity, true);
    const value$1 = (value2) => {
      const applyHelper = (fn3) => fn3(value2);
      const constHelper = constant(value2);
      const outputHelper = () => output;
      const output = {
        tag: true,
        inner: value2,
        fold: (_onError, onValue) => onValue(value2),
        isValue: always,
        isError: never,
        map: (mapper) => Result.value(mapper(value2)),
        mapError: outputHelper,
        bind: applyHelper,
        exists: applyHelper,
        forall: applyHelper,
        getOr: constHelper,
        or: outputHelper,
        getOrThunk: constHelper,
        orThunk: outputHelper,
        getOrDie: constHelper,
        each: (fn3) => {
          fn3(value2);
        },
        toOptional: () => Optional.some(value2)
      };
      return output;
    };
    const error2 = (error3) => {
      const outputHelper = () => output;
      const output = {
        tag: false,
        inner: error3,
        fold: (onError, _onValue) => onError(error3),
        isValue: never,
        isError: always,
        map: outputHelper,
        mapError: (mapper) => Result.error(mapper(error3)),
        bind: outputHelper,
        exists: never,
        forall: always,
        getOr: identity,
        or: identity,
        getOrThunk: apply$1,
        orThunk: apply$1,
        getOrDie: die(String(error3)),
        each: noop2,
        toOptional: Optional.none
      };
      return output;
    };
    const fromOption = (optional, err) => optional.fold(() => error2(err), value$1);
    const Result = {
      value: value$1,
      error: error2,
      fromOption
    };
    const generate = (cases) => {
      if (!isArray$12(cases)) {
        throw new Error("cases must be an array");
      }
      if (cases.length === 0) {
        throw new Error("there must be at least one case");
      }
      const constructors = [];
      const adt2 = {};
      each$e(cases, (acase, count2) => {
        const keys$1 = keys(acase);
        if (keys$1.length !== 1) {
          throw new Error("one and only one name per case");
        }
        const key = keys$1[0];
        const value2 = acase[key];
        if (adt2[key] !== void 0) {
          throw new Error("duplicate key detected:" + key);
        } else if (key === "cata") {
          throw new Error("cannot have a case named cata (sorry)");
        } else if (!isArray$12(value2)) {
          throw new Error("case arguments must be an array");
        }
        constructors.push(key);
        adt2[key] = (...args) => {
          const argLength = args.length;
          if (argLength !== value2.length) {
            throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
          }
          const match2 = (branches) => {
            const branchKeys = keys(branches);
            if (constructors.length !== branchKeys.length) {
              throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
            }
            const allReqd = forall(constructors, (reqKey) => {
              return contains$2(branchKeys, reqKey);
            });
            if (!allReqd) {
              throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
            }
            return branches[key].apply(null, args);
          };
          return {
            fold: (...foldArgs) => {
              if (foldArgs.length !== cases.length) {
                throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
              }
              const target = foldArgs[count2];
              return target.apply(null, args);
            },
            match: match2,
            log: (label) => {
              console.log(label, {
                constructors,
                constructor: key,
                params: args
              });
            }
          };
        };
      });
      return adt2;
    };
    const Adt = { generate };
    Adt.generate([
      {
        bothErrors: [
          "error1",
          "error2"
        ]
      },
      {
        firstError: [
          "error1",
          "value2"
        ]
      },
      {
        secondError: [
          "value1",
          "error2"
        ]
      },
      {
        bothValues: [
          "value1",
          "value2"
        ]
      }
    ]);
    const partition$1 = (results) => {
      const errors = [];
      const values2 = [];
      each$e(results, (result) => {
        result.fold((err) => {
          errors.push(err);
        }, (value2) => {
          values2.push(value2);
        });
      });
      return {
        errors,
        values: values2
      };
    };
    const isInlinePattern = (pattern) => pattern.type === "inline-command" || pattern.type === "inline-format";
    const isBlockPattern = (pattern) => pattern.type === "block-command" || pattern.type === "block-format";
    const normalizePattern = (pattern) => {
      const err = (message) => Result.error({
        message,
        pattern
      });
      const formatOrCmd = (name3, onFormat, onCommand) => {
        if (pattern.format !== void 0) {
          let formats;
          if (isArray$12(pattern.format)) {
            if (!forall(pattern.format, isString2)) {
              return err(name3 + " pattern has non-string items in the `format` array");
            }
            formats = pattern.format;
          } else if (isString2(pattern.format)) {
            formats = [pattern.format];
          } else {
            return err(name3 + " pattern has non-string `format` parameter");
          }
          return Result.value(onFormat(formats));
        } else if (pattern.cmd !== void 0) {
          if (!isString2(pattern.cmd)) {
            return err(name3 + " pattern has non-string `cmd` parameter");
          }
          return Result.value(onCommand(pattern.cmd, pattern.value));
        } else {
          return err(name3 + " pattern is missing both `format` and `cmd` parameters");
        }
      };
      if (!isObject2(pattern)) {
        return err("Raw pattern is not an object");
      }
      if (!isString2(pattern.start)) {
        return err("Raw pattern is missing `start` parameter");
      }
      if (pattern.end !== void 0) {
        if (!isString2(pattern.end)) {
          return err("Inline pattern has non-string `end` parameter");
        }
        if (pattern.start.length === 0 && pattern.end.length === 0) {
          return err("Inline pattern has empty `start` and `end` parameters");
        }
        let start3 = pattern.start;
        let end3 = pattern.end;
        if (end3.length === 0) {
          end3 = start3;
          start3 = "";
        }
        return formatOrCmd("Inline", (format) => ({
          type: "inline-format",
          start: start3,
          end: end3,
          format
        }), (cmd, value2) => ({
          type: "inline-command",
          start: start3,
          end: end3,
          cmd,
          value: value2
        }));
      } else if (pattern.replacement !== void 0) {
        if (!isString2(pattern.replacement)) {
          return err("Replacement pattern has non-string `replacement` parameter");
        }
        if (pattern.start.length === 0) {
          return err("Replacement pattern has empty `start` parameter");
        }
        return Result.value({
          type: "inline-command",
          start: "",
          end: pattern.start,
          cmd: "mceInsertContent",
          value: pattern.replacement
        });
      } else {
        if (pattern.start.length === 0) {
          return err("Block pattern has empty `start` parameter");
        }
        return formatOrCmd("Block", (formats) => ({
          type: "block-format",
          start: pattern.start,
          format: formats[0]
        }), (command, commandValue) => ({
          type: "block-command",
          start: pattern.start,
          cmd: command,
          value: commandValue
        }));
      }
    };
    const getBlockPatterns = (patterns) => filter$5(patterns, isBlockPattern);
    const getInlinePatterns = (patterns) => filter$5(patterns, isInlinePattern);
    const createPatternSet = (patterns, dynamicPatternsLookup) => ({
      inlinePatterns: getInlinePatterns(patterns),
      blockPatterns: getBlockPatterns(patterns),
      dynamicPatternsLookup
    });
    const fromRawPatterns = (patterns) => {
      const normalized = partition$1(map$3(patterns, normalizePattern));
      each$e(normalized.errors, (err) => console.error(err.message, err.pattern));
      return normalized.values;
    };
    const fromRawPatternsLookup = (lookupFn) => {
      return (ctx) => {
        const rawPatterns = lookupFn(ctx);
        return fromRawPatterns(rawPatterns);
      };
    };
    const deviceDetection$1 = detect$2().deviceType;
    const isTouch = deviceDetection$1.isTouch();
    const DOM$a = DOMUtils.DOM;
    const getHash = (value2) => {
      const items = value2.indexOf("=") > 0 ? value2.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value2.split(",");
      return foldl(items, (output, item2) => {
        const arr = item2.split("=");
        const key = arr[0];
        const val = arr.length > 1 ? arr[1] : key;
        output[trim$3(key)] = trim$3(val);
        return output;
      }, {});
    };
    const isRegExp2 = (x) => is$4(x, RegExp);
    const option2 = (name3) => (editor) => editor.options.get(name3);
    const stringOrObjectProcessor = (value2) => isString2(value2) || isObject2(value2);
    const bodyOptionProcessor = (editor, defaultValue = "") => (value2) => {
      const valid = isString2(value2);
      if (valid) {
        if (value2.indexOf("=") !== -1) {
          const bodyObj = getHash(value2);
          return {
            value: get$a(bodyObj, editor.id).getOr(defaultValue),
            valid
          };
        } else {
          return {
            value: value2,
            valid
          };
        }
      } else {
        return {
          valid: false,
          message: "Must be a string."
        };
      }
    };
    const register$7 = (editor) => {
      const registerOption = editor.options.register;
      registerOption("id", {
        processor: "string",
        default: editor.id
      });
      registerOption("selector", { processor: "string" });
      registerOption("target", { processor: "object" });
      registerOption("suffix", { processor: "string" });
      registerOption("cache_suffix", { processor: "string" });
      registerOption("base_url", { processor: "string" });
      registerOption("referrer_policy", {
        processor: "string",
        default: ""
      });
      registerOption("language_load", {
        processor: "boolean",
        default: true
      });
      registerOption("inline", {
        processor: "boolean",
        default: false
      });
      registerOption("iframe_attrs", {
        processor: "object",
        default: {}
      });
      registerOption("doctype", {
        processor: "string",
        default: "<!DOCTYPE html>"
      });
      registerOption("document_base_url", {
        processor: "string",
        default: editor.documentBaseUrl
      });
      registerOption("body_id", {
        processor: bodyOptionProcessor(editor, "tinymce"),
        default: "tinymce"
      });
      registerOption("body_class", {
        processor: bodyOptionProcessor(editor),
        default: ""
      });
      registerOption("content_security_policy", {
        processor: "string",
        default: ""
      });
      registerOption("br_in_pre", {
        processor: "boolean",
        default: true
      });
      registerOption("forced_root_block", {
        processor: (value2) => {
          const valid = isString2(value2) && isNotEmpty(value2);
          if (valid) {
            return {
              value: value2,
              valid
            };
          } else {
            return {
              valid: false,
              message: "Must be a non-empty string."
            };
          }
        },
        default: "p"
      });
      registerOption("forced_root_block_attrs", {
        processor: "object",
        default: {}
      });
      registerOption("newline_behavior", {
        processor: (value2) => {
          const valid = contains$2([
            "block",
            "linebreak",
            "invert",
            "default"
          ], value2);
          return valid ? {
            value: value2,
            valid
          } : {
            valid: false,
            message: "Must be one of: block, linebreak, invert or default."
          };
        },
        default: "default"
      });
      registerOption("br_newline_selector", {
        processor: "string",
        default: ".mce-toc h2,figcaption,caption"
      });
      registerOption("no_newline_selector", {
        processor: "string",
        default: ""
      });
      registerOption("keep_styles", {
        processor: "boolean",
        default: true
      });
      registerOption("end_container_on_empty_block", {
        processor: (value2) => {
          if (isBoolean2(value2)) {
            return {
              valid: true,
              value: value2
            };
          } else if (isString2(value2)) {
            return {
              valid: true,
              value: value2
            };
          } else {
            return {
              valid: false,
              message: "Must be boolean or a string"
            };
          }
        },
        default: "blockquote"
      });
      registerOption("font_size_style_values", {
        processor: "string",
        default: "xx-small,x-small,small,medium,large,x-large,xx-large"
      });
      registerOption("font_size_legacy_values", {
        processor: "string",
        default: "xx-small,small,medium,large,x-large,xx-large,300%"
      });
      registerOption("font_size_classes", {
        processor: "string",
        default: ""
      });
      registerOption("automatic_uploads", {
        processor: "boolean",
        default: true
      });
      registerOption("images_reuse_filename", {
        processor: "boolean",
        default: false
      });
      registerOption("images_replace_blob_uris", {
        processor: "boolean",
        default: true
      });
      registerOption("icons", {
        processor: "string",
        default: ""
      });
      registerOption("icons_url", {
        processor: "string",
        default: ""
      });
      registerOption("images_upload_url", {
        processor: "string",
        default: ""
      });
      registerOption("images_upload_base_path", {
        processor: "string",
        default: ""
      });
      registerOption("images_upload_credentials", {
        processor: "boolean",
        default: false
      });
      registerOption("images_upload_handler", { processor: "function" });
      registerOption("language", {
        processor: "string",
        default: "en"
      });
      registerOption("language_url", {
        processor: "string",
        default: ""
      });
      registerOption("entity_encoding", {
        processor: "string",
        default: "named"
      });
      registerOption("indent", {
        processor: "boolean",
        default: true
      });
      registerOption("indent_before", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      });
      registerOption("indent_after", {
        processor: "string",
        default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
      });
      registerOption("indent_use_margin", {
        processor: "boolean",
        default: false
      });
      registerOption("indentation", {
        processor: "string",
        default: "40px"
      });
      registerOption("content_css", {
        processor: (value2) => {
          const valid = value2 === false || isString2(value2) || isArrayOf(value2, isString2);
          if (valid) {
            if (isString2(value2)) {
              return {
                value: map$3(value2.split(","), trim$3),
                valid
              };
            } else if (isArray$12(value2)) {
              return {
                value: value2,
                valid
              };
            } else if (value2 === false) {
              return {
                value: [],
                valid
              };
            } else {
              return {
                value: value2,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: "Must be false, a string or an array of strings."
            };
          }
        },
        default: isInline(editor) ? [] : ["default"]
      });
      registerOption("content_style", { processor: "string" });
      registerOption("content_css_cors", {
        processor: "boolean",
        default: false
      });
      registerOption("font_css", {
        processor: (value2) => {
          const valid = isString2(value2) || isArrayOf(value2, isString2);
          if (valid) {
            const newValue = isArray$12(value2) ? value2 : map$3(value2.split(","), trim$3);
            return {
              value: newValue,
              valid
            };
          } else {
            return {
              valid: false,
              message: "Must be a string or an array of strings."
            };
          }
        },
        default: []
      });
      registerOption("inline_boundaries", {
        processor: "boolean",
        default: true
      });
      registerOption("inline_boundaries_selector", {
        processor: "string",
        default: "a[href],code,span.mce-annotation"
      });
      registerOption("object_resizing", {
        processor: (value2) => {
          const valid = isBoolean2(value2) || isString2(value2);
          if (valid) {
            if (value2 === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {
              return {
                value: "",
                valid
              };
            } else {
              return {
                value: value2 === true ? "table,img,figure.image,div,video,iframe" : value2,
                valid
              };
            }
          } else {
            return {
              valid: false,
              message: "Must be boolean or a string"
            };
          }
        },
        default: !isTouch
      });
      registerOption("resize_img_proportional", {
        processor: "boolean",
        default: true
      });
      registerOption("event_root", { processor: "object" });
      registerOption("service_message", { processor: "string" });
      registerOption("theme", {
        processor: (value2) => value2 === false || isString2(value2) || isFunction2(value2),
        default: "silver"
      });
      registerOption("theme_url", { processor: "string" });
      registerOption("formats", { processor: "object" });
      registerOption("format_empty_lines", {
        processor: "boolean",
        default: false
      });
      registerOption("format_noneditable_selector", {
        processor: "string",
        default: ""
      });
      registerOption("preview_styles", {
        processor: (value2) => {
          const valid = value2 === false || isString2(value2);
          if (valid) {
            return {
              value: value2 === false ? "" : value2,
              valid
            };
          } else {
            return {
              valid: false,
              message: "Must be false or a string"
            };
          }
        },
        default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
      });
      registerOption("custom_ui_selector", {
        processor: "string",
        default: ""
      });
      registerOption("hidden_input", {
        processor: "boolean",
        default: true
      });
      registerOption("submit_patch", {
        processor: "boolean",
        default: true
      });
      registerOption("encoding", { processor: "string" });
      registerOption("add_form_submit_trigger", {
        processor: "boolean",
        default: true
      });
      registerOption("add_unload_trigger", {
        processor: "boolean",
        default: true
      });
      registerOption("custom_undo_redo_levels", {
        processor: "number",
        default: 0
      });
      registerOption("disable_nodechange", {
        processor: "boolean",
        default: false
      });
      registerOption("readonly", {
        processor: "boolean",
        default: false
      });
      registerOption("plugins", {
        processor: "string[]",
        default: []
      });
      registerOption("external_plugins", { processor: "object" });
      registerOption("forced_plugins", { processor: "string[]" });
      registerOption("model", {
        processor: "string",
        default: editor.hasPlugin("rtc") ? "plugin" : "dom"
      });
      registerOption("model_url", { processor: "string" });
      registerOption("block_unsupported_drop", {
        processor: "boolean",
        default: true
      });
      registerOption("visual", {
        processor: "boolean",
        default: true
      });
      registerOption("visual_table_class", {
        processor: "string",
        default: "mce-item-table"
      });
      registerOption("visual_anchor_class", {
        processor: "string",
        default: "mce-item-anchor"
      });
      registerOption("iframe_aria_text", {
        processor: "string",
        default: "Rich Text Area. Press ALT-0 for help."
      });
      registerOption("setup", { processor: "function" });
      registerOption("init_instance_callback", { processor: "function" });
      registerOption("url_converter", {
        processor: "function",
        default: editor.convertURL
      });
      registerOption("url_converter_scope", {
        processor: "object",
        default: editor
      });
      registerOption("urlconverter_callback", { processor: "function" });
      registerOption("allow_conditional_comments", {
        processor: "boolean",
        default: false
      });
      registerOption("allow_html_data_urls", {
        processor: "boolean",
        default: false
      });
      registerOption("allow_svg_data_urls", { processor: "boolean" });
      registerOption("allow_html_in_named_anchor", {
        processor: "boolean",
        default: false
      });
      registerOption("allow_script_urls", {
        processor: "boolean",
        default: false
      });
      registerOption("allow_unsafe_link_target", {
        processor: "boolean",
        default: false
      });
      registerOption("convert_fonts_to_spans", {
        processor: "boolean",
        default: true,
        deprecated: true
      });
      registerOption("fix_list_elements", {
        processor: "boolean",
        default: false
      });
      registerOption("preserve_cdata", {
        processor: "boolean",
        default: false
      });
      registerOption("remove_trailing_brs", { processor: "boolean" });
      registerOption("inline_styles", {
        processor: "boolean",
        default: true,
        deprecated: true
      });
      registerOption("element_format", {
        processor: "string",
        default: "html"
      });
      registerOption("entities", { processor: "string" });
      registerOption("schema", {
        processor: "string",
        default: "html5"
      });
      registerOption("convert_urls", {
        processor: "boolean",
        default: true
      });
      registerOption("relative_urls", {
        processor: "boolean",
        default: true
      });
      registerOption("remove_script_host", {
        processor: "boolean",
        default: true
      });
      registerOption("custom_elements", { processor: "string" });
      registerOption("extended_valid_elements", { processor: "string" });
      registerOption("invalid_elements", { processor: "string" });
      registerOption("invalid_styles", { processor: stringOrObjectProcessor });
      registerOption("valid_children", { processor: "string" });
      registerOption("valid_classes", { processor: stringOrObjectProcessor });
      registerOption("valid_elements", { processor: "string" });
      registerOption("valid_styles", { processor: stringOrObjectProcessor });
      registerOption("verify_html", {
        processor: "boolean",
        default: true
      });
      registerOption("auto_focus", { processor: (value2) => isString2(value2) || value2 === true });
      registerOption("browser_spellcheck", {
        processor: "boolean",
        default: false
      });
      registerOption("protect", { processor: "array" });
      registerOption("images_file_types", {
        processor: "string",
        default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
      });
      registerOption("deprecation_warnings", {
        processor: "boolean",
        default: true
      });
      registerOption("a11y_advanced_options", {
        processor: "boolean",
        default: false
      });
      registerOption("api_key", { processor: "string" });
      registerOption("paste_block_drop", {
        processor: "boolean",
        default: false
      });
      registerOption("paste_data_images", {
        processor: "boolean",
        default: true
      });
      registerOption("paste_preprocess", { processor: "function" });
      registerOption("paste_postprocess", { processor: "function" });
      registerOption("paste_webkit_styles", {
        processor: "string",
        default: "none"
      });
      registerOption("paste_remove_styles_if_webkit", {
        processor: "boolean",
        default: true
      });
      registerOption("paste_merge_formats", {
        processor: "boolean",
        default: true
      });
      registerOption("smart_paste", {
        processor: "boolean",
        default: true
      });
      registerOption("paste_as_text", {
        processor: "boolean",
        default: false
      });
      registerOption("paste_tab_spaces", {
        processor: "number",
        default: 4
      });
      registerOption("text_patterns", {
        processor: (value2) => {
          if (isArrayOf(value2, isObject2) || value2 === false) {
            const patterns = value2 === false ? [] : value2;
            return {
              value: fromRawPatterns(patterns),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: "Must be an array of objects or false."
            };
          }
        },
        default: [
          {
            start: "*",
            end: "*",
            format: "italic"
          },
          {
            start: "**",
            end: "**",
            format: "bold"
          },
          {
            start: "#",
            format: "h1"
          },
          {
            start: "##",
            format: "h2"
          },
          {
            start: "###",
            format: "h3"
          },
          {
            start: "####",
            format: "h4"
          },
          {
            start: "#####",
            format: "h5"
          },
          {
            start: "######",
            format: "h6"
          },
          {
            start: "1. ",
            cmd: "InsertOrderedList"
          },
          {
            start: "* ",
            cmd: "InsertUnorderedList"
          },
          {
            start: "- ",
            cmd: "InsertUnorderedList"
          }
        ]
      });
      registerOption("text_patterns_lookup", {
        processor: (value2) => {
          if (isFunction2(value2)) {
            return {
              value: fromRawPatternsLookup(value2),
              valid: true
            };
          } else {
            return {
              valid: false,
              message: "Must be a single function"
            };
          }
        },
        default: (_ctx) => []
      });
      registerOption("noneditable_class", {
        processor: "string",
        default: "mceNonEditable"
      });
      registerOption("editable_class", {
        processor: "string",
        default: "mceEditable"
      });
      registerOption("noneditable_regexp", {
        processor: (value2) => {
          if (isArrayOf(value2, isRegExp2)) {
            return {
              value: value2,
              valid: true
            };
          } else if (isRegExp2(value2)) {
            return {
              value: [value2],
              valid: true
            };
          } else {
            return {
              valid: false,
              message: "Must be a RegExp or an array of RegExp."
            };
          }
        },
        default: []
      });
      registerOption("table_tab_navigation", {
        processor: "boolean",
        default: true
      });
      registerOption("highlight_on_focus", {
        processor: "boolean",
        default: false
      });
      registerOption("xss_sanitization", {
        processor: "boolean",
        default: true
      });
      editor.on("ScriptsLoaded", () => {
        registerOption("directionality", {
          processor: "string",
          default: I18n.isRtl() ? "rtl" : void 0
        });
        registerOption("placeholder", {
          processor: "string",
          default: DOM$a.getAttrib(editor.getElement(), "placeholder")
        });
      });
    };
    const getIframeAttrs = option2("iframe_attrs");
    const getDocType = option2("doctype");
    const getDocumentBaseUrl = option2("document_base_url");
    const getBodyId = option2("body_id");
    const getBodyClass = option2("body_class");
    const getContentSecurityPolicy = option2("content_security_policy");
    const shouldPutBrInPre$1 = option2("br_in_pre");
    const getForcedRootBlock = option2("forced_root_block");
    const getForcedRootBlockAttrs = option2("forced_root_block_attrs");
    const getNewlineBehavior = option2("newline_behavior");
    const getBrNewLineSelector = option2("br_newline_selector");
    const getNoNewLineSelector = option2("no_newline_selector");
    const shouldKeepStyles = option2("keep_styles");
    const shouldEndContainerOnEmptyBlock = option2("end_container_on_empty_block");
    const isAutomaticUploadsEnabled = option2("automatic_uploads");
    const shouldReuseFileName = option2("images_reuse_filename");
    const shouldReplaceBlobUris = option2("images_replace_blob_uris");
    const getIconPackName = option2("icons");
    const getIconsUrl = option2("icons_url");
    const getImageUploadUrl = option2("images_upload_url");
    const getImageUploadBasePath = option2("images_upload_base_path");
    const getImagesUploadCredentials = option2("images_upload_credentials");
    const getImagesUploadHandler = option2("images_upload_handler");
    const shouldUseContentCssCors = option2("content_css_cors");
    const getReferrerPolicy = option2("referrer_policy");
    const getLanguageCode = option2("language");
    const getLanguageUrl = option2("language_url");
    const shouldIndentUseMargin = option2("indent_use_margin");
    const getIndentation = option2("indentation");
    const getContentCss = option2("content_css");
    const getContentStyle = option2("content_style");
    const getFontCss = option2("font_css");
    const getDirectionality = option2("directionality");
    const getInlineBoundarySelector = option2("inline_boundaries_selector");
    const getObjectResizing = option2("object_resizing");
    const getResizeImgProportional = option2("resize_img_proportional");
    const getPlaceholder = option2("placeholder");
    const getEventRoot = option2("event_root");
    const getServiceMessage = option2("service_message");
    const getTheme = option2("theme");
    const getThemeUrl = option2("theme_url");
    const getModel = option2("model");
    const getModelUrl = option2("model_url");
    const isInlineBoundariesEnabled = option2("inline_boundaries");
    const getFormats = option2("formats");
    const getPreviewStyles = option2("preview_styles");
    const canFormatEmptyLines = option2("format_empty_lines");
    const getFormatNoneditableSelector = option2("format_noneditable_selector");
    const getCustomUiSelector = option2("custom_ui_selector");
    const isInline = option2("inline");
    const hasHiddenInput = option2("hidden_input");
    const shouldPatchSubmit = option2("submit_patch");
    const shouldAddFormSubmitTrigger = option2("add_form_submit_trigger");
    const shouldAddUnloadTrigger = option2("add_unload_trigger");
    const getCustomUndoRedoLevels = option2("custom_undo_redo_levels");
    const shouldDisableNodeChange = option2("disable_nodechange");
    const isReadOnly$1 = option2("readonly");
    const hasContentCssCors = option2("content_css_cors");
    const getPlugins = option2("plugins");
    const getExternalPlugins$1 = option2("external_plugins");
    const shouldBlockUnsupportedDrop = option2("block_unsupported_drop");
    const isVisualAidsEnabled = option2("visual");
    const getVisualAidsTableClass = option2("visual_table_class");
    const getVisualAidsAnchorClass = option2("visual_anchor_class");
    const getIframeAriaText = option2("iframe_aria_text");
    const getSetupCallback = option2("setup");
    const getInitInstanceCallback = option2("init_instance_callback");
    const getUrlConverterCallback = option2("urlconverter_callback");
    const getAutoFocus = option2("auto_focus");
    const shouldBrowserSpellcheck = option2("browser_spellcheck");
    const getProtect = option2("protect");
    const shouldPasteBlockDrop = option2("paste_block_drop");
    const shouldPasteDataImages = option2("paste_data_images");
    const getPastePreProcess = option2("paste_preprocess");
    const getPastePostProcess = option2("paste_postprocess");
    const getPasteWebkitStyles = option2("paste_webkit_styles");
    const shouldPasteRemoveWebKitStyles = option2("paste_remove_styles_if_webkit");
    const shouldPasteMergeFormats = option2("paste_merge_formats");
    const isSmartPasteEnabled = option2("smart_paste");
    const isPasteAsTextEnabled = option2("paste_as_text");
    const getPasteTabSpaces = option2("paste_tab_spaces");
    const shouldAllowHtmlDataUrls = option2("allow_html_data_urls");
    const getTextPatterns = option2("text_patterns");
    const getTextPatternsLookup = option2("text_patterns_lookup");
    const getNonEditableClass = option2("noneditable_class");
    const getEditableClass = option2("editable_class");
    const getNonEditableRegExps = option2("noneditable_regexp");
    const shouldPreserveCData = option2("preserve_cdata");
    const shouldHighlightOnFocus = option2("highlight_on_focus");
    const shouldSanitizeXss = option2("xss_sanitization");
    const hasTextPatternsLookup = (editor) => editor.options.isSet("text_patterns_lookup");
    const getFontStyleValues = (editor) => Tools.explode(editor.options.get("font_size_style_values"));
    const getFontSizeClasses = (editor) => Tools.explode(editor.options.get("font_size_classes"));
    const isEncodingXml = (editor) => editor.options.get("encoding") === "xml";
    const getAllowedImageFileTypes = (editor) => Tools.explode(editor.options.get("images_file_types"));
    const hasTableTabNavigation = option2("table_tab_navigation");
    const isElement$3 = isElement$6;
    const isText$5 = isText$a;
    const removeNode$1 = (node) => {
      const parentNode = node.parentNode;
      if (parentNode) {
        parentNode.removeChild(node);
      }
    };
    const trimCount = (text3) => {
      const trimmedText = trim$12(text3);
      return {
        count: text3.length - trimmedText.length,
        text: trimmedText
      };
    };
    const deleteZwspChars = (caretContainer) => {
      let idx;
      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {
        caretContainer.deleteData(idx, 1);
      }
    };
    const removeUnchanged = (caretContainer, pos) => {
      remove$4(caretContainer);
      return pos;
    };
    const removeTextAndReposition = (caretContainer, pos) => {
      const before2 = trimCount(caretContainer.data.substr(0, pos.offset()));
      const after2 = trimCount(caretContainer.data.substr(pos.offset()));
      const text3 = before2.text + after2.text;
      if (text3.length > 0) {
        deleteZwspChars(caretContainer);
        return CaretPosition(caretContainer, pos.offset() - before2.count);
      } else {
        return pos;
      }
    };
    const removeElementAndReposition = (caretContainer, pos) => {
      const parentNode = pos.container();
      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map((index) => {
        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;
      }).getOr(pos);
      remove$4(caretContainer);
      return newPosition;
    };
    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);
    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);
    const remove$4 = (caretContainerNode) => {
      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {
        if (hasContent(caretContainerNode)) {
          caretContainerNode.removeAttribute("data-mce-caret");
        } else {
          removeNode$1(caretContainerNode);
        }
      }
      if (isText$5(caretContainerNode)) {
        deleteZwspChars(caretContainerNode);
        if (caretContainerNode.data.length === 0) {
          removeNode$1(caretContainerNode);
        }
      }
    };
    const isContentEditableFalse$8 = isContentEditableFalse$b;
    const isMedia$1 = isMedia$2;
    const isTableCell$1 = isTableCell$3;
    const inlineFakeCaretSelector = "*[contentEditable=false],video,audio,embed,object";
    const getAbsoluteClientRect = (root2, element, before2) => {
      const clientRect = collapse(element.getBoundingClientRect(), before2);
      let scrollX;
      let scrollY;
      if (root2.tagName === "BODY") {
        const docElm = root2.ownerDocument.documentElement;
        scrollX = root2.scrollLeft || docElm.scrollLeft;
        scrollY = root2.scrollTop || docElm.scrollTop;
      } else {
        const rootRect = root2.getBoundingClientRect();
        scrollX = root2.scrollLeft - rootRect.left;
        scrollY = root2.scrollTop - rootRect.top;
      }
      clientRect.left += scrollX;
      clientRect.right += scrollX;
      clientRect.top += scrollY;
      clientRect.bottom += scrollY;
      clientRect.width = 1;
      let margin = element.offsetWidth - element.clientWidth;
      if (margin > 0) {
        if (before2) {
          margin *= -1;
        }
        clientRect.left += margin;
        clientRect.right += margin;
      }
      return clientRect;
    };
    const trimInlineCaretContainers = (root2) => {
      var _a, _b;
      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root2), inlineFakeCaretSelector);
      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {
        const node = fakeCaretTargetNodes[i].dom;
        let sibling2 = node.previousSibling;
        if (endsWithCaretContainer$1(sibling2)) {
          const data3 = sibling2.data;
          if (data3.length === 1) {
            (_a = sibling2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling2);
          } else {
            sibling2.deleteData(data3.length - 1, 1);
          }
        }
        sibling2 = node.nextSibling;
        if (startsWithCaretContainer$1(sibling2)) {
          const data3 = sibling2.data;
          if (data3.length === 1) {
            (_b = sibling2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling2);
          } else {
            sibling2.deleteData(0, 1);
          }
        }
      }
    };
    const FakeCaret = (editor, root2, isBlock2, hasFocus2) => {
      const lastVisualCaret = value$2();
      let cursorInterval;
      let caretContainerNode;
      const caretBlock = getForcedRootBlock(editor);
      const dom2 = editor.dom;
      const show = (before2, element) => {
        let rng;
        hide2();
        if (isTableCell$1(element)) {
          return null;
        }
        if (isBlock2(element)) {
          const caretContainer = insertBlock(caretBlock, element, before2);
          const clientRect = getAbsoluteClientRect(root2, element, before2);
          dom2.setStyle(caretContainer, "top", clientRect.top);
          caretContainerNode = caretContainer;
          const caret = dom2.create("div", {
            "class": "mce-visual-caret",
            "data-mce-bogus": "all"
          });
          dom2.setStyles(caret, { ...clientRect });
          dom2.add(root2, caret);
          lastVisualCaret.set({
            caret,
            element,
            before: before2
          });
          if (before2) {
            dom2.addClass(caret, "mce-visual-caret-before");
          }
          startBlink();
          rng = element.ownerDocument.createRange();
          rng.setStart(caretContainer, 0);
          rng.setEnd(caretContainer, 0);
        } else {
          caretContainerNode = insertInline$1(element, before2);
          rng = element.ownerDocument.createRange();
          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {
            rng.setStart(caretContainerNode, 0);
            rng.setEnd(caretContainerNode, 0);
          } else {
            rng.setStart(caretContainerNode, 1);
            rng.setEnd(caretContainerNode, 1);
          }
          return rng;
        }
        return rng;
      };
      const hide2 = () => {
        trimInlineCaretContainers(root2);
        if (caretContainerNode) {
          remove$4(caretContainerNode);
          caretContainerNode = null;
        }
        lastVisualCaret.on((caretState) => {
          dom2.remove(caretState.caret);
          lastVisualCaret.clear();
        });
        if (cursorInterval) {
          clearInterval(cursorInterval);
          cursorInterval = void 0;
        }
      };
      const startBlink = () => {
        cursorInterval = setInterval(() => {
          lastVisualCaret.on((caretState) => {
            if (hasFocus2()) {
              dom2.toggleClass(caretState.caret, "mce-visual-caret-hidden");
            } else {
              dom2.addClass(caretState.caret, "mce-visual-caret-hidden");
            }
          });
        }, 500);
      };
      const reposition2 = () => {
        lastVisualCaret.on((caretState) => {
          const clientRect = getAbsoluteClientRect(root2, caretState.element, caretState.before);
          dom2.setStyles(caretState.caret, { ...clientRect });
        });
      };
      const destroy3 = () => clearInterval(cursorInterval);
      const getCss = () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
      return {
        show,
        hide: hide2,
        getCss,
        reposition: reposition2,
        destroy: destroy3
      };
    };
    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();
    const isInlineFakeCaretTarget = (node) => isContentEditableFalse$8(node) || isMedia$1(node);
    const isFakeCaretTarget = (node) => {
      const isTarget2 = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();
      return isTarget2 && parentElement(SugarElement.fromDom(node)).exists(isEditable$3);
    };
    const isContentEditableTrue$1 = isContentEditableTrue$3;
    const isContentEditableFalse$7 = isContentEditableFalse$b;
    const isMedia = isMedia$2;
    const isBlockLike = matchStyleValues("display", "block table table-cell table-caption list-item");
    const isCaretContainer = isCaretContainer$2;
    const isCaretContainerBlock = isCaretContainerBlock$1;
    const isElement$2 = isElement$6;
    const isText$4 = isText$a;
    const isCaretCandidate$1 = isCaretCandidate$3;
    const isForwards = (direction) => direction > 0;
    const isBackwards = (direction) => direction < 0;
    const skipCaretContainers = (walk2, shallow2) => {
      let node;
      while (node = walk2(shallow2)) {
        if (!isCaretContainerBlock(node)) {
          return node;
        }
      }
      return null;
    };
    const findNode = (node, direction, predicateFn, rootNode, shallow2) => {
      const walker = new DomTreeWalker(node, rootNode);
      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);
      let tempNode;
      if (isBackwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.prev.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow2)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      if (isForwards(direction)) {
        if (isCefOrCaretContainer) {
          tempNode = skipCaretContainers(walker.next.bind(walker), true);
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow2)) {
          if (predicateFn(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const getEditingHost = (node, rootNode) => {
      const isCETrue = (node2) => isContentEditableTrue$1(node2.dom);
      const isRoot2 = (node2) => node2.dom === rootNode;
      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot2).map((elm) => elm.dom).getOr(rootNode);
    };
    const getParentBlock$3 = (node, rootNode) => {
      while (node && node !== rootNode) {
        if (isBlockLike(node)) {
          return node;
        }
        node = node.parentNode;
      }
      return null;
    };
    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);
    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {
      if (!caretPosition) {
        return Optional.none();
      }
      const container = caretPosition.container();
      const offset2 = caretPosition.offset();
      if (!isElement$2(container)) {
        return Optional.none();
      }
      return Optional.from(container.childNodes[offset2 + relativeOffset]);
    };
    const beforeAfter = (before2, node) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const range2 = doc.createRange();
      if (before2) {
        range2.setStartBefore(node);
        range2.setEndBefore(node);
      } else {
        range2.setStartAfter(node);
        range2.setEndAfter(node);
      }
      return range2;
    };
    const isNodesInSameBlock = (root2, node1, node2) => getParentBlock$3(node1, root2) === getParentBlock$3(node2, root2);
    const lean = (left2, root2, node) => {
      const siblingName = left2 ? "previousSibling" : "nextSibling";
      let tempNode = node;
      while (tempNode && tempNode !== root2) {
        let sibling2 = tempNode[siblingName];
        if (sibling2 && isCaretContainer(sibling2)) {
          sibling2 = sibling2[siblingName];
        }
        if (isContentEditableFalse$7(sibling2) || isMedia(sibling2)) {
          if (isNodesInSameBlock(root2, sibling2, tempNode)) {
            return sibling2;
          }
          break;
        }
        if (isCaretCandidate$1(sibling2)) {
          break;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };
    const before$2 = curry(beforeAfter, true);
    const after$2 = curry(beforeAfter, false);
    const normalizeRange = (direction, root2, range2) => {
      let node;
      const leanLeft = curry(lean, true, root2);
      const leanRight2 = curry(lean, false, root2);
      const container = range2.startContainer;
      const offset2 = range2.startOffset;
      if (isCaretContainerBlock$1(container)) {
        const block = isText$4(container) ? container.parentNode : container;
        const location2 = block.getAttribute("data-mce-caret");
        if (location2 === "before") {
          node = block.nextSibling;
          if (isFakeCaretTarget(node)) {
            return before$2(node);
          }
        }
        if (location2 === "after") {
          node = block.previousSibling;
          if (isFakeCaretTarget(node)) {
            return after$2(node);
          }
        }
      }
      if (!range2.collapsed) {
        return range2;
      }
      if (isText$a(container)) {
        if (isCaretContainer(container)) {
          if (direction === 1) {
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
          }
          return range2;
        }
        if (endsWithCaretContainer$1(container) && offset2 >= container.data.length - 1) {
          if (direction === 1) {
            node = leanRight2(container);
            if (node) {
              return before$2(node);
            }
          }
          return range2;
        }
        if (startsWithCaretContainer$1(container) && offset2 <= 1) {
          if (direction === -1) {
            node = leanLeft(container);
            if (node) {
              return after$2(node);
            }
          }
          return range2;
        }
        if (offset2 === container.data.length) {
          node = leanRight2(container);
          if (node) {
            return before$2(node);
          }
          return range2;
        }
        if (offset2 === 0) {
          node = leanLeft(container);
          if (node) {
            return after$2(node);
          }
          return range2;
        }
      }
      return range2;
    };
    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);
    const getNormalizedRangeEndPoint = (direction, root2, range2) => {
      const normalizedRange = normalizeRange(direction, root2, range2);
      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);
    };
    const getElementFromPosition = (pos) => Optional.from(pos.getNode()).map(SugarElement.fromDom);
    const getElementFromPrevPosition = (pos) => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);
    const getVisualCaretPosition = (walkFn, caretPosition) => {
      let pos = caretPosition;
      while (pos = walkFn(pos)) {
        if (pos.isVisible()) {
          return pos;
        }
      }
      return pos;
    };
    const isMoveInsideSameBlock = (from2, to2) => {
      const inSameBlock = isInSameBlock(from2, to2);
      if (!inSameBlock && isBr$6(from2.getNode())) {
        return true;
      }
      return inSameBlock;
    };
    var HDirection;
    (function(HDirection2) {
      HDirection2[HDirection2["Backwards"] = -1] = "Backwards";
      HDirection2[HDirection2["Forwards"] = 1] = "Forwards";
    })(HDirection || (HDirection = {}));
    const isContentEditableFalse$6 = isContentEditableFalse$b;
    const isText$3 = isText$a;
    const isElement$12 = isElement$6;
    const isBr$2 = isBr$6;
    const isCaretCandidate = isCaretCandidate$3;
    const isAtomic = isAtomic$1;
    const isEditableCaretCandidate = isEditableCaretCandidate$1;
    const getParents$3 = (node, root2) => {
      const parents2 = [];
      let tempNode = node;
      while (tempNode && tempNode !== root2) {
        parents2.push(tempNode);
        tempNode = tempNode.parentNode;
      }
      return parents2;
    };
    const nodeAtIndex = (container, offset2) => {
      if (container.hasChildNodes() && offset2 < container.childNodes.length) {
        return container.childNodes[offset2];
      }
      return null;
    };
    const getCaretCandidatePosition = (direction, node) => {
      if (isForwards(direction)) {
        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {
          return CaretPosition.before(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, 0);
        }
      }
      if (isBackwards(direction)) {
        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {
          return CaretPosition.after(node);
        }
        if (isText$3(node)) {
          return CaretPosition(node, node.data.length);
        }
      }
      if (isBackwards(direction)) {
        if (isBr$2(node)) {
          return CaretPosition.before(node);
        }
        return CaretPosition.after(node);
      }
      return CaretPosition.before(node);
    };
    const moveForwardFromBr = (root2, nextNode) => {
      const nextSibling2 = nextNode.nextSibling;
      if (nextSibling2 && isCaretCandidate(nextSibling2)) {
        if (isText$3(nextSibling2)) {
          return CaretPosition(nextSibling2, 0);
        } else {
          return CaretPosition.before(nextSibling2);
        }
      } else {
        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root2);
      }
    };
    const findCaretPosition$1 = (direction, startPos, root2) => {
      let node;
      let nextNode;
      let innerNode;
      let caretPosition;
      if (!isElement$12(root2) || !startPos) {
        return null;
      }
      if (startPos.isEqual(CaretPosition.after(root2)) && root2.lastChild) {
        caretPosition = CaretPosition.after(root2.lastChild);
        if (isBackwards(direction) && isCaretCandidate(root2.lastChild) && isElement$12(root2.lastChild)) {
          return isBr$2(root2.lastChild) ? CaretPosition.before(root2.lastChild) : caretPosition;
        }
      } else {
        caretPosition = startPos;
      }
      const container = caretPosition.container();
      let offset2 = caretPosition.offset();
      if (isText$3(container)) {
        if (isBackwards(direction) && offset2 > 0) {
          return CaretPosition(container, --offset2);
        }
        if (isForwards(direction) && offset2 < container.length) {
          return CaretPosition(container, ++offset2);
        }
        node = container;
      } else {
        if (isBackwards(direction) && offset2 > 0) {
          nextNode = nodeAtIndex(container, offset2 - 1);
          if (isCaretCandidate(nextNode)) {
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, innerNode.data.length);
                }
                return CaretPosition.after(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, nextNode.data.length);
            }
            return CaretPosition.before(nextNode);
          }
        }
        if (isForwards(direction) && offset2 < container.childNodes.length) {
          nextNode = nodeAtIndex(container, offset2);
          if (isCaretCandidate(nextNode)) {
            if (isBr$2(nextNode)) {
              return moveForwardFromBr(root2, nextNode);
            }
            if (!isAtomic(nextNode)) {
              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);
              if (innerNode) {
                if (isText$3(innerNode)) {
                  return CaretPosition(innerNode, 0);
                }
                return CaretPosition.before(innerNode);
              }
            }
            if (isText$3(nextNode)) {
              return CaretPosition(nextNode, 0);
            }
            return CaretPosition.after(nextNode);
          }
        }
        node = nextNode ? nextNode : caretPosition.getNode();
      }
      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {
        node = findNode(node, direction, always, root2, true);
        if (isEditableCaretCandidate(node, root2)) {
          return getCaretCandidatePosition(direction, node);
        }
      }
      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root2) : node;
      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root2), isContentEditableFalse$6));
      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {
        if (isForwards(direction)) {
          caretPosition = CaretPosition.after(rootContentEditableFalseElm);
        } else {
          caretPosition = CaretPosition.before(rootContentEditableFalseElm);
        }
        return caretPosition;
      }
      if (nextNode) {
        return getCaretCandidatePosition(direction, nextNode);
      }
      return null;
    };
    const CaretWalker = (root2) => ({
      next: (caretPosition) => {
        return findCaretPosition$1(HDirection.Forwards, caretPosition, root2);
      },
      prev: (caretPosition) => {
        return findCaretPosition$1(HDirection.Backwards, caretPosition, root2);
      }
    });
    const walkToPositionIn = (forward, root2, start3) => {
      const position = forward ? CaretPosition.before(start3) : CaretPosition.after(start3);
      return fromPosition(forward, root2, position);
    };
    const afterElement = (node) => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);
    const isBeforeOrStart = (position) => {
      if (CaretPosition.isTextPosition(position)) {
        return position.offset() === 0;
      } else {
        return isCaretCandidate$3(position.getNode());
      }
    };
    const isAfterOrEnd = (position) => {
      if (CaretPosition.isTextPosition(position)) {
        const container = position.container();
        return position.offset() === container.data.length;
      } else {
        return isCaretCandidate$3(position.getNode(true));
      }
    };
    const isBeforeAfterSameElement = (from2, to2) => !CaretPosition.isTextPosition(from2) && !CaretPosition.isTextPosition(to2) && from2.getNode() === to2.getNode(true);
    const isAtBr = (position) => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());
    const shouldSkipPosition = (forward, from2, to2) => {
      if (forward) {
        return !isBeforeAfterSameElement(from2, to2) && !isAtBr(from2) && isAfterOrEnd(from2) && isBeforeOrStart(to2);
      } else {
        return !isBeforeAfterSameElement(to2, from2) && isBeforeOrStart(from2) && isAfterOrEnd(to2);
      }
    };
    const fromPosition = (forward, root2, pos) => {
      const walker = CaretWalker(root2);
      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));
    };
    const navigate = (forward, root2, from2) => fromPosition(forward, root2, from2).bind((to2) => {
      if (isInSameBlock(from2, to2, root2) && shouldSkipPosition(forward, from2, to2)) {
        return fromPosition(forward, root2, to2);
      } else {
        return Optional.some(to2);
      }
    });
    const navigateIgnore = (forward, root2, from2, ignoreFilter) => navigate(forward, root2, from2).bind((pos) => ignoreFilter(pos) ? navigateIgnore(forward, root2, pos, ignoreFilter) : Optional.some(pos));
    const positionIn = (forward, element) => {
      const startNode = forward ? element.firstChild : element.lastChild;
      if (isText$a(startNode)) {
        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));
      } else if (startNode) {
        if (isCaretCandidate$3(startNode)) {
          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));
        } else {
          return walkToPositionIn(forward, element, startNode);
        }
      } else {
        return Optional.none();
      }
    };
    const nextPosition = curry(fromPosition, true);
    const prevPosition = curry(fromPosition, false);
    const firstPositionIn = curry(positionIn, true);
    const lastPositionIn = curry(positionIn, false);
    const CARET_ID = "_mce_caret";
    const isCaretNode = (node) => isElement$6(node) && node.id === CARET_ID;
    const getParentCaretContainer = (body, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== body) {
        if (isCaretNode(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    const isStringPathBookmark = (bookmark) => isString2(bookmark.start);
    const isRangeBookmark = (bookmark) => has$2(bookmark, "rng");
    const isIdBookmark = (bookmark) => has$2(bookmark, "id");
    const isIndexBookmark = (bookmark) => has$2(bookmark, "name");
    const isPathBookmark = (bookmark) => Tools.isArray(bookmark.start);
    const isForwardBookmark = (bookmark) => !isIndexBookmark(bookmark) && isBoolean2(bookmark.forward) ? bookmark.forward : true;
    const addBogus = (dom2, node) => {
      if (isElement$6(node) && dom2.isBlock(node) && !node.innerHTML) {
        node.innerHTML = '<br data-mce-bogus="1" />';
      }
      return node;
    };
    const resolveCaretPositionBookmark = (dom2, bookmark) => {
      const startPos = Optional.from(resolve$1(dom2.getRoot(), bookmark.start));
      const endPos = Optional.from(resolve$1(dom2.getRoot(), bookmark.end));
      return lift2(startPos, endPos, (start3, end3) => {
        const range2 = dom2.createRng();
        range2.setStart(start3.container(), start3.offset());
        range2.setEnd(end3.container(), end3.offset());
        return {
          range: range2,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const insertZwsp = (node, rng) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      const textNode = doc.createTextNode(ZWSP$1);
      node.appendChild(textNode);
      rng.setStart(textNode, 0);
      rng.setEnd(textNode, 0);
    };
    const isEmpty$1 = (node) => !node.hasChildNodes();
    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, (pos) => {
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      return true;
    });
    const padEmptyCaretContainer = (root2, node, rng) => {
      if (isEmpty$1(node) && getParentCaretContainer(root2, node)) {
        insertZwsp(node, rng);
        return true;
      } else {
        return false;
      }
    };
    const setEndPoint = (dom2, start3, bookmark, rng) => {
      const point2 = bookmark[start3 ? "start" : "end"];
      const root2 = dom2.getRoot();
      if (point2) {
        let node = root2;
        let offset2 = point2[0];
        for (let i = point2.length - 1; node && i >= 1; i--) {
          const children2 = node.childNodes;
          if (padEmptyCaretContainer(root2, node, rng)) {
            return true;
          }
          if (point2[i] > children2.length - 1) {
            if (padEmptyCaretContainer(root2, node, rng)) {
              return true;
            }
            return tryFindRangePosition(node, rng);
          }
          node = children2[point2[i]];
        }
        if (isText$a(node)) {
          offset2 = Math.min(point2[0], node.data.length);
        }
        if (isElement$6(node)) {
          offset2 = Math.min(point2[0], node.childNodes.length);
        }
        if (start3) {
          rng.setStart(node, offset2);
        } else {
          rng.setEnd(node, offset2);
        }
      }
      return true;
    };
    const isValidTextNode = (node) => isText$a(node) && node.data.length > 0;
    const restoreEndPoint = (dom2, suffix, bookmark) => {
      const marker = dom2.get(bookmark.id + "_" + suffix);
      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;
      const keep = bookmark.keep;
      if (marker && markerParent) {
        let container;
        let offset2;
        if (suffix === "start") {
          if (!keep) {
            container = markerParent;
            offset2 = dom2.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset2 = 1;
            } else if (isValidTextNode(marker.nextSibling)) {
              container = marker.nextSibling;
              offset2 = 0;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset2 = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset2 = dom2.nodeIndex(marker) + 1;
            }
          }
        } else {
          if (!keep) {
            container = markerParent;
            offset2 = dom2.nodeIndex(marker);
          } else {
            if (marker.hasChildNodes()) {
              container = marker.firstChild;
              offset2 = 1;
            } else if (isValidTextNode(marker.previousSibling)) {
              container = marker.previousSibling;
              offset2 = marker.previousSibling.data.length;
            } else {
              container = markerParent;
              offset2 = dom2.nodeIndex(marker);
            }
          }
        }
        if (!keep) {
          const prev2 = marker.previousSibling;
          const next2 = marker.nextSibling;
          Tools.each(Tools.grep(marker.childNodes), (node) => {
            if (isText$a(node)) {
              node.data = node.data.replace(/\uFEFF/g, "");
            }
          });
          let otherMarker;
          while (otherMarker = dom2.get(bookmark.id + "_" + suffix)) {
            dom2.remove(otherMarker, true);
          }
          if (isText$a(next2) && isText$a(prev2) && !Env.browser.isOpera()) {
            const idx = prev2.data.length;
            prev2.appendData(next2.data);
            dom2.remove(next2);
            container = prev2;
            offset2 = idx;
          }
        }
        return Optional.some(CaretPosition(container, offset2));
      } else {
        return Optional.none();
      }
    };
    const resolvePaths = (dom2, bookmark) => {
      const range2 = dom2.createRng();
      if (setEndPoint(dom2, true, bookmark, range2) && setEndPoint(dom2, false, bookmark, range2)) {
        return Optional.some({
          range: range2,
          forward: isForwardBookmark(bookmark)
        });
      } else {
        return Optional.none();
      }
    };
    const resolveId = (dom2, bookmark) => {
      const startPos = restoreEndPoint(dom2, "start", bookmark);
      const endPos = restoreEndPoint(dom2, "end", bookmark);
      return lift2(startPos, endPos.or(startPos), (spos, epos) => {
        const range2 = dom2.createRng();
        range2.setStart(addBogus(dom2, spos.container()), spos.offset());
        range2.setEnd(addBogus(dom2, epos.container()), epos.offset());
        return {
          range: range2,
          forward: isForwardBookmark(bookmark)
        };
      });
    };
    const resolveIndex = (dom2, bookmark) => Optional.from(dom2.select(bookmark.name)[bookmark.index]).map((elm) => {
      const range2 = dom2.createRng();
      range2.selectNode(elm);
      return {
        range: range2,
        forward: true
      };
    });
    const resolve = (selection, bookmark) => {
      const dom2 = selection.dom;
      if (bookmark) {
        if (isPathBookmark(bookmark)) {
          return resolvePaths(dom2, bookmark);
        } else if (isStringPathBookmark(bookmark)) {
          return resolveCaretPositionBookmark(dom2, bookmark);
        } else if (isIdBookmark(bookmark)) {
          return resolveId(dom2, bookmark);
        } else if (isIndexBookmark(bookmark)) {
          return resolveIndex(dom2, bookmark);
        } else if (isRangeBookmark(bookmark)) {
          return Optional.some({
            range: bookmark.rng,
            forward: isForwardBookmark(bookmark)
          });
        }
      }
      return Optional.none();
    };
    const getBookmark$1 = (selection, type2, normalized) => {
      return getBookmark$2(selection, type2, normalized);
    };
    const moveToBookmark = (selection, bookmark) => {
      resolve(selection, bookmark).each(({ range: range2, forward }) => {
        selection.setRng(range2, forward);
      });
    };
    const isBookmarkNode$1 = (node) => {
      return isElement$6(node) && node.tagName === "SPAN" && node.getAttribute("data-mce-type") === "bookmark";
    };
    const is = (expected) => (actual) => expected === actual;
    const isNbsp = is(nbsp);
    const isWhiteSpace = (chr) => chr !== "" && " \f\n\r	\v".indexOf(chr) !== -1;
    const isContent = (chr) => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$1(chr);
    const hexColour = (value2) => ({ value: normalizeHex(value2) });
    const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
    const toHex = (component) => {
      const hex = component.toString(16);
      return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
    };
    const fromRgba = (rgbaColour2) => {
      const value2 = toHex(rgbaColour2.red) + toHex(rgbaColour2.green) + toHex(rgbaColour2.blue);
      return hexColour(value2);
    };
    const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
    const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
    const rgbaColour = (red, green, blue, alpha) => ({
      red,
      green,
      blue,
      alpha
    });
    const fromStringValues = (red, green, blue, alpha) => {
      const r2 = parseInt(red, 10);
      const g = parseInt(green, 10);
      const b = parseInt(blue, 10);
      const a = parseFloat(alpha);
      return rgbaColour(r2, g, b, a);
    };
    const fromString = (rgbaString) => {
      if (rgbaString === "transparent") {
        return Optional.some(rgbaColour(0, 0, 0, 0));
      }
      const rgbMatch = rgbRegex.exec(rgbaString);
      if (rgbMatch !== null) {
        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
      }
      const rgbaMatch = rgbaRegex.exec(rgbaString);
      if (rgbaMatch !== null) {
        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
      }
      return Optional.none();
    };
    const rgbaToHexString = (color) => fromString(color).map(fromRgba).map((h) => "#" + h.value).getOr(color);
    const getRanges$1 = (selection) => {
      const ranges = [];
      if (selection) {
        for (let i = 0; i < selection.rangeCount; i++) {
          ranges.push(selection.getRangeAt(i));
        }
      }
      return ranges;
    };
    const getSelectedNodes = (ranges) => {
      return bind$3(ranges, (range2) => {
        const node = getSelectedNode(range2);
        return node ? [SugarElement.fromDom(node)] : [];
      });
    };
    const hasMultipleRanges = (selection) => {
      return getRanges$1(selection).length > 1;
    };
    const getCellsFromRanges = (ranges) => filter$5(getSelectedNodes(ranges), isTableCell$2);
    const getCellsFromElement = (elm) => descendants(elm, "td[data-mce-selected],th[data-mce-selected]");
    const getCellsFromElementOrRanges = (ranges, element) => {
      const selectedCells = getCellsFromElement(element);
      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);
    };
    const getCellsFromEditor = (editor) => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));
    const getClosestTable = (cell2, isRoot2) => ancestor$3(cell2, "table", isRoot2);
    const getStartNode = (rng) => {
      const sc = rng.startContainer, so = rng.startOffset;
      if (isText$a(sc)) {
        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();
      } else {
        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);
      }
    };
    const getEndNode = (rng) => {
      const ec = rng.endContainer, eo = rng.endOffset;
      if (isText$a(ec)) {
        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();
      } else {
        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);
      }
    };
    const getFirstChildren = (node) => {
      return firstChild(node).fold(constant([node]), (child2) => {
        return [node].concat(getFirstChildren(child2));
      });
    };
    const getLastChildren = (node) => {
      return lastChild(node).fold(constant([node]), (child2) => {
        if (name2(child2) === "br") {
          return prevSibling(child2).map((sibling2) => {
            return [node].concat(getLastChildren(sibling2));
          }).getOr([]);
        } else {
          return [node].concat(getLastChildren(child2));
        }
      });
    };
    const hasAllContentsSelected = (elm, rng) => {
      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {
        const start3 = find$2(getFirstChildren(elm), curry(eq, startNode));
        const end3 = find$2(getLastChildren(elm), curry(eq, endNode));
        return start3.isSome() && end3.isSome();
      }).getOr(false);
    };
    const moveEndPoint = (dom2, rng, node, start3) => {
      const root2 = node;
      const walker = new DomTreeWalker(node, root2);
      const moveCaretBeforeOnEnterElementsMap = filter$4(dom2.schema.getMoveCaretBeforeOnEnterElements(), (_2, name3) => !contains$2([
        "td",
        "th",
        "table"
      ], name3.toLowerCase()));
      let currentNode = node;
      do {
        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {
          if (start3) {
            rng.setStart(currentNode, 0);
          } else {
            rng.setEnd(currentNode, currentNode.data.length);
          }
          return;
        }
        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {
          if (start3) {
            rng.setStartBefore(currentNode);
          } else {
            if (currentNode.nodeName === "BR") {
              rng.setEndBefore(currentNode);
            } else {
              rng.setEndAfter(currentNode);
            }
          }
          return;
        }
      } while (currentNode = start3 ? walker.next() : walker.prev());
      if (root2.nodeName === "BODY") {
        if (start3) {
          rng.setStart(root2, 0);
        } else {
          rng.setEnd(root2, root2.childNodes.length);
        }
      }
    };
    const hasAnyRanges = (editor) => {
      const sel = editor.selection.getSel();
      return isNonNullable(sel) && sel.rangeCount > 0;
    };
    const runOnRanges = (editor, executor) => {
      const fakeSelectionNodes = getCellsFromEditor(editor);
      if (fakeSelectionNodes.length > 0) {
        each$e(fakeSelectionNodes, (elem) => {
          const node = elem.dom;
          const fakeNodeRng = editor.dom.createRng();
          fakeNodeRng.setStartBefore(node);
          fakeNodeRng.setEndAfter(node);
          executor(fakeNodeRng, true);
        });
      } else {
        executor(editor.selection.getRng(), false);
      }
    };
    const preserve = (selection, fillBookmark, executor) => {
      const bookmark = getPersistentBookmark(selection, fillBookmark);
      executor(bookmark);
      selection.moveToBookmark(bookmark);
    };
    const isNode2 = (node) => isNumber2(node === null || node === void 0 ? void 0 : node.nodeType);
    const isElementNode$1 = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const isElementDirectlySelected = (dom2, node) => {
      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {
        const selectedAttr = dom2.getAttrib(node, "data-mce-selected");
        const value2 = parseInt(selectedAttr, 10);
        return !isNaN(value2) && value2 > 0;
      } else {
        return false;
      }
    };
    const isEditable$2 = (elm) => elm.isContentEditable === true;
    const preserveSelection = (editor, action2, shouldMoveStart) => {
      const { selection, dom: dom2 } = editor;
      const selectedNodeBeforeAction = selection.getNode();
      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);
      preserve(selection, true, () => {
        action2();
      });
      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);
      if (isBeforeNodeStillNoneditable && dom2.isChildOf(selectedNodeBeforeAction, editor.getBody())) {
        editor.selection.select(selectedNodeBeforeAction);
      } else if (shouldMoveStart(selection.getStart())) {
        moveStartToNearestText(dom2, selection);
      }
    };
    const moveStartToNearestText = (dom2, selection) => {
      var _a, _b;
      const rng = selection.getRng();
      const { startContainer, startOffset } = rng;
      const selectedNode = selection.getNode();
      if (isElementDirectlySelected(dom2, selectedNode)) {
        return;
      }
      if (isElement$6(startContainer)) {
        const nodes = startContainer.childNodes;
        const root2 = dom2.getRoot();
        let walker;
        if (startOffset < nodes.length) {
          const startNode = nodes[startOffset];
          walker = new DomTreeWalker(startNode, (_a = dom2.getParent(startNode, dom2.isBlock)) !== null && _a !== void 0 ? _a : root2);
        } else {
          const startNode = nodes[nodes.length - 1];
          walker = new DomTreeWalker(startNode, (_b = dom2.getParent(startNode, dom2.isBlock)) !== null && _b !== void 0 ? _b : root2);
          walker.next(true);
        }
        for (let node = walker.current(); node; node = walker.next()) {
          if (dom2.getContentEditable(node) === "false") {
            return;
          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {
            rng.setStart(node, 0);
            selection.setRng(rng);
            return;
          }
        }
      }
    };
    const getNonWhiteSpaceSibling = (node, next2, inc) => {
      if (node) {
        const nextName = next2 ? "nextSibling" : "previousSibling";
        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {
          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {
            return node;
          }
        }
      }
      return void 0;
    };
    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);
    const isValid = (ed, parent2, child2) => {
      return ed.schema.isValidChild(parent2, child2);
    };
    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {
      if (isNonNullable(node) && isText$a(node)) {
        const data3 = allowSpaces ? node.data.replace(/ /g, " ") : node.data;
        return isWhitespaceText(data3);
      } else {
        return false;
      }
    };
    const isEmptyTextNode$1 = (node) => {
      return isNonNullable(node) && isText$a(node) && node.length === 0;
    };
    const isWrapNoneditableTarget = (editor, node) => {
      const baseDataSelector = "[data-mce-cef-wrappable]";
      const formatNoneditableSelector = getFormatNoneditableSelector(editor);
      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;
      return is$1(SugarElement.fromDom(node), selector);
    };
    const isWrappableNoneditable = (editor, node) => {
      const dom2 = editor.dom;
      return isElementNode$1(node) && dom2.getContentEditable(node) === "false" && isWrapNoneditableTarget(editor, node) && dom2.select('[contenteditable="true"]', node).length === 0;
    };
    const replaceVars = (value2, vars) => {
      if (isFunction2(value2)) {
        return value2(vars);
      } else if (isNonNullable(vars)) {
        value2 = value2.replace(/%(\w+)/g, (str, name3) => {
          return vars[name3] || str;
        });
      }
      return value2;
    };
    const isEq$5 = (str1, str2) => {
      str1 = str1 || "";
      str2 = str2 || "";
      str1 = "" + (str1.nodeName || str1);
      str2 = "" + (str2.nodeName || str2);
      return str1.toLowerCase() === str2.toLowerCase();
    };
    const normalizeStyleValue = (value2, name3) => {
      if (isNullable(value2)) {
        return null;
      } else {
        let strValue = String(value2);
        if (name3 === "color" || name3 === "backgroundColor") {
          strValue = rgbaToHexString(strValue);
        }
        if (name3 === "fontWeight" && value2 === 700) {
          strValue = "bold";
        }
        if (name3 === "fontFamily") {
          strValue = strValue.replace(/[\'\"]/g, "").replace(/,\s+/g, ",");
        }
        return strValue;
      }
    };
    const getStyle = (dom2, node, name3) => {
      const style = dom2.getStyle(node, name3);
      return normalizeStyleValue(style, name3);
    };
    const getTextDecoration = (dom2, node) => {
      let decoration;
      dom2.getParent(node, (n) => {
        if (isElement$6(n)) {
          decoration = dom2.getStyle(n, "text-decoration");
          return !!decoration && decoration !== "none";
        } else {
          return false;
        }
      });
      return decoration;
    };
    const getParents$2 = (dom2, node, selector) => {
      return dom2.getParents(node, selector, dom2.getRoot());
    };
    const isFormatPredicate = (editor, formatName, predicate) => {
      const formats = editor.formatter.get(formatName);
      return isNonNullable(formats) && exists(formats, predicate);
    };
    const isVariableFormatName = (editor, formatName) => {
      const hasVariableValues = (format) => {
        const isVariableValue = (val) => isFunction2(val) || val.length > 1 && val.charAt(0) === "%";
        return exists([
          "styles",
          "attributes"
        ], (key) => get$a(format, key).exists((field2) => {
          const fieldValues = isArray$12(field2) ? field2 : values(field2);
          return exists(fieldValues, isVariableValue);
        }));
      };
      return isFormatPredicate(editor, formatName, hasVariableValues);
    };
    const areSimilarFormats = (editor, formatName, otherFormatName) => {
      const validKeys = [
        "inline",
        "block",
        "selector",
        "attributes",
        "styles",
        "classes"
      ];
      const filterObj = (format) => filter$4(format, (_2, key) => exists(validKeys, (validKey) => validKey === key));
      return isFormatPredicate(editor, formatName, (fmt1) => {
        const filteredFmt1 = filterObj(fmt1);
        return isFormatPredicate(editor, otherFormatName, (fmt2) => {
          const filteredFmt2 = filterObj(fmt2);
          return equal$1(filteredFmt1, filteredFmt2);
        });
      });
    };
    const isBlockFormat = (format) => hasNonNullableKey(format, "block");
    const isWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper === true;
    const isNonWrappingBlockFormat = (format) => isBlockFormat(format) && format.wrapper !== true;
    const isSelectorFormat = (format) => hasNonNullableKey(format, "selector");
    const isInlineFormat = (format) => hasNonNullableKey(format, "inline");
    const isMixedFormat = (format) => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, "mixed"), true);
    const shouldExpandToSelector = (format) => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);
    const isBookmarkNode = isBookmarkNode$1;
    const getParents$1 = getParents$2;
    const isWhiteSpaceNode = isWhiteSpaceNode$1;
    const isTextBlock = isTextBlock$1;
    const isBogusBr = (node) => {
      return isBr$6(node) && node.getAttribute("data-mce-bogus") && !node.nextSibling;
    };
    const findParentContentEditable = (dom2, node) => {
      let parent2 = node;
      while (parent2) {
        if (isElement$6(parent2) && dom2.getContentEditable(parent2)) {
          return dom2.getContentEditable(parent2) === "false" ? parent2 : node;
        }
        parent2 = parent2.parentNode;
      }
      return node;
    };
    const walkText = (start3, node, offset2, predicate) => {
      const str = node.data;
      if (start3) {
        for (let i = offset2; i > 0; i--) {
          if (predicate(str.charAt(i - 1))) {
            return i;
          }
        }
      } else {
        for (let i = offset2; i < str.length; i++) {
          if (predicate(str.charAt(i))) {
            return i;
          }
        }
      }
      return -1;
    };
    const findSpace = (start3, node, offset2) => walkText(start3, node, offset2, (c) => isNbsp(c) || isWhiteSpace(c));
    const findContent = (start3, node, offset2) => walkText(start3, node, offset2, isContent);
    const findWordEndPoint = (dom2, body, container, offset2, start3, includeTrailingSpaces) => {
      let lastTextNode;
      const rootNode = dom2.getParent(container, dom2.isBlock) || body;
      const walk2 = (container2, offset3, pred) => {
        const textSeeker = TextSeeker(dom2);
        const walker = start3 ? textSeeker.backwards : textSeeker.forwards;
        return Optional.from(walker(container2, offset3, (text3, textOffset) => {
          if (isBookmarkNode(text3.parentNode)) {
            return -1;
          } else {
            lastTextNode = text3;
            return pred(start3, text3, textOffset);
          }
        }, rootNode));
      };
      const spaceResult = walk2(container, offset2, findSpace);
      return spaceResult.bind((result) => includeTrailingSpaces ? walk2(result.container, result.offset + (start3 ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({
        container: lastTextNode,
        offset: start3 ? 0 : lastTextNode.length
      }) : Optional.none());
    };
    const findSelectorEndPoint = (dom2, formatList, rng, container, siblingName) => {
      const sibling2 = container[siblingName];
      if (isText$a(container) && isEmpty$3(container.data) && sibling2) {
        container = sibling2;
      }
      const parents2 = getParents$1(dom2, container);
      for (let i = 0; i < parents2.length; i++) {
        for (let y = 0; y < formatList.length; y++) {
          const curFormat = formatList[y];
          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {
            continue;
          }
          if (isSelectorFormat(curFormat) && dom2.is(parents2[i], curFormat.selector)) {
            return parents2[i];
          }
        }
      }
      return container;
    };
    const findBlockEndPoint = (dom2, formatList, container, siblingName) => {
      var _a;
      let node = container;
      const root2 = dom2.getRoot();
      const format = formatList[0];
      if (isBlockFormat(format)) {
        node = format.wrapper ? null : dom2.getParent(container, format.block, root2);
      }
      if (!node) {
        const scopeRoot = (_a = dom2.getParent(container, "LI,TD,TH")) !== null && _a !== void 0 ? _a : root2;
        node = dom2.getParent(isText$a(container) ? container.parentNode : container, (node2) => node2 !== root2 && isTextBlock(dom2.schema, node2), scopeRoot);
      }
      if (node && isBlockFormat(format) && format.wrapper) {
        node = getParents$1(dom2, node, "ul,ol").reverse()[0] || node;
      }
      if (!node) {
        node = container;
        while (node && node[siblingName] && !dom2.isBlock(node[siblingName])) {
          node = node[siblingName];
          if (isEq$5(node, "br")) {
            break;
          }
        }
      }
      return node || container;
    };
    const isAtBlockBoundary$1 = (dom2, root2, container, siblingName) => {
      const parent2 = container.parentNode;
      if (isNonNullable(container[siblingName])) {
        return false;
      } else if (parent2 === root2 || isNullable(parent2) || dom2.isBlock(parent2)) {
        return true;
      } else {
        return isAtBlockBoundary$1(dom2, root2, parent2, siblingName);
      }
    };
    const findParentContainer = (dom2, formatList, container, offset2, start3) => {
      let parent2 = container;
      const siblingName = start3 ? "previousSibling" : "nextSibling";
      const root2 = dom2.getRoot();
      if (isText$a(container) && !isWhiteSpaceNode(container)) {
        if (start3 ? offset2 > 0 : offset2 < container.data.length) {
          return container;
        }
      }
      while (parent2) {
        if (!formatList[0].block_expand && dom2.isBlock(parent2)) {
          return parent2;
        }
        for (let sibling2 = parent2[siblingName]; sibling2; sibling2 = sibling2[siblingName]) {
          const allowSpaces = isText$a(sibling2) && !isAtBlockBoundary$1(dom2, root2, sibling2, siblingName);
          if (!isBookmarkNode(sibling2) && !isBogusBr(sibling2) && !isWhiteSpaceNode(sibling2, allowSpaces)) {
            return parent2;
          }
        }
        if (parent2 === root2 || parent2.parentNode === root2) {
          container = parent2;
          break;
        }
        parent2 = parent2.parentNode;
      }
      return container;
    };
    const isSelfOrParentBookmark = (container) => isBookmarkNode(container.parentNode) || isBookmarkNode(container);
    const expandRng = (dom2, rng, formatList, includeTrailingSpace = false) => {
      let { startContainer, startOffset, endContainer, endOffset } = rng;
      const format = formatList[0];
      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {
        startContainer = getNode$1(startContainer, startOffset);
        if (isText$a(startContainer)) {
          startOffset = 0;
        }
      }
      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {
        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);
        if (isText$a(endContainer)) {
          endOffset = endContainer.data.length;
        }
      }
      startContainer = findParentContentEditable(dom2, startContainer);
      endContainer = findParentContentEditable(dom2, endContainer);
      if (isSelfOrParentBookmark(startContainer)) {
        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;
        if (rng.collapsed) {
          startContainer = startContainer.previousSibling || startContainer;
        } else {
          startContainer = startContainer.nextSibling || startContainer;
        }
        if (isText$a(startContainer)) {
          startOffset = rng.collapsed ? startContainer.length : 0;
        }
      }
      if (isSelfOrParentBookmark(endContainer)) {
        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;
        if (rng.collapsed) {
          endContainer = endContainer.nextSibling || endContainer;
        } else {
          endContainer = endContainer.previousSibling || endContainer;
        }
        if (isText$a(endContainer)) {
          endOffset = rng.collapsed ? 0 : endContainer.length;
        }
      }
      if (rng.collapsed) {
        const startPoint = findWordEndPoint(dom2, dom2.getRoot(), startContainer, startOffset, true, includeTrailingSpace);
        startPoint.each(({ container, offset: offset2 }) => {
          startContainer = container;
          startOffset = offset2;
        });
        const endPoint = findWordEndPoint(dom2, dom2.getRoot(), endContainer, endOffset, false, includeTrailingSpace);
        endPoint.each(({ container, offset: offset2 }) => {
          endContainer = container;
          endOffset = offset2;
        });
      }
      if (isInlineFormat(format) || format.block_expand) {
        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {
          startContainer = findParentContainer(dom2, formatList, startContainer, startOffset, true);
        }
        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {
          endContainer = findParentContainer(dom2, formatList, endContainer, endOffset, false);
        }
      }
      if (shouldExpandToSelector(format)) {
        startContainer = findSelectorEndPoint(dom2, formatList, rng, startContainer, "previousSibling");
        endContainer = findSelectorEndPoint(dom2, formatList, rng, endContainer, "nextSibling");
      }
      if (isBlockFormat(format) || isSelectorFormat(format)) {
        startContainer = findBlockEndPoint(dom2, formatList, startContainer, "previousSibling");
        endContainer = findBlockEndPoint(dom2, formatList, endContainer, "nextSibling");
        if (isBlockFormat(format)) {
          if (!dom2.isBlock(startContainer)) {
            startContainer = findParentContainer(dom2, formatList, startContainer, startOffset, true);
          }
          if (!dom2.isBlock(endContainer)) {
            endContainer = findParentContainer(dom2, formatList, endContainer, endOffset, false);
          }
        }
      }
      if (isElement$6(startContainer) && startContainer.parentNode) {
        startOffset = dom2.nodeIndex(startContainer);
        startContainer = startContainer.parentNode;
      }
      if (isElement$6(endContainer) && endContainer.parentNode) {
        endOffset = dom2.nodeIndex(endContainer) + 1;
        endContainer = endContainer.parentNode;
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };
    const walk$3 = (dom2, rng, callback) => {
      var _a;
      const startOffset = rng.startOffset;
      const startContainer = getNode$1(rng.startContainer, startOffset);
      const endOffset = rng.endOffset;
      const endContainer = getNode$1(rng.endContainer, endOffset - 1);
      const exclude = (nodes) => {
        const firstNode = nodes[0];
        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {
          nodes.splice(0, 1);
        }
        const lastNode = nodes[nodes.length - 1];
        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {
          nodes.splice(nodes.length - 1, 1);
        }
        return nodes;
      };
      const collectSiblings = (node, name3, endNode) => {
        const siblings3 = [];
        for (; node && node !== endNode; node = node[name3]) {
          siblings3.push(node);
        }
        return siblings3;
      };
      const findEndPoint = (node, root2) => dom2.getParent(node, (node2) => node2.parentNode === root2, root2);
      const walkBoundary = (startNode, endNode, next2) => {
        const siblingName = next2 ? "nextSibling" : "previousSibling";
        for (let node = startNode, parent2 = node.parentNode; node && node !== endNode; node = parent2) {
          parent2 = node.parentNode;
          const siblings3 = collectSiblings(node === startNode ? node : node[siblingName], siblingName);
          if (siblings3.length) {
            if (!next2) {
              siblings3.reverse();
            }
            callback(exclude(siblings3));
          }
        }
      };
      if (startContainer === endContainer) {
        return callback(exclude([startContainer]));
      }
      const ancestor2 = (_a = dom2.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom2.getRoot();
      if (dom2.isChildOf(startContainer, endContainer)) {
        return walkBoundary(startContainer, ancestor2, true);
      }
      if (dom2.isChildOf(endContainer, startContainer)) {
        return walkBoundary(endContainer, ancestor2);
      }
      const startPoint = findEndPoint(startContainer, ancestor2) || startContainer;
      const endPoint = findEndPoint(endContainer, ancestor2) || endContainer;
      walkBoundary(startContainer, startPoint, true);
      const siblings2 = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, "nextSibling", endPoint === endContainer ? endPoint.nextSibling : endPoint);
      if (siblings2.length) {
        callback(exclude(siblings2));
      }
      walkBoundary(endContainer, endPoint);
    };
    const validBlocks = [
      'pre[class*=language-][contenteditable="false"]',
      "figure.image",
      "div[data-ephox-embed-iri]",
      "div.tiny-pageembed",
      "div.mce-toc",
      "div[data-mce-toc]"
    ];
    const isZeroWidth = (elem) => isText$b(elem) && get$3(elem) === ZWSP$1;
    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => "skipping", (parent2) => {
      if (nodeName === "br" || isZeroWidth(elem)) {
        return "valid";
      } else if (isAnnotation(elem)) {
        return "existing";
      } else if (isCaretNode(elem.dom)) {
        return "caret";
      } else if (exists(validBlocks, (selector) => is$1(elem, selector))) {
        return "valid-block";
      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name2(parent2), wrapName)) {
        return "invalid-child";
      } else {
        return "valid";
      }
    });
    const applyWordGrab = (editor, rng) => {
      const r2 = expandRng(editor.dom, rng, [{ inline: "span" }]);
      rng.setStart(r2.startContainer, r2.startOffset);
      rng.setEnd(r2.endContainer, r2.endOffset);
      editor.selection.setRng(rng);
    };
    const applyAnnotation = (elem, masterUId, data3, annotationName, decorate, directAnnotation) => {
      const { uid: uid2 = masterUId, ...otherData } = data3;
      add$2(elem, annotation());
      set$3(elem, `${dataAnnotationId()}`, uid2);
      set$3(elem, `${dataAnnotation()}`, annotationName);
      const { attributes = {}, classes = [] } = decorate(uid2, otherData);
      setAll$1(elem, attributes);
      add(elem, classes);
      if (directAnnotation) {
        if (classes.length > 0) {
          set$3(elem, `${dataAnnotationClasses()}`, classes.join(","));
        }
        const attributeNames = keys(attributes);
        if (attributeNames.length > 0) {
          set$3(elem, `${dataAnnotationAttributes()}`, attributeNames.join(","));
        }
      }
    };
    const removeDirectAnnotation = (elem) => {
      remove$8(elem, annotation());
      remove$b(elem, `${dataAnnotationId()}`);
      remove$b(elem, `${dataAnnotation()}`);
      remove$b(elem, `${dataAnnotationActive()}`);
      const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map((names) => names.split(",")).getOr([]);
      const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map((names) => names.split(",")).getOr([]);
      each$e(customAttrNames, (name3) => remove$b(elem, name3));
      remove$5(elem, customClasses);
      remove$b(elem, `${dataAnnotationClasses()}`);
      remove$b(elem, `${dataAnnotationAttributes()}`);
    };
    const makeAnnotation = (eDoc, uid2, data3, annotationName, decorate) => {
      const master = SugarElement.fromTag("span", eDoc);
      applyAnnotation(master, uid2, data3, annotationName, decorate, false);
      return master;
    };
    const annotate = (editor, rng, uid2, annotationName, decorate, data3) => {
      const newWrappers = [];
      const master = makeAnnotation(editor.getDoc(), uid2, data3, annotationName, decorate);
      const wrapper = value$2();
      const finishWrapper = () => {
        wrapper.clear();
      };
      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {
        const nu2 = shallow$1(master);
        newWrappers.push(nu2);
        wrapper.set(nu2);
        return nu2;
      });
      const processElements = (elems) => {
        each$e(elems, processElement);
      };
      const processElement = (elem) => {
        const ctx = context(editor, elem, "span", name2(elem));
        switch (ctx) {
          case "invalid-child": {
            finishWrapper();
            const children2 = children$1(elem);
            processElements(children2);
            finishWrapper();
            break;
          }
          case "valid-block": {
            finishWrapper();
            applyAnnotation(elem, uid2, data3, annotationName, decorate, true);
            break;
          }
          case "valid": {
            const w = getOrOpenWrapper();
            wrap$2(elem, w);
            break;
          }
        }
      };
      const processNodes = (nodes) => {
        const elems = map$3(nodes, SugarElement.fromDom);
        processElements(elems);
      };
      walk$3(editor.dom, rng, (nodes) => {
        finishWrapper();
        processNodes(nodes);
      });
      return newWrappers;
    };
    const annotateWithBookmark = (editor, name3, settings, data3) => {
      editor.undoManager.transact(() => {
        const selection = editor.selection;
        const initialRng = selection.getRng();
        const hasFakeSelection = getCellsFromEditor(editor).length > 0;
        const masterUid = generate$1("mce-annotation");
        if (initialRng.collapsed && !hasFakeSelection) {
          applyWordGrab(editor, initialRng);
        }
        if (selection.getRng().collapsed && !hasFakeSelection) {
          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data3, name3, settings.decorate);
          set$1(wrapper, nbsp);
          selection.getRng().insertNode(wrapper.dom);
          selection.select(wrapper.dom);
        } else {
          preserve(selection, false, () => {
            runOnRanges(editor, (selectionRng) => {
              annotate(editor, selectionRng, masterUid, name3, settings.decorate, data3);
            });
          });
        }
      });
    };
    const Annotator = (editor) => {
      const registry2 = create$c2();
      setup$w(editor, registry2);
      const changes = setup$x(editor, registry2);
      const isSpan2 = isTag("span");
      const removeAnnotations = (elements) => {
        each$e(elements, (element) => {
          if (isSpan2(element)) {
            unwrap(element);
          } else {
            removeDirectAnnotation(element);
          }
        });
      };
      return {
        register: (name3, settings) => {
          registry2.register(name3, settings);
        },
        annotate: (name3, data3) => {
          registry2.lookup(name3).each((settings) => {
            annotateWithBookmark(editor, name3, settings, data3);
          });
        },
        annotationChanged: (name3, callback) => {
          changes.addListener(name3, callback);
        },
        remove: (name3) => {
          identify(editor, Optional.some(name3)).each(({ elements }) => {
            const bookmark = editor.selection.getBookmark();
            removeAnnotations(elements);
            editor.selection.moveToBookmark(bookmark);
          });
        },
        removeAll: (name3) => {
          const bookmark = editor.selection.getBookmark();
          each$d(findAll(editor, name3), (elements, _2) => {
            removeAnnotations(elements);
          });
          editor.selection.moveToBookmark(bookmark);
        },
        getAll: (name3) => {
          const directory = findAll(editor, name3);
          return map$2(directory, (elems) => map$3(elems, (elem) => elem.dom));
        }
      };
    };
    const BookmarkManager = (selection) => {
      return {
        getBookmark: curry(getBookmark$1, selection),
        moveToBookmark: curry(moveToBookmark, selection)
      };
    };
    BookmarkManager.isBookmarkNode = isBookmarkNode$1;
    const isXYWithinRange = (clientX, clientY, range2) => {
      if (range2.collapsed) {
        return false;
      } else {
        return exists(range2.getClientRects(), (rect) => containsXY(rect, clientX, clientY));
      }
    };
    const firePreProcess = (editor, args) => editor.dispatch("PreProcess", args);
    const firePostProcess = (editor, args) => editor.dispatch("PostProcess", args);
    const fireRemove = (editor) => {
      editor.dispatch("remove");
    };
    const fireDetach = (editor) => {
      editor.dispatch("detach");
    };
    const fireSwitchMode = (editor, mode) => {
      editor.dispatch("SwitchMode", { mode });
    };
    const fireObjectResizeStart = (editor, target, width2, height2, origin) => {
      editor.dispatch("ObjectResizeStart", {
        target,
        width: width2,
        height: height2,
        origin
      });
    };
    const fireObjectResized = (editor, target, width2, height2, origin) => {
      editor.dispatch("ObjectResized", {
        target,
        width: width2,
        height: height2,
        origin
      });
    };
    const firePreInit = (editor) => {
      editor.dispatch("PreInit");
    };
    const firePostRender = (editor) => {
      editor.dispatch("PostRender");
    };
    const fireInit = (editor) => {
      editor.dispatch("Init");
    };
    const firePlaceholderToggle = (editor, state2) => {
      editor.dispatch("PlaceholderToggle", { state: state2 });
    };
    const fireError = (editor, errorType, error3) => {
      editor.dispatch(errorType, error3);
    };
    const fireFormatApply = (editor, format, node, vars) => {
      editor.dispatch("FormatApply", {
        format,
        node,
        vars
      });
    };
    const fireFormatRemove = (editor, format, node, vars) => {
      editor.dispatch("FormatRemove", {
        format,
        node,
        vars
      });
    };
    const fireBeforeSetContent = (editor, args) => editor.dispatch("BeforeSetContent", args);
    const fireSetContent = (editor, args) => editor.dispatch("SetContent", args);
    const fireBeforeGetContent = (editor, args) => editor.dispatch("BeforeGetContent", args);
    const fireGetContent = (editor, args) => editor.dispatch("GetContent", args);
    const fireAutocompleterStart = (editor, args) => {
      editor.dispatch("AutocompleterStart", args);
    };
    const fireAutocompleterUpdate = (editor, args) => {
      editor.dispatch("AutocompleterUpdate", args);
    };
    const fireAutocompleterEnd = (editor) => {
      editor.dispatch("AutocompleterEnd");
    };
    const firePastePreProcess = (editor, html2, internal) => editor.dispatch("PastePreProcess", {
      content: html2,
      internal
    });
    const firePastePostProcess = (editor, node, internal) => editor.dispatch("PastePostProcess", {
      node,
      internal
    });
    const firePastePlainTextToggle = (editor, state2) => editor.dispatch("PastePlainTextToggle", { state: state2 });
    const VK = {
      BACKSPACE: 8,
      DELETE: 46,
      DOWN: 40,
      ENTER: 13,
      ESC: 27,
      LEFT: 37,
      RIGHT: 39,
      SPACEBAR: 32,
      TAB: 9,
      UP: 38,
      PAGE_UP: 33,
      PAGE_DOWN: 34,
      END: 35,
      HOME: 36,
      modifierPressed: (e) => {
        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);
      },
      metaKeyPressed: (e) => {
        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;
      }
    };
    const elementSelectionAttr = "data-mce-selected";
    const controlElmSelector = "table,img,figure.image,hr,video,span.mce-preview-object";
    const abs = Math.abs;
    const round$1 = Math.round;
    const resizeHandles = {
      nw: [
        0,
        0,
        -1,
        -1
      ],
      ne: [
        1,
        0,
        1,
        -1
      ],
      se: [
        1,
        1,
        1,
        1
      ],
      sw: [
        0,
        1,
        -1,
        1
      ]
    };
    const isTouchEvent = (evt) => evt.type === "longpress" || evt.type.indexOf("touch") === 0;
    const ControlSelection = (selection, editor) => {
      const dom2 = editor.dom;
      const editableDoc = editor.getDoc();
      const rootDocument = document;
      const rootElement = editor.getBody();
      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;
      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;
      let width2;
      let height2;
      let startScrollWidth;
      let startScrollHeight;
      const isImage3 = (elm) => isNonNullable(elm) && (isImg(elm) || dom2.is(elm, "figure.image"));
      const isMedia2 = (elm) => isMedia$2(elm) || dom2.hasClass(elm, "mce-preview-object");
      const isEventOnImageOutsideRange = (evt, range2) => {
        if (isTouchEvent(evt)) {
          const touch = evt.touches[0];
          return isImage3(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range2);
        } else {
          return isImage3(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range2);
        }
      };
      const contextMenuSelectImage = (evt) => {
        const target = evt.target;
        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {
          editor.selection.select(target);
        }
      };
      const getResizeTargets = (elm) => {
        if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
          return [
            elm,
            elm.firstElementChild
          ];
        } else if (dom2.is(elm, "figure.image")) {
          return [elm.querySelector("img")];
        } else {
          return [elm];
        }
      };
      const isResizable = (elm) => {
        const selector = getObjectResizing(editor);
        if (!selector) {
          return false;
        }
        if (elm.getAttribute("data-mce-resize") === "false") {
          return false;
        }
        if (elm === editor.getBody()) {
          return false;
        }
        if (dom2.hasClass(elm, "mce-preview-object") && isNonNullable(elm.firstElementChild)) {
          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);
        } else {
          return is$1(SugarElement.fromDom(elm), selector);
        }
      };
      const createGhostElement = (elm) => {
        if (isMedia2(elm)) {
          return dom2.create("img", { src: Env.transparentSrc });
        } else {
          return elm.cloneNode(true);
        }
      };
      const setSizeProp = (element, name3, value2) => {
        if (isNonNullable(value2)) {
          const targets = getResizeTargets(element);
          each$e(targets, (target) => {
            if (target.style[name3] || !editor.schema.isValid(target.nodeName.toLowerCase(), name3)) {
              dom2.setStyle(target, name3, value2);
            } else {
              dom2.setAttrib(target, name3, "" + value2);
            }
          });
        }
      };
      const setGhostElmSize = (ghostElm, width3, height3) => {
        setSizeProp(ghostElm, "width", width3);
        setSizeProp(ghostElm, "height", height3);
      };
      const resizeGhostElement = (e) => {
        let deltaX, deltaY, proportional;
        let resizeHelperX, resizeHelperY;
        deltaX = e.screenX - startX;
        deltaY = e.screenY - startY;
        width2 = deltaX * selectedHandle[2] + startW;
        height2 = deltaY * selectedHandle[3] + startH;
        width2 = width2 < 5 ? 5 : width2;
        height2 = height2 < 5 ? 5 : height2;
        if ((isImage3(selectedElm) || isMedia2(selectedElm)) && getResizeImgProportional(editor) !== false) {
          proportional = !VK.modifierPressed(e);
        } else {
          proportional = VK.modifierPressed(e);
        }
        if (proportional) {
          if (abs(deltaX) > abs(deltaY)) {
            height2 = round$1(width2 * ratio);
            width2 = round$1(height2 / ratio);
          } else {
            width2 = round$1(height2 / ratio);
            height2 = round$1(width2 * ratio);
          }
        }
        setGhostElmSize(selectedElmGhost, width2, height2);
        resizeHelperX = selectedHandle.startPos.x + deltaX;
        resizeHelperY = selectedHandle.startPos.y + deltaY;
        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;
        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;
        dom2.setStyles(resizeHelper, {
          left: resizeHelperX,
          top: resizeHelperY,
          display: "block"
        });
        resizeHelper.innerHTML = width2 + " &times; " + height2;
        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width2) {
          dom2.setStyle(selectedElmGhost, "left", selectedElmX + (startW - width2));
        }
        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height2) {
          dom2.setStyle(selectedElmGhost, "top", selectedElmY + (startH - height2));
        }
        deltaX = rootElement.scrollWidth - startScrollWidth;
        deltaY = rootElement.scrollHeight - startScrollHeight;
        if (deltaX + deltaY !== 0) {
          dom2.setStyles(resizeHelper, {
            left: resizeHelperX - deltaX,
            top: resizeHelperY - deltaY
          });
        }
        if (!resizeStarted) {
          fireObjectResizeStart(editor, selectedElm, startW, startH, "corner-" + selectedHandle.name);
          resizeStarted = true;
        }
      };
      const endGhostResize = () => {
        const wasResizeStarted = resizeStarted;
        resizeStarted = false;
        if (wasResizeStarted) {
          setSizeProp(selectedElm, "width", width2);
          setSizeProp(selectedElm, "height", height2);
        }
        dom2.unbind(editableDoc, "mousemove", resizeGhostElement);
        dom2.unbind(editableDoc, "mouseup", endGhostResize);
        if (rootDocument !== editableDoc) {
          dom2.unbind(rootDocument, "mousemove", resizeGhostElement);
          dom2.unbind(rootDocument, "mouseup", endGhostResize);
        }
        dom2.remove(selectedElmGhost);
        dom2.remove(resizeHelper);
        dom2.remove(resizeBackdrop);
        showResizeRect(selectedElm);
        if (wasResizeStarted) {
          fireObjectResized(editor, selectedElm, width2, height2, "corner-" + selectedHandle.name);
          dom2.setAttrib(selectedElm, "style", dom2.getAttrib(selectedElm, "style"));
        }
        editor.nodeChanged();
      };
      const showResizeRect = (targetElm) => {
        unbindResizeHandleEvents();
        const position = dom2.getPos(targetElm, rootElement);
        const selectedElmX2 = position.x;
        const selectedElmY2 = position.y;
        const rect = targetElm.getBoundingClientRect();
        const targetWidth = rect.width || rect.right - rect.left;
        const targetHeight = rect.height || rect.bottom - rect.top;
        if (selectedElm !== targetElm) {
          hideResizeRect();
          selectedElm = targetElm;
          width2 = height2 = 0;
        }
        const e = editor.dispatch("ObjectSelected", { target: targetElm });
        if (isResizable(targetElm) && !e.isDefaultPrevented()) {
          each$d(resizeHandles, (handle2, name3) => {
            const startDrag = (e2) => {
              const target = getResizeTargets(selectedElm)[0];
              startX = e2.screenX;
              startY = e2.screenY;
              startW = target.clientWidth;
              startH = target.clientHeight;
              ratio = startH / startW;
              selectedHandle = handle2;
              selectedHandle.name = name3;
              selectedHandle.startPos = {
                x: targetWidth * handle2[0] + selectedElmX2,
                y: targetHeight * handle2[1] + selectedElmY2
              };
              startScrollWidth = rootElement.scrollWidth;
              startScrollHeight = rootElement.scrollHeight;
              resizeBackdrop = dom2.add(rootElement, "div", {
                "class": "mce-resize-backdrop",
                "data-mce-bogus": "all"
              });
              dom2.setStyles(resizeBackdrop, {
                position: "fixed",
                left: "0",
                top: "0",
                width: "100%",
                height: "100%"
              });
              selectedElmGhost = createGhostElement(selectedElm);
              dom2.addClass(selectedElmGhost, "mce-clonedresizable");
              dom2.setAttrib(selectedElmGhost, "data-mce-bogus", "all");
              selectedElmGhost.contentEditable = "false";
              dom2.setStyles(selectedElmGhost, {
                left: selectedElmX2,
                top: selectedElmY2,
                margin: 0
              });
              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);
              selectedElmGhost.removeAttribute(elementSelectionAttr);
              rootElement.appendChild(selectedElmGhost);
              dom2.bind(editableDoc, "mousemove", resizeGhostElement);
              dom2.bind(editableDoc, "mouseup", endGhostResize);
              if (rootDocument !== editableDoc) {
                dom2.bind(rootDocument, "mousemove", resizeGhostElement);
                dom2.bind(rootDocument, "mouseup", endGhostResize);
              }
              resizeHelper = dom2.add(rootElement, "div", {
                "class": "mce-resize-helper",
                "data-mce-bogus": "all"
              }, startW + " &times; " + startH);
            };
            let handleElm = dom2.get("mceResizeHandle" + name3);
            if (handleElm) {
              dom2.remove(handleElm);
            }
            handleElm = dom2.add(rootElement, "div", {
              "id": "mceResizeHandle" + name3,
              "data-mce-bogus": "all",
              "class": "mce-resizehandle",
              "unselectable": true,
              "style": "cursor:" + name3 + "-resize; margin:0; padding:0"
            });
            dom2.bind(handleElm, "mousedown", (e2) => {
              e2.stopImmediatePropagation();
              e2.preventDefault();
              startDrag(e2);
            });
            handle2.elm = handleElm;
            dom2.setStyles(handleElm, {
              left: targetWidth * handle2[0] + selectedElmX2 - handleElm.offsetWidth / 2,
              top: targetHeight * handle2[1] + selectedElmY2 - handleElm.offsetHeight / 2
            });
          });
        } else {
          hideResizeRect(false);
        }
      };
      const throttledShowResizeRect = first$1(showResizeRect, 0);
      const hideResizeRect = (removeSelected = true) => {
        throttledShowResizeRect.cancel();
        unbindResizeHandleEvents();
        if (selectedElm && removeSelected) {
          selectedElm.removeAttribute(elementSelectionAttr);
        }
        each$d(resizeHandles, (value2, name3) => {
          const handleElm = dom2.get("mceResizeHandle" + name3);
          if (handleElm) {
            dom2.unbind(handleElm);
            dom2.remove(handleElm);
          }
        });
      };
      const isChildOrEqual = (node, parent2) => dom2.isChildOf(node, parent2);
      const updateResizeRect = (e) => {
        if (resizeStarted || editor.removed || editor.composing) {
          return;
        }
        const targetElm = e.type === "mousedown" ? e.target : selection.getNode();
        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map((e2) => e2.dom).filter((e2) => dom2.isEditable(e2.parentElement)).getOrUndefined();
        const selectedValue = isNonNullable(controlElm) ? dom2.getAttrib(controlElm, elementSelectionAttr, "1") : "1";
        each$e(dom2.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), (img) => {
          img.removeAttribute(elementSelectionAttr);
        });
        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement)) {
          disableGeckoResize();
          const startElm = selection.getStart(true);
          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {
            dom2.setAttrib(controlElm, elementSelectionAttr, selectedValue);
            throttledShowResizeRect.throttle(controlElm);
            return;
          }
        }
        hideResizeRect();
      };
      const unbindResizeHandleEvents = () => {
        each$d(resizeHandles, (handle2) => {
          if (handle2.elm) {
            dom2.unbind(handle2.elm);
            delete handle2.elm;
          }
        });
      };
      const disableGeckoResize = () => {
        try {
          editor.getDoc().execCommand("enableObjectResizing", false, "false");
        } catch (ex) {
        }
      };
      editor.on("init", () => {
        disableGeckoResize();
        editor.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", updateResizeRect);
        editor.on("keyup compositionend", (e) => {
          if (selectedElm && selectedElm.nodeName === "TABLE") {
            updateResizeRect(e);
          }
        });
        editor.on("hide blur", hideResizeRect);
        editor.on("contextmenu longpress", contextMenuSelectImage, true);
      });
      editor.on("remove", unbindResizeHandleEvents);
      const destroy3 = () => {
        throttledShowResizeRect.cancel();
        selectedElm = selectedElmGhost = resizeBackdrop = null;
      };
      return {
        isResizable,
        showResizeRect,
        hideResizeRect,
        updateResizeRect,
        destroy: destroy3
      };
    };
    const setStart = (rng, situ) => {
      situ.fold((e) => {
        rng.setStartBefore(e.dom);
      }, (e, o) => {
        rng.setStart(e.dom, o);
      }, (e) => {
        rng.setStartAfter(e.dom);
      });
    };
    const setFinish = (rng, situ) => {
      situ.fold((e) => {
        rng.setEndBefore(e.dom);
      }, (e, o) => {
        rng.setEnd(e.dom, o);
      }, (e) => {
        rng.setEndAfter(e.dom);
      });
    };
    const relativeToNative = (win, startSitu, finishSitu) => {
      const range2 = win.document.createRange();
      setStart(range2, startSitu);
      setFinish(range2, finishSitu);
      return range2;
    };
    const exactToNative = (win, start3, soffset, finish, foffset) => {
      const rng = win.document.createRange();
      rng.setStart(start3.dom, soffset);
      rng.setEnd(finish.dom, foffset);
      return rng;
    };
    const adt$3 = Adt.generate([
      {
        ltr: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      },
      {
        rtl: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]);
    const fromRange = (win, type2, range2) => type2(SugarElement.fromDom(range2.startContainer), range2.startOffset, SugarElement.fromDom(range2.endContainer), range2.endOffset);
    const getRanges = (win, selection) => selection.match({
      domRange: (rng) => {
        return {
          ltr: constant(rng),
          rtl: Optional.none
        };
      },
      relative: (startSitu, finishSitu) => {
        return {
          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
        };
      },
      exact: (start3, soffset, finish, foffset) => {
        return {
          ltr: cached(() => exactToNative(win, start3, soffset, finish, foffset)),
          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start3, soffset)))
        };
      }
    });
    const doDiagnose = (win, ranges) => {
      const rng = ranges.ltr();
      if (rng.collapsed) {
        const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
        return reversed.map((rev) => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
      } else {
        return fromRange(win, adt$3.ltr, rng);
      }
    };
    const diagnose = (win, selection) => {
      const ranges = getRanges(win, selection);
      return doDiagnose(win, ranges);
    };
    adt$3.ltr;
    adt$3.rtl;
    const create$a2 = (start3, soffset, finish, foffset) => ({
      start: start3,
      soffset,
      finish,
      foffset
    });
    const SimRange = { create: create$a2 };
    const caretPositionFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind((pos) => {
        if (pos.offsetNode === null) {
          return Optional.none();
        }
        const r2 = doc.dom.createRange();
        r2.setStart(pos.offsetNode, pos.offset);
        r2.collapse();
        return Optional.some(r2);
      });
    };
    const caretRangeFromPoint = (doc, x, y) => {
      var _a, _b;
      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
    };
    const availableSearch = (() => {
      if (document.caretPositionFromPoint) {
        return caretPositionFromPoint;
      } else if (document.caretRangeFromPoint) {
        return caretRangeFromPoint;
      } else {
        return Optional.none;
      }
    })();
    const fromPoint$1 = (win, x, y) => {
      const doc = SugarElement.fromDom(win.document);
      return availableSearch(doc, x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    };
    const adt$2 = Adt.generate([
      { before: ["element"] },
      {
        on: [
          "element",
          "offset"
        ]
      },
      { after: ["element"] }
    ]);
    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
    const getStart$2 = (situ) => situ.fold(identity, identity, identity);
    const before$1 = adt$2.before;
    const on2 = adt$2.on;
    const after$1 = adt$2.after;
    const Situ = {
      before: before$1,
      on: on2,
      after: after$1,
      cata,
      getStart: getStart$2
    };
    const adt$1 = Adt.generate([
      { domRange: ["rng"] },
      {
        relative: [
          "startSitu",
          "finishSitu"
        ]
      },
      {
        exact: [
          "start",
          "soffset",
          "finish",
          "foffset"
        ]
      }
    ]);
    const exactFromRange = (simRange) => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
    const getStart$1 = (selection) => selection.match({
      domRange: (rng) => SugarElement.fromDom(rng.startContainer),
      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
      exact: (start3, _soffset, _finish, _foffset) => start3
    });
    const domRange = adt$1.domRange;
    const relative = adt$1.relative;
    const exact = adt$1.exact;
    const getWin = (selection) => {
      const start3 = getStart$1(selection);
      return defaultView(start3);
    };
    const range = SimRange.create;
    const SimSelection = {
      domRange,
      relative,
      exact,
      exactFromRange,
      getWin,
      range
    };
    const beforeSpecial = (element, offset2) => {
      const name$1 = name2(element);
      if ("input" === name$1) {
        return Situ.after(element);
      } else if (!contains$2([
        "br",
        "img"
      ], name$1)) {
        return Situ.on(element, offset2);
      } else {
        return offset2 === 0 ? Situ.before(element) : Situ.after(element);
      }
    };
    const preprocessRelative = (startSitu, finishSitu) => {
      const start3 = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
      return SimSelection.relative(start3, finish);
    };
    const preprocessExact = (start3, soffset, finish, foffset) => {
      const startSitu = beforeSpecial(start3, soffset);
      const finishSitu = beforeSpecial(finish, foffset);
      return SimSelection.relative(startSitu, finishSitu);
    };
    const preprocess = (selection) => selection.match({
      domRange: (rng) => {
        const start3 = SugarElement.fromDom(rng.startContainer);
        const finish = SugarElement.fromDom(rng.endContainer);
        return preprocessExact(start3, rng.startOffset, finish, rng.endOffset);
      },
      relative: preprocessRelative,
      exact: preprocessExact
    });
    const fromElements = (elements, scope) => {
      const doc = scope || document;
      const fragment = doc.createDocumentFragment();
      each$e(elements, (element) => {
        fragment.appendChild(element.dom);
      });
      return SugarElement.fromDom(fragment);
    };
    const toNative = (selection) => {
      const win = SimSelection.getWin(selection).dom;
      const getDomRange = (start3, soffset, finish, foffset) => exactToNative(win, start3, soffset, finish, foffset);
      const filtered = preprocess(selection);
      return diagnose(win, filtered).match({
        ltr: getDomRange,
        rtl: getDomRange
      });
    };
    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);
    const fromPoint = (clientX, clientY, doc) => {
      const win = defaultView(SugarElement.fromDom(doc));
      return getAtPoint(win.dom, clientX, clientY).map((simRange) => {
        const rng = doc.createRange();
        rng.setStart(simRange.start.dom, simRange.soffset);
        rng.setEnd(simRange.finish.dom, simRange.foffset);
        return rng;
      }).getOrUndefined();
    };
    const isEq$4 = (rng1, rng2) => {
      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);
    };
    const findParent = (node, rootNode, predicate) => {
      let currentNode = node;
      while (currentNode && currentNode !== rootNode) {
        if (predicate(currentNode)) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;
    const hasParentWithName = (node, rootNode, name3) => hasParent$1(node, rootNode, (node2) => node2.nodeName === name3);
    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);
    const hasBrBeforeAfter = (dom2, node, left2) => {
      const parentNode = node.parentNode;
      if (parentNode) {
        const walker = new DomTreeWalker(node, dom2.getParent(parentNode, dom2.isBlock) || dom2.getRoot());
        let currentNode;
        while (currentNode = walker[left2 ? "prev" : "next"]()) {
          if (isBr$6(currentNode)) {
            return true;
          }
        }
      }
      return false;
    };
    const isPrevNode = (node, name3) => {
      var _a;
      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name3;
    };
    const hasContentEditableFalseParent = (root2, node) => {
      let currentNode = node;
      while (currentNode && currentNode !== root2) {
        if (isContentEditableFalse$b(currentNode)) {
          return true;
        }
        currentNode = currentNode.parentNode;
      }
      return false;
    };
    const findTextNodeRelative = (dom2, isAfterNode, collapsed, left2, startNode) => {
      const body = dom2.getRoot();
      const nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
      const parentNode = startNode.parentNode;
      let lastInlineElement;
      let node;
      if (!parentNode) {
        return Optional.none();
      }
      const parentBlockContainer = dom2.getParent(parentNode, dom2.isBlock) || body;
      if (left2 && isBr$6(startNode) && isAfterNode && dom2.isEmpty(parentBlockContainer)) {
        return Optional.some(CaretPosition(parentNode, dom2.nodeIndex(startNode)));
      }
      const walker = new DomTreeWalker(startNode, parentBlockContainer);
      while (node = walker[left2 ? "prev" : "next"]()) {
        if (dom2.getContentEditableParent(node) === "false" || isCeFalseCaretContainer(node, body)) {
          return Optional.none();
        }
        if (isText$a(node) && node.data.length > 0) {
          if (!hasParentWithName(node, body, "A")) {
            return Optional.some(CaretPosition(node, left2 ? node.data.length : 0));
          }
          return Optional.none();
        }
        if (dom2.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {
          return Optional.none();
        }
        lastInlineElement = node;
      }
      if (isComment(lastInlineElement)) {
        return Optional.none();
      }
      if (collapsed && lastInlineElement) {
        return Optional.some(CaretPosition(lastInlineElement, 0));
      }
      return Optional.none();
    };
    const normalizeEndPoint = (dom2, collapsed, start3, rng) => {
      const body = dom2.getRoot();
      let node;
      let normalized = false;
      let container = start3 ? rng.startContainer : rng.endContainer;
      let offset2 = start3 ? rng.startOffset : rng.endOffset;
      const isAfterNode = isElement$6(container) && offset2 === container.childNodes.length;
      const nonEmptyElementsMap = dom2.schema.getNonEmptyElements();
      let directionLeft = start3;
      if (isCaretContainer$2(container)) {
        return Optional.none();
      }
      if (isElement$6(container) && offset2 > container.childNodes.length - 1) {
        directionLeft = false;
      }
      if (isDocument$1(container)) {
        container = body;
        offset2 = 0;
      }
      if (container === body) {
        if (directionLeft) {
          node = container.childNodes[offset2 > 0 ? offset2 - 1 : 0];
          if (node) {
            if (isCaretContainer$2(node)) {
              return Optional.none();
            }
            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {
              return Optional.none();
            }
          }
        }
        if (container.hasChildNodes()) {
          offset2 = Math.min(!directionLeft && offset2 > 0 ? offset2 - 1 : offset2, container.childNodes.length - 1);
          container = container.childNodes[offset2];
          offset2 = isText$a(container) && isAfterNode ? container.data.length : 0;
          if (!collapsed && container === body.lastChild && isTable$2(container)) {
            return Optional.none();
          }
          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {
            return Optional.none();
          }
          if (container.hasChildNodes() && !isTable$2(container)) {
            node = container;
            const walker = new DomTreeWalker(container, body);
            do {
              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {
                normalized = false;
                break;
              }
              if (isText$a(node) && node.data.length > 0) {
                offset2 = directionLeft ? 0 : node.data.length;
                container = node;
                normalized = true;
                break;
              }
              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {
                offset2 = dom2.nodeIndex(node);
                container = node.parentNode;
                if (!directionLeft) {
                  offset2++;
                }
                normalized = true;
                break;
              }
            } while (node = directionLeft ? walker.next() : walker.prev());
          }
        }
      }
      if (collapsed) {
        if (isText$a(container) && offset2 === 0) {
          findTextNodeRelative(dom2, isAfterNode, collapsed, true, container).each((pos) => {
            container = pos.container();
            offset2 = pos.offset();
            normalized = true;
          });
        }
        if (isElement$6(container)) {
          node = container.childNodes[offset2];
          if (!node) {
            node = container.childNodes[offset2 - 1];
          }
          if (node && isBr$6(node) && !isPrevNode(node, "A") && !hasBrBeforeAfter(dom2, node, false) && !hasBrBeforeAfter(dom2, node, true)) {
            findTextNodeRelative(dom2, isAfterNode, collapsed, true, node).each((pos) => {
              container = pos.container();
              offset2 = pos.offset();
              normalized = true;
            });
          }
        }
      }
      if (directionLeft && !collapsed && isText$a(container) && offset2 === container.data.length) {
        findTextNodeRelative(dom2, isAfterNode, collapsed, false, container).each((pos) => {
          container = pos.container();
          offset2 = pos.offset();
          normalized = true;
        });
      }
      return normalized && container ? Optional.some(CaretPosition(container, offset2)) : Optional.none();
    };
    const normalize$2 = (dom2, rng) => {
      const collapsed = rng.collapsed, normRng = rng.cloneRange();
      const startPos = CaretPosition.fromRangeStart(rng);
      normalizeEndPoint(dom2, collapsed, true, normRng).each((pos) => {
        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {
          normRng.setStart(pos.container(), pos.offset());
        }
      });
      if (!collapsed) {
        normalizeEndPoint(dom2, collapsed, false, normRng).each((pos) => {
          normRng.setEnd(pos.container(), pos.offset());
        });
      }
      if (collapsed) {
        normRng.collapse(true);
      }
      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);
    };
    const splitText = (node, offset2) => {
      return node.splitText(offset2);
    };
    const split = (rng) => {
      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;
      if (startContainer === endContainer && isText$a(startContainer)) {
        if (startOffset > 0 && startOffset < startContainer.data.length) {
          endContainer = splitText(startContainer, startOffset);
          startContainer = endContainer.previousSibling;
          if (endOffset > startOffset) {
            endOffset = endOffset - startOffset;
            const newContainer = splitText(endContainer, endOffset).previousSibling;
            startContainer = endContainer = newContainer;
            endOffset = newContainer.data.length;
            startOffset = 0;
          } else {
            endOffset = 0;
          }
        }
      } else {
        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {
          startContainer = splitText(startContainer, startOffset);
          startOffset = 0;
        }
        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {
          const newContainer = splitText(endContainer, endOffset).previousSibling;
          endContainer = newContainer;
          endOffset = newContainer.data.length;
        }
      }
      return {
        startContainer,
        startOffset,
        endContainer,
        endOffset
      };
    };
    const RangeUtils = (dom2) => {
      const walk2 = (rng, callback) => {
        return walk$3(dom2, rng, callback);
      };
      const split$12 = split;
      const normalize2 = (rng) => {
        return normalize$2(dom2, rng).fold(never, (normalizedRng) => {
          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);
          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);
          return true;
        });
      };
      const expand = (rng, options = { type: "word" }) => {
        if (options.type === "word") {
          const rangeLike = expandRng(dom2, rng, [{ inline: "span" }]);
          const newRange = dom2.createRng();
          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);
          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);
          return newRange;
        }
        return rng;
      };
      return {
        walk: walk2,
        split: split$12,
        expand,
        normalize: normalize2
      };
    };
    RangeUtils.compareRanges = isEq$4;
    RangeUtils.getCaretRangeFromPoint = fromPoint;
    RangeUtils.getSelectedNode = getSelectedNode;
    RangeUtils.getNode = getNode$1;
    const Dimension = (name3, getOffset) => {
      const set2 = (element, h) => {
        if (!isNumber2(h) && !h.match(/^[0-9]+$/)) {
          throw new Error(name3 + ".set accepts only positive integer values. Value was " + h);
        }
        const dom2 = element.dom;
        if (isSupported(dom2)) {
          dom2.style[name3] = h + "px";
        }
      };
      const get2 = (element) => {
        const r2 = getOffset(element);
        if (r2 <= 0 || r2 === null) {
          const css = get$7(element, name3);
          return parseFloat(css) || 0;
        }
        return r2;
      };
      const getOuter2 = get2;
      const aggregate = (element, properties) => foldl(properties, (acc, property) => {
        const val = get$7(element, property);
        const value2 = val === void 0 ? 0 : parseInt(val, 10);
        return isNaN(value2) ? acc : acc + value2;
      }, 0);
      const max3 = (element, value2, properties) => {
        const cumulativeInclusions = aggregate(element, properties);
        const absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
        return absoluteMax;
      };
      return {
        set: set2,
        get: get2,
        getOuter: getOuter2,
        aggregate,
        max: max3
      };
    };
    const api = Dimension("height", (element) => {
      const dom2 = element.dom;
      return inBody(element) ? dom2.getBoundingClientRect().height : dom2.offsetHeight;
    });
    const get$2 = (element) => api.get(element);
    const getDocument = () => SugarElement.fromDom(document);
    const walkUp = (navigation, doc) => {
      const frame = navigation.view(doc);
      return frame.fold(constant([]), (f) => {
        const parent2 = navigation.owner(f);
        const rest = walkUp(navigation, parent2);
        return [f].concat(rest);
      });
    };
    const pathTo = (element, navigation) => {
      const d = navigation.owner(element);
      return walkUp(navigation, d);
    };
    const view = (doc) => {
      var _a;
      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
      return element.map(SugarElement.fromDom);
    };
    const owner = (element) => documentOrOwner(element);
    var Navigation = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view,
      owner
    });
    const find2 = (element) => {
      const doc = getDocument();
      const scroll = get$5(doc);
      const frames = pathTo(element, Navigation);
      const offset2 = viewport2(element);
      const r2 = foldr(frames, (b, a) => {
        const loc = viewport2(a);
        return {
          left: b.left + loc.left,
          top: b.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r2.left + offset2.left + scroll.left, r2.top + offset2.top + scroll.top);
    };
    const excludeFromDescend = (element) => name2(element) === "textarea";
    const fireScrollIntoViewEvent = (editor, data3) => {
      const scrollEvent = editor.dispatch("ScrollIntoView", data3);
      return scrollEvent.isDefaultPrevented();
    };
    const fireAfterScrollIntoViewEvent = (editor, data3) => {
      editor.dispatch("AfterScrollIntoView", data3);
    };
    const descend = (element, offset2) => {
      const children2 = children$1(element);
      if (children2.length === 0 || excludeFromDescend(element)) {
        return {
          element,
          offset: offset2
        };
      } else if (offset2 < children2.length && !excludeFromDescend(children2[offset2])) {
        return {
          element: children2[offset2],
          offset: 0
        };
      } else {
        const last2 = children2[children2.length - 1];
        if (excludeFromDescend(last2)) {
          return {
            element,
            offset: offset2
          };
        } else {
          if (name2(last2) === "img") {
            return {
              element: last2,
              offset: 1
            };
          } else if (isText$b(last2)) {
            return {
              element: last2,
              offset: get$3(last2).length
            };
          } else {
            return {
              element: last2,
              offset: children$1(last2).length
            };
          }
        }
      }
    };
    const markerInfo = (element, cleanupFun) => {
      const pos = absolute(element);
      const height2 = get$2(element);
      return {
        element,
        bottom: pos.top + height2,
        height: height2,
        pos,
        cleanup: cleanupFun
      };
    };
    const createMarker$1 = (element, offset2) => {
      const startPoint = descend(element, offset2);
      const span = SugarElement.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + ZWSP$1 + "</span>");
      before$3(startPoint.element, span);
      return markerInfo(span, () => remove$6(span));
    };
    const elementMarker = (element) => markerInfo(SugarElement.fromDom(element), noop2);
    const withMarker = (editor, f, rng, alignToTop) => {
      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);
    };
    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {
      const data3 = {
        elm: marker.element.dom,
        alignToTop
      };
      if (fireScrollIntoViewEvent(editor, data3)) {
        return;
      }
      const scrollTop = get$5(doc).top;
      f(doc, scrollTop, marker, alignToTop);
      fireAfterScrollIntoViewEvent(editor, data3);
    };
    const applyWithMarker = (editor, f, rng, alignToTop) => {
      const body = SugarElement.fromDom(editor.getBody());
      const doc = SugarElement.fromDom(editor.getDoc());
      reflow2(body);
      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);
      withScrollEvents(editor, doc, f, marker, alignToTop);
      marker.cleanup();
    };
    const withElement = (editor, element, f, alignToTop) => {
      const doc = SugarElement.fromDom(editor.getDoc());
      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);
    };
    const preserveWith = (editor, f, rng) => {
      const startElement = rng.startContainer;
      const startOffset = rng.startOffset;
      const endElement = rng.endContainer;
      const endOffset = rng.endOffset;
      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));
      const newRng = editor.dom.createRng();
      newRng.setStart(startElement, startOffset);
      newRng.setEnd(endElement, endOffset);
      editor.selection.setRng(rng);
    };
    const scrollToMarker = (marker, viewHeight, alignToTop, doc) => {
      const pos = marker.pos;
      if (alignToTop) {
        to(pos.left, pos.top, doc);
      } else {
        const y = pos.top - viewHeight + marker.height;
        to(pos.left, y, doc);
      }
    };
    const intoWindowIfNeeded = (doc, scrollTop, viewHeight, marker, alignToTop) => {
      const viewportBottom = viewHeight + scrollTop;
      const markerTop = marker.pos.top;
      const markerBottom = marker.bottom;
      const largerThanViewport = markerBottom - markerTop >= viewHeight;
      if (markerTop < scrollTop) {
        scrollToMarker(marker, viewHeight, alignToTop !== false, doc);
      } else if (markerTop > viewportBottom) {
        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;
        scrollToMarker(marker, viewHeight, align, doc);
      } else if (markerBottom > viewportBottom && !largerThanViewport) {
        scrollToMarker(marker, viewHeight, alignToTop === true, doc);
      }
    };
    const intoWindow = (doc, scrollTop, marker, alignToTop) => {
      const viewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(doc, scrollTop, viewHeight, marker, alignToTop);
    };
    const intoFrame = (doc, scrollTop, marker, alignToTop) => {
      const frameViewHeight = defaultView(doc).dom.innerHeight;
      intoWindowIfNeeded(doc, scrollTop, frameViewHeight, marker, alignToTop);
      const op = find2(marker.element);
      const viewportBounds = getBounds(window);
      if (op.top < viewportBounds.y) {
        intoView(marker.element, alignToTop !== false);
      } else if (op.top > viewportBounds.bottom) {
        intoView(marker.element, alignToTop === true);
      }
    };
    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);
    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);
    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);
    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);
    const scrollElementIntoView = (editor, element, alignToTop) => {
      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;
      scroller(editor, element, alignToTop);
    };
    const scrollRangeIntoView = (editor, rng, alignToTop) => {
      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;
      scroller(editor, rng, alignToTop);
    };
    const focus$1 = (element) => element.dom.focus();
    const hasFocus$1 = (element) => {
      const root2 = getRootNode2(element).dom;
      return element.dom === root2.activeElement;
    };
    const active$1 = (root2 = getDocument()) => Optional.from(root2.dom.activeElement).map(SugarElement.fromDom);
    const search = (element) => active$1(getRootNode2(element)).filter((e) => element.dom.contains(e.dom));
    const clamp$1 = (offset2, element) => {
      const max3 = isText$b(element) ? get$3(element).length : children$1(element).length + 1;
      if (offset2 > max3) {
        return max3;
      } else if (offset2 < 0) {
        return 0;
      }
      return offset2;
    };
    const normalizeRng = (rng) => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));
    const isOrContains = (root2, elm) => !isRestrictedNode(elm.dom) && (contains2(root2, elm) || eq(root2, elm));
    const isRngInRoot = (root2) => (rng) => isOrContains(root2, rng.start) && isOrContains(root2, rng.finish);
    const shouldStore = (editor) => editor.inline || Env.browser.isFirefox();
    const nativeRangeToSelectionRange = (r2) => SimSelection.range(SugarElement.fromDom(r2.startContainer), r2.startOffset, SugarElement.fromDom(r2.endContainer), r2.endOffset);
    const readRange = (win) => {
      const selection = win.getSelection();
      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));
      return rng.map(nativeRangeToSelectionRange);
    };
    const getBookmark = (root2) => {
      const win = defaultView(root2);
      return readRange(win.dom).filter(isRngInRoot(root2));
    };
    const validate = (root2, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root2)).map(normalizeRng);
    const bookmarkToNativeRng = (bookmark) => {
      const rng = document.createRange();
      try {
        rng.setStart(bookmark.start.dom, bookmark.soffset);
        rng.setEnd(bookmark.finish.dom, bookmark.foffset);
        return Optional.some(rng);
      } catch (_2) {
        return Optional.none();
      }
    };
    const store = (editor) => {
      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();
      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;
    };
    const getRng = (editor) => {
      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();
      return bookmark.bind((x) => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);
    };
    const restore = (editor) => {
      getRng(editor).each((rng) => editor.selection.setRng(rng));
    };
    const isEditorUIElement$1 = (elm) => {
      const className = elm.className.toString();
      return className.indexOf("tox-") !== -1 || className.indexOf("mce-") !== -1;
    };
    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };
    const wrappedSetTimeout = (callback, time) => {
      if (!isNumber2(time)) {
        time = 0;
      }
      return setTimeout(callback, time);
    };
    const wrappedSetInterval = (callback, time) => {
      if (!isNumber2(time)) {
        time = 0;
      }
      return setInterval(callback, time);
    };
    const Delay = {
      setEditorTimeout: (editor, callback, time) => {
        return wrappedSetTimeout(() => {
          if (!editor.removed) {
            callback();
          }
        }, time);
      },
      setEditorInterval: (editor, callback, time) => {
        const timer = wrappedSetInterval(() => {
          if (!editor.removed) {
            callback();
          } else {
            clearInterval(timer);
          }
        }, time);
        return timer;
      }
    };
    const isManualNodeChange = (e) => {
      return e.type === "nodechange" && e.selectionChange;
    };
    const registerPageMouseUp = (editor, throttledStore) => {
      const mouseUpPage = () => {
        throttledStore.throttle();
      };
      DOMUtils.DOM.bind(document, "mouseup", mouseUpPage);
      editor.on("remove", () => {
        DOMUtils.DOM.unbind(document, "mouseup", mouseUpPage);
      });
    };
    const registerMouseUp = (editor, throttledStore) => {
      editor.on("mouseup touchend", (_e) => {
        throttledStore.throttle();
      });
    };
    const registerEditorEvents = (editor, throttledStore) => {
      registerMouseUp(editor, throttledStore);
      editor.on("keyup NodeChange AfterSetSelectionRange", (e) => {
        if (!isManualNodeChange(e)) {
          store(editor);
        }
      });
    };
    const register$6 = (editor) => {
      const throttledStore = first$1(() => {
        store(editor);
      }, 0);
      editor.on("init", () => {
        if (editor.inline) {
          registerPageMouseUp(editor, throttledStore);
        }
        registerEditorEvents(editor, throttledStore);
      });
      editor.on("remove", () => {
        throttledStore.cancel();
      });
    };
    let documentFocusInHandler;
    const DOM$9 = DOMUtils.DOM;
    const isEditorUIElement = (elm) => {
      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);
    };
    const isEditorContentAreaElement = (elm) => {
      const classList = elm.classList;
      if (classList !== void 0) {
        return classList.contains("tox-edit-area") || classList.contains("tox-edit-area__iframe") || classList.contains("mce-content-body");
      } else {
        return false;
      }
    };
    const isUIElement = (editor, elm) => {
      const customSelector = getCustomUiSelector(editor);
      const parent2 = DOM$9.getParent(elm, (elm2) => {
        return isEditorUIElement(elm2) || (customSelector ? editor.dom.is(elm2, customSelector) : false);
      });
      return parent2 !== null;
    };
    const getActiveElement = (editor) => {
      try {
        const root2 = getRootNode2(SugarElement.fromDom(editor.getElement()));
        return active$1(root2).fold(() => document.body, (x) => x.dom);
      } catch (ex) {
        return document.body;
      }
    };
    const registerEvents$1 = (editorManager, e) => {
      const editor = e.editor;
      register$6(editor);
      const toggleContentAreaOnFocus = (editor2, fn3) => {
        if (shouldHighlightOnFocus(editor2) && editor2.inline !== true) {
          const contentArea = SugarElement.fromDom(editor2.getContainer());
          fn3(contentArea, "tox-edit-focus");
        }
      };
      editor.on("focusin", () => {
        const focusedEditor = editorManager.focusedEditor;
        if (isEditorContentAreaElement(getActiveElement(editor))) {
          toggleContentAreaOnFocus(editor, add$2);
        }
        if (focusedEditor !== editor) {
          if (focusedEditor) {
            focusedEditor.dispatch("blur", { focusedEditor: editor });
          }
          editorManager.setActive(editor);
          editorManager.focusedEditor = editor;
          editor.dispatch("focus", { blurredEditor: focusedEditor });
          editor.focus(true);
        }
      });
      editor.on("focusout", () => {
        Delay.setEditorTimeout(editor, () => {
          const focusedEditor = editorManager.focusedEditor;
          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {
            toggleContentAreaOnFocus(editor, remove$8);
          }
          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {
            editor.dispatch("blur", { focusedEditor: null });
            editorManager.focusedEditor = null;
          }
        });
      });
      if (!documentFocusInHandler) {
        documentFocusInHandler = (e2) => {
          const activeEditor = editorManager.activeEditor;
          if (activeEditor) {
            getOriginalEventTarget(e2).each((target) => {
              const elem = target;
              if (elem.ownerDocument === document) {
                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {
                  activeEditor.dispatch("blur", { focusedEditor: null });
                  editorManager.focusedEditor = null;
                }
              }
            });
          }
        };
        DOM$9.bind(document, "focusin", documentFocusInHandler);
      }
    };
    const unregisterDocumentEvents = (editorManager, e) => {
      if (editorManager.focusedEditor === e.editor) {
        editorManager.focusedEditor = null;
      }
      if (!editorManager.activeEditor && documentFocusInHandler) {
        DOM$9.unbind(document, "focusin", documentFocusInHandler);
        documentFocusInHandler = null;
      }
    };
    const setup$v = (editorManager) => {
      editorManager.on("AddEditor", curry(registerEvents$1, editorManager));
      editorManager.on("RemoveEditor", curry(unregisterDocumentEvents, editorManager));
    };
    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, (node2) => editor.dom.getContentEditable(node2) === "true");
    const getCollapsedNode = (rng) => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();
    const getFocusInElement = (root2, rng) => getCollapsedNode(rng).bind((node) => {
      if (isTableSection(node)) {
        return Optional.some(node);
      } else if (!contains2(root2, node)) {
        return Optional.some(root2);
      } else {
        return Optional.none();
      }
    });
    const normalizeSelection = (editor, rng) => {
      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind((elm) => {
        return firstPositionIn(elm.dom);
      }).fold(() => {
        editor.selection.normalize();
      }, (caretPos) => editor.selection.setRng(caretPos.toRange()));
    };
    const focusBody = (body) => {
      if (body.setActive) {
        try {
          body.setActive();
        } catch (ex) {
          body.focus();
        }
      } else {
        body.focus();
      }
    };
    const hasElementFocus = (elm) => hasFocus$1(elm) || search(elm).isSome();
    const hasIframeFocus = (editor) => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));
    const hasInlineFocus = (editor) => {
      const rawBody = editor.getBody();
      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));
    };
    const hasUiFocus = (editor) => {
      const dos = getRootNode2(SugarElement.fromDom(editor.getElement()));
      return active$1(dos).filter((elem) => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();
    };
    const hasFocus = (editor) => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);
    const hasEditorOrUiFocus = (editor) => hasFocus(editor) || hasUiFocus(editor);
    const focusEditor = (editor) => {
      const selection = editor.selection;
      const body = editor.getBody();
      let rng = selection.getRng();
      editor.quirks.refreshContentEditable();
      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
        getRng(editor).each((bookmarkRng) => {
          editor.selection.setRng(bookmarkRng);
          rng = bookmarkRng;
        });
      }
      const contentEditableHost = getContentEditableHost(editor, selection.getNode());
      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {
        focusBody(contentEditableHost);
        normalizeSelection(editor, rng);
        activateEditor(editor);
        return;
      }
      if (!editor.inline) {
        if (!Env.browser.isOpera()) {
          focusBody(body);
        }
        editor.getWin().focus();
      }
      if (Env.browser.isFirefox() || editor.inline) {
        focusBody(body);
        normalizeSelection(editor, rng);
      }
      activateEditor(editor);
    };
    const activateEditor = (editor) => editor.editorManager.setActive(editor);
    const focus = (editor, skipFocus) => {
      if (editor.removed) {
        return;
      }
      if (skipFocus) {
        activateEditor(editor);
      } else {
        focusEditor(editor);
      }
    };
    const getEndpointElement = (root2, rng, start3, real, resolve2) => {
      const container = start3 ? rng.startContainer : rng.endContainer;
      const offset2 = start3 ? rng.startOffset : rng.endOffset;
      return Optional.from(container).map(SugarElement.fromDom).map((elm) => !real || !rng.collapsed ? child$1(elm, resolve2(elm, offset2)).getOr(elm) : elm).bind((elm) => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map((elm) => elm.dom).getOr(root2);
    };
    const getStart = (root2, rng, real = false) => getEndpointElement(root2, rng, true, real, (elm, offset2) => Math.min(childNodesCount(elm), offset2));
    const getEnd$1 = (root2, rng, real = false) => getEndpointElement(root2, rng, false, real, (elm, offset2) => offset2 > 0 ? offset2 - 1 : offset2);
    const skipEmptyTextNodes = (node, forwards) => {
      const orig = node;
      while (node && isText$a(node) && node.length === 0) {
        node = forwards ? node.nextSibling : node.previousSibling;
      }
      return node || orig;
    };
    const getNode = (root2, rng) => {
      if (!rng) {
        return root2;
      }
      let startContainer = rng.startContainer;
      let endContainer = rng.endContainer;
      const startOffset = rng.startOffset;
      const endOffset = rng.endOffset;
      let node = rng.commonAncestorContainer;
      if (!rng.collapsed) {
        if (startContainer === endContainer) {
          if (endOffset - startOffset < 2) {
            if (startContainer.hasChildNodes()) {
              node = startContainer.childNodes[startOffset];
            }
          }
        }
        if (isText$a(startContainer) && isText$a(endContainer)) {
          if (startContainer.length === startOffset) {
            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);
          } else {
            startContainer = startContainer.parentNode;
          }
          if (endOffset === 0) {
            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);
          } else {
            endContainer = endContainer.parentNode;
          }
          if (startContainer && startContainer === endContainer) {
            node = startContainer;
          }
        }
      }
      const elm = isText$a(node) ? node.parentNode : node;
      return isElement$6(elm) ? elm : root2;
    };
    const getSelectedBlocks = (dom2, rng, startElm, endElm) => {
      const selectedBlocks = [];
      const root2 = dom2.getRoot();
      const start3 = dom2.getParent(startElm || getStart(root2, rng, rng.collapsed), dom2.isBlock);
      const end3 = dom2.getParent(endElm || getEnd$1(root2, rng, rng.collapsed), dom2.isBlock);
      if (start3 && start3 !== root2) {
        selectedBlocks.push(start3);
      }
      if (start3 && end3 && start3 !== end3) {
        let node;
        const walker = new DomTreeWalker(start3, root2);
        while ((node = walker.next()) && node !== end3) {
          if (dom2.isBlock(node)) {
            selectedBlocks.push(node);
          }
        }
      }
      if (end3 && start3 !== end3 && end3 !== root2) {
        selectedBlocks.push(end3);
      }
      return selectedBlocks;
    };
    const select = (dom2, node, content) => Optional.from(node).bind((node2) => Optional.from(node2.parentNode).map((parent2) => {
      const idx = dom2.nodeIndex(node2);
      const rng = dom2.createRng();
      rng.setStart(parent2, idx);
      rng.setEnd(parent2, idx + 1);
      if (content) {
        moveEndPoint(dom2, rng, node2, true);
        moveEndPoint(dom2, rng, node2, false);
      }
      return rng;
    }));
    const processRanges = (editor, ranges) => map$3(ranges, (range2) => {
      const evt = editor.dispatch("GetSelectionRange", { range: range2 });
      return evt.range !== range2 ? evt.range : range2;
    });
    const getEnd = (element) => name2(element) === "img" ? 1 : getOption(element).fold(() => children$1(element).length, (v) => v.length);
    const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text3) => text3.trim().length !== 0 || text3.indexOf(nbsp) > -1).isSome();
    const isContentEditableFalse$5 = (elem) => isHTMLElement2(elem) && get$9(elem, "contenteditable") === "false";
    const elementsWithCursorPosition = [
      "img",
      "br"
    ];
    const isCursorPosition = (elem) => {
      const hasCursorPosition = isTextNodeWithCursorPosition(elem);
      return hasCursorPosition || contains$2(elementsWithCursorPosition, name2(elem)) || isContentEditableFalse$5(elem);
    };
    const first = (element) => descendant$1(element, isCursorPosition);
    const last = (element) => descendantRtl(element, isCursorPosition);
    const descendantRtl = (scope, predicate) => {
      const descend2 = (element) => {
        const children2 = children$1(element);
        for (let i = children2.length - 1; i >= 0; i--) {
          const child2 = children2[i];
          if (predicate(child2)) {
            return Optional.some(child2);
          }
          const res2 = descend2(child2);
          if (res2.isSome()) {
            return res2;
          }
        }
        return Optional.none();
      };
      return descend2(scope);
    };
    const autocompleteSelector = "[data-mce-autocompleter]";
    const create$92 = (editor, range2) => {
      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {
        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter="1" data-mce-bogus="1"></span>', editor.getDoc());
        append$1(wrapper, SugarElement.fromDom(range2.extractContents()));
        range2.insertNode(wrapper.dom);
        parent(wrapper).each((elm) => elm.dom.normalize());
        last(wrapper).map((last2) => {
          editor.selection.setCursorLocation(last2.dom, getEnd(last2));
        });
      }
    };
    const detect$1 = (elm) => closest$3(elm, autocompleteSelector);
    const findIn = (elm) => descendant(elm, autocompleteSelector);
    const remove$3 = (editor, elm) => findIn(elm).each((wrapper) => {
      const bookmark = editor.selection.getBookmark();
      unwrap(wrapper);
      editor.selection.moveToBookmark(bookmark);
    });
    const typeLookup = {
      "#text": 3,
      "#comment": 8,
      "#cdata": 4,
      "#pi": 7,
      "#doctype": 10,
      "#document-fragment": 11
    };
    const walk$2 = (node, root2, prev2) => {
      const startName = prev2 ? "lastChild" : "firstChild";
      const siblingName = prev2 ? "prev" : "next";
      if (node[startName]) {
        return node[startName];
      }
      if (node !== root2) {
        let sibling2 = node[siblingName];
        if (sibling2) {
          return sibling2;
        }
        for (let parent2 = node.parent; parent2 && parent2 !== root2; parent2 = parent2.parent) {
          sibling2 = parent2[siblingName];
          if (sibling2) {
            return sibling2;
          }
        }
      }
      return void 0;
    };
    const isEmptyTextNode = (node) => {
      var _a;
      const text3 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
      if (!isWhitespaceText(text3)) {
        return false;
      }
      const parentNode = node.parent;
      if (parentNode && (parentNode.name !== "span" || parentNode.attr("style")) && /^[ ]+$/.test(text3)) {
        return false;
      }
      return true;
    };
    const isNonEmptyElement = (node) => {
      const isNamedAnchor2 = node.name === "a" && !node.attr("href") && node.attr("id");
      return node.attr("name") || node.attr("id") && !node.firstChild || node.attr("data-mce-bookmark") || isNamedAnchor2;
    };
    class AstNode {
      constructor(name3, type2) {
        this.name = name3;
        this.type = type2;
        if (type2 === 1) {
          this.attributes = [];
          this.attributes.map = {};
        }
      }
      static create(name3, attrs) {
        const node = new AstNode(name3, typeLookup[name3] || 1);
        if (attrs) {
          each$d(attrs, (value2, attrName) => {
            node.attr(attrName, value2);
          });
        }
        return node;
      }
      replace(node) {
        const self2 = this;
        if (node.parent) {
          node.remove();
        }
        self2.insert(node, self2);
        self2.remove();
        return self2;
      }
      attr(name3, value2) {
        const self2 = this;
        if (!isString2(name3)) {
          if (isNonNullable(name3)) {
            each$d(name3, (value3, key) => {
              self2.attr(key, value3);
            });
          }
          return self2;
        }
        const attrs = self2.attributes;
        if (attrs) {
          if (value2 !== void 0) {
            if (value2 === null) {
              if (name3 in attrs.map) {
                delete attrs.map[name3];
                let i = attrs.length;
                while (i--) {
                  if (attrs[i].name === name3) {
                    attrs.splice(i, 1);
                    return self2;
                  }
                }
              }
              return self2;
            }
            if (name3 in attrs.map) {
              let i = attrs.length;
              while (i--) {
                if (attrs[i].name === name3) {
                  attrs[i].value = value2;
                  break;
                }
              }
            } else {
              attrs.push({
                name: name3,
                value: value2
              });
            }
            attrs.map[name3] = value2;
            return self2;
          }
          return attrs.map[name3];
        }
        return void 0;
      }
      clone() {
        const self2 = this;
        const clone2 = new AstNode(self2.name, self2.type);
        const selfAttrs = self2.attributes;
        if (selfAttrs) {
          const cloneAttrs = [];
          cloneAttrs.map = {};
          for (let i = 0, l = selfAttrs.length; i < l; i++) {
            const selfAttr = selfAttrs[i];
            if (selfAttr.name !== "id") {
              cloneAttrs[cloneAttrs.length] = {
                name: selfAttr.name,
                value: selfAttr.value
              };
              cloneAttrs.map[selfAttr.name] = selfAttr.value;
            }
          }
          clone2.attributes = cloneAttrs;
        }
        clone2.value = self2.value;
        return clone2;
      }
      wrap(wrapper) {
        const self2 = this;
        if (self2.parent) {
          self2.parent.insert(wrapper, self2);
          wrapper.append(self2);
        }
        return self2;
      }
      unwrap() {
        const self2 = this;
        for (let node = self2.firstChild; node; ) {
          const next2 = node.next;
          self2.insert(node, self2, true);
          node = next2;
        }
        self2.remove();
      }
      remove() {
        const self2 = this, parent2 = self2.parent, next2 = self2.next, prev2 = self2.prev;
        if (parent2) {
          if (parent2.firstChild === self2) {
            parent2.firstChild = next2;
            if (next2) {
              next2.prev = null;
            }
          } else if (prev2) {
            prev2.next = next2;
          }
          if (parent2.lastChild === self2) {
            parent2.lastChild = prev2;
            if (prev2) {
              prev2.next = null;
            }
          } else if (next2) {
            next2.prev = prev2;
          }
          self2.parent = self2.next = self2.prev = null;
        }
        return self2;
      }
      append(node) {
        const self2 = this;
        if (node.parent) {
          node.remove();
        }
        const last2 = self2.lastChild;
        if (last2) {
          last2.next = node;
          node.prev = last2;
          self2.lastChild = node;
        } else {
          self2.lastChild = self2.firstChild = node;
        }
        node.parent = self2;
        return node;
      }
      insert(node, refNode, before2) {
        if (node.parent) {
          node.remove();
        }
        const parent2 = refNode.parent || this;
        if (before2) {
          if (refNode === parent2.firstChild) {
            parent2.firstChild = node;
          } else if (refNode.prev) {
            refNode.prev.next = node;
          }
          node.prev = refNode.prev;
          node.next = refNode;
          refNode.prev = node;
        } else {
          if (refNode === parent2.lastChild) {
            parent2.lastChild = node;
          } else if (refNode.next) {
            refNode.next.prev = node;
          }
          node.next = refNode.next;
          node.prev = refNode;
          refNode.next = node;
        }
        node.parent = parent2;
        return node;
      }
      getAll(name3) {
        const self2 = this;
        const collection = [];
        for (let node = self2.firstChild; node; node = walk$2(node, self2)) {
          if (node.name === name3) {
            collection.push(node);
          }
        }
        return collection;
      }
      children() {
        const self2 = this;
        const collection = [];
        for (let node = self2.firstChild; node; node = node.next) {
          collection.push(node);
        }
        return collection;
      }
      empty() {
        const self2 = this;
        if (self2.firstChild) {
          const nodes = [];
          for (let node = self2.firstChild; node; node = walk$2(node, self2)) {
            nodes.push(node);
          }
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
          }
        }
        self2.firstChild = self2.lastChild = null;
        return self2;
      }
      isEmpty(elements, whitespace = {}, predicate) {
        var _a;
        const self2 = this;
        let node = self2.firstChild;
        if (isNonEmptyElement(self2)) {
          return false;
        }
        if (node) {
          do {
            if (node.type === 1) {
              if (node.attr("data-mce-bogus")) {
                continue;
              }
              if (elements[node.name]) {
                return false;
              }
              if (isNonEmptyElement(node)) {
                return false;
              }
            }
            if (node.type === 8) {
              return false;
            }
            if (node.type === 3 && !isEmptyTextNode(node)) {
              return false;
            }
            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : "")) {
              return false;
            }
            if (predicate && predicate(node)) {
              return false;
            }
          } while (node = walk$2(node, self2));
        }
        return true;
      }
      walk(prev2) {
        return walk$2(this, null, prev2);
      }
    }
    const isConditionalComment = (html2, startIndex) => /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html2.substr(startIndex));
    const findCommentEndIndex = (html2, isBogus2, startIndex = 0) => {
      const lcHtml = html2.toLowerCase();
      if (lcHtml.indexOf("[if ", startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
        const endIfIndex = lcHtml.indexOf("[endif]", startIndex);
        return lcHtml.indexOf(">", endIfIndex);
      } else {
        if (isBogus2) {
          const endIndex = lcHtml.indexOf(">", startIndex);
          return endIndex !== -1 ? endIndex : lcHtml.length;
        } else {
          const endCommentRegexp = /--!?>/g;
          endCommentRegexp.lastIndex = startIndex;
          const match2 = endCommentRegexp.exec(html2);
          return match2 ? match2.index + match2[0].length : lcHtml.length;
        }
      }
    };
    const findMatchingEndTagIndex = (schema, html2, startIndex) => {
      const startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
      const endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
      const voidElements = schema.getVoidElements();
      let count2 = 1, index = startIndex;
      while (count2 !== 0) {
        startTagRegExp.lastIndex = index;
        while (true) {
          const startMatch = startTagRegExp.exec(html2);
          if (startMatch === null) {
            return index;
          } else if (startMatch[1] === "!") {
            if (startsWith(startMatch[2], "--")) {
              index = findCommentEndIndex(html2, false, startMatch.index + "!--".length);
            } else {
              index = findCommentEndIndex(html2, true, startMatch.index + 1);
            }
            break;
          } else {
            endTagRegExp.lastIndex = startTagRegExp.lastIndex;
            const endMatch = endTagRegExp.exec(html2);
            if (isNull2(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
              continue;
            }
            if (startMatch[1] === "/") {
              count2 -= 1;
            } else if (!has$2(voidElements, startMatch[2])) {
              count2 += 1;
            }
            index = startTagRegExp.lastIndex + endMatch[0].length;
            break;
          }
        }
      }
      return index;
    };
    const trimHtml$1 = (tempAttrs, html2) => {
      const trimContentRegExp = new RegExp(["\\s?(" + tempAttrs.join("|") + ')="[^"]+"'].join("|"), "gi");
      return html2.replace(trimContentRegExp, "");
    };
    const trimInternal = (serializer, html2) => {
      const bogusAllRegExp = /<(\w+) [^>]*data-mce-bogus="all"[^>]*>/g;
      const schema = serializer.schema;
      let content = trimHtml$1(serializer.getTempAttrs(), html2);
      const voidElements = schema.getVoidElements();
      let matches;
      while (matches = bogusAllRegExp.exec(content)) {
        const index = bogusAllRegExp.lastIndex;
        const matchLength = matches[0].length;
        let endTagIndex;
        if (voidElements[matches[1]]) {
          endTagIndex = index;
        } else {
          endTagIndex = findMatchingEndTagIndex(schema, content, index);
        }
        content = content.substring(0, index - matchLength) + content.substring(endTagIndex);
        bogusAllRegExp.lastIndex = index - matchLength;
      }
      return trim$12(content);
    };
    const trimExternal = trimInternal;
    const cleanupBogusElements = (parent2) => {
      const bogusElements = descendants(parent2, "[data-mce-bogus]");
      each$e(bogusElements, (elem) => {
        const bogusValue = get$9(elem, "data-mce-bogus");
        if (bogusValue === "all") {
          remove$6(elem);
        } else if (isBr$5(elem)) {
          before$3(elem, SugarElement.fromText(zeroWidth));
          remove$6(elem);
        } else {
          unwrap(elem);
        }
      });
    };
    const cleanupInputNames = (parent2) => {
      const inputs = descendants(parent2, "input");
      each$e(inputs, (input) => {
        remove$b(input, "name");
      });
    };
    const trimEmptyContents = (editor, html2) => {
      const blockName = getForcedRootBlock(editor);
      const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${blockName}>[\r
]*|<br \\/>[\r
]*)$`);
      return html2.replace(emptyRegExp, "");
    };
    const getPlainTextContent = (editor, body) => {
      const doc = editor.getDoc();
      const dos = getRootNode2(SugarElement.fromDom(editor.getBody()));
      const offscreenDiv = SugarElement.fromTag("div", doc);
      set$3(offscreenDiv, "data-mce-bogus", "all");
      setAll(offscreenDiv, {
        position: "fixed",
        left: "-9999999px",
        top: "0"
      });
      set$1(offscreenDiv, body.innerHTML);
      cleanupBogusElements(offscreenDiv);
      cleanupInputNames(offscreenDiv);
      const root2 = getContentContainer(dos);
      append$1(root2, offscreenDiv);
      const content = trim$12(offscreenDiv.dom.innerText);
      remove$6(offscreenDiv);
      return content;
    };
    const getContentFromBody = (editor, args, body) => {
      let content;
      if (args.format === "raw") {
        content = Tools.trim(trimExternal(editor.serializer, body.innerHTML));
      } else if (args.format === "text") {
        content = getPlainTextContent(editor, body);
      } else if (args.format === "tree") {
        content = editor.serializer.serialize(body, args);
      } else {
        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
      }
      const shouldTrim = args.format !== "text" && !isWsPreserveElement(SugarElement.fromDom(body));
      return shouldTrim && isString2(content) ? Tools.trim(content) : content;
    };
    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === "tree" ? new AstNode("body", 11) : ""), (body) => getContentFromBody(editor, args, body));
    const makeMap$1 = Tools.makeMap;
    const Writer = (settings) => {
      const html2 = [];
      settings = settings || {};
      const indent2 = settings.indent;
      const indentBefore = makeMap$1(settings.indent_before || "");
      const indentAfter = makeMap$1(settings.indent_after || "");
      const encode2 = Entities.getEncodeFunc(settings.entity_encoding || "raw", settings.entities);
      const htmlOutput = settings.element_format !== "xhtml";
      return {
        start: (name3, attrs, empty2) => {
          if (indent2 && indentBefore[name3] && html2.length > 0) {
            const value2 = html2[html2.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html2.push("\n");
            }
          }
          html2.push("<", name3);
          if (attrs) {
            for (let i = 0, l = attrs.length; i < l; i++) {
              const attr2 = attrs[i];
              html2.push(" ", attr2.name, '="', encode2(attr2.value, true), '"');
            }
          }
          if (!empty2 || htmlOutput) {
            html2[html2.length] = ">";
          } else {
            html2[html2.length] = " />";
          }
          if (empty2 && indent2 && indentAfter[name3] && html2.length > 0) {
            const value2 = html2[html2.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html2.push("\n");
            }
          }
        },
        end: (name3) => {
          let value2;
          html2.push("</", name3, ">");
          if (indent2 && indentAfter[name3] && html2.length > 0) {
            value2 = html2[html2.length - 1];
            if (value2.length > 0 && value2 !== "\n") {
              html2.push("\n");
            }
          }
        },
        text: (text3, raw) => {
          if (text3.length > 0) {
            html2[html2.length] = raw ? text3 : encode2(text3);
          }
        },
        cdata: (text3) => {
          html2.push("<![CDATA[", text3, "]]>");
        },
        comment: (text3) => {
          html2.push("<!--", text3, "-->");
        },
        pi: (name3, text3) => {
          if (text3) {
            html2.push("<?", name3, " ", encode2(text3), "?>");
          } else {
            html2.push("<?", name3, "?>");
          }
          if (indent2) {
            html2.push("\n");
          }
        },
        doctype: (text3) => {
          html2.push("<!DOCTYPE", text3, ">", indent2 ? "\n" : "");
        },
        reset: () => {
          html2.length = 0;
        },
        getContent: () => {
          return html2.join("").replace(/\n$/, "");
        }
      };
    };
    const HtmlSerializer = (settings = {}, schema = Schema()) => {
      const writer = Writer(settings);
      settings.validate = "validate" in settings ? settings.validate : true;
      const serialize = (node) => {
        const validate2 = settings.validate;
        const handlers = {
          3: (node2) => {
            var _a;
            writer.text((_a = node2.value) !== null && _a !== void 0 ? _a : "", node2.raw);
          },
          8: (node2) => {
            var _a;
            writer.comment((_a = node2.value) !== null && _a !== void 0 ? _a : "");
          },
          7: (node2) => {
            writer.pi(node2.name, node2.value);
          },
          10: (node2) => {
            var _a;
            writer.doctype((_a = node2.value) !== null && _a !== void 0 ? _a : "");
          },
          4: (node2) => {
            var _a;
            writer.cdata((_a = node2.value) !== null && _a !== void 0 ? _a : "");
          },
          11: (node2) => {
            let tempNode = node2;
            if (tempNode = tempNode.firstChild) {
              do {
                walk2(tempNode);
              } while (tempNode = tempNode.next);
            }
          }
        };
        writer.reset();
        const walk2 = (node2) => {
          var _a;
          const handler = handlers[node2.type];
          if (!handler) {
            const name3 = node2.name;
            const isEmpty3 = name3 in schema.getVoidElements();
            let attrs = node2.attributes;
            if (validate2 && attrs && attrs.length > 1) {
              const sortedAttrs = [];
              sortedAttrs.map = {};
              const elementRule = schema.getElementRule(node2.name);
              if (elementRule) {
                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {
                  const attrName = elementRule.attributesOrder[i];
                  if (attrName in attrs.map) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                for (let i = 0, l = attrs.length; i < l; i++) {
                  const attrName = attrs[i].name;
                  if (!(attrName in sortedAttrs.map)) {
                    const attrValue = attrs.map[attrName];
                    sortedAttrs.map[attrName] = attrValue;
                    sortedAttrs.push({
                      name: attrName,
                      value: attrValue
                    });
                  }
                }
                attrs = sortedAttrs;
              }
            }
            writer.start(name3, attrs, isEmpty3);
            if (!isEmpty3) {
              let child2 = node2.firstChild;
              if (child2) {
                if ((name3 === "pre" || name3 === "textarea") && child2.type === 3 && ((_a = child2.value) === null || _a === void 0 ? void 0 : _a[0]) === "\n") {
                  writer.text("\n", true);
                }
                do {
                  walk2(child2);
                } while (child2 = child2.next);
              }
              writer.end(name3);
            }
          } else {
            handler(node2);
          }
        };
        if (node.type === 1 && !settings.inner) {
          walk2(node);
        } else if (node.type === 3) {
          handlers[3](node);
        } else {
          handlers[11](node);
        }
        return writer.getContent();
      };
      return { serialize };
    };
    const nonInheritableStyles = /* @__PURE__ */ new Set();
    (() => {
      const nonInheritableStylesArr = [
        "margin",
        "margin-left",
        "margin-right",
        "margin-top",
        "margin-bottom",
        "padding",
        "padding-left",
        "padding-right",
        "padding-top",
        "padding-bottom",
        "border",
        "border-width",
        "border-style",
        "border-color",
        "background",
        "background-attachment",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "float",
        "position",
        "left",
        "right",
        "top",
        "bottom",
        "z-index",
        "display",
        "transform",
        "width",
        "max-width",
        "min-width",
        "height",
        "max-height",
        "min-height",
        "overflow",
        "overflow-x",
        "overflow-y",
        "text-overflow",
        "vertical-align",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ];
      each$e(nonInheritableStylesArr, (style) => {
        nonInheritableStyles.add(style);
      });
    })();
    const shorthandStyleProps = [
      "font",
      "text-decoration",
      "text-emphasis"
    ];
    const getStyleProps = (dom2, node) => keys(dom2.parseStyle(dom2.getAttrib(node, "style")));
    const isNonInheritableStyle = (style) => nonInheritableStyles.has(style);
    const hasInheritableStyles = (dom2, node) => forall(getStyleProps(dom2, node), (style) => !isNonInheritableStyle(style));
    const getLonghandStyleProps = (styles2) => filter$5(styles2, (style) => exists(shorthandStyleProps, (prop) => startsWith(style, prop)));
    const hasStyleConflict = (dom2, node, parentNode) => {
      const nodeStyleProps = getStyleProps(dom2, node);
      const parentNodeStyleProps = getStyleProps(dom2, parentNode);
      const valueMismatch = (prop) => {
        var _a, _b;
        const nodeValue = (_a = dom2.getStyle(node, prop)) !== null && _a !== void 0 ? _a : "";
        const parentValue = (_b = dom2.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : "";
        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;
      };
      return exists(nodeStyleProps, (nodeStyleProp) => {
        const propExists = (props) => exists(props, (prop) => prop === nodeStyleProp);
        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {
          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);
          return exists(longhandProps, valueMismatch);
        } else {
          return valueMismatch(nodeStyleProp);
        }
      });
    };
    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists((text3) => {
      const delta = forward ? 0 : -1;
      return predicate(text3.data.charAt(pos.offset() + delta));
    });
    const isBeforeSpace = curry(isChar, true, isWhiteSpace);
    const isAfterSpace = curry(isChar, false, isWhiteSpace);
    const isEmptyText = (pos) => {
      const container = pos.container();
      return isText$a(container) && (container.data.length === 0 || isZwsp(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));
    };
    const matchesElementPosition = (before2, predicate) => (pos) => getChildNodeAtRelativeOffset(before2 ? 0 : -1, pos).filter(predicate).isSome();
    const isImageBlock = (node) => isImg(node) && get$7(SugarElement.fromDom(node), "display") === "block";
    const isCefNode = (node) => isContentEditableFalse$b(node) && !isBogusAll$1(node);
    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);
    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);
    const isBeforeMedia = matchesElementPosition(true, isMedia$2);
    const isAfterMedia = matchesElementPosition(false, isMedia$2);
    const isBeforeTable = matchesElementPosition(true, isTable$2);
    const isAfterTable = matchesElementPosition(false, isTable$2);
    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);
    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);
    const dropLast = (xs) => xs.slice(0, -1);
    const parentsUntil = (start3, root2, predicate) => {
      if (contains2(root2, start3)) {
        return dropLast(parents$1(start3, (elm) => {
          return predicate(elm) || eq(elm, root2);
        }));
      } else {
        return [];
      }
    };
    const parents = (start3, root2) => parentsUntil(start3, root2, never);
    const parentsAndSelf = (start3, root2) => [start3].concat(parents(start3, root2));
    const navigateIgnoreEmptyTextNodes = (forward, root2, from2) => navigateIgnore(forward, root2, from2, isEmptyText);
    const getClosestBlock$1 = (root2, pos) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root2), isBlock$2);
    const isAtBeforeAfterBlockBoundary = (forward, root2, pos) => navigateIgnoreEmptyTextNodes(forward, root2.dom, pos).forall((newPos) => getClosestBlock$1(root2, pos).fold(() => !isInSameBlock(newPos, pos, root2.dom), (fromBlock) => !isInSameBlock(newPos, pos, root2.dom) && contains2(fromBlock, SugarElement.fromDom(newPos.container()))));
    const isAtBlockBoundary = (forward, root2, pos) => getClosestBlock$1(root2, pos).fold(() => navigateIgnoreEmptyTextNodes(forward, root2.dom, pos).forall((newPos) => !isInSameBlock(newPos, pos, root2.dom)), (parent2) => navigateIgnoreEmptyTextNodes(forward, parent2.dom, pos).isNone());
    const isAtStartOfBlock = curry(isAtBlockBoundary, false);
    const isAtEndOfBlock = curry(isAtBlockBoundary, true);
    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);
    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);
    const isBr$1 = (pos) => getElementFromPosition(pos).exists(isBr$5);
    const findBr = (forward, root2, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root2), isBlock$2);
      const scope = head(parentBlocks).getOr(root2);
      return fromPosition(forward, scope.dom, pos).filter(isBr$1);
    };
    const isBeforeBr$1 = (root2, pos) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root2, pos).isSome();
    const isAfterBr = (root2, pos) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root2, pos).isSome();
    const findPreviousBr = curry(findBr, false);
    const findNextBr = curry(findBr, true);
    const isInMiddleOfText = (pos) => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();
    const getClosestBlock = (root2, pos) => {
      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root2), isBlock$2);
      return head(parentBlocks).getOr(root2);
    };
    const hasSpaceBefore = (root2, pos) => {
      if (isInMiddleOfText(pos)) {
        return isAfterSpace(pos);
      } else {
        return isAfterSpace(pos) || prevPosition(getClosestBlock(root2, pos).dom, pos).exists(isAfterSpace);
      }
    };
    const hasSpaceAfter = (root2, pos) => {
      if (isInMiddleOfText(pos)) {
        return isBeforeSpace(pos);
      } else {
        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root2, pos).dom, pos).exists(isBeforeSpace);
      }
    };
    const isPreValue = (value2) => contains$2([
      "pre",
      "pre-wrap"
    ], value2);
    const isInPre = (pos) => getElementFromPosition(pos).bind((elm) => closest$4(elm, isElement$7)).exists((elm) => isPreValue(get$7(elm, "white-space")));
    const isAtBeginningOfBody = (root2, pos) => prevPosition(root2.dom, pos).isNone();
    const isAtEndOfBody = (root2, pos) => nextPosition(root2.dom, pos).isNone();
    const isAtLineBoundary = (root2, pos) => isAtBeginningOfBody(root2, pos) || isAtEndOfBody(root2, pos) || isAtStartOfBlock(root2, pos) || isAtEndOfBlock(root2, pos) || isAfterBr(root2, pos) || isBeforeBr$1(root2, pos);
    const isCefBlock = (node) => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);
    const isSiblingCefBlock = (root2, direction) => (container) => {
      return isCefBlock(new DomTreeWalker(container, root2)[direction]());
    };
    const isBeforeCefBlock = (root2, pos) => {
      const nextPos = nextPosition(root2.dom, pos).getOr(pos);
      const isNextCefBlock = isSiblingCefBlock(root2.dom, "next");
      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));
    };
    const isAfterCefBlock = (root2, pos) => {
      const prevPos = prevPosition(root2.dom, pos).getOr(pos);
      const isPrevCefBlock = isSiblingCefBlock(root2.dom, "prev");
      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));
    };
    const needsToHaveNbsp = (root2, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtLineBoundary(root2, pos) || hasSpaceBefore(root2, pos) || hasSpaceAfter(root2, pos);
      }
    };
    const needsToBeNbspLeft = (root2, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtStartOfBlock(root2, pos) || isBeforeBlock(root2, pos) || isAfterBr(root2, pos) || hasSpaceBefore(root2, pos) || isAfterCefBlock(root2, pos);
      }
    };
    const leanRight = (pos) => {
      const container = pos.container();
      const offset2 = pos.offset();
      if (isText$a(container) && offset2 < container.data.length) {
        return CaretPosition(container, offset2 + 1);
      } else {
        return pos;
      }
    };
    const needsToBeNbspRight = (root2, pos) => {
      if (isInPre(pos)) {
        return false;
      } else {
        return isAtEndOfBlock(root2, pos) || isAfterBlock(root2, pos) || isBeforeBr$1(root2, pos) || hasSpaceAfter(root2, pos) || isBeforeCefBlock(root2, pos);
      }
    };
    const needsToBeNbsp = (root2, pos) => needsToBeNbspLeft(root2, pos) || needsToBeNbspRight(root2, leanRight(pos));
    const isNbspAt = (text3, offset2) => isNbsp(text3.charAt(offset2));
    const isWhiteSpaceAt = (text3, offset2) => isWhiteSpace(text3.charAt(offset2));
    const hasNbsp = (pos) => {
      const container = pos.container();
      return isText$a(container) && contains$1(container.data, nbsp);
    };
    const normalizeNbspMiddle = (text3) => {
      const chars = text3.split("");
      return map$3(chars, (chr, i) => {
        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {
          return " ";
        } else {
          return chr;
        }
      }).join("");
    };
    const normalizeNbspAtStart = (root2, node, makeNbsp) => {
      const text3 = node.data;
      const firstPos = CaretPosition(node, 0);
      if (!makeNbsp && isNbspAt(text3, 0) && !needsToBeNbsp(root2, firstPos)) {
        node.data = " " + text3.slice(1);
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text3, 0) && needsToBeNbspLeft(root2, firstPos)) {
        node.data = nbsp + text3.slice(1);
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspInMiddleOfTextNode = (node) => {
      const text3 = node.data;
      const newText = normalizeNbspMiddle(text3);
      if (newText !== text3) {
        node.data = newText;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbspAtEnd = (root2, node, makeNbsp) => {
      const text3 = node.data;
      const lastPos = CaretPosition(node, text3.length - 1);
      if (!makeNbsp && isNbspAt(text3, text3.length - 1) && !needsToBeNbsp(root2, lastPos)) {
        node.data = text3.slice(0, -1) + " ";
        return true;
      } else if (makeNbsp && isWhiteSpaceAt(text3, text3.length - 1) && needsToBeNbspRight(root2, lastPos)) {
        node.data = text3.slice(0, -1) + nbsp;
        return true;
      } else {
        return false;
      }
    };
    const normalizeNbsps = (root2, pos) => {
      const container = pos.container();
      if (!isText$a(container)) {
        return Optional.none();
      }
      if (hasNbsp(pos)) {
        const normalized = normalizeNbspAtStart(root2, container, false) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root2, container, false);
        return someIf(normalized, pos);
      } else if (needsToBeNbsp(root2, pos)) {
        const normalized = normalizeNbspAtStart(root2, container, true) || normalizeNbspAtEnd(root2, container, true);
        return someIf(normalized, pos);
      } else {
        return Optional.none();
      }
    };
    const normalizeNbspsInEditor = (editor) => {
      const root2 = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        normalizeNbsps(root2, CaretPosition.fromRangeStart(editor.selection.getRng())).each((pos) => {
          editor.selection.setRng(pos.toRange());
        });
      }
    };
    const normalize$1 = (node, offset2, count2) => {
      if (count2 === 0) {
        return;
      }
      const elm = SugarElement.fromDom(node);
      const root2 = ancestor$4(elm, isBlock$2).getOr(elm);
      const whitespace = node.data.slice(offset2, offset2 + count2);
      const isEndOfContent = offset2 + count2 >= node.data.length && needsToBeNbspRight(root2, CaretPosition(node, node.data.length));
      const isStartOfContent = offset2 === 0 && needsToBeNbspLeft(root2, CaretPosition(node, 0));
      node.replaceData(offset2, count2, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));
    };
    const normalizeWhitespaceAfter = (node, offset2) => {
      const content = node.data.slice(offset2);
      const whitespaceCount = content.length - lTrim(content).length;
      normalize$1(node, offset2, whitespaceCount);
    };
    const normalizeWhitespaceBefore = (node, offset2) => {
      const content = node.data.slice(0, offset2);
      const whitespaceCount = content.length - rTrim(content).length;
      normalize$1(node, offset2 - whitespaceCount, whitespaceCount);
    };
    const mergeTextNodes = (prevNode, nextNode, normalizeWhitespace, mergeToPrev = true) => {
      const whitespaceOffset = rTrim(prevNode.data).length;
      const newNode = mergeToPrev ? prevNode : nextNode;
      const removeNode2 = mergeToPrev ? nextNode : prevNode;
      if (mergeToPrev) {
        newNode.appendData(removeNode2.data);
      } else {
        newNode.insertData(0, removeNode2.data);
      }
      remove$6(SugarElement.fromDom(removeNode2));
      if (normalizeWhitespace) {
        normalizeWhitespaceAfter(newNode, whitespaceOffset);
      }
      return newNode;
    };
    const needsReposition = (pos, elm) => {
      const container = pos.container();
      const offset2 = pos.offset();
      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset2 > CaretPosition.before(elm).offset();
    };
    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;
    const beforeOrStartOf = (node) => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);
    const afterOrEndOf = (node) => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);
    const getPreviousSiblingCaretPosition = (elm) => {
      if (isCaretCandidate$3(elm.previousSibling)) {
        return Optional.some(afterOrEndOf(elm.previousSibling));
      } else {
        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();
      }
    };
    const getNextSiblingCaretPosition = (elm) => {
      if (isCaretCandidate$3(elm.nextSibling)) {
        return Optional.some(beforeOrStartOf(elm.nextSibling));
      } else {
        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();
      }
    };
    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {
      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind((node) => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));
    };
    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));
    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));
    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));
    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);
    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));
    const setSelection$1 = (editor, forward, pos) => {
      pos.fold(() => {
        editor.focus();
      }, (pos2) => {
        editor.selection.setRng(pos2.toRange(), forward);
      });
    };
    const eqRawNode = (rawNode) => (elm) => elm.dom === rawNode;
    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name2(elm));
    const paddEmptyBlock = (elm) => {
      if (isEmpty$2(elm)) {
        const br = SugarElement.fromHtml('<br data-mce-bogus="1">');
        empty(elm);
        append$1(elm, br);
        return Optional.some(CaretPosition.before(br.dom));
      } else {
        return Optional.none();
      }
    };
    const deleteNormalized = (elm, afterDeletePosOpt, normalizeWhitespace) => {
      const prevTextOpt = prevSibling(elm).filter(isText$b);
      const nextTextOpt = nextSibling(elm).filter(isText$b);
      remove$6(elm);
      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev2, next2, pos) => {
        const prevNode = prev2.dom, nextNode = next2.dom;
        const offset2 = prevNode.data.length;
        mergeTextNodes(prevNode, nextNode, normalizeWhitespace);
        return pos.container() === nextNode ? CaretPosition(prevNode, offset2) : pos;
      }).orThunk(() => {
        if (normalizeWhitespace) {
          prevTextOpt.each((elm2) => normalizeWhitespaceBefore(elm2.dom, elm2.dom.length));
          nextTextOpt.each((elm2) => normalizeWhitespaceAfter(elm2.dom, 0));
        }
        return afterDeletePosOpt;
      });
    };
    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name2(element));
    const deleteElement$2 = (editor, forward, elm, moveCaret2 = true) => {
      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);
      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));
      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, isInlineElement(editor, elm));
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent("");
        editor.selection.setCursorLocation();
      } else {
        parentBlock.bind(paddEmptyBlock).fold(() => {
          if (moveCaret2) {
            setSelection$1(editor, forward, normalizedAfterDeletePos);
          }
        }, (paddPos) => {
          if (moveCaret2) {
            setSelection$1(editor, forward, Optional.some(paddPos));
          }
        });
      }
    };
    const strongRtl = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/;
    const hasStrongRtl = (text3) => strongRtl.test(text3);
    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);
    const isRtl = (element) => {
      var _a;
      return DOMUtils.DOM.getStyle(element, "direction", true) === "rtl" || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : "");
    };
    const findInlineParents = (isInlineTarget2, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), "*", rootNode), isInlineTarget2);
    const findRootInline = (isInlineTarget2, rootNode, pos) => {
      const parents2 = findInlineParents(isInlineTarget2, rootNode, pos);
      return Optional.from(parents2[parents2.length - 1]);
    };
    const hasSameParentBlock = (rootNode, node1, node2) => {
      const block1 = getParentBlock$3(node1, rootNode);
      const block2 = getParentBlock$3(node2, rootNode);
      return isNonNullable(block1) && block1 === block2;
    };
    const isAtZwsp = (pos) => isBeforeInline(pos) || isAfterInline(pos);
    const normalizePosition = (forward, pos) => {
      const container = pos.container(), offset2 = pos.offset();
      if (forward) {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.nextSibling)) {
            return CaretPosition(container.nextSibling, 0);
          } else {
            return CaretPosition.after(container);
          }
        } else {
          return isBeforeInline(pos) ? CaretPosition(container, offset2 + 1) : pos;
        }
      } else {
        if (isCaretContainerInline(container)) {
          if (isText$a(container.previousSibling)) {
            return CaretPosition(container.previousSibling, container.previousSibling.data.length);
          } else {
            return CaretPosition.before(container);
          }
        } else {
          return isAfterInline(pos) ? CaretPosition(container, offset2 - 1) : pos;
        }
      }
    };
    const normalizeForwards = curry(normalizePosition, true);
    const normalizeBackwards = curry(normalizePosition, false);
    const execCommandIgnoreInputEvents = (editor, command) => {
      const inputBlocker = (e) => e.stopImmediatePropagation();
      editor.on("beforeinput input", inputBlocker, true);
      editor.getDoc().execCommand(command);
      editor.off("beforeinput input", inputBlocker);
    };
    const execEditorDeleteCommand = (editor) => {
      editor.execCommand("delete");
    };
    const execNativeDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "Delete");
    const execNativeForwardDeleteCommand = (editor) => execCommandIgnoreInputEvents(editor, "ForwardDelete");
    const isBeforeRoot = (rootNode) => (elm) => is$2(parent(elm), rootNode, eq);
    const isTextBlockOrListItem = (element) => isTextBlock$2(element) || isListItem$1(element);
    const getParentBlock$2 = (rootNode, elm) => {
      if (contains2(rootNode, elm)) {
        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));
      } else {
        return Optional.none();
      }
    };
    const paddEmptyBody = (editor, moveSelection2 = true) => {
      if (editor.dom.isEmpty(editor.getBody())) {
        editor.setContent("", { no_selection: !moveSelection2 });
      }
    };
    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      const normalizedFromPos = normalizePosition(false, fromPos);
      if (forward) {
        return nextPosition(elm, normalizedFromPos).exists((nextPos) => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));
      } else {
        return prevPosition(elm, normalizedFromPos).exists((prevPos) => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));
      }
    }).getOr(true);
    const freefallRtl = (root2) => {
      const child2 = isComment$1(root2) ? prevSibling(root2) : lastChild(root2);
      return child2.bind(freefallRtl).orThunk(() => Optional.some(root2));
    };
    const deleteRangeContents = (editor, rng, root2, moveSelection2 = true) => {
      var _a;
      rng.deleteContents();
      const lastNode = freefallRtl(root2).getOr(root2);
      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root2.dom);
      if (lastBlock.dom === editor.getBody()) {
        paddEmptyBody(editor, moveSelection2);
      } else if (isEmpty$2(lastBlock)) {
        fillWithPaddingBr(lastBlock);
        if (moveSelection2) {
          editor.selection.setCursorLocation(lastBlock.dom, 0);
        }
      }
      if (!eq(root2, lastBlock)) {
        const additionalCleanupNodes = is$2(parent(lastBlock), root2) ? [] : siblings(lastBlock);
        each$e(additionalCleanupNodes.concat(children$1(root2)), (node) => {
          if (!eq(node, lastBlock) && !contains2(node, lastBlock) && isEmpty$2(node)) {
            remove$6(node);
          }
        });
      }
    };
    const isRootFromElement = (root2) => (cur) => eq(root2, cur);
    const getTableCells = (table2) => descendants(table2, "td,th");
    const getTableDetailsFromRange = (rng, isRoot2) => {
      const getTable2 = (node) => getClosestTable(SugarElement.fromDom(node), isRoot2);
      const startTable = getTable2(rng.startContainer);
      const endTable = getTable2(rng.endContainer);
      const isStartInTable = startTable.isSome();
      const isEndInTable = endTable.isSome();
      const isSameTable = lift2(startTable, endTable, eq).getOr(false);
      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;
      return {
        startTable,
        endTable,
        isStartInTable,
        isEndInTable,
        isSameTable,
        isMultiTable
      };
    };
    const tableCellRng = (start3, end3) => ({
      start: start3,
      end: end3
    });
    const tableSelection = (rng, table2, cells2) => ({
      rng,
      table: table2,
      cells: cells2
    });
    const deleteAction = Adt.generate([
      {
        singleCellTable: [
          "rng",
          "cell"
        ]
      },
      { fullTable: ["table"] },
      {
        partialTable: [
          "cells",
          "outsideDetails"
        ]
      },
      {
        multiTable: [
          "startTableCells",
          "endTableCells",
          "betweenRng"
        ]
      }
    ]);
    const getClosestCell$1 = (container, isRoot2) => closest$3(SugarElement.fromDom(container), "td,th", isRoot2);
    const isExpandedCellRng = (cellRng) => !eq(cellRng.start, cellRng.end);
    const getTableFromCellRng = (cellRng, isRoot2) => getClosestTable(cellRng.start, isRoot2).bind((startParentTable) => getClosestTable(cellRng.end, isRoot2).bind((endParentTable) => someIf(eq(startParentTable, endParentTable), startParentTable)));
    const isSingleCellTable = (cellRng, isRoot2) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot2).exists((table2) => {
      const rows = table2.dom.rows;
      return rows.length === 1 && rows[0].cells.length === 1;
    });
    const getCellRng = (rng, isRoot2) => {
      const startCell = getClosestCell$1(rng.startContainer, isRoot2);
      const endCell = getClosestCell$1(rng.endContainer, isRoot2);
      return lift2(startCell, endCell, tableCellRng);
    };
    const getCellRangeFromStartTable = (isRoot2) => (startCell) => getClosestTable(startCell, isRoot2).bind((table2) => last$3(getTableCells(table2)).map((endCell) => tableCellRng(startCell, endCell)));
    const getCellRangeFromEndTable = (isRoot2) => (endCell) => getClosestTable(endCell, isRoot2).bind((table2) => head(getTableCells(table2)).map((startCell) => tableCellRng(startCell, endCell)));
    const getTableSelectionFromCellRng = (isRoot2) => (cellRng) => getTableFromCellRng(cellRng, isRoot2).map((table2) => tableSelection(cellRng, table2, getTableCells(table2)));
    const getTableSelections = (cellRng, selectionDetails, rng, isRoot2) => {
      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {
        return Optional.none();
      } else if (selectionDetails.isSameTable) {
        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot2));
        return Optional.some({
          start: sameTableSelection,
          end: sameTableSelection
        });
      } else {
        const startCell = getClosestCell$1(rng.startContainer, isRoot2);
        const endCell = getClosestCell$1(rng.endContainer, isRoot2);
        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot2)).bind(getTableSelectionFromCellRng(isRoot2));
        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot2)).bind(getTableSelectionFromCellRng(isRoot2));
        return Optional.some({
          start: startTableSelection,
          end: endTableSelection
        });
      }
    };
    const getCellIndex = (cells2, cell2) => findIndex$2(cells2, (x) => eq(x, cell2));
    const getSelectedCells = (tableSelection2) => lift2(getCellIndex(tableSelection2.cells, tableSelection2.rng.start), getCellIndex(tableSelection2.cells, tableSelection2.rng.end), (startIndex, endIndex) => tableSelection2.cells.slice(startIndex, endIndex + 1));
    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot2) => optCellRng.exists((cellRng) => isSingleCellTable(cellRng, isRoot2) && hasAllContentsSelected(cellRng.start, rng));
    const unselectCells = (rng, selectionDetails) => {
      const { startTable, endTable } = selectionDetails;
      const otherContentRng = rng.cloneRange();
      startTable.each((table2) => otherContentRng.setStartAfter(table2.dom));
      endTable.each((table2) => otherContentRng.setEndBefore(table2.dom));
      return otherContentRng;
    };
    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot2) => getTableSelections(cellRng, selectionDetails, rng, isRoot2).bind(({ start: start3, end: end3 }) => start3.or(end3)).bind((tableSelection2) => {
      const { isSameTable } = selectionDetails;
      const selectedCells = getSelectedCells(tableSelection2).getOr([]);
      if (isSameTable && tableSelection2.cells.length === selectedCells.length) {
        return Optional.some(deleteAction.fullTable(tableSelection2.table));
      } else if (selectedCells.length > 0) {
        if (isSameTable) {
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));
        } else {
          const otherContentRng = unselectCells(rng, selectionDetails);
          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({
            ...selectionDetails,
            rng: otherContentRng
          })));
        }
      } else {
        return Optional.none();
      }
    });
    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot2) => getTableSelections(cellRng, selectionDetails, rng, isRoot2).bind(({ start: start3, end: end3 }) => {
      const startTableSelectedCells = start3.bind(getSelectedCells).getOr([]);
      const endTableSelectedCells = end3.bind(getSelectedCells).getOr([]);
      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {
        const otherContentRng = unselectCells(rng, selectionDetails);
        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));
      } else {
        return Optional.none();
      }
    });
    const getActionFromRange = (root2, rng) => {
      const isRoot2 = isRootFromElement(root2);
      const optCellRng = getCellRng(rng, isRoot2);
      const selectionDetails = getTableDetailsFromRange(rng, isRoot2);
      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot2)) {
        return optCellRng.map((cellRng) => deleteAction.singleCellTable(rng, cellRng.start));
      } else if (selectionDetails.isMultiTable) {
        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot2);
      } else {
        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot2);
      }
    };
    const cleanCells = (cells2) => each$e(cells2, (cell2) => {
      remove$b(cell2, "contenteditable");
      fillWithPaddingBr(cell2);
    });
    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);
    const handleEmptyBlock = (editor, startInTable, emptyBlock2) => {
      emptyBlock2.each((block) => {
        if (startInTable) {
          remove$6(block);
        } else {
          fillWithPaddingBr(block);
          editor.selection.setCursorLocation(block.dom, 0);
        }
      });
    };
    const deleteContentInsideCell = (editor, cell2, rng, isFirstCellInSelection) => {
      const insideTableRng = rng.cloneRange();
      if (isFirstCellInSelection) {
        insideTableRng.setStart(rng.startContainer, rng.startOffset);
        insideTableRng.setEndAfter(cell2.dom.lastChild);
      } else {
        insideTableRng.setStartBefore(cell2.dom.firstChild);
        insideTableRng.setEnd(rng.endContainer, rng.endOffset);
      }
      deleteCellContents(editor, insideTableRng, cell2, false).each((action2) => action2());
    };
    const collapseAndRestoreCellSelection = (editor) => {
      const selectedCells = getCellsFromEditor(editor);
      const selectedNode = SugarElement.fromDom(editor.selection.getNode());
      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {
        editor.selection.setCursorLocation(selectedNode.dom, 0);
      } else {
        editor.selection.collapse(true);
      }
      if (selectedCells.length > 1 && exists(selectedCells, (cell2) => eq(cell2, selectedNode))) {
        set$3(selectedNode, "data-mce-selected", "1");
      }
    };
    const emptySingleTableCells = (editor, cells2, outsideDetails) => Optional.some(() => {
      const editorRng = editor.selection.getRng();
      const cellsToClean = outsideDetails.bind(({ rng, isStartInTable }) => {
        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);
        rng.deleteContents();
        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));
        const endPointCell = isStartInTable ? cells2[0] : cells2[cells2.length - 1];
        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);
        if (!isEmpty$2(endPointCell)) {
          return Optional.some(isStartInTable ? cells2.slice(1) : cells2.slice(0, -1));
        } else {
          return Optional.none();
        }
      }).getOr(cells2);
      cleanCells(cellsToClean);
      collapseAndRestoreCellSelection(editor);
    });
    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {
      const rng = editor.selection.getRng();
      const startCell = startTableCells[0];
      const endCell = endTableCells[endTableCells.length - 1];
      deleteContentInsideCell(editor, startCell, rng, true);
      deleteContentInsideCell(editor, endCell, rng, false);
      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);
      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);
      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));
      betweenRng.deleteContents();
      collapseAndRestoreCellSelection(editor);
    });
    const deleteCellContents = (editor, rng, cell2, moveSelection2 = true) => Optional.some(() => {
      deleteRangeContents(editor, rng, cell2, moveSelection2);
    });
    const deleteTableElement = (editor, table2) => Optional.some(() => deleteElement$2(editor, false, table2));
    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind((action2) => action2.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));
    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);
    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), (caption) => deleteCaptionRange(editor, caption));
    const deleteRange$3 = (editor, startElm, selectedCells) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);
    };
    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);
    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag("caption"));
    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from2) => navigate(forward, editor.getBody(), from2).bind((to2) => getParentCell(rootElm, SugarElement.fromDom(to2.getNode())).bind((toCell) => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop2)));
    const emptyElement = (editor, elm) => Optional.some(() => {
      fillWithPaddingBr(elm);
      editor.selection.setCursorLocation(elm.dom, 0);
    });
    const isDeleteOfLastCharPos = (fromCaption, forward, from2, to2) => firstPositionIn(fromCaption.dom).bind((first2) => lastPositionIn(fromCaption.dom).map((last2) => forward ? from2.isEqual(first2) && to2.isEqual(last2) : from2.isEqual(last2) && to2.isEqual(first2))).getOr(true);
    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);
    const validateCaretCaption = (rootElm, fromCaption, to2) => getParentCaption(rootElm, SugarElement.fromDom(to2.getNode())).fold(() => Optional.some(noop2), (toCaption) => someIf(!eq(toCaption, fromCaption), noop2));
    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from2) => navigate(forward, editor.getBody(), from2).fold(() => Optional.some(noop2), (to2) => isDeleteOfLastCharPos(fromCaption, forward, from2, to2) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to2));
    const deleteCaretCells = (editor, forward, rootElm, startElm) => {
      const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getParentCell(rootElm, startElm).bind((fromCell) => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from2));
    };
    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {
      const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from2);
    };
    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);
    const isBeforeOrAfterTable = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists((pos) => isNearTable(forward, pos));
    };
    const deleteCaret$3 = (editor, forward, startElm) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop2)), (fromCaption) => deleteCaretCaption(editor, forward, rootElm, fromCaption));
    };
    const backspaceDelete$9 = (editor, forward) => {
      const startElm = SugarElement.fromDom(editor.selection.getStart(true));
      const cells2 = getCellsFromEditor(editor);
      return editor.selection.isCollapsed() && cells2.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells2);
    };
    const getContentEditableRoot$1 = (root2, node) => {
      let tempNode = node;
      while (tempNode && tempNode !== root2) {
        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {
          return tempNode;
        }
        tempNode = tempNode.parentNode;
      }
      return null;
    };
    const internalAttributesPrefixes = [
      "data-ephox-",
      "data-mce-",
      "data-alloy-",
      "data-snooker-",
      "_"
    ];
    const each$9 = Tools.each;
    const ElementUtils = (editor) => {
      const dom2 = editor.dom;
      const internalAttributes = new Set(editor.serializer.getTempAttrs());
      const compare = (node1, node2) => {
        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {
          return false;
        }
        const getAttribs = (node) => {
          const attribs = {};
          each$9(dom2.getAttribs(node), (attr2) => {
            const name3 = attr2.nodeName.toLowerCase();
            if (name3 !== "style" && !isAttributeInternal(name3)) {
              attribs[name3] = dom2.getAttrib(node, name3);
            }
          });
          return attribs;
        };
        const compareObjects = (obj1, obj2) => {
          for (const name3 in obj1) {
            if (has$2(obj1, name3)) {
              const value2 = obj2[name3];
              if (isUndefined2(value2)) {
                return false;
              }
              if (obj1[name3] !== value2) {
                return false;
              }
              delete obj2[name3];
            }
          }
          for (const name3 in obj2) {
            if (has$2(obj2, name3)) {
              return false;
            }
          }
          return true;
        };
        if (isElement$6(node1) && isElement$6(node2)) {
          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {
            return false;
          }
          if (!compareObjects(dom2.parseStyle(dom2.getAttrib(node1, "style")), dom2.parseStyle(dom2.getAttrib(node2, "style")))) {
            return false;
          }
        }
        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);
      };
      const isAttributeInternal = (attributeName) => exists(internalAttributesPrefixes, (value2) => startsWith(attributeName, value2)) || internalAttributes.has(attributeName);
      return {
        compare,
        isAttributeInternal
      };
    };
    const traverse = (root2, fn3) => {
      let node = root2;
      while (node = node.walk()) {
        fn3(node);
      }
    };
    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {
      const name3 = node.name;
      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {
        const filter3 = nodeFilters[ni];
        if (filter3.name === name3) {
          const match2 = matches.nodes[name3];
          if (match2) {
            match2.nodes.push(node);
          } else {
            matches.nodes[name3] = {
              filter: filter3,
              nodes: [node]
            };
          }
        }
      }
      if (node.attributes) {
        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {
          const filter3 = attributeFilters[ai];
          const attrName = filter3.name;
          if (attrName in node.attributes.map) {
            const match2 = matches.attributes[attrName];
            if (match2) {
              match2.nodes.push(node);
            } else {
              matches.attributes[attrName] = {
                filter: filter3,
                nodes: [node]
              };
            }
          }
        }
      }
    };
    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {
      const matches = {
        nodes: {},
        attributes: {}
      };
      if (node.firstChild) {
        traverse(node, (childNode) => {
          matchNode$1(nodeFilters, attributeFilters, childNode, matches);
        });
      }
      return matches;
    };
    const runFilters = (matches, args) => {
      const run2 = (matchRecord, filteringAttributes) => {
        each$d(matchRecord, (match2) => {
          const nodes = from(match2.nodes);
          each$e(match2.filter.callbacks, (callback) => {
            for (let i = nodes.length - 1; i >= 0; i--) {
              const node = nodes[i];
              const valueMatches = filteringAttributes ? node.attr(match2.filter.name) !== void 0 : node.name === match2.filter.name;
              if (!valueMatches || isNullable(node.parent)) {
                nodes.splice(i, 1);
              }
            }
            if (nodes.length > 0) {
              callback(nodes, match2.filter.name, args);
            }
          });
        });
      };
      run2(matches.nodes, false);
      run2(matches.attributes, true);
    };
    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {
      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);
      runFilters(matches, args);
    };
    const paddEmptyNode = (args, isBlock2, node) => {
      if (args.insert && isBlock2(node)) {
        const astNode = new AstNode("br", 1);
        astNode.attr("data-mce-bogus", "1");
        node.empty().append(astNode);
      } else {
        node.empty().append(new AstNode("#text", 3)).value = nbsp;
      }
    };
    const isPaddedWithNbsp = (node) => {
      var _a;
      return hasOnlyChild(node, "#text") && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;
    };
    const hasOnlyChild = (node, name3) => {
      const firstChild2 = node === null || node === void 0 ? void 0 : node.firstChild;
      return isNonNullable(firstChild2) && firstChild2 === node.lastChild && firstChild2.name === name3;
    };
    const isPadded = (schema, node) => {
      const rule = schema.getElementRule(node.name);
      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;
    };
    const isEmpty2 = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, (node2) => isPadded(schema, node2));
    const isLineBreakNode = (node, isBlock2) => isNonNullable(node) && (isBlock2(node) || node.name === "br");
    const findClosestEditingHost = (scope) => {
      let editableNode;
      for (let node = scope; node; node = node.parent) {
        const contentEditable = node.attr("contenteditable");
        if (contentEditable === "false") {
          break;
        } else if (contentEditable === "true") {
          editableNode = node;
        }
      }
      return Optional.from(editableNode);
    };
    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {
      if (schema.getSpecialElements()[node.name]) {
        node.empty().remove();
      } else {
        const children2 = node.children();
        for (const childNode of children2) {
          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {
            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);
          }
        }
        node.unwrap();
      }
    };
    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop2) => {
      const textBlockElements = schema.getTextBlockElements();
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const nonSplittableElements = Tools.makeMap("tr,td,th,tbody,thead,tfoot,table");
      const fixed = /* @__PURE__ */ new Set();
      const isSplittableElement = (node) => node !== rootNode && !nonSplittableElements[node.name];
      for (let ni = 0; ni < nodes.length; ni++) {
        const node = nodes[ni];
        let parent2;
        let newParent;
        let tempNode;
        if (!node.parent || fixed.has(node)) {
          continue;
        }
        if (textBlockElements[node.name] && node.parent.name === "li") {
          let sibling2 = node.next;
          while (sibling2) {
            if (textBlockElements[sibling2.name]) {
              sibling2.name = "li";
              fixed.add(sibling2);
              node.parent.insert(sibling2, node.parent);
            } else {
              break;
            }
            sibling2 = sibling2.next;
          }
          node.unwrap();
          continue;
        }
        const parents2 = [node];
        for (parent2 = node.parent; parent2 && !schema.isValidChild(parent2.name, node.name) && isSplittableElement(parent2); parent2 = parent2.parent) {
          parents2.push(parent2);
        }
        if (parent2 && parents2.length > 1) {
          if (schema.isValidChild(parent2.name, node.name)) {
            parents2.reverse();
            newParent = parents2[0].clone();
            onCreate(newParent);
            let currentNode = newParent;
            for (let i = 0; i < parents2.length - 1; i++) {
              if (schema.isValidChild(currentNode.name, parents2[i].name) && i > 0) {
                tempNode = parents2[i].clone();
                onCreate(tempNode);
                currentNode.append(tempNode);
              } else {
                tempNode = currentNode;
              }
              for (let childNode = parents2[i].firstChild; childNode && childNode !== parents2[i + 1]; ) {
                const nextNode = childNode.next;
                tempNode.append(childNode);
                childNode = nextNode;
              }
              currentNode = tempNode;
            }
            if (!isEmpty2(schema, nonEmptyElements, whitespaceElements, newParent)) {
              parent2.insert(newParent, parents2[0], true);
              parent2.insert(node, newParent);
            } else {
              parent2.insert(node, parents2[0], true);
            }
            parent2 = parents2[0];
            if (isEmpty2(schema, nonEmptyElements, whitespaceElements, parent2) || hasOnlyChild(parent2, "br")) {
              parent2.empty().remove();
            }
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        } else if (node.parent) {
          if (node.name === "li") {
            let sibling2 = node.prev;
            if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol")) {
              sibling2.append(node);
              continue;
            }
            sibling2 = node.next;
            if (sibling2 && (sibling2.name === "ul" || sibling2.name === "ol") && sibling2.firstChild) {
              sibling2.insert(node, sibling2.firstChild, true);
              continue;
            }
            const wrapper = new AstNode("ul", 1);
            onCreate(wrapper);
            node.wrap(wrapper);
            continue;
          }
          if (schema.isValidChild(node.parent.name, "div") && schema.isValidChild("div", node.name)) {
            const wrapper = new AstNode("div", 1);
            onCreate(wrapper);
            node.wrap(wrapper);
          } else {
            removeOrUnwrapInvalidNode(node, schema);
          }
        }
      }
    };
    const hasClosest = (node, parentName) => {
      let tempNode = node;
      while (tempNode) {
        if (tempNode.name === parentName) {
          return true;
        }
        tempNode = tempNode.parent;
      }
      return false;
    };
    const isInvalid = (schema, node, parent2 = node.parent) => {
      if (parent2 && schema.children[node.name] && !schema.isValidChild(parent2.name, node.name)) {
        return true;
      } else if (parent2 && node.name === "a" && hasClosest(parent2, "a")) {
        return true;
      } else {
        return false;
      }
    };
    const createRange = (sc, so, ec, eo) => {
      const rng = document.createRange();
      rng.setStart(sc, so);
      rng.setEnd(ec, eo);
      return rng;
    };
    const normalizeBlockSelectionRange = (rng) => {
      const startPos = CaretPosition.fromRangeStart(rng);
      const endPos = CaretPosition.fromRangeEnd(rng);
      const rootNode = rng.commonAncestorContainer;
      return fromPosition(false, rootNode, endPos).map((newEndPos) => {
        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {
          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());
        } else {
          return rng;
        }
      }).getOr(rng);
    };
    const normalize = (rng) => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);
    const hasOnlyOneChild = (node) => {
      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;
    };
    const isPaddingNode = (node) => {
      return node.name === "br" || node.value === nbsp;
    };
    const isPaddedEmptyBlock = (schema, node) => {
      const blockElements = schema.getBlockElements();
      return blockElements[node.name] && hasOnlyOneChild(node) && isPaddingNode(node.firstChild);
    };
    const isEmptyFragmentElement = (schema, node) => {
      const nonEmptyElements = schema.getNonEmptyElements();
      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));
    };
    const isListFragment = (schema, fragment) => {
      let firstChild2 = fragment.firstChild;
      let lastChild2 = fragment.lastChild;
      if (firstChild2 && firstChild2.name === "meta") {
        firstChild2 = firstChild2.next;
      }
      if (lastChild2 && lastChild2.attr("id") === "mce_marker") {
        lastChild2 = lastChild2.prev;
      }
      if (isEmptyFragmentElement(schema, lastChild2)) {
        lastChild2 = lastChild2 === null || lastChild2 === void 0 ? void 0 : lastChild2.prev;
      }
      if (!firstChild2 || firstChild2 !== lastChild2) {
        return false;
      }
      return firstChild2.name === "ul" || firstChild2.name === "ol";
    };
    const cleanupDomFragment = (domFragment) => {
      var _a, _b;
      const firstChild2 = domFragment.firstChild;
      const lastChild2 = domFragment.lastChild;
      if (firstChild2 && firstChild2.nodeName === "META") {
        (_a = firstChild2.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild2);
      }
      if (lastChild2 && lastChild2.id === "mce_marker") {
        (_b = lastChild2.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild2);
      }
      return domFragment;
    };
    const toDomFragment = (dom2, serializer, fragment) => {
      const html2 = serializer.serialize(fragment);
      const domFragment = dom2.createFragment(html2);
      return cleanupDomFragment(domFragment);
    };
    const listItems = (elm) => {
      var _a;
      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], (child2) => {
        return child2.nodeName === "LI";
      });
    };
    const isPadding = (node) => {
      return node.data === nbsp || isBr$6(node);
    };
    const isListItemPadded = (node) => {
      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);
    };
    const isEmptyOrPadded = (elm) => {
      return !elm.firstChild || isListItemPadded(elm);
    };
    const trimListItems = (elms) => {
      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;
    };
    const getParentLi = (dom2, node) => {
      const parentBlock = dom2.getParent(node, dom2.isBlock);
      return parentBlock && parentBlock.nodeName === "LI" ? parentBlock : null;
    };
    const isParentBlockLi = (dom2, node) => {
      return !!getParentLi(dom2, node);
    };
    const getSplit = (parentNode, rng) => {
      const beforeRng = rng.cloneRange();
      const afterRng = rng.cloneRange();
      beforeRng.setStartBefore(parentNode);
      afterRng.setEndAfter(parentNode);
      return [
        beforeRng.cloneContents(),
        afterRng.cloneContents()
      ];
    };
    const findFirstIn = (node, rootNode) => {
      const caretPos = CaretPosition.before(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.next(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const findLastOf = (node, rootNode) => {
      const caretPos = CaretPosition.after(node);
      const caretWalker = CaretWalker(rootNode);
      const newCaretPos = caretWalker.prev(caretPos);
      return newCaretPos ? newCaretPos.toRange() : null;
    };
    const insertMiddle = (target, elms, rootNode, rng) => {
      const parts = getSplit(target, rng);
      const parentElm = target.parentNode;
      if (parentElm) {
        parentElm.insertBefore(parts[0], target);
        Tools.each(elms, (li) => {
          parentElm.insertBefore(li, target);
        });
        parentElm.insertBefore(parts[1], target);
        parentElm.removeChild(target);
      }
      return findLastOf(elms[elms.length - 1], rootNode);
    };
    const insertBefore$1 = (target, elms, rootNode) => {
      const parentElm = target.parentNode;
      if (parentElm) {
        Tools.each(elms, (elm) => {
          parentElm.insertBefore(elm, target);
        });
      }
      return findFirstIn(target, rootNode);
    };
    const insertAfter$1 = (target, elms, rootNode, dom2) => {
      dom2.insertAfter(elms.reverse(), target);
      return findLastOf(elms[0], rootNode);
    };
    const insertAtCaret$1 = (serializer, dom2, rng, fragment) => {
      const domFragment = toDomFragment(dom2, serializer, fragment);
      const liTarget = getParentLi(dom2, rng.startContainer);
      const liElms = trimListItems(listItems(domFragment.firstChild));
      const BEGINNING = 1, END = 2;
      const rootNode = dom2.getRoot();
      const isAt = (location2) => {
        const caretPos = CaretPosition.fromRangeStart(rng);
        const caretWalker = CaretWalker(dom2.getRoot());
        const newPos = location2 === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);
        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();
        return newPosNode ? getParentLi(dom2, newPosNode) !== liTarget : true;
      };
      if (!liTarget) {
        return null;
      } else if (isAt(BEGINNING)) {
        return insertBefore$1(liTarget, liElms, rootNode);
      } else if (isAt(END)) {
        return insertAfter$1(liTarget, liElms, rootNode, dom2);
      } else {
        return insertMiddle(liTarget, liElms, rootNode, rng);
      }
    };
    const mergeableWrappedElements = ["pre"];
    const shouldPasteContentOnly = (dom2, fragment, parentNode, root2) => {
      var _a;
      const firstNode = fragment.firstChild;
      const lastNode = fragment.lastChild;
      const last2 = lastNode.attr("data-mce-type") === "bookmark" ? lastNode.prev : lastNode;
      const isPastingSingleElement = firstNode === last2;
      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);
      if (isPastingSingleElement && isWrappedElement) {
        const isContentEditable2 = firstNode.attr("contenteditable") !== "false";
        const isPastingInTheSameBlockTag = ((_a = dom2.getParent(parentNode, dom2.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;
        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root2, parentNode)).forall(isContentEditableTrue$3);
        return isContentEditable2 && isPastingInTheSameBlockTag && isPastingInContentEditable;
      } else {
        return false;
      }
    };
    const isTableCell = isTableCell$3;
    const isTableCellContentSelected = (dom2, rng, cell2) => {
      if (isNonNullable(cell2)) {
        const endCell = dom2.getParent(rng.endContainer, isTableCell);
        return cell2 === endCell && hasAllContentsSelected(SugarElement.fromDom(cell2), rng);
      } else {
        return false;
      }
    };
    const validInsertion = (editor, value2, parentNode) => {
      var _a;
      if (parentNode.getAttribute("data-mce-bogus") === "all") {
        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value2), parentNode);
      } else {
        const node = parentNode.firstChild;
        const node2 = parentNode.lastChild;
        if (!node || node === node2 && node.nodeName === "BR") {
          editor.dom.setHTML(parentNode, value2);
        } else {
          editor.selection.setContent(value2, { no_events: true });
        }
      }
    };
    const trimBrsFromTableCell = (dom2, elm) => {
      Optional.from(dom2.getParent(elm, "td,th")).map(SugarElement.fromDom).each(trimBlockTrailingBr);
    };
    const reduceInlineTextElements = (editor, merge3) => {
      const textInlineElements = editor.schema.getTextInlineElements();
      const dom2 = editor.dom;
      if (merge3) {
        const root2 = editor.getBody();
        const elementUtils = ElementUtils(editor);
        Tools.each(dom2.select("*[data-mce-fragment]"), (node) => {
          const isInline2 = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);
          if (isInline2 && hasInheritableStyles(dom2, node)) {
            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root2; parentNode = parentNode.parentElement) {
              const styleConflict = hasStyleConflict(dom2, node, parentNode);
              if (styleConflict) {
                break;
              }
              if (elementUtils.compare(parentNode, node)) {
                dom2.remove(node, true);
                break;
              }
            }
          }
        });
      }
    };
    const markFragmentElements = (fragment) => {
      let node = fragment;
      while (node = node.walk()) {
        if (node.type === 1) {
          node.attr("data-mce-fragment", "1");
        }
      }
    };
    const unmarkFragmentElements = (elm) => {
      Tools.each(elm.getElementsByTagName("*"), (elm2) => {
        elm2.removeAttribute("data-mce-fragment");
      });
    };
    const isPartOfFragment = (node) => {
      return !!node.getAttribute("data-mce-fragment");
    };
    const canHaveChildren = (editor, node) => {
      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];
    };
    const moveSelectionToMarker = (editor, marker) => {
      var _a, _b, _c;
      let nextRng;
      const dom2 = editor.dom;
      const selection = editor.selection;
      if (!marker) {
        return;
      }
      selection.scrollIntoView(marker);
      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);
      if (parentEditableElm && dom2.getContentEditable(parentEditableElm) === "false") {
        dom2.remove(marker);
        selection.select(parentEditableElm);
        return;
      }
      let rng = dom2.createRng();
      const node = marker.previousSibling;
      if (isText$a(node)) {
        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        const node2 = marker.nextSibling;
        if (isText$a(node2)) {
          node.appendData(node2.data);
          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);
        }
      } else {
        rng.setStartBefore(marker);
        rng.setEndBefore(marker);
      }
      const findNextCaretRng = (rng2) => {
        let caretPos = CaretPosition.fromRangeStart(rng2);
        const caretWalker = CaretWalker(editor.getBody());
        caretPos = caretWalker.next(caretPos);
        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();
      };
      const parentBlock = dom2.getParent(marker, dom2.isBlock);
      dom2.remove(marker);
      if (parentBlock && dom2.isEmpty(parentBlock)) {
        empty(SugarElement.fromDom(parentBlock));
        rng.setStart(parentBlock, 0);
        rng.setEnd(parentBlock, 0);
        if (!isTableCell(parentBlock) && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {
          rng = nextRng;
          dom2.remove(parentBlock);
        } else {
          dom2.add(parentBlock, dom2.create("br", { "data-mce-bogus": "1" }));
        }
      }
      selection.setRng(rng);
    };
    const deleteSelectedContent = (editor) => {
      const dom2 = editor.dom;
      const rng = normalize(editor.selection.getRng());
      editor.selection.setRng(rng);
      const startCell = dom2.getParent(rng.startContainer, isTableCell);
      if (isTableCellContentSelected(dom2, rng, startCell)) {
        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));
      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {
        rng.deleteContents();
      } else {
        editor.getDoc().execCommand("Delete", false);
      }
    };
    const findMarkerNode = (scope) => {
      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {
        if (markerNode.attr("id") === "mce_marker") {
          return Optional.some(markerNode);
        }
      }
      return Optional.none();
    };
    const insertHtmlAtCaret = (editor, value2, details) => {
      var _a, _b;
      const selection = editor.selection;
      const dom2 = editor.dom;
      const parser = editor.parser;
      const merge3 = details.merge;
      const serializer = HtmlSerializer({ validate: true }, editor.schema);
      const bookmarkHtml = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
      if (value2.indexOf("{$caret}") === -1) {
        value2 += "{$caret}";
      }
      value2 = value2.replace(/\{\$caret\}/, bookmarkHtml);
      let rng = selection.getRng();
      const caretElement = rng.startContainer;
      const body = editor.getBody();
      if (caretElement === body && selection.isCollapsed()) {
        if (dom2.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom2.isEmpty(body.firstChild)) {
          rng = dom2.createRng();
          rng.setStart(body.firstChild, 0);
          rng.setEnd(body.firstChild, 0);
          selection.setRng(rng);
        }
      }
      if (!selection.isCollapsed()) {
        deleteSelectedContent(editor);
      }
      const parentNode = selection.getNode();
      const parserArgs = {
        context: parentNode.nodeName.toLowerCase(),
        data: details.data,
        insert: true
      };
      const fragment = parser.parse(value2, parserArgs);
      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom2, parentNode)) {
        rng = insertAtCaret$1(serializer, dom2, selection.getRng(), fragment);
        if (rng) {
          selection.setRng(rng);
        }
        return value2;
      }
      if (details.paste === true && shouldPasteContentOnly(dom2, fragment, parentNode, editor.getBody())) {
        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();
      }
      markFragmentElements(fragment);
      let node = fragment.lastChild;
      if (node && node.attr("id") === "mce_marker") {
        const marker = node;
        for (node = node.prev; node; node = node.walk(true)) {
          if (node.type === 3 || !dom2.isBlock(node.name)) {
            if (node.parent && editor.schema.isValidChild(node.parent.name, "span")) {
              node.parent.insert(marker, node, node.name === "br");
            }
            break;
          }
        }
      }
      editor._selectionOverrides.showBlockCaretContainer(parentNode);
      if (!parserArgs.invalid) {
        value2 = serializer.serialize(fragment);
        validInsertion(editor, value2, parentNode);
      } else {
        editor.selection.setContent(bookmarkHtml);
        let parentNode2 = selection.getNode();
        let tempNode;
        const rootNode = editor.getBody();
        if (isDocument$1(parentNode2)) {
          parentNode2 = tempNode = rootNode;
        } else {
          tempNode = parentNode2;
        }
        while (tempNode && tempNode !== rootNode) {
          parentNode2 = tempNode;
          tempNode = tempNode.parentNode;
        }
        value2 = parentNode2 === rootNode ? rootNode.innerHTML : dom2.getOuterHTML(parentNode2);
        const root2 = parser.parse(value2);
        const markerNode = findMarkerNode(root2);
        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root2);
        markerNode.each((marker) => marker.replace(fragment));
        const toExtract = fragment.children();
        const parent2 = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root2;
        fragment.unwrap();
        const invalidChildren = filter$5(toExtract, (node2) => isInvalid(editor.schema, node2, parent2));
        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);
        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root2);
        value2 = serializer.serialize(root2);
        if (parentNode2 === rootNode) {
          dom2.setHTML(rootNode, value2);
        } else {
          dom2.setOuterHTML(parentNode2, value2);
        }
      }
      reduceInlineTextElements(editor, merge3);
      moveSelectionToMarker(editor, dom2.get("mce_marker"));
      unmarkFragmentElements(editor.getBody());
      trimBrsFromTableCell(dom2, selection.getStart());
      updateCaret(editor.schema, editor.getBody(), selection.getStart());
      return value2;
    };
    const isTreeNode = (content) => content instanceof AstNode;
    const moveSelection = (editor) => {
      if (hasFocus(editor)) {
        firstPositionIn(editor.getBody()).each((pos) => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const setEditorHtml = (editor, html2, noSelection) => {
      editor.dom.setHTML(editor.getBody(), html2);
      if (noSelection !== true) {
        moveSelection(editor);
      }
    };
    const setContentString = (editor, body, content, args) => {
      if (content.length === 0 || /^\s+$/.test(content)) {
        const padd = '<br data-mce-bogus="1">';
        if (body.nodeName === "TABLE") {
          content = "<tr><td>" + padd + "</td></tr>";
        } else if (/^(UL|OL)$/.test(body.nodeName)) {
          content = "<li>" + padd + "</li>";
        }
        const forcedRootBlockName = getForcedRootBlock(editor);
        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {
          content = padd;
          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);
        } else if (!content) {
          content = padd;
        }
        setEditorHtml(editor, content, args.no_selection);
        return {
          content,
          html: content
        };
      } else {
        if (args.format !== "raw") {
          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {
            isRootContent: true,
            insert: true
          }));
        }
        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);
        setEditorHtml(editor, trimmedHtml, args.no_selection);
        return {
          content: trimmedHtml,
          html: trimmedHtml
        };
      }
    };
    const setContentTree = (editor, body, content, args) => {
      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);
      const html2 = HtmlSerializer({ validate: false }, editor.schema).serialize(content);
      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? html2 : Tools.trim(html2);
      setEditorHtml(editor, trimmedHtml, args.no_selection);
      return {
        content,
        html: trimmedHtml
      };
    };
    const setContentInternal = (editor, content, args) => {
      return Optional.from(editor.getBody()).map((body) => {
        if (isTreeNode(content)) {
          return setContentTree(editor, body, content, args);
        } else {
          return setContentString(editor, body, content, args);
        }
      }).getOr({
        content,
        html: isTreeNode(args.content) ? "" : args.content
      });
    };
    const ancestor$1 = (scope, predicate, isRoot2) => ancestor$4(scope, predicate, isRoot2).isSome();
    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();
    const ensureIsRoot = (isRoot2) => isFunction2(isRoot2) ? isRoot2 : never;
    const ancestor = (scope, transform, isRoot2) => {
      let element = scope.dom;
      const stop2 = ensureIsRoot(isRoot2);
      while (element.parentNode) {
        element = element.parentNode;
        const el = SugarElement.fromDom(element);
        const transformed = transform(el);
        if (transformed.isSome()) {
          return transformed;
        } else if (stop2(el)) {
          break;
        }
      }
      return Optional.none();
    };
    const closest$1 = (scope, transform, isRoot2) => {
      const current = transform(scope);
      const stop2 = ensureIsRoot(isRoot2);
      return current.orThunk(() => stop2(scope) ? Optional.none() : ancestor(scope, transform, stop2));
    };
    const isEq$3 = isEq$5;
    const matchesUnInheritedFormatSelector = (ed, node, name3) => {
      const formatList = ed.formatter.get(name3);
      if (formatList) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {
            return true;
          }
        }
      }
      return false;
    };
    const matchParents = (editor, node, name3, vars, similar) => {
      const root2 = editor.dom.getRoot();
      if (node === root2) {
        return false;
      }
      const matchedNode = editor.dom.getParent(node, (elm) => {
        if (matchesUnInheritedFormatSelector(editor, elm, name3)) {
          return true;
        }
        return elm.parentNode === root2 || !!matchNode(editor, elm, name3, vars, true);
      });
      return !!matchNode(editor, matchedNode, name3, vars, similar);
    };
    const matchName = (dom2, node, format) => {
      if (isInlineFormat(format) && isEq$3(node, format.inline)) {
        return true;
      }
      if (isBlockFormat(format) && isEq$3(node, format.block)) {
        return true;
      }
      if (isSelectorFormat(format)) {
        return isElement$6(node) && dom2.is(node, format.selector);
      }
      return false;
    };
    const matchItems = (dom2, node, format, itemName, similar, vars) => {
      const items = format[itemName];
      const matchAttributes = itemName === "attributes";
      if (isFunction2(format.onmatch)) {
        return format.onmatch(node, format, itemName);
      }
      if (items) {
        if (!isArrayLike(items)) {
          for (const key in items) {
            if (has$2(items, key)) {
              const value2 = matchAttributes ? dom2.getAttrib(node, key) : getStyle(dom2, node, key);
              const expectedValue = replaceVars(items[key], vars);
              const isEmptyValue = isNullable(value2) || isEmpty$3(value2);
              if (isEmptyValue && isNullable(expectedValue)) {
                continue;
              }
              if (similar && isEmptyValue && !format.exact) {
                return false;
              }
              if ((!similar || format.exact) && !isEq$3(value2, normalizeStyleValue(expectedValue, key))) {
                return false;
              }
            }
          }
        } else {
          for (let i = 0; i < items.length; i++) {
            if (matchAttributes ? dom2.getAttrib(node, items[i]) : getStyle(dom2, node, items[i])) {
              return true;
            }
          }
        }
      }
      return true;
    };
    const matchNode = (ed, node, name3, vars, similar) => {
      const formatList = ed.formatter.get(name3);
      const dom2 = ed.dom;
      if (formatList && isElement$6(node)) {
        for (let i = 0; i < formatList.length; i++) {
          const format = formatList[i];
          if (matchName(ed.dom, node, format) && matchItems(dom2, node, format, "attributes", similar, vars) && matchItems(dom2, node, format, "styles", similar, vars)) {
            const classes = format.classes;
            if (classes) {
              for (let x = 0; x < classes.length; x++) {
                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {
                  return;
                }
              }
            }
            return format;
          }
        }
      }
      return void 0;
    };
    const match$2 = (editor, name3, vars, node, similar) => {
      if (node) {
        return matchParents(editor, node, name3, vars, similar);
      }
      node = editor.selection.getNode();
      if (matchParents(editor, node, name3, vars, similar)) {
        return true;
      }
      const startNode = editor.selection.getStart();
      if (startNode !== node) {
        if (matchParents(editor, startNode, name3, vars, similar)) {
          return true;
        }
      }
      return false;
    };
    const matchAll2 = (editor, names, vars) => {
      const matchedFormatNames = [];
      const checkedMap = {};
      const startElement = editor.selection.getStart();
      editor.dom.getParent(startElement, (node) => {
        for (let i = 0; i < names.length; i++) {
          const name3 = names[i];
          if (!checkedMap[name3] && matchNode(editor, node, name3, vars)) {
            checkedMap[name3] = true;
            matchedFormatNames.push(name3);
          }
        }
      }, editor.dom.getRoot());
      return matchedFormatNames;
    };
    const closest = (editor, names) => {
      const isRoot2 = (elm) => eq(elm, SugarElement.fromDom(editor.getBody()));
      const match2 = (elm, name3) => matchNode(editor, elm.dom, name3) ? Optional.some(name3) : Optional.none();
      return Optional.from(editor.selection.getStart(true)).bind((rawElm) => closest$1(SugarElement.fromDom(rawElm), (elm) => findMap(names, (name3) => match2(elm, name3)), isRoot2)).getOrNull();
    };
    const canApply = (editor, name3) => {
      const formatList = editor.formatter.get(name3);
      const dom2 = editor.dom;
      if (formatList) {
        const startNode = editor.selection.getStart();
        const parents2 = getParents$2(dom2, startNode);
        for (let x = formatList.length - 1; x >= 0; x--) {
          const format = formatList[x];
          if (!isSelectorFormat(format)) {
            return true;
          }
          for (let i = parents2.length - 1; i >= 0; i--) {
            if (dom2.is(parents2[i], format.selector)) {
              return true;
            }
          }
        }
      }
      return false;
    };
    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name3) => {
      const matchSimilar = isVariableFormatName(editor, name3);
      if (editor.formatter.matchNode(node, name3, {}, matchSimilar)) {
        return acc.concat([name3]);
      } else {
        return acc;
      }
    }, []);
    const ZWSP = ZWSP$1;
    const importNode = (ownerDocument, node) => {
      return ownerDocument.importNode(node, true);
    };
    const getEmptyCaretContainers = (node) => {
      const nodes = [];
      let tempNode = node;
      while (tempNode) {
        if (isText$a(tempNode) && tempNode.data !== ZWSP || tempNode.childNodes.length > 1) {
          return [];
        }
        if (isElement$6(tempNode)) {
          nodes.push(tempNode);
        }
        tempNode = tempNode.firstChild;
      }
      return nodes;
    };
    const isCaretContainerEmpty = (node) => {
      return getEmptyCaretContainers(node).length > 0;
    };
    const findFirstTextNode = (node) => {
      if (node) {
        const walker = new DomTreeWalker(node, node);
        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {
          if (isText$a(tempNode)) {
            return tempNode;
          }
        }
      }
      return null;
    };
    const createCaretContainer = (fill) => {
      const caretContainer = SugarElement.fromTag("span");
      setAll$1(caretContainer, {
        "id": CARET_ID,
        "data-mce-bogus": "1",
        "data-mce-type": "format-caret"
      });
      if (fill) {
        append$1(caretContainer, SugarElement.fromText(ZWSP));
      }
      return caretContainer;
    };
    const trimZwspFromCaretContainer = (caretContainerNode) => {
      const textNode = findFirstTextNode(caretContainerNode);
      if (textNode && textNode.data.charAt(0) === ZWSP) {
        textNode.deleteData(0, 1);
      }
      return textNode;
    };
    const removeCaretContainerNode = (editor, node, moveCaret2 = true) => {
      const dom2 = editor.dom, selection = editor.selection;
      if (isCaretContainerEmpty(node)) {
        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret2);
      } else {
        const rng = selection.getRng();
        const block = dom2.getParent(node, dom2.isBlock);
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        const textNode = trimZwspFromCaretContainer(node);
        dom2.remove(node, true);
        if (startContainer === textNode && startOffset > 0) {
          rng.setStart(textNode, startOffset - 1);
        }
        if (endContainer === textNode && endOffset > 0) {
          rng.setEnd(textNode, endOffset - 1);
        }
        if (block && dom2.isEmpty(block)) {
          fillWithPaddingBr(SugarElement.fromDom(block));
        }
        selection.setRng(rng);
      }
    };
    const removeCaretContainer = (editor, node, moveCaret2 = true) => {
      const dom2 = editor.dom, selection = editor.selection;
      if (!node) {
        node = getParentCaretContainer(editor.getBody(), selection.getStart());
        if (!node) {
          while (node = dom2.get(CARET_ID)) {
            removeCaretContainerNode(editor, node, false);
          }
        }
      } else {
        removeCaretContainerNode(editor, node, moveCaret2);
      }
    };
    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {
      var _a, _b;
      const dom2 = editor.dom;
      const block = dom2.getParent(formatNode, curry(isTextBlock$1, editor.schema));
      if (block && dom2.isEmpty(block)) {
        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);
      } else {
        removeTrailingBr(SugarElement.fromDom(formatNode));
        if (dom2.isEmpty(formatNode)) {
          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);
        } else {
          dom2.insertAfter(caretContainer, formatNode);
        }
      }
    };
    const appendNode = (parentNode, node) => {
      parentNode.appendChild(node);
      return node;
    };
    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {
      var _a;
      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {
        return appendNode(parentNode, formatNode.cloneNode(false));
      }, caretContainer);
      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));
    };
    const cleanFormatNode = (editor, caretContainer, formatNode, name3, vars, similar) => {
      const formatter = editor.formatter;
      const dom2 = editor.dom;
      const validFormats = filter$5(keys(formatter.get()), (formatName) => formatName !== name3 && !contains$1(formatName, "removeformat"));
      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);
      const uniqueFormats = filter$5(matchedFormats, (fmtName) => !areSimilarFormats(editor, fmtName, name3));
      if (uniqueFormats.length > 0) {
        const clonedFormatNode = formatNode.cloneNode(false);
        dom2.add(caretContainer, clonedFormatNode);
        formatter.remove(name3, vars, clonedFormatNode, similar);
        dom2.remove(clonedFormatNode);
        return Optional.some(clonedFormatNode);
      } else {
        return Optional.none();
      }
    };
    const applyCaretFormat = (editor, name3, vars) => {
      let caretContainer;
      const selection = editor.selection;
      const formatList = editor.formatter.get(name3);
      if (!formatList) {
        return;
      }
      const selectionRng = selection.getRng();
      let offset2 = selectionRng.startOffset;
      const container = selectionRng.startContainer;
      const text3 = container.nodeValue;
      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());
      const wordcharRegex = /[^\s\u00a0\u00ad\u200b\ufeff]/;
      if (text3 && offset2 > 0 && offset2 < text3.length && wordcharRegex.test(text3.charAt(offset2)) && wordcharRegex.test(text3.charAt(offset2 - 1))) {
        const bookmark = selection.getBookmark();
        selectionRng.collapse(true);
        let rng = expandRng(editor.dom, selectionRng, formatList);
        rng = split(rng);
        editor.formatter.apply(name3, vars, rng);
        selection.moveToBookmark(bookmark);
      } else {
        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;
        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {
          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);
          textNode = caretContainer.firstChild;
          selectionRng.insertNode(caretContainer);
          offset2 = 1;
          editor.formatter.apply(name3, vars, caretContainer);
        } else {
          editor.formatter.apply(name3, vars, caretContainer);
        }
        selection.setCursorLocation(textNode, offset2);
      }
    };
    const removeCaretFormat = (editor, name3, vars, similar) => {
      const dom2 = editor.dom;
      const selection = editor.selection;
      let hasContentAfter = false;
      const formatList = editor.formatter.get(name3);
      if (!formatList) {
        return;
      }
      const rng = selection.getRng();
      const container = rng.startContainer;
      const offset2 = rng.startOffset;
      let node = container;
      if (isText$a(container)) {
        if (offset2 !== container.data.length) {
          hasContentAfter = true;
        }
        node = node.parentNode;
      }
      const parents2 = [];
      let formatNode;
      while (node) {
        if (matchNode(editor, node, name3, vars, similar)) {
          formatNode = node;
          break;
        }
        if (node.nextSibling) {
          hasContentAfter = true;
        }
        parents2.push(node);
        node = node.parentNode;
      }
      if (!formatNode) {
        return;
      }
      if (hasContentAfter) {
        const bookmark = selection.getBookmark();
        rng.collapse(true);
        let expandedRng = expandRng(dom2, rng, formatList, true);
        expandedRng = split(expandedRng);
        editor.formatter.remove(name3, vars, expandedRng, similar);
        selection.moveToBookmark(bookmark);
      } else {
        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);
        const newCaretContainer = createCaretContainer(false).dom;
        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);
        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name3, vars, similar);
        const caretTextNode = insertFormatNodesIntoCaretContainer(parents2.concat(cleanedFormatNode.toArray()), newCaretContainer);
        if (caretContainer) {
          removeCaretContainerNode(editor, caretContainer, false);
        }
        selection.setCursorLocation(caretTextNode, 1);
        if (dom2.isEmpty(formatNode)) {
          dom2.remove(formatNode);
        }
      }
    };
    const disableCaretContainer = (editor, keyCode) => {
      const selection = editor.selection, body = editor.getBody();
      removeCaretContainer(editor, null, false);
      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
      if (keyCode === 37 || keyCode === 39) {
        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()));
      }
    };
    const setup$u = (editor) => {
      editor.on("mouseup keydown", (e) => {
        disableCaretContainer(editor, e.keyCode);
      });
    };
    const createCaretFormat = (formatNodes) => {
      const caretContainer = createCaretContainer(false);
      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);
      return {
        caretContainer,
        caretPosition: CaretPosition(innerMost, 0)
      };
    };
    const replaceWithCaretFormat = (targetNode, formatNodes) => {
      const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
      before$3(SugarElement.fromDom(targetNode), caretContainer);
      remove$6(SugarElement.fromDom(targetNode));
      return caretPosition;
    };
    const createCaretFormatAtStart$1 = (editor, formatNodes) => {
      const { caretContainer, caretPosition } = createCaretFormat(formatNodes);
      editor.selection.getRng().insertNode(caretContainer.dom);
      return caretPosition;
    };
    const isFormatElement = (editor, element) => {
      const inlineElements = editor.schema.getTextInlineElements();
      return has$2(inlineElements, name2(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);
    };
    const isEmptyCaretFormatElement = (element) => {
      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);
    };
    const postProcessHooks = {};
    const isPre = matchNodeNames(["pre"]);
    const addPostProcessHook = (name3, hook) => {
      const hooks = postProcessHooks[name3];
      if (!hooks) {
        postProcessHooks[name3] = [];
      }
      postProcessHooks[name3].push(hook);
    };
    const postProcess$1 = (name3, editor) => {
      if (has$2(postProcessHooks, name3)) {
        each$e(postProcessHooks[name3], (hook) => {
          hook(editor);
        });
      }
    };
    addPostProcessHook("pre", (editor) => {
      const rng = editor.selection.getRng();
      const hasPreSibling = (blocks2) => (pre) => {
        const prev2 = pre.previousSibling;
        return isPre(prev2) && contains$2(blocks2, prev2);
      };
      const joinPre = (pre1, pre2) => {
        const sPre2 = SugarElement.fromDom(pre2);
        const doc = documentOrOwner(sPre2).dom;
        remove$6(sPre2);
        append2(SugarElement.fromDom(pre1), [
          SugarElement.fromTag("br", doc),
          SugarElement.fromTag("br", doc),
          ...children$1(sPre2)
        ]);
      };
      if (!rng.collapsed) {
        const blocks2 = editor.selection.getSelectedBlocks();
        const preBlocks = filter$5(filter$5(blocks2, isPre), hasPreSibling(blocks2));
        each$e(preBlocks, (pre) => {
          joinPre(pre.previousSibling, pre);
        });
      }
    });
    const listItemStyles = [
      "fontWeight",
      "fontStyle",
      "color",
      "fontSize",
      "fontFamily"
    ];
    const hasListStyles = (fmt) => isObject2(fmt.styles) && exists(keys(fmt.styles), (name3) => contains$2(listItemStyles, name3));
    const findExpandedListItemFormat = (formats) => find$2(formats, (fmt) => isInlineFormat(fmt) && fmt.inline === "span" && hasListStyles(fmt));
    const getExpandedListItemFormat = (formatter, format) => {
      const formatList = formatter.get(format);
      return isArray$12(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();
    };
    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();
    const isRngEndAtEndOfElement = (rng, elm) => {
      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists((pos) => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;
    };
    const isEditableListItem = (dom2) => (elm) => isListItem$2(elm) && dom2.isEditable(elm);
    const getFullySelectedBlocks = (selection) => {
      const blocks2 = selection.getSelectedBlocks();
      const rng = selection.getRng();
      if (selection.isCollapsed()) {
        return [];
      }
      if (blocks2.length === 1) {
        return isRngStartAtStartOfElement(rng, blocks2[0]) && isRngEndAtEndOfElement(rng, blocks2[0]) ? blocks2 : [];
      } else {
        const first2 = head(blocks2).filter((elm) => isRngStartAtStartOfElement(rng, elm)).toArray();
        const last2 = last$3(blocks2).filter((elm) => isRngEndAtEndOfElement(rng, elm)).toArray();
        const middle = blocks2.slice(1, -1);
        return first2.concat(middle).concat(last2);
      }
    };
    const getFullySelectedListItems = (selection) => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));
    const getPartiallySelectedListItems = (selection) => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));
    const each$8 = Tools.each;
    const isElementNode = (node) => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);
    const findElementSibling = (node, siblingName) => {
      for (let sibling2 = node; sibling2; sibling2 = sibling2[siblingName]) {
        if (isText$a(sibling2) && isNotEmpty(sibling2.data)) {
          return node;
        }
        if (isElement$6(sibling2) && !isBookmarkNode$1(sibling2)) {
          return sibling2;
        }
      }
      return node;
    };
    const mergeSiblingsNodes = (editor, prev2, next2) => {
      const elementUtils = ElementUtils(editor);
      const isPrevEditable = isElement$6(prev2) && isEditable$2(prev2);
      const isNextEditable = isElement$6(next2) && isEditable$2(next2);
      if (isPrevEditable && isNextEditable) {
        const prevSibling2 = findElementSibling(prev2, "previousSibling");
        const nextSibling2 = findElementSibling(next2, "nextSibling");
        if (elementUtils.compare(prevSibling2, nextSibling2)) {
          for (let sibling2 = prevSibling2.nextSibling; sibling2 && sibling2 !== nextSibling2; ) {
            const tmpSibling = sibling2;
            sibling2 = sibling2.nextSibling;
            prevSibling2.appendChild(tmpSibling);
          }
          editor.dom.remove(nextSibling2);
          Tools.each(Tools.grep(nextSibling2.childNodes), (node) => {
            prevSibling2.appendChild(node);
          });
          return prevSibling2;
        }
      }
      return next2;
    };
    const mergeSiblings = (editor, format, vars, node) => {
      var _a;
      if (node && format.merge_siblings !== false) {
        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;
        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));
      }
    };
    const clearChildStyles = (dom2, format, node) => {
      if (format.clear_child_styles) {
        const selector = format.links ? "*:not(a)" : "*";
        each$8(dom2.select(selector, node), (childNode) => {
          if (isElementNode(childNode) && isEditable$2(childNode)) {
            each$8(format.styles, (_value, name3) => {
              dom2.setStyle(childNode, name3, "");
            });
          }
        });
      }
    };
    const processChildElements = (node, filter3, process2) => {
      each$8(node.childNodes, (node2) => {
        if (isElementNode(node2)) {
          if (filter3(node2)) {
            process2(node2);
          }
          if (node2.hasChildNodes()) {
            processChildElements(node2, filter3, process2);
          }
        }
      });
    };
    const unwrapEmptySpan = (dom2, node) => {
      if (node.nodeName === "SPAN" && dom2.getAttribs(node).length === 0) {
        dom2.remove(node, true);
      }
    };
    const hasStyle = (dom2, name3) => (node) => !!(node && getStyle(dom2, node, name3));
    const applyStyle = (dom2, name3, value2) => (node) => {
      dom2.setStyle(node, name3, value2);
      if (node.getAttribute("style") === "") {
        node.removeAttribute("style");
      }
      unwrapEmptySpan(dom2, node);
    };
    const removeResult = Adt.generate([
      { keep: [] },
      { rename: ["name"] },
      { removed: [] }
    ]);
    const MCE_ATTR_RE = /^(src|href|style)$/;
    const each$7 = Tools.each;
    const isEq$2 = isEq$5;
    const isTableCellOrRow = (node) => /^(TR|TH|TD)$/.test(node.nodeName);
    const isChildOfInlineParent = (dom2, node, parent2) => dom2.isChildOf(node, parent2) && node !== parent2 && !dom2.isBlock(parent2);
    const getContainer = (ed, rng, start3) => {
      let container = rng[start3 ? "startContainer" : "endContainer"];
      let offset2 = rng[start3 ? "startOffset" : "endOffset"];
      if (isElement$6(container)) {
        const lastIdx = container.childNodes.length - 1;
        if (!start3 && offset2) {
          offset2--;
        }
        container = container.childNodes[offset2 > lastIdx ? lastIdx : offset2];
      }
      if (isText$a(container) && start3 && offset2 >= container.data.length) {
        container = new DomTreeWalker(container, ed.getBody()).next() || container;
      }
      if (isText$a(container) && !start3 && offset2 === 0) {
        container = new DomTreeWalker(container, ed.getBody()).prev() || container;
      }
      return container;
    };
    const normalizeTableSelection = (node, start3) => {
      const prop = start3 ? "firstChild" : "lastChild";
      const childNode = node[prop];
      if (isTableCellOrRow(node) && childNode) {
        if (node.nodeName === "TR") {
          return childNode[prop] || childNode;
        } else {
          return childNode;
        }
      }
      return node;
    };
    const wrap$1 = (dom2, node, name3, attrs) => {
      var _a;
      const wrapper = dom2.create(name3, attrs);
      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);
      wrapper.appendChild(node);
      return wrapper;
    };
    const wrapWithSiblings = (dom2, node, next2, name3, attrs) => {
      const start3 = SugarElement.fromDom(node);
      const wrapper = SugarElement.fromDom(dom2.create(name3, attrs));
      const siblings2 = next2 ? nextSiblings(start3) : prevSiblings(start3);
      append2(wrapper, siblings2);
      if (next2) {
        before$3(start3, wrapper);
        prepend(wrapper, start3);
      } else {
        after$4(start3, wrapper);
        append$1(wrapper, start3);
      }
      return wrapper.dom;
    };
    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === "A";
    const removeNode = (ed, node, format) => {
      const parentNode = node.parentNode;
      let rootBlockElm;
      const dom2 = ed.dom;
      const forcedRootBlock = getForcedRootBlock(ed);
      if (isBlockFormat(format)) {
        if (parentNode === dom2.getRoot()) {
          if (!format.list_block || !isEq$2(node, format.list_block)) {
            each$e(from(node.childNodes), (node2) => {
              if (isValid(ed, forcedRootBlock, node2.nodeName.toLowerCase())) {
                if (!rootBlockElm) {
                  rootBlockElm = wrap$1(dom2, node2, forcedRootBlock);
                  dom2.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));
                } else {
                  rootBlockElm.appendChild(node2);
                }
              } else {
                rootBlockElm = null;
              }
            });
          }
        }
      }
      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {
        return;
      }
      dom2.remove(node, true);
    };
    const processFormatAttrOrStyle = (name3, value2, vars) => {
      if (isNumber2(name3)) {
        return {
          name: value2,
          value: null
        };
      } else {
        return {
          name: name3,
          value: replaceVars(value2, vars)
        };
      }
    };
    const removeEmptyStyleAttributeIfNeeded = (dom2, elm) => {
      if (dom2.getAttrib(elm, "style") === "") {
        elm.removeAttribute("style");
        elm.removeAttribute("data-mce-style");
      }
    };
    const removeStyles = (dom2, elm, format, vars, compareNode) => {
      let stylesModified = false;
      each$7(format.styles, (value2, name3) => {
        const {
          name: styleName,
          value: styleValue
        } = processFormatAttrOrStyle(name3, value2, vars);
        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);
        if (format.remove_similar || isNull2(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom2, compareNode, styleName), normalizedStyleValue)) {
          dom2.setStyle(elm, styleName, "");
        }
        stylesModified = true;
      });
      if (stylesModified) {
        removeEmptyStyleAttributeIfNeeded(dom2, elm);
      }
    };
    const removeListStyleFormats = (editor, name3, vars) => {
      if (name3 === "removeformat") {
        each$e(getPartiallySelectedListItems(editor.selection), (li) => {
          each$e(listItemStyles, (name4) => editor.dom.setStyle(li, name4, ""));
          removeEmptyStyleAttributeIfNeeded(editor.dom, li);
        });
      } else {
        getExpandedListItemFormat(editor.formatter, name3).each((liFmt) => {
          each$e(getPartiallySelectedListItems(editor.selection), (li) => removeStyles(editor.dom, li, liFmt, vars, null));
        });
      }
    };
    const removeFormatInternal = (ed, format, vars, node, compareNode) => {
      const dom2 = ed.dom;
      const elementUtils = ElementUtils(ed);
      const schema = ed.schema;
      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {
        removeNode(ed, node, format);
        return removeResult.removed();
      }
      if (!format.ceFalseOverride && node && dom2.getContentEditableParent(node) === "false") {
        return removeResult.keep();
      }
      if (node && !matchName(dom2, node, format) && !isColorFormatAndAnchor(node, format)) {
        return removeResult.keep();
      }
      const elm = node;
      const preserveAttributes = format.preserve_attributes;
      if (isInlineFormat(format) && format.remove === "all" && isArray$12(preserveAttributes)) {
        const attrsToPreserve = filter$5(dom2.getAttribs(elm), (attr2) => contains$2(preserveAttributes, attr2.name.toLowerCase()));
        dom2.removeAllAttribs(elm);
        each$e(attrsToPreserve, (attr2) => dom2.setAttrib(elm, attr2.name, attr2.value));
        if (attrsToPreserve.length > 0) {
          return removeResult.rename("span");
        }
      }
      if (format.remove !== "all") {
        removeStyles(dom2, elm, format, vars, compareNode);
        each$7(format.attributes, (value2, name3) => {
          const {
            name: attrName,
            value: attrValue
          } = processFormatAttrOrStyle(name3, value2, vars);
          if (format.remove_similar || isNull2(attrValue) || !isElement$6(compareNode) || isEq$2(dom2.getAttrib(compareNode, attrName), attrValue)) {
            if (attrName === "class") {
              const currentValue = dom2.getAttrib(elm, attrName);
              if (currentValue) {
                let valueOut = "";
                each$e(currentValue.split(/\s+/), (cls) => {
                  if (/mce\-\w+/.test(cls)) {
                    valueOut += (valueOut ? " " : "") + cls;
                  }
                });
                if (valueOut) {
                  dom2.setAttrib(elm, attrName, valueOut);
                  return;
                }
              }
            }
            if (MCE_ATTR_RE.test(attrName)) {
              elm.removeAttribute("data-mce-" + attrName);
            }
            if (attrName === "style" && matchNodeNames(["li"])(elm) && dom2.getStyle(elm, "list-style-type") === "none") {
              elm.removeAttribute(attrName);
              dom2.setStyle(elm, "list-style-type", "none");
              return;
            }
            if (attrName === "class") {
              elm.removeAttribute("className");
            }
            elm.removeAttribute(attrName);
          }
        });
        each$7(format.classes, (value2) => {
          value2 = replaceVars(value2, vars);
          if (!isElement$6(compareNode) || dom2.hasClass(compareNode, value2)) {
            dom2.removeClass(elm, value2);
          }
        });
        const attrs = dom2.getAttribs(elm);
        for (let i = 0; i < attrs.length; i++) {
          const attrName = attrs[i].nodeName;
          if (!elementUtils.isAttributeInternal(attrName)) {
            return removeResult.keep();
          }
        }
      }
      if (format.remove !== "none") {
        removeNode(ed, elm, format);
        return removeResult.removed();
      }
      return removeResult.keep();
    };
    const removeFormat$1 = (ed, format, vars, node, compareNode) => removeFormatInternal(ed, format, vars, node, compareNode).fold(never, (newName) => {
      ed.dom.rename(node, newName);
      return true;
    }, always);
    const findFormatRoot = (editor, container, name3, vars, similar) => {
      let formatRoot;
      if (container.parentNode) {
        each$e(getParents$2(editor.dom, container.parentNode).reverse(), (parent2) => {
          if (!formatRoot && isElement$6(parent2) && parent2.id !== "_start" && parent2.id !== "_end") {
            const format = matchNode(editor, parent2, name3, vars, similar);
            if (format && format.split !== false) {
              formatRoot = parent2;
            }
          }
        });
      }
      return formatRoot;
    };
    const removeFormatFromClone = (editor, format, vars, clone2) => removeFormatInternal(editor, format, vars, clone2, clone2).fold(constant(clone2), (newName) => {
      const fragment = editor.dom.createFragment();
      fragment.appendChild(clone2);
      return editor.dom.rename(clone2, newName);
    }, constant(null));
    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split2, format, vars) => {
      var _a, _b;
      let lastClone;
      let firstClone;
      const dom2 = editor.dom;
      if (formatRoot) {
        const formatRootParent = formatRoot.parentNode;
        for (let parent2 = container.parentNode; parent2 && parent2 !== formatRootParent; parent2 = parent2.parentNode) {
          let clone2 = dom2.clone(parent2, false);
          for (let i = 0; i < formatList.length; i++) {
            clone2 = removeFormatFromClone(editor, formatList[i], vars, clone2);
            if (clone2 === null) {
              break;
            }
          }
          if (clone2) {
            if (lastClone) {
              clone2.appendChild(lastClone);
            }
            if (!firstClone) {
              firstClone = clone2;
            }
            lastClone = clone2;
          }
        }
        if (split2 && (!format.mixed || !dom2.isBlock(formatRoot))) {
          container = (_a = dom2.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;
        }
        if (lastClone && firstClone) {
          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);
          firstClone.appendChild(target);
          if (isInlineFormat(format)) {
            mergeSiblings(editor, format, vars, lastClone);
          }
        }
      }
      return container;
    };
    const remove$2 = (ed, name3, vars, node, similar) => {
      const formatList = ed.formatter.get(name3);
      const format = formatList[0];
      const dom2 = ed.dom;
      const selection = ed.selection;
      const splitToFormatRoot = (container) => {
        const formatRoot = findFormatRoot(ed, container, name3, vars, similar);
        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);
      };
      const isRemoveBookmarkNode = (node2) => isBookmarkNode$1(node2) && isElement$6(node2) && (node2.id === "_start" || node2.id === "_end");
      const removeNodeFormat = (node2) => exists(formatList, (fmt) => removeFormat$1(ed, fmt, vars, node2, node2));
      const process2 = (node2) => {
        const children2 = from(node2.childNodes);
        const removed = removeNodeFormat(node2);
        const currentNodeMatches = removed || exists(formatList, (f) => matchName(dom2, node2, f));
        const parentNode = node2.parentNode;
        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
          removeNodeFormat(parentNode);
        }
        if (format.deep) {
          if (children2.length) {
            for (let i = 0; i < children2.length; i++) {
              process2(children2[i]);
            }
          }
        }
        const textDecorations = [
          "underline",
          "line-through",
          "overline"
        ];
        each$e(textDecorations, (decoration) => {
          if (isElement$6(node2) && ed.dom.getStyle(node2, "text-decoration") === decoration && node2.parentNode && getTextDecoration(dom2, node2.parentNode) === decoration) {
            removeFormat$1(ed, {
              deep: false,
              exact: true,
              inline: "span",
              styles: { textDecoration: decoration }
            }, void 0, node2);
          }
        });
      };
      const unwrap2 = (start3) => {
        const node2 = dom2.get(start3 ? "_start" : "_end");
        if (node2) {
          let out = node2[start3 ? "firstChild" : "lastChild"];
          if (isRemoveBookmarkNode(out)) {
            out = out[start3 ? "firstChild" : "lastChild"];
          }
          if (isText$a(out) && out.data.length === 0) {
            out = start3 ? node2.previousSibling || node2.nextSibling : node2.nextSibling || node2.previousSibling;
          }
          dom2.remove(node2, true);
          return out;
        } else {
          return null;
        }
      };
      const removeRngStyle = (rng) => {
        let startContainer;
        let endContainer;
        let expandedRng = expandRng(dom2, rng, formatList, rng.collapsed);
        if (format.split) {
          expandedRng = split(expandedRng);
          startContainer = getContainer(ed, expandedRng, true);
          endContainer = getContainer(ed, expandedRng);
          if (startContainer !== endContainer) {
            startContainer = normalizeTableSelection(startContainer, true);
            endContainer = normalizeTableSelection(endContainer, false);
            if (isChildOfInlineParent(dom2, startContainer, endContainer)) {
              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);
              splitToFormatRoot(wrapWithSiblings(dom2, marker, true, "span", {
                "id": "_start",
                "data-mce-type": "bookmark"
              }));
              unwrap2(true);
              return;
            }
            if (isChildOfInlineParent(dom2, endContainer, startContainer)) {
              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);
              splitToFormatRoot(wrapWithSiblings(dom2, marker, false, "span", {
                "id": "_end",
                "data-mce-type": "bookmark"
              }));
              unwrap2(false);
              return;
            }
            startContainer = wrap$1(dom2, startContainer, "span", {
              "id": "_start",
              "data-mce-type": "bookmark"
            });
            endContainer = wrap$1(dom2, endContainer, "span", {
              "id": "_end",
              "data-mce-type": "bookmark"
            });
            const newRng = dom2.createRng();
            newRng.setStartAfter(startContainer);
            newRng.setEndBefore(endContainer);
            walk$3(dom2, newRng, (nodes) => {
              each$e(nodes, (n) => {
                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {
                  splitToFormatRoot(n);
                }
              });
            });
            splitToFormatRoot(startContainer);
            splitToFormatRoot(endContainer);
            startContainer = unwrap2(true);
            endContainer = unwrap2();
          } else {
            startContainer = endContainer = splitToFormatRoot(startContainer);
          }
          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;
          expandedRng.startOffset = dom2.nodeIndex(startContainer);
          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;
          expandedRng.endOffset = dom2.nodeIndex(endContainer) + 1;
        }
        walk$3(dom2, expandedRng, (nodes) => {
          each$e(nodes, process2);
        });
      };
      if (node) {
        if (isNode2(node)) {
          const rng = dom2.createRng();
          rng.setStartBefore(node);
          rng.setEndAfter(node);
          removeRngStyle(rng);
        } else {
          removeRngStyle(node);
        }
        fireFormatRemove(ed, name3, node, vars);
        return;
      }
      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), (startNode) => isInlineFormat(format) && match$2(ed, name3, vars, startNode));
        ed.nodeChanged();
      } else {
        removeCaretFormat(ed, name3, vars, similar);
      }
      removeListStyleFormats(ed, name3, vars);
      fireFormatRemove(ed, name3, node, vars);
    };
    const each$6 = Tools.each;
    const mergeTextDecorationsAndColor = (dom2, format, vars, node) => {
      const processTextDecorationsAndColor = (n) => {
        if (isElement$6(n) && isElement$6(n.parentNode) && isEditable$2(n)) {
          const parentTextDecoration = getTextDecoration(dom2, n.parentNode);
          if (dom2.getStyle(n, "color") && parentTextDecoration) {
            dom2.setStyle(n, "text-decoration", parentTextDecoration);
          } else if (dom2.getStyle(n, "text-decoration") === parentTextDecoration) {
            dom2.setStyle(n, "text-decoration", null);
          }
        }
      };
      if (format.styles && (format.styles.color || format.styles.textDecoration)) {
        Tools.walk(node, processTextDecorationsAndColor, "childNodes");
        processTextDecorationsAndColor(node);
      }
    };
    const mergeBackgroundColorAndFontSize = (dom2, format, vars, node) => {
      if (format.styles && format.styles.backgroundColor) {
        const hasFontSize = hasStyle(dom2, "fontSize");
        processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom2, "backgroundColor", replaceVars(format.styles.backgroundColor, vars)));
      }
    };
    const mergeSubSup = (dom2, format, vars, node) => {
      if (isInlineFormat(format) && (format.inline === "sub" || format.inline === "sup")) {
        const hasFontSize = hasStyle(dom2, "fontSize");
        processChildElements(node, (elm) => hasFontSize(elm) && isEditable$2(elm), applyStyle(dom2, "fontSize", ""));
        const inverseTagDescendants = filter$5(dom2.select(format.inline === "sup" ? "sub" : "sup", node), isEditable$2);
        dom2.remove(inverseTagDescendants, true);
      }
    };
    const mergeWithChildren = (editor, formatList, vars, node) => {
      each$6(formatList, (format) => {
        if (isInlineFormat(format)) {
          each$6(editor.dom.select(format.inline, node), (child2) => {
            if (isElementNode(child2)) {
              removeFormat$1(editor, format, vars, child2, format.exact ? child2 : null);
            }
          });
        }
        clearChildStyles(editor.dom, format, node);
      });
    };
    const mergeWithParents = (editor, format, name3, vars, node) => {
      const parentNode = node.parentNode;
      if (matchNode(editor, parentNode, name3, vars)) {
        if (removeFormat$1(editor, format, vars, node)) {
          return;
        }
      }
      if (format.merge_with_parents && parentNode) {
        editor.dom.getParent(parentNode, (parent2) => {
          if (matchNode(editor, parent2, name3, vars)) {
            removeFormat$1(editor, format, vars, node);
            return true;
          } else {
            return false;
          }
        });
      }
    };
    const each$5 = Tools.each;
    const canFormatBR = (editor, format, node, parentName) => {
      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {
        const validBRParentElements = getTextRootBlockElements(editor.schema);
        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), (sibling2) => isCaretNode(sibling2.dom));
        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;
      } else {
        return false;
      }
    };
    const applyStyles2 = (dom2, elm, format, vars) => {
      each$5(format.styles, (value2, name3) => {
        dom2.setStyle(elm, name3, replaceVars(value2, vars));
      });
      if (format.styles) {
        const styleVal = dom2.getAttrib(elm, "style");
        if (styleVal) {
          dom2.setAttrib(elm, "data-mce-style", styleVal);
        }
      }
    };
    const applyFormat$1 = (ed, name3, vars, node) => {
      const formatList = ed.formatter.get(name3);
      const format = formatList[0];
      const isCollapsed = !node && ed.selection.isCollapsed();
      const dom2 = ed.dom;
      const selection = ed.selection;
      const setElementFormat = (elm, fmt = format) => {
        if (isFunction2(fmt.onformat)) {
          fmt.onformat(elm, fmt, vars, node);
        }
        applyStyles2(dom2, elm, fmt, vars);
        each$5(fmt.attributes, (value2, name4) => {
          dom2.setAttrib(elm, name4, replaceVars(value2, vars));
        });
        each$5(fmt.classes, (value2) => {
          const newValue = replaceVars(value2, vars);
          if (!dom2.hasClass(elm, newValue)) {
            dom2.addClass(elm, newValue);
          }
        });
      };
      const applyNodeStyle = (formatList2, node2) => {
        let found = false;
        each$5(formatList2, (format2) => {
          if (!isSelectorFormat(format2)) {
            return false;
          }
          if (dom2.getContentEditable(node2) === "false" && !format2.ceFalseOverride) {
            return true;
          }
          if (isNonNullable(format2.collapsed) && format2.collapsed !== isCollapsed) {
            return true;
          }
          if (dom2.is(node2, format2.selector) && !isCaretNode(node2)) {
            setElementFormat(node2, format2);
            found = true;
            return false;
          }
          return true;
        });
        return found;
      };
      const createWrapElement = (wrapName) => {
        if (isString2(wrapName)) {
          const wrapElm = dom2.create(wrapName);
          setElementFormat(wrapElm);
          return wrapElm;
        } else {
          return null;
        }
      };
      const applyRngStyle = (dom3, rng, nodeSpecific) => {
        const newWrappers = [];
        let contentEditable = true;
        const wrapName = format.inline || format.block;
        const wrapElm = createWrapElement(wrapName);
        const isMatchingWrappingBlock = (node2) => isWrappingBlockFormat(format) && matchNode(ed, node2, name3, vars);
        const canRenameBlock = (node2, parentName, isEditableDescendant) => {
          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node2) && isValid(ed, parentName, wrapName);
          return isEditableDescendant && isValidBlockFormatForNode;
        };
        const canWrapNode = (node2, parentName, isEditableDescendant, isWrappableNoneditableElm) => {
          const nodeName = node2.nodeName.toLowerCase();
          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);
          const isZwsp$12 = !nodeSpecific && isText$a(node2) && isZwsp(node2.data);
          const isCaret = isCaretNode(node2);
          const isCorrectFormatForNode = !isInlineFormat(format) || !dom3.isBlock(node2);
          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp$12 && !isCaret && isCorrectFormatForNode;
        };
        walk$3(dom3, rng, (nodes) => {
          let currentWrapElm;
          const process2 = (node2) => {
            let hasContentEditableState2 = false;
            let lastContentEditable = contentEditable;
            let isWrappableNoneditableElm = false;
            const parentNode = node2.parentNode;
            const parentName = parentNode.nodeName.toLowerCase();
            const contentEditableValue = dom3.getContentEditable(node2);
            if (isNonNullable(contentEditableValue)) {
              lastContentEditable = contentEditable;
              contentEditable = contentEditableValue === "true";
              hasContentEditableState2 = true;
              isWrappableNoneditableElm = isWrappableNoneditable(ed, node2);
            }
            const isEditableDescendant = contentEditable && !hasContentEditableState2;
            if (isBr$6(node2) && !canFormatBR(ed, format, node2, parentName)) {
              currentWrapElm = null;
              if (isBlockFormat(format)) {
                dom3.remove(node2);
              }
              return;
            }
            if (isMatchingWrappingBlock(node2)) {
              currentWrapElm = null;
              return;
            }
            if (canRenameBlock(node2, parentName, isEditableDescendant)) {
              const elm = dom3.rename(node2, wrapName);
              setElementFormat(elm);
              newWrappers.push(elm);
              currentWrapElm = null;
              return;
            }
            if (isSelectorFormat(format)) {
              let found = applyNodeStyle(formatList, node2);
              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {
                found = applyNodeStyle(formatList, parentNode);
              }
              if (!isInlineFormat(format) || found) {
                currentWrapElm = null;
                return;
              }
            }
            if (isNonNullable(wrapElm) && canWrapNode(node2, parentName, isEditableDescendant, isWrappableNoneditableElm)) {
              if (!currentWrapElm) {
                currentWrapElm = dom3.clone(wrapElm, false);
                parentNode.insertBefore(currentWrapElm, node2);
                newWrappers.push(currentWrapElm);
              }
              if (isWrappableNoneditableElm && hasContentEditableState2) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm.appendChild(node2);
            } else {
              currentWrapElm = null;
              each$e(from(node2.childNodes), process2);
              if (hasContentEditableState2) {
                contentEditable = lastContentEditable;
              }
              currentWrapElm = null;
            }
          };
          each$e(nodes, process2);
        });
        if (format.links === true) {
          each$e(newWrappers, (node2) => {
            const process2 = (node3) => {
              if (node3.nodeName === "A") {
                setElementFormat(node3, format);
              }
              each$e(from(node3.childNodes), process2);
            };
            process2(node2);
          });
        }
        each$e(newWrappers, (node2) => {
          const getChildCount2 = (node3) => {
            let count2 = 0;
            each$e(node3.childNodes, (node4) => {
              if (!isEmptyTextNode$1(node4) && !isBookmarkNode$1(node4)) {
                count2++;
              }
            });
            return count2;
          };
          const mergeStyles = (node3) => {
            const childElement = find$2(node3.childNodes, isElementNode$1).filter((child2) => dom3.getContentEditable(child2) !== "false" && matchName(dom3, child2, format));
            return childElement.map((child2) => {
              const clone2 = dom3.clone(child2, false);
              setElementFormat(clone2);
              dom3.replace(clone2, node3, true);
              dom3.remove(child2, true);
              return clone2;
            }).getOr(node3);
          };
          const childCount = getChildCount2(node2);
          if ((newWrappers.length > 1 || !dom3.isBlock(node2)) && childCount === 0) {
            dom3.remove(node2, true);
            return;
          }
          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {
            if (!format.exact && childCount === 1) {
              node2 = mergeStyles(node2);
            }
            mergeWithChildren(ed, formatList, vars, node2);
            mergeWithParents(ed, format, name3, vars, node2);
            mergeBackgroundColorAndFontSize(dom3, format, vars, node2);
            mergeTextDecorationsAndColor(dom3, format, vars, node2);
            mergeSubSup(dom3, format, vars, node2);
            mergeSiblings(ed, format, vars, node2);
          }
        });
      };
      const targetNode = isNode2(node) ? node : selection.getNode();
      if (dom2.getContentEditable(targetNode) === "false" && !isWrappableNoneditable(ed, targetNode)) {
        node = targetNode;
        applyNodeStyle(formatList, node);
        fireFormatApply(ed, name3, node, vars);
        return;
      }
      if (format) {
        if (node) {
          if (isNode2(node)) {
            if (!applyNodeStyle(formatList, node)) {
              const rng = dom2.createRng();
              rng.setStartBefore(node);
              rng.setEndAfter(node);
              applyRngStyle(dom2, expandRng(dom2, rng, formatList), true);
            }
          } else {
            applyRngStyle(dom2, node, true);
          }
        } else {
          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {
            selection.setRng(normalize(selection.getRng()));
            preserveSelection(ed, () => {
              runOnRanges(ed, (selectionRng, fake) => {
                const expandedRng = fake ? selectionRng : expandRng(dom2, selectionRng, formatList);
                applyRngStyle(dom2, expandedRng, false);
              });
            }, always);
            ed.nodeChanged();
          } else {
            applyCaretFormat(ed, name3, vars);
          }
          getExpandedListItemFormat(ed.formatter, name3).each((liFmt) => {
            each$e(getFullySelectedListItems(ed.selection), (li) => applyStyles2(dom2, li, liFmt, vars));
          });
        }
        postProcess$1(name3, ed);
      }
      fireFormatApply(ed, name3, node, vars);
    };
    const hasVars = (value2) => has$2(value2, "vars");
    const setup$t = (registeredFormatListeners, editor) => {
      registeredFormatListeners.set({});
      editor.on("NodeChange", (e) => {
        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());
      });
      editor.on("FormatApply FormatRemove", (e) => {
        const element = Optional.from(e.node).map((nodeOrRange) => isNode2(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind((node) => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));
        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());
      });
    };
    const fallbackElement = (editor) => editor.selection.getStart();
    const matchingNode = (editor, parents2, format, similar, vars) => {
      const isMatchingNode = (node) => {
        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);
        return !isUndefined2(matchingFormat);
      };
      const isUnableToMatch = (node) => {
        if (matchesUnInheritedFormatSelector(editor, node, format)) {
          return true;
        } else {
          if (!similar) {
            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));
          } else {
            return false;
          }
        }
      };
      return findUntil$1(parents2, isMatchingNode, isUnableToMatch);
    };
    const getParents = (editor, elm) => {
      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);
      return filter$5(getParents$2(editor.dom, element), (node) => isElement$6(node) && !isBogus$2(node));
    };
    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {
      const parents2 = getParents(editor, elm);
      each$d(registeredCallbacks, (data3, format) => {
        const runIfChanged = (spec) => {
          const match2 = matchingNode(editor, parents2, format, spec.similar, hasVars(spec) ? spec.vars : void 0);
          const isSet = match2.isSome();
          if (spec.state.get() !== isSet) {
            spec.state.set(isSet);
            const node = match2.getOr(elm);
            if (hasVars(spec)) {
              spec.callback(isSet, {
                node,
                format,
                parents: parents2
              });
            } else {
              each$e(spec.callbacks, (callback) => callback(isSet, {
                node,
                format,
                parents: parents2
              }));
            }
          }
        };
        each$e([
          data3.withSimilar,
          data3.withoutSimilar
        ], runIfChanged);
        each$e(data3.withVars, runIfChanged);
      });
    };
    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(","), (format) => {
        const group = get$a(formatChangeItems, format).getOrThunk(() => {
          const base = {
            withSimilar: {
              state: Cell(false),
              similar: true,
              callbacks: []
            },
            withoutSimilar: {
              state: Cell(false),
              similar: false,
              callbacks: []
            },
            withVars: []
          };
          formatChangeItems[format] = base;
          return base;
        });
        const getCurrent = () => {
          const parents2 = getParents(editor);
          return matchingNode(editor, parents2, format, similar, vars).isSome();
        };
        if (isUndefined2(vars)) {
          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;
          toAppendTo.callbacks.push(callback);
          if (toAppendTo.callbacks.length === 1) {
            toAppendTo.state.set(getCurrent());
          }
        } else {
          group.withVars.push({
            state: Cell(getCurrent()),
            similar,
            vars,
            callback
          });
        }
      });
      registeredFormatListeners.set(formatChangeItems);
    };
    const removeListeners = (registeredFormatListeners, formats, callback) => {
      const formatChangeItems = registeredFormatListeners.get();
      each$e(formats.split(","), (format) => get$a(formatChangeItems, format).each((group) => {
        formatChangeItems[format] = {
          withSimilar: {
            ...group.withSimilar,
            callbacks: filter$5(group.withSimilar.callbacks, (cb) => cb !== callback)
          },
          withoutSimilar: {
            ...group.withoutSimilar,
            callbacks: filter$5(group.withoutSimilar.callbacks, (cb) => cb !== callback)
          },
          withVars: filter$5(group.withVars, (item2) => item2.callback !== callback)
        };
      }));
      registeredFormatListeners.set(formatChangeItems);
    };
    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {
      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);
      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };
    };
    const toggle = (editor, name3, vars, node) => {
      const fmt = editor.formatter.get(name3);
      if (fmt) {
        if (match$2(editor, name3, vars, node) && (!("toggle" in fmt[0]) || fmt[0].toggle)) {
          remove$2(editor, name3, vars, node);
        } else {
          applyFormat$1(editor, name3, vars, node);
        }
      }
    };
    const explode$1 = Tools.explode;
    const create$82 = () => {
      const filters2 = {};
      const addFilter2 = (name3, callback) => {
        each$e(explode$1(name3), (name4) => {
          if (!has$2(filters2, name4)) {
            filters2[name4] = {
              name: name4,
              callbacks: []
            };
          }
          filters2[name4].callbacks.push(callback);
        });
      };
      const getFilters = () => values(filters2);
      const removeFilter = (name3, callback) => {
        each$e(explode$1(name3), (name4) => {
          if (has$2(filters2, name4)) {
            if (isNonNullable(callback)) {
              const filter3 = filters2[name4];
              const newCallbacks = filter$5(filter3.callbacks, (c) => c !== callback);
              if (newCallbacks.length > 0) {
                filter3.callbacks = newCallbacks;
              } else {
                delete filters2[name4];
              }
            } else {
              delete filters2[name4];
            }
          }
        });
      };
      return {
        addFilter: addFilter2,
        getFilters,
        removeFilter
      };
    };
    const removeAttrs = (node, names) => {
      each$e(names, (name3) => {
        node.attr(name3, null);
      });
    };
    const addFontToSpansFilter = (domParser, styles2, fontSizes) => {
      domParser.addNodeFilter("font", (nodes) => {
        each$e(nodes, (node) => {
          const props = styles2.parse(node.attr("style"));
          const color = node.attr("color");
          const face = node.attr("face");
          const size = node.attr("size");
          if (color) {
            props.color = color;
          }
          if (face) {
            props["font-family"] = face;
          }
          if (size) {
            toInt2(size).each((num) => {
              props["font-size"] = fontSizes[num - 1];
            });
          }
          node.name = "span";
          node.attr("style", styles2.serialize(props));
          removeAttrs(node, [
            "color",
            "face",
            "size"
          ]);
        });
      });
    };
    const addStrikeFilter = (domParser, schema, styles2) => {
      domParser.addNodeFilter("strike", (nodes) => {
        const convertToSTag = schema.type !== "html4";
        each$e(nodes, (node) => {
          if (convertToSTag) {
            node.name = "s";
          } else {
            const props = styles2.parse(node.attr("style"));
            props["text-decoration"] = "line-through";
            node.name = "span";
            node.attr("style", styles2.serialize(props));
          }
        });
      });
    };
    const addFilters = (domParser, settings, schema) => {
      var _a;
      const styles2 = Styles();
      if (settings.convert_fonts_to_spans) {
        addFontToSpansFilter(domParser, styles2, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ""));
      }
      addStrikeFilter(domParser, schema, styles2);
    };
    const register$5 = (domParser, settings, schema) => {
      if (settings.inline_styles) {
        addFilters(domParser, settings, schema);
      }
    };
    const blobUriToBlob = (url) => fetch(url).then((res2) => res2.ok ? res2.blob() : Promise.reject()).catch(() => Promise.reject(`Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`));
    const extractBase64Data = (data3) => {
      const matches = /([a-z0-9+\/=\s]+)/i.exec(data3);
      return matches ? matches[1] : "";
    };
    const parseDataUri = (uri) => {
      const [type2, ...rest] = uri.split(",");
      const data3 = rest.join(",");
      const matches = /data:([^/]+\/[^;]+)(;.+)?/.exec(type2);
      if (matches) {
        const base64Encoded = matches[2] === ";base64";
        const extractedData = base64Encoded ? extractBase64Data(data3) : decodeURIComponent(data3);
        return Optional.some({
          type: matches[1],
          data: extractedData,
          base64Encoded
        });
      } else {
        return Optional.none();
      }
    };
    const buildBlob = (type2, data3, base64Encoded = true) => {
      let str = data3;
      if (base64Encoded) {
        try {
          str = atob(data3);
        } catch (e) {
          return Optional.none();
        }
      }
      const arr = new Uint8Array(str.length);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = str.charCodeAt(i);
      }
      return Optional.some(new Blob([arr], { type: type2 }));
    };
    const dataUriToBlob = (uri) => {
      return new Promise((resolve2, reject) => {
        parseDataUri(uri).bind(({ type: type2, data: data3, base64Encoded }) => buildBlob(type2, data3, base64Encoded)).fold(() => reject("Invalid data URI"), resolve2);
      });
    };
    const uriToBlob = (url) => {
      if (startsWith(url, "blob:")) {
        return blobUriToBlob(url);
      } else if (startsWith(url, "data:")) {
        return dataUriToBlob(url);
      } else {
        return Promise.reject("Unknown URI format");
      }
    };
    const blobToDataUri = (blob2) => {
      return new Promise((resolve2, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          resolve2(reader.result);
        };
        reader.onerror = () => {
          var _a;
          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);
        };
        reader.readAsDataURL(blob2);
      });
    };
    let count$1 = 0;
    const uniqueId$1 = (prefix) => {
      return (prefix || "blobid") + count$1++;
    };
    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {
      return parseDataUri(dataUri).bind(({ data: data3, type: type2, base64Encoded }) => {
        if (base64Only && !base64Encoded) {
          return Optional.none();
        } else {
          const base64 = base64Encoded ? data3 : btoa(data3);
          return generateBlobInfo(base64, type2);
        }
      });
    };
    const createBlobInfo$1 = (blobCache, blob2, base64) => {
      const blobInfo = blobCache.create(uniqueId$1(), blob2, base64);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {
      return processDataUri(dataUri, base64Only, (base64, type2) => Optional.from(blobCache.getByData(base64, type2)).orThunk(() => buildBlob(type2, base64).map((blob2) => createBlobInfo$1(blobCache, blob2, base64))));
    };
    const imageToBlobInfo = (blobCache, imageSrc) => {
      const invalidDataUri = () => Promise.reject("Invalid data URI");
      if (startsWith(imageSrc, "blob:")) {
        const blobInfo = blobCache.getByUri(imageSrc);
        if (isNonNullable(blobInfo)) {
          return Promise.resolve(blobInfo);
        } else {
          return uriToBlob(imageSrc).then((blob2) => {
            return blobToDataUri(blob2).then((dataUri) => {
              return processDataUri(dataUri, false, (base64) => {
                return Optional.some(createBlobInfo$1(blobCache, blob2, base64));
              }).getOrThunk(invalidDataUri);
            });
          });
        }
      } else if (startsWith(imageSrc, "data:")) {
        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, (blobInfo) => Promise.resolve(blobInfo));
      } else {
        return Promise.reject("Unknown image data format");
      }
    };
    const isBogusImage = (img) => isNonNullable(img.attr("data-mce-bogus"));
    const isInternalImageSource = (img) => img.attr("src") === Env.transparentSrc || isNonNullable(img.attr("data-mce-placeholder"));
    const registerBase64ImageFilter = (parser, settings) => {
      const { blob_cache: blobCache } = settings;
      if (blobCache) {
        const processImage = (img) => {
          const inputSrc = img.attr("src");
          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {
            return;
          }
          dataUriToBlobInfo(blobCache, inputSrc, true).each((blobInfo) => {
            img.attr("src", blobInfo.blobUri());
          });
        };
        parser.addAttributeFilter("src", (nodes) => each$e(nodes, processImage));
      }
    };
    const register$4 = (parser, settings) => {
      const schema = parser.schema;
      if (settings.remove_trailing_brs) {
        parser.addNodeFilter("br", (nodes, _2, args) => {
          const blockElements = Tools.extend({}, schema.getBlockElements());
          const nonEmptyElements = schema.getNonEmptyElements();
          const whitespaceElements = schema.getWhitespaceElements();
          blockElements.body = 1;
          const isBlock2 = (node) => node.name in blockElements && isTransparentAstInline(schema, node);
          for (let i = 0, l = nodes.length; i < l; i++) {
            let node = nodes[i];
            let parent2 = node.parent;
            if (parent2 && blockElements[parent2.name] && node === parent2.lastChild) {
              let prev2 = node.prev;
              while (prev2) {
                const prevName = prev2.name;
                if (prevName !== "span" || prev2.attr("data-mce-type") !== "bookmark") {
                  if (prevName === "br") {
                    node = null;
                  }
                  break;
                }
                prev2 = prev2.prev;
              }
              if (node) {
                node.remove();
                if (isEmpty2(schema, nonEmptyElements, whitespaceElements, parent2)) {
                  const elementRule = schema.getElementRule(parent2.name);
                  if (elementRule) {
                    if (elementRule.removeEmpty) {
                      parent2.remove();
                    } else if (elementRule.paddEmpty) {
                      paddEmptyNode(args, isBlock2, parent2);
                    }
                  }
                }
              }
            } else {
              let lastParent = node;
              while (parent2 && parent2.firstChild === lastParent && parent2.lastChild === lastParent) {
                lastParent = parent2;
                if (blockElements[parent2.name]) {
                  break;
                }
                parent2 = parent2.parent;
              }
              if (lastParent === parent2) {
                const textNode = new AstNode("#text", 3);
                textNode.value = nbsp;
                node.replace(textNode);
              }
            }
          }
        });
      }
      parser.addAttributeFilter("href", (nodes) => {
        let i = nodes.length;
        const appendRel = (rel) => {
          const parts = rel.split(" ").filter((p) => p.length > 0);
          return parts.concat(["noopener"]).sort().join(" ");
        };
        const addNoOpener = (rel) => {
          const newRel = rel ? Tools.trim(rel) : "";
          if (!/\b(noopener)\b/g.test(newRel)) {
            return appendRel(newRel);
          } else {
            return newRel;
          }
        };
        if (!settings.allow_unsafe_link_target) {
          while (i--) {
            const node = nodes[i];
            if (node.name === "a" && node.attr("target") === "_blank") {
              node.attr("rel", addNoOpener(node.attr("rel")));
            }
          }
        }
      });
      if (!settings.allow_html_in_named_anchor) {
        parser.addAttributeFilter("id,name", (nodes) => {
          let i = nodes.length, sibling2, prevSibling2, parent2, node;
          while (i--) {
            node = nodes[i];
            if (node.name === "a" && node.firstChild && !node.attr("href")) {
              parent2 = node.parent;
              sibling2 = node.lastChild;
              while (sibling2 && parent2) {
                prevSibling2 = sibling2.prev;
                parent2.insert(sibling2, node);
                sibling2 = prevSibling2;
              }
            }
          }
        });
      }
      if (settings.fix_list_elements) {
        parser.addNodeFilter("ul,ol", (nodes) => {
          let i = nodes.length, node, parentNode;
          while (i--) {
            node = nodes[i];
            parentNode = node.parent;
            if (parentNode && (parentNode.name === "ul" || parentNode.name === "ol")) {
              if (node.prev && node.prev.name === "li") {
                node.prev.append(node);
              } else {
                const li = new AstNode("li", 1);
                li.attr("style", "list-style-type: none");
                node.wrap(li);
              }
            }
          }
        });
      }
      const validClasses = schema.getValidClasses();
      if (settings.validate && validClasses) {
        parser.addAttributeFilter("class", (nodes) => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            const clazz = (_a = node.attr("class")) !== null && _a !== void 0 ? _a : "";
            const classList = Tools.explode(clazz, " ");
            let classValue = "";
            for (let ci = 0; ci < classList.length; ci++) {
              const className = classList[ci];
              let valid = false;
              let validClassesMap = validClasses["*"];
              if (validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              validClassesMap = validClasses[node.name];
              if (!valid && validClassesMap && validClassesMap[className]) {
                valid = true;
              }
              if (valid) {
                if (classValue) {
                  classValue += " ";
                }
                classValue += className;
              }
            }
            if (!classValue.length) {
              classValue = null;
            }
            node.attr("class", classValue);
          }
        });
      }
      registerBase64ImageFilter(parser, settings);
    };
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance2 = new Constructor();
          if (Class2)
            _setPrototypeOf(instance2, Class2.prototype);
          return instance2;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf2 = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var freeze = Object.freeze, seal = Object.seal, create$72 = Object.create;
    var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
    if (!apply) {
      apply = function apply2(fun, thisValue, args) {
        return fun.apply(thisValue, args);
      };
    }
    if (!freeze) {
      freeze = function freeze2(x) {
        return x;
      };
    }
    if (!seal) {
      seal = function seal2(x) {
        return x;
      };
    }
    if (!construct) {
      construct = function construct2(Func, args) {
        return _construct(Func, _toConsumableArray(args));
      };
    }
    var arrayForEach = unapply(Array.prototype.forEach);
    var arrayPop = unapply(Array.prototype.pop);
    var arrayPush = unapply(Array.prototype.push);
    var stringToLowerCase = unapply(String.prototype.toLowerCase);
    var stringMatch = unapply(String.prototype.match);
    var stringReplace = unapply(String.prototype.replace);
    var stringIndexOf = unapply(String.prototype.indexOf);
    var stringTrim = unapply(String.prototype.trim);
    var regExpTest = unapply(RegExp.prototype.test);
    var typeErrorCreate = unconstruct(TypeError);
    function unapply(func) {
      return function(thisArg) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return apply(func, thisArg, args);
      };
    }
    function unconstruct(func) {
      return function() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return construct(func, args);
      };
    }
    function addToSet(set2, array) {
      if (setPrototypeOf) {
        setPrototypeOf(set2, null);
      }
      var l = array.length;
      while (l--) {
        var element = array[l];
        if (typeof element === "string") {
          var lcElement = stringToLowerCase(element);
          if (lcElement !== element) {
            if (!isFrozen(array)) {
              array[l] = lcElement;
            }
            element = lcElement;
          }
        }
        set2[element] = true;
      }
      return set2;
    }
    function clone(object) {
      var newObject = create$72(null);
      var property;
      for (property in object) {
        if (apply(hasOwnProperty2, object, [property])) {
          newObject[property] = object[property];
        }
      }
      return newObject;
    }
    function lookupGetter(object, prop) {
      while (object !== null) {
        var desc = getOwnPropertyDescriptor(object, prop);
        if (desc) {
          if (desc.get) {
            return unapply(desc.get);
          }
          if (typeof desc.value === "function") {
            return unapply(desc.value);
          }
        }
        object = getPrototypeOf2(object);
      }
      function fallbackValue(element) {
        console.warn("fallback value for", element);
        return null;
      }
      return fallbackValue;
    }
    var html$1 = freeze([
      "a",
      "abbr",
      "acronym",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "bdi",
      "bdo",
      "big",
      "blink",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "center",
      "cite",
      "code",
      "col",
      "colgroup",
      "content",
      "data",
      "datalist",
      "dd",
      "decorator",
      "del",
      "details",
      "dfn",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "element",
      "em",
      "fieldset",
      "figcaption",
      "figure",
      "font",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "img",
      "input",
      "ins",
      "kbd",
      "label",
      "legend",
      "li",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meter",
      "nav",
      "nobr",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "section",
      "select",
      "shadow",
      "small",
      "source",
      "spacer",
      "span",
      "strike",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "template",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "tr",
      "track",
      "tt",
      "u",
      "ul",
      "var",
      "video",
      "wbr"
    ]);
    var svg$12 = freeze([
      "svg",
      "a",
      "altglyph",
      "altglyphdef",
      "altglyphitem",
      "animatecolor",
      "animatemotion",
      "animatetransform",
      "circle",
      "clippath",
      "defs",
      "desc",
      "ellipse",
      "filter",
      "font",
      "g",
      "glyph",
      "glyphref",
      "hkern",
      "image",
      "line",
      "lineargradient",
      "marker",
      "mask",
      "metadata",
      "mpath",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialgradient",
      "rect",
      "stop",
      "style",
      "switch",
      "symbol",
      "text",
      "textpath",
      "title",
      "tref",
      "tspan",
      "view",
      "vkern"
    ]);
    var svgFilters = freeze([
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence"
    ]);
    var svgDisallowed = freeze([
      "animate",
      "color-profile",
      "cursor",
      "discard",
      "fedropshadow",
      "font-face",
      "font-face-format",
      "font-face-name",
      "font-face-src",
      "font-face-uri",
      "foreignobject",
      "hatch",
      "hatchpath",
      "mesh",
      "meshgradient",
      "meshpatch",
      "meshrow",
      "missing-glyph",
      "script",
      "set",
      "solidcolor",
      "unknown",
      "use"
    ]);
    var mathMl$1 = freeze([
      "math",
      "menclose",
      "merror",
      "mfenced",
      "mfrac",
      "mglyph",
      "mi",
      "mlabeledtr",
      "mmultiscripts",
      "mn",
      "mo",
      "mover",
      "mpadded",
      "mphantom",
      "mroot",
      "mrow",
      "ms",
      "mspace",
      "msqrt",
      "mstyle",
      "msub",
      "msup",
      "msubsup",
      "mtable",
      "mtd",
      "mtext",
      "mtr",
      "munder",
      "munderover"
    ]);
    var mathMlDisallowed = freeze([
      "maction",
      "maligngroup",
      "malignmark",
      "mlongdiv",
      "mscarries",
      "mscarry",
      "msgroup",
      "mstack",
      "msline",
      "msrow",
      "semantics",
      "annotation",
      "annotation-xml",
      "mprescripts",
      "none"
    ]);
    var text2 = freeze(["#text"]);
    var html = freeze([
      "accept",
      "action",
      "align",
      "alt",
      "autocapitalize",
      "autocomplete",
      "autopictureinpicture",
      "autoplay",
      "background",
      "bgcolor",
      "border",
      "capture",
      "cellpadding",
      "cellspacing",
      "checked",
      "cite",
      "class",
      "clear",
      "color",
      "cols",
      "colspan",
      "controls",
      "controlslist",
      "coords",
      "crossorigin",
      "datetime",
      "decoding",
      "default",
      "dir",
      "disabled",
      "disablepictureinpicture",
      "disableremoteplayback",
      "download",
      "draggable",
      "enctype",
      "enterkeyhint",
      "face",
      "for",
      "headers",
      "height",
      "hidden",
      "high",
      "href",
      "hreflang",
      "id",
      "inputmode",
      "integrity",
      "ismap",
      "kind",
      "label",
      "lang",
      "list",
      "loading",
      "loop",
      "low",
      "max",
      "maxlength",
      "media",
      "method",
      "min",
      "minlength",
      "multiple",
      "muted",
      "name",
      "nonce",
      "noshade",
      "novalidate",
      "nowrap",
      "open",
      "optimum",
      "pattern",
      "placeholder",
      "playsinline",
      "poster",
      "preload",
      "pubdate",
      "radiogroup",
      "readonly",
      "rel",
      "required",
      "rev",
      "reversed",
      "role",
      "rows",
      "rowspan",
      "spellcheck",
      "scope",
      "selected",
      "shape",
      "size",
      "sizes",
      "span",
      "srclang",
      "start",
      "src",
      "srcset",
      "step",
      "style",
      "summary",
      "tabindex",
      "title",
      "translate",
      "type",
      "usemap",
      "valign",
      "value",
      "width",
      "xmlns",
      "slot"
    ]);
    var svg2 = freeze([
      "accent-height",
      "accumulate",
      "additive",
      "alignment-baseline",
      "ascent",
      "attributename",
      "attributetype",
      "azimuth",
      "basefrequency",
      "baseline-shift",
      "begin",
      "bias",
      "by",
      "class",
      "clip",
      "clippathunits",
      "clip-path",
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cx",
      "cy",
      "d",
      "dx",
      "dy",
      "diffuseconstant",
      "direction",
      "display",
      "divisor",
      "dur",
      "edgemode",
      "elevation",
      "end",
      "fill",
      "fill-opacity",
      "fill-rule",
      "filter",
      "filterunits",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "fx",
      "fy",
      "g1",
      "g2",
      "glyph-name",
      "glyphref",
      "gradientunits",
      "gradienttransform",
      "height",
      "href",
      "id",
      "image-rendering",
      "in",
      "in2",
      "k",
      "k1",
      "k2",
      "k3",
      "k4",
      "kerning",
      "keypoints",
      "keysplines",
      "keytimes",
      "lang",
      "lengthadjust",
      "letter-spacing",
      "kernelmatrix",
      "kernelunitlength",
      "lighting-color",
      "local",
      "marker-end",
      "marker-mid",
      "marker-start",
      "markerheight",
      "markerunits",
      "markerwidth",
      "maskcontentunits",
      "maskunits",
      "max",
      "mask",
      "media",
      "method",
      "mode",
      "min",
      "name",
      "numoctaves",
      "offset",
      "operator",
      "opacity",
      "order",
      "orient",
      "orientation",
      "origin",
      "overflow",
      "paint-order",
      "path",
      "pathlength",
      "patterncontentunits",
      "patterntransform",
      "patternunits",
      "points",
      "preservealpha",
      "preserveaspectratio",
      "primitiveunits",
      "r",
      "rx",
      "ry",
      "radius",
      "refx",
      "refy",
      "repeatcount",
      "repeatdur",
      "restart",
      "result",
      "rotate",
      "scale",
      "seed",
      "shape-rendering",
      "specularconstant",
      "specularexponent",
      "spreadmethod",
      "startoffset",
      "stddeviation",
      "stitchtiles",
      "stop-color",
      "stop-opacity",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke",
      "stroke-width",
      "style",
      "surfacescale",
      "systemlanguage",
      "tabindex",
      "targetx",
      "targety",
      "transform",
      "transform-origin",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "textlength",
      "type",
      "u1",
      "u2",
      "unicode",
      "values",
      "viewbox",
      "visibility",
      "version",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "width",
      "word-spacing",
      "wrap",
      "writing-mode",
      "xchannelselector",
      "ychannelselector",
      "x",
      "x1",
      "x2",
      "xmlns",
      "y",
      "y1",
      "y2",
      "z",
      "zoomandpan"
    ]);
    var mathMl = freeze([
      "accent",
      "accentunder",
      "align",
      "bevelled",
      "close",
      "columnsalign",
      "columnlines",
      "columnspan",
      "denomalign",
      "depth",
      "dir",
      "display",
      "displaystyle",
      "encoding",
      "fence",
      "frame",
      "height",
      "href",
      "id",
      "largeop",
      "length",
      "linethickness",
      "lspace",
      "lquote",
      "mathbackground",
      "mathcolor",
      "mathsize",
      "mathvariant",
      "maxsize",
      "minsize",
      "movablelimits",
      "notation",
      "numalign",
      "open",
      "rowalign",
      "rowlines",
      "rowspacing",
      "rowspan",
      "rspace",
      "rquote",
      "scriptlevel",
      "scriptminsize",
      "scriptsizemultiplier",
      "selection",
      "separator",
      "separators",
      "stretchy",
      "subscriptshift",
      "supscriptshift",
      "symmetric",
      "voffset",
      "width",
      "xmlns"
    ]);
    var xml = freeze([
      "xlink:href",
      "xml:id",
      "xlink:title",
      "xml:space",
      "xmlns:xlink"
    ]);
    var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
    var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
    var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
    var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
    var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
    var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
    var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
    var DOCTYPE_NAME = seal(/^html$/i);
    var getGlobal = function getGlobal2() {
      return typeof window === "undefined" ? null : window;
    };
    var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
      if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
        return null;
      }
      var suffix = null;
      var ATTR_NAME = "data-tt-policy-suffix";
      if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
        suffix = document2.currentScript.getAttribute(ATTR_NAME);
      }
      var policyName = "dompurify" + (suffix ? "#" + suffix : "");
      try {
        return trustedTypes.createPolicy(policyName, {
          createHTML: function createHTML(html2) {
            return html2;
          }
        });
      } catch (_2) {
        console.warn("TrustedTypes policy " + policyName + " could not be created.");
        return null;
      }
    };
    function createDOMPurify() {
      var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
      var DOMPurify = function DOMPurify2(root2) {
        return createDOMPurify(root2);
      };
      DOMPurify.version = "2.3.8";
      DOMPurify.removed = [];
      if (!window2 || !window2.document || window2.document.nodeType !== 9) {
        DOMPurify.isSupported = false;
        return DOMPurify;
      }
      var originalDocument = window2.document;
      var document2 = window2.document;
      var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
      var ElementPrototype = Element2.prototype;
      var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
      var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
      var getChildNodes2 = lookupGetter(ElementPrototype, "childNodes");
      var getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
      if (typeof HTMLTemplateElement === "function") {
        var template = document2.createElement("template");
        if (template.content && template.content.ownerDocument) {
          document2 = template.content.ownerDocument;
        }
      }
      var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
      var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
      var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
      var importNode2 = originalDocument.importNode;
      var documentMode = {};
      try {
        documentMode = clone(document2).documentMode ? document2.documentMode : {};
      } catch (_2) {
      }
      var hooks = {};
      DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
      var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
      var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
      var ALLOWED_TAGS = null;
      var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$12), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text2)));
      var ALLOWED_ATTR = null;
      var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg2), _toConsumableArray(mathMl), _toConsumableArray(xml)));
      var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
        tagNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        attributeNameCheck: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: true,
          configurable: false,
          enumerable: true,
          value: false
        }
      }));
      var FORBID_TAGS = null;
      var FORBID_ATTR = null;
      var ALLOW_ARIA_ATTR = true;
      var ALLOW_DATA_ATTR = true;
      var ALLOW_UNKNOWN_PROTOCOLS = false;
      var SAFE_FOR_TEMPLATES = false;
      var WHOLE_DOCUMENT = false;
      var SET_CONFIG = false;
      var FORCE_BODY = false;
      var RETURN_DOM = false;
      var RETURN_DOM_FRAGMENT = false;
      var RETURN_TRUSTED_TYPE = false;
      var SANITIZE_DOM = true;
      var KEEP_CONTENT = true;
      var IN_PLACE = false;
      var USE_PROFILES = {};
      var FORBID_CONTENTS = null;
      var DEFAULT_FORBID_CONTENTS = addToSet({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp"
      ]);
      var DATA_URI_TAGS = null;
      var DEFAULT_DATA_URI_TAGS = addToSet({}, [
        "audio",
        "video",
        "img",
        "source",
        "image",
        "track"
      ]);
      var URI_SAFE_ATTRIBUTES = null;
      var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns"
      ]);
      var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var NAMESPACE = HTML_NAMESPACE;
      var IS_EMPTY_INPUT = false;
      var PARSER_MEDIA_TYPE;
      var SUPPORTED_PARSER_MEDIA_TYPES = [
        "application/xhtml+xml",
        "text/html"
      ];
      var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
      var transformCaseFunc;
      var CONFIG = null;
      var formElement = document2.createElement("form");
      var isRegexOrFunction = function isRegexOrFunction2(testValue) {
        return testValue instanceof RegExp || testValue instanceof Function;
      };
      var _parseConfig = function _parseConfig2(cfg) {
        if (CONFIG && CONFIG === cfg) {
          return;
        }
        if (!cfg || _typeof(cfg) !== "object") {
          cfg = {};
        }
        cfg = clone(cfg);
        ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
        ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
        URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
        DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
        FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
        FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
        FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
        USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
        RETURN_DOM = cfg.RETURN_DOM || false;
        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
        FORCE_BODY = cfg.FORCE_BODY || false;
        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
        IN_PLACE = cfg.IN_PLACE || false;
        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
        }
        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
        }
        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
        transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
          return x;
        } : stringToLowerCase;
        if (SAFE_FOR_TEMPLATES) {
          ALLOW_DATA_ATTR = false;
        }
        if (RETURN_DOM_FRAGMENT) {
          RETURN_DOM = true;
        }
        if (USE_PROFILES) {
          ALLOWED_TAGS = addToSet({}, _toConsumableArray(text2));
          ALLOWED_ATTR = [];
          if (USE_PROFILES.html === true) {
            addToSet(ALLOWED_TAGS, html$1);
            addToSet(ALLOWED_ATTR, html);
          }
          if (USE_PROFILES.svg === true) {
            addToSet(ALLOWED_TAGS, svg$12);
            addToSet(ALLOWED_ATTR, svg2);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.svgFilters === true) {
            addToSet(ALLOWED_TAGS, svgFilters);
            addToSet(ALLOWED_ATTR, svg2);
            addToSet(ALLOWED_ATTR, xml);
          }
          if (USE_PROFILES.mathMl === true) {
            addToSet(ALLOWED_TAGS, mathMl$1);
            addToSet(ALLOWED_ATTR, mathMl);
            addToSet(ALLOWED_ATTR, xml);
          }
        }
        if (cfg.ADD_TAGS) {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
        }
        if (cfg.ADD_ATTR) {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
        }
        if (cfg.ADD_URI_SAFE_ATTR) {
          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
        }
        if (cfg.FORBID_CONTENTS) {
          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
            FORBID_CONTENTS = clone(FORBID_CONTENTS);
          }
          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
        }
        if (KEEP_CONTENT) {
          ALLOWED_TAGS["#text"] = true;
        }
        if (WHOLE_DOCUMENT) {
          addToSet(ALLOWED_TAGS, [
            "html",
            "head",
            "body"
          ]);
        }
        if (ALLOWED_TAGS.table) {
          addToSet(ALLOWED_TAGS, ["tbody"]);
          delete FORBID_TAGS.tbody;
        }
        if (freeze) {
          freeze(cfg);
        }
        CONFIG = cfg;
      };
      var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext"
      ]);
      var HTML_INTEGRATION_POINTS = addToSet({}, [
        "foreignobject",
        "desc",
        "title",
        "annotation-xml"
      ]);
      var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
        "title",
        "style",
        "font",
        "a",
        "script"
      ]);
      var ALL_SVG_TAGS = addToSet({}, svg$12);
      addToSet(ALL_SVG_TAGS, svgFilters);
      addToSet(ALL_SVG_TAGS, svgDisallowed);
      var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
      var _checkValidNamespace = function _checkValidNamespace2(element) {
        var parent2 = getParentNode2(element);
        if (!parent2 || !parent2.tagName) {
          parent2 = {
            namespaceURI: HTML_NAMESPACE,
            tagName: "template"
          };
        }
        var tagName = stringToLowerCase(element.tagName);
        var parentTagName = stringToLowerCase(parent2.tagName);
        if (element.namespaceURI === SVG_NAMESPACE) {
          if (parent2.namespaceURI === HTML_NAMESPACE) {
            return tagName === "svg";
          }
          if (parent2.namespaceURI === MATHML_NAMESPACE) {
            return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
          }
          return Boolean(ALL_SVG_TAGS[tagName]);
        }
        if (element.namespaceURI === MATHML_NAMESPACE) {
          if (parent2.namespaceURI === HTML_NAMESPACE) {
            return tagName === "math";
          }
          if (parent2.namespaceURI === SVG_NAMESPACE) {
            return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
          }
          return Boolean(ALL_MATHML_TAGS[tagName]);
        }
        if (element.namespaceURI === HTML_NAMESPACE) {
          if (parent2.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          if (parent2.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
            return false;
          }
          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
        }
        return false;
      };
      var _forceRemove = function _forceRemove2(node) {
        arrayPush(DOMPurify.removed, { element: node });
        try {
          node.parentNode.removeChild(node);
        } catch (_2) {
          try {
            node.outerHTML = emptyHTML;
          } catch (_3) {
            node.remove();
          }
        }
      };
      var _removeAttribute = function _removeAttribute2(name3, node) {
        try {
          arrayPush(DOMPurify.removed, {
            attribute: node.getAttributeNode(name3),
            from: node
          });
        } catch (_2) {
          arrayPush(DOMPurify.removed, {
            attribute: null,
            from: node
          });
        }
        node.removeAttribute(name3);
        if (name3 === "is" && !ALLOWED_ATTR[name3]) {
          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
            try {
              _forceRemove(node);
            } catch (_2) {
            }
          } else {
            try {
              node.setAttribute(name3, "");
            } catch (_2) {
            }
          }
        }
      };
      var _initDocument = function _initDocument2(dirty) {
        var doc;
        var leadingWhitespace;
        if (FORCE_BODY) {
          dirty = "<remove></remove>" + dirty;
        } else {
          var matches = stringMatch(dirty, /^[\r\n\t ]+/);
          leadingWhitespace = matches && matches[0];
        }
        if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
          dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
        }
        var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
        if (NAMESPACE === HTML_NAMESPACE) {
          try {
            doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
          } catch (_2) {
          }
        }
        if (!doc || !doc.documentElement) {
          doc = implementation.createDocument(NAMESPACE, "template", null);
          try {
            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
          } catch (_2) {
          }
        }
        var body = doc.body || doc.documentElement;
        if (dirty && leadingWhitespace) {
          body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
        }
        if (NAMESPACE === HTML_NAMESPACE) {
          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
        }
        return WHOLE_DOCUMENT ? doc.documentElement : body;
      };
      var _createIterator = function _createIterator2(root2) {
        return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT, null, false);
      };
      var _isClobbered = function _isClobbered2(elm) {
        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
      };
      var _isNode = function _isNode2(object) {
        return _typeof(Node2) === "object" ? object instanceof Node2 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
      };
      var _executeHook = function _executeHook2(entryPoint, currentNode, data3) {
        if (!hooks[entryPoint]) {
          return;
        }
        arrayForEach(hooks[entryPoint], function(hook) {
          hook.call(DOMPurify, currentNode, data3, CONFIG);
        });
      };
      var _sanitizeElements = function _sanitizeElements2(currentNode) {
        var content;
        _executeHook("beforeSanitizeElements", currentNode, null);
        if (_isClobbered(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
          _forceRemove(currentNode);
          return true;
        }
        var tagName = transformCaseFunc(currentNode.nodeName);
        _executeHook("uponSanitizeElement", currentNode, {
          tagName,
          allowedTags: ALLOWED_TAGS
        });
        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
          _forceRemove(currentNode);
          return true;
        }
        if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
              return false;
            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
              return false;
          }
          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
            var parentNode = getParentNode2(currentNode) || currentNode.parentNode;
            var childNodes = getChildNodes2(currentNode) || currentNode.childNodes;
            if (childNodes && parentNode) {
              var childCount = childNodes.length;
              for (var i = childCount - 1; i >= 0; --i) {
                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
              }
            }
          }
          _forceRemove(currentNode);
          return true;
        }
        if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
          _forceRemove(currentNode);
          return true;
        }
        if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
          _forceRemove(currentNode);
          return true;
        }
        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
          content = currentNode.textContent;
          content = stringReplace(content, MUSTACHE_EXPR$1, " ");
          content = stringReplace(content, ERB_EXPR$1, " ");
          if (currentNode.textContent !== content) {
            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
            currentNode.textContent = content;
          }
        }
        _executeHook("afterSanitizeElements", currentNode, null);
        return false;
      };
      var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value2) {
        if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value2 in document2 || value2 in formElement)) {
          return false;
        }
        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
          ;
        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
          ;
        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value2) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value2)))
            ;
          else {
            return false;
          }
        } else if (URI_SAFE_ATTRIBUTES[lcName])
          ;
        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
          ;
        else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value2, "data:") === 0 && DATA_URI_TAGS[lcTag])
          ;
        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
          ;
        else if (!value2)
          ;
        else {
          return false;
        }
        return true;
      };
      var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
        return tagName.indexOf("-") > 0;
      };
      var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
        var attr2;
        var value2;
        var lcName;
        var l;
        _executeHook("beforeSanitizeAttributes", currentNode, null);
        var attributes = currentNode.attributes;
        if (!attributes) {
          return;
        }
        var hookEvent = {
          attrName: "",
          attrValue: "",
          keepAttr: true,
          allowedAttributes: ALLOWED_ATTR
        };
        l = attributes.length;
        while (l--) {
          attr2 = attributes[l];
          var _attr = attr2, name3 = _attr.name, namespaceURI = _attr.namespaceURI;
          value2 = name3 === "value" ? attr2.value : stringTrim(attr2.value);
          lcName = transformCaseFunc(name3);
          var initValue = value2;
          hookEvent.attrName = lcName;
          hookEvent.attrValue = value2;
          hookEvent.keepAttr = true;
          hookEvent.forceKeepAttr = void 0;
          _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
          value2 = hookEvent.attrValue;
          if (hookEvent.forceKeepAttr) {
            continue;
          }
          if (!hookEvent.keepAttr) {
            _removeAttribute(name3, currentNode);
            continue;
          }
          if (regExpTest(/\/>/i, value2)) {
            _removeAttribute(name3, currentNode);
            continue;
          }
          if (SAFE_FOR_TEMPLATES) {
            value2 = stringReplace(value2, MUSTACHE_EXPR$1, " ");
            value2 = stringReplace(value2, ERB_EXPR$1, " ");
          }
          var lcTag = transformCaseFunc(currentNode.nodeName);
          if (!_isValidAttribute(lcTag, lcName, value2)) {
            _removeAttribute(name3, currentNode);
            continue;
          }
          if (value2 !== initValue) {
            try {
              if (namespaceURI) {
                currentNode.setAttributeNS(namespaceURI, name3, value2);
              } else {
                currentNode.setAttribute(name3, value2);
              }
            } catch (_2) {
              _removeAttribute(name3, currentNode);
            }
          }
        }
        _executeHook("afterSanitizeAttributes", currentNode, null);
      };
      var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
        var shadowNode;
        var shadowIterator = _createIterator(fragment);
        _executeHook("beforeSanitizeShadowDOM", fragment, null);
        while (shadowNode = shadowIterator.nextNode()) {
          _executeHook("uponSanitizeShadowNode", shadowNode, null);
          if (_sanitizeElements(shadowNode)) {
            continue;
          }
          if (shadowNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM2(shadowNode.content);
          }
          _sanitizeAttributes(shadowNode);
        }
        _executeHook("afterSanitizeShadowDOM", fragment, null);
      };
      DOMPurify.sanitize = function(dirty, cfg) {
        var body;
        var importedNode;
        var currentNode;
        var oldNode;
        var returnNode;
        IS_EMPTY_INPUT = !dirty;
        if (IS_EMPTY_INPUT) {
          dirty = "<!-->";
        }
        if (typeof dirty !== "string" && !_isNode(dirty)) {
          if (typeof dirty.toString !== "function") {
            throw typeErrorCreate("toString is not a function");
          } else {
            dirty = dirty.toString();
            if (typeof dirty !== "string") {
              throw typeErrorCreate("dirty is not a string, aborting");
            }
          }
        }
        if (!DOMPurify.isSupported) {
          if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
            if (typeof dirty === "string") {
              return window2.toStaticHTML(dirty);
            }
            if (_isNode(dirty)) {
              return window2.toStaticHTML(dirty.outerHTML);
            }
          }
          return dirty;
        }
        if (!SET_CONFIG) {
          _parseConfig(cfg);
        }
        DOMPurify.removed = [];
        if (typeof dirty === "string") {
          IN_PLACE = false;
        }
        if (IN_PLACE) {
          if (dirty.nodeName) {
            var tagName = transformCaseFunc(dirty.nodeName);
            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
              throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
            }
          }
        } else if (dirty instanceof Node2) {
          body = _initDocument("<!---->");
          importedNode = body.ownerDocument.importNode(dirty, true);
          if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
            body = importedNode;
          } else if (importedNode.nodeName === "HTML") {
            body = importedNode;
          } else {
            body.appendChild(importedNode);
          }
        } else {
          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
          }
          body = _initDocument(dirty);
          if (!body) {
            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
          }
        }
        if (body && FORCE_BODY) {
          _forceRemove(body.firstChild);
        }
        var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
        while (currentNode = nodeIterator.nextNode()) {
          if (currentNode.nodeType === 3 && currentNode === oldNode) {
            continue;
          }
          if (_sanitizeElements(currentNode)) {
            continue;
          }
          if (currentNode.content instanceof DocumentFragment) {
            _sanitizeShadowDOM(currentNode.content);
          }
          _sanitizeAttributes(currentNode);
          oldNode = currentNode;
        }
        oldNode = null;
        if (IN_PLACE) {
          return dirty;
        }
        if (RETURN_DOM) {
          if (RETURN_DOM_FRAGMENT) {
            returnNode = createDocumentFragment.call(body.ownerDocument);
            while (body.firstChild) {
              returnNode.appendChild(body.firstChild);
            }
          } else {
            returnNode = body;
          }
          if (ALLOWED_ATTR.shadowroot) {
            returnNode = importNode2.call(originalDocument, returnNode, true);
          }
          return returnNode;
        }
        var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
        if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
          serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
        }
        if (SAFE_FOR_TEMPLATES) {
          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
          serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
        }
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
      };
      DOMPurify.setConfig = function(cfg) {
        _parseConfig(cfg);
        SET_CONFIG = true;
      };
      DOMPurify.clearConfig = function() {
        CONFIG = null;
        SET_CONFIG = false;
      };
      DOMPurify.isValidAttribute = function(tag, attr2, value2) {
        if (!CONFIG) {
          _parseConfig({});
        }
        var lcTag = transformCaseFunc(tag);
        var lcName = transformCaseFunc(attr2);
        return _isValidAttribute(lcTag, lcName, value2);
      };
      DOMPurify.addHook = function(entryPoint, hookFunction) {
        if (typeof hookFunction !== "function") {
          return;
        }
        hooks[entryPoint] = hooks[entryPoint] || [];
        arrayPush(hooks[entryPoint], hookFunction);
      };
      DOMPurify.removeHook = function(entryPoint) {
        if (hooks[entryPoint]) {
          return arrayPop(hooks[entryPoint]);
        }
      };
      DOMPurify.removeHooks = function(entryPoint) {
        if (hooks[entryPoint]) {
          hooks[entryPoint] = [];
        }
      };
      DOMPurify.removeAllHooks = function() {
        hooks = {};
      };
      return DOMPurify;
    }
    var purify = createDOMPurify();
    const each$4 = Tools.each, trim2 = Tools.trim;
    const queryParts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    const DEFAULT_PORTS = {
      ftp: 21,
      http: 80,
      https: 443,
      mailto: 25
    };
    const safeSvgDataUrlElements = [
      "img",
      "video"
    ];
    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {
      if (isNonNullable(allowSvgDataUrls)) {
        return !allowSvgDataUrls;
      } else {
        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;
      }
    };
    const decodeUri = (encodedUri) => {
      try {
        return decodeURIComponent(encodedUri);
      } catch (ex) {
        return unescape(encodedUri);
      }
    };
    const isInvalidUri = (settings, uri, tagName) => {
      const decodedUri = decodeUri(uri).replace(/\s/g, "");
      if (settings.allow_script_urls) {
        return false;
      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {
        return true;
      } else if (settings.allow_html_data_urls) {
        return false;
      } else if (/^data:image\//i.test(decodedUri)) {
        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\/svg\+xml/i.test(decodedUri);
      } else {
        return /^data:/i.test(decodedUri);
      }
    };
    class URI {
      constructor(url, settings = {}) {
        this.path = "";
        this.directory = "";
        url = trim2(url);
        this.settings = settings;
        const baseUri = settings.base_uri;
        const self2 = this;
        if (/^([\w\-]+):([^\/]{2})/i.test(url) || /^\s*#/.test(url)) {
          self2.source = url;
          return;
        }
        const isProtocolRelative = url.indexOf("//") === 0;
        if (url.indexOf("/") === 0 && !isProtocolRelative) {
          url = (baseUri ? baseUri.protocol || "http" : "http") + "://mce_host" + url;
        }
        if (!/^[\w\-]*:?\/\//.test(url)) {
          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;
          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === "") {
            url = "//mce_host" + self2.toAbsPath(baseUrl, url);
          } else {
            const match2 = /([^#?]*)([#?]?.*)/.exec(url);
            if (match2) {
              url = (baseUri && baseUri.protocol || "http") + "://mce_host" + self2.toAbsPath(baseUrl, match2[1]) + match2[2];
            }
          }
        }
        url = url.replace(/@@/g, "(mce_at)");
        const urlMatch = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(url);
        if (urlMatch) {
          each$4(queryParts, (v, i) => {
            let part = urlMatch[i];
            if (part) {
              part = part.replace(/\(mce_at\)/g, "@@");
            }
            self2[v] = part;
          });
        }
        if (baseUri) {
          if (!self2.protocol) {
            self2.protocol = baseUri.protocol;
          }
          if (!self2.userInfo) {
            self2.userInfo = baseUri.userInfo;
          }
          if (!self2.port && self2.host === "mce_host") {
            self2.port = baseUri.port;
          }
          if (!self2.host || self2.host === "mce_host") {
            self2.host = baseUri.host;
          }
          self2.source = "";
        }
        if (isProtocolRelative) {
          self2.protocol = "";
        }
      }
      static parseDataUri(uri) {
        let type2;
        const uriComponents = decodeURIComponent(uri).split(",");
        const matches = /data:([^;]+)/.exec(uriComponents[0]);
        if (matches) {
          type2 = matches[1];
        }
        return {
          type: type2,
          data: uriComponents[1]
        };
      }
      static isDomSafe(uri, context2, options = {}) {
        if (options.allow_script_urls) {
          return true;
        } else {
          const decodedUri = Entities.decode(uri).replace(/[\s\u0000-\u001F]+/g, "");
          return !isInvalidUri(options, decodedUri, context2);
        }
      }
      static getDocumentBaseUrl(loc) {
        var _a;
        let baseUrl;
        if (loc.protocol.indexOf("http") !== 0 && loc.protocol !== "file:") {
          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : "";
        } else {
          baseUrl = loc.protocol + "//" + loc.host + loc.pathname;
        }
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(baseUrl)) {
          baseUrl = baseUrl.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
          if (!/[\/\\]$/.test(baseUrl)) {
            baseUrl += "/";
          }
        }
        return baseUrl;
      }
      setPath(path2) {
        const pathMatch = /^(.*?)\/?(\w+)?$/.exec(path2);
        if (pathMatch) {
          this.path = pathMatch[0];
          this.directory = pathMatch[1];
          this.file = pathMatch[2];
        }
        this.source = "";
        this.getURI();
      }
      toRelative(uri) {
        if (uri === "./") {
          return uri;
        }
        const relativeUri = new URI(uri, { base_uri: this });
        if (relativeUri.host !== "mce_host" && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== "") {
          return relativeUri.getURI();
        }
        const tu = this.getURI(), uu = relativeUri.getURI();
        if (tu === uu || tu.charAt(tu.length - 1) === "/" && tu.substr(0, tu.length - 1) === uu) {
          return tu;
        }
        let output = this.toRelPath(this.path, relativeUri.path);
        if (relativeUri.query) {
          output += "?" + relativeUri.query;
        }
        if (relativeUri.anchor) {
          output += "#" + relativeUri.anchor;
        }
        return output;
      }
      toAbsolute(uri, noHost) {
        const absoluteUri = new URI(uri, { base_uri: this });
        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));
      }
      isSameOrigin(uri) {
        if (this.host == uri.host && this.protocol == uri.protocol) {
          if (this.port == uri.port) {
            return true;
          }
          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;
          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {
            return true;
          }
        }
        return false;
      }
      toRelPath(base, path2) {
        let breakPoint = 0, out = "", i, l;
        const normalizedBase = base.substring(0, base.lastIndexOf("/")).split("/");
        const items = path2.split("/");
        if (normalizedBase.length >= items.length) {
          for (i = 0, l = normalizedBase.length; i < l; i++) {
            if (i >= items.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (normalizedBase.length < items.length) {
          for (i = 0, l = items.length; i < l; i++) {
            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {
              breakPoint = i + 1;
              break;
            }
          }
        }
        if (breakPoint === 1) {
          return path2;
        }
        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {
          out += "../";
        }
        for (i = breakPoint - 1, l = items.length; i < l; i++) {
          if (i !== breakPoint - 1) {
            out += "/" + items[i];
          } else {
            out += items[i];
          }
        }
        return out;
      }
      toAbsPath(base, path2) {
        let nb = 0;
        const tr = /\/$/.test(path2) ? "/" : "";
        const normalizedBase = base.split("/");
        const normalizedPath = path2.split("/");
        const baseParts = [];
        each$4(normalizedBase, (k) => {
          if (k) {
            baseParts.push(k);
          }
        });
        const pathParts = [];
        for (let i2 = normalizedPath.length - 1; i2 >= 0; i2--) {
          if (normalizedPath[i2].length === 0 || normalizedPath[i2] === ".") {
            continue;
          }
          if (normalizedPath[i2] === "..") {
            nb++;
            continue;
          }
          if (nb > 0) {
            nb--;
            continue;
          }
          pathParts.push(normalizedPath[i2]);
        }
        const i = baseParts.length - nb;
        let outPath;
        if (i <= 0) {
          outPath = reverse(pathParts).join("/");
        } else {
          outPath = baseParts.slice(0, i).join("/") + "/" + reverse(pathParts).join("/");
        }
        if (outPath.indexOf("/") !== 0) {
          outPath = "/" + outPath;
        }
        if (tr && outPath.lastIndexOf("/") !== outPath.length - 1) {
          outPath += tr;
        }
        return outPath;
      }
      getURI(noProtoHost = false) {
        let s;
        if (!this.source || noProtoHost) {
          s = "";
          if (!noProtoHost) {
            if (this.protocol) {
              s += this.protocol + "://";
            } else {
              s += "//";
            }
            if (this.userInfo) {
              s += this.userInfo + "@";
            }
            if (this.host) {
              s += this.host;
            }
            if (this.port) {
              s += ":" + this.port;
            }
          }
          if (this.path) {
            s += this.path;
          }
          if (this.query) {
            s += "?" + this.query;
          }
          if (this.anchor) {
            s += "#" + this.anchor;
          }
          this.source = s;
        }
        return this.source;
      }
    }
    const filteredUrlAttrs = Tools.makeMap("src,href,data,background,action,formaction,poster,xlink:href");
    const internalElementAttr = "data-mce-type";
    let uid = 0;
    const processNode = (node, settings, schema, evt) => {
      var _a, _b, _c, _d;
      const validate2 = settings.validate;
      const specialElements = schema.getSpecialElements();
      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : "")) {
        node.nodeValue = " " + node.nodeValue;
      }
      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();
      if (node.nodeType !== ELEMENT || lcTagName === "body") {
        return;
      }
      const element = SugarElement.fromDom(node);
      const isInternalElement = has$1(element, internalElementAttr);
      const bogus = get$9(element, "data-mce-bogus");
      if (!isInternalElement && isString2(bogus)) {
        if (bogus === "all") {
          remove$6(element);
        } else {
          unwrap(element);
        }
        return;
      }
      const rule = schema.getElementRule(lcTagName);
      if (validate2 && !rule) {
        if (has$2(specialElements, lcTagName)) {
          remove$6(element);
        } else {
          unwrap(element);
        }
        return;
      } else {
        if (isNonNullable(evt)) {
          evt.allowedTags[lcTagName] = true;
        }
      }
      if (validate2 && rule && !isInternalElement) {
        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], (attr2) => {
          set$3(element, attr2.name, attr2.value === "{$uid}" ? `mce_${uid++}` : attr2.value);
        });
        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], (attr2) => {
          if (!has$1(element, attr2.name)) {
            set$3(element, attr2.name, attr2.value === "{$uid}" ? `mce_${uid++}` : attr2.value);
          }
        });
        if (rule.attributesRequired && !exists(rule.attributesRequired, (attr2) => has$1(element, attr2))) {
          unwrap(element);
          return;
        }
        if (rule.removeEmptyAttrs && hasNone(element)) {
          unwrap(element);
          return;
        }
        if (rule.outputName && rule.outputName !== lcTagName) {
          mutate(element, rule.outputName);
        }
      }
    };
    const shouldKeepAttribute = (settings, schema, tagName, attrName, attrValue) => !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, "data-") || startsWith(attrName, "aria-"));
    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === "id" || attrName === "class" || attrName === "style");
    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();
    const filterAttributes = (ele, settings, schema) => {
      const { attributes } = ele;
      for (let i = attributes.length - 1; i >= 0; i--) {
        const attr2 = attributes[i];
        const attrName = attr2.name;
        const attrValue = attr2.value;
        if (!shouldKeepAttribute(settings, schema, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {
          ele.removeAttribute(attrName);
        } else if (isBooleanAttribute(attrName, schema)) {
          ele.setAttribute(attrName, attrName);
        }
      }
    };
    const setupPurify = (settings, schema) => {
      const purify$1 = purify();
      purify$1.addHook("uponSanitizeElement", (ele, evt) => {
        processNode(ele, settings, schema, evt);
      });
      purify$1.addHook("uponSanitizeAttribute", (ele, evt) => {
        const tagName = ele.tagName.toLowerCase();
        const { attrName, attrValue } = evt;
        evt.keepAttr = shouldKeepAttribute(settings, schema, tagName, attrName, attrValue);
        if (evt.keepAttr) {
          evt.allowedAttributes[attrName] = true;
          if (isBooleanAttribute(attrName, schema)) {
            evt.attrValue = attrName;
          }
          if (settings.allow_svg_data_urls && startsWith(attrValue, "data:image/svg+xml")) {
            evt.forceKeepAttr = true;
          }
        } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {
          evt.forceKeepAttr = true;
        }
      });
      return purify$1;
    };
    const getPurifyConfig = (settings, mimeType) => {
      const basePurifyConfig = {
        IN_PLACE: true,
        ALLOW_UNKNOWN_PROTOCOLS: true,
        ALLOWED_TAGS: [
          "#comment",
          "#cdata-section",
          "body"
        ],
        ALLOWED_ATTR: []
      };
      const config = { ...basePurifyConfig };
      config.PARSER_MEDIA_TYPE = mimeType;
      if (settings.allow_script_urls) {
        config.ALLOWED_URI_REGEXP = /.*/;
      } else if (settings.allow_html_data_urls) {
        config.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i;
      }
      return config;
    };
    const getSanitizer = (settings, schema) => {
      if (settings.sanitize) {
        const purify2 = setupPurify(settings, schema);
        return (body, mimeType) => {
          purify2.sanitize(body, getPurifyConfig(settings, mimeType));
          purify2.removed = [];
        };
      } else {
        return (body, _2) => {
          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
          let node;
          while (node = nodeIterator.nextNode()) {
            processNode(node, settings, schema);
            if (isElement$6(node)) {
              filterAttributes(node, settings, schema);
            }
          }
        };
      }
    };
    const makeMap = Tools.makeMap, extend$1 = Tools.extend;
    const transferChildren = (parent2, nativeParent, specialElements) => {
      const parentName = parent2.name;
      const isSpecial = parentName in specialElements && parentName !== "title" && parentName !== "textarea";
      const childNodes = nativeParent.childNodes;
      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {
        const nativeChild = childNodes[ni];
        const child2 = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);
        if (isElement$6(nativeChild)) {
          const attributes = nativeChild.attributes;
          for (let ai = 0, al = attributes.length; ai < al; ai++) {
            const attr2 = attributes[ai];
            child2.attr(attr2.name, attr2.value);
          }
        } else if (isText$a(nativeChild)) {
          child2.value = nativeChild.data;
          if (isSpecial) {
            child2.raw = true;
          }
        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {
          child2.value = nativeChild.data;
        }
        transferChildren(child2, nativeChild, specialElements);
        parent2.append(child2);
      }
    };
    const walkTree = (root2, preprocessors, postprocessors) => {
      const traverseOrder = [];
      for (let node = root2, lastNode = node; node; lastNode = node, node = node.walk()) {
        const tempNode = node;
        each$e(preprocessors, (preprocess2) => preprocess2(tempNode));
        if (isNullable(tempNode.parent) && tempNode !== root2) {
          node = lastNode;
        } else {
          traverseOrder.push(tempNode);
        }
      }
      for (let i = traverseOrder.length - 1; i >= 0; i--) {
        const node = traverseOrder[i];
        each$e(postprocessors, (postprocess) => postprocess(node));
      }
    };
    const whitespaceCleaner = (root2, schema, settings, args) => {
      const validate2 = settings.validate;
      const nonEmptyElements = schema.getNonEmptyElements();
      const whitespaceElements = schema.getWhitespaceElements();
      const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
      const textRootBlockElements = getTextRootBlockElements(schema);
      const allWhiteSpaceRegExp = /[ \t\r\n]+/g;
      const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
      const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
      const hasWhitespaceParent = (node) => {
        let tempNode = node.parent;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in whitespaceElements) {
            return true;
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isTextRootBlockEmpty = (node) => {
        let tempNode = node;
        while (isNonNullable(tempNode)) {
          if (tempNode.name in textRootBlockElements) {
            return isEmpty2(schema, nonEmptyElements, whitespaceElements, tempNode);
          } else {
            tempNode = tempNode.parent;
          }
        }
        return false;
      };
      const isBlock2 = (node) => node.name in blockElements && !isTransparentAstInline(schema, node);
      const isAtEdgeOfBlock = (node, start3) => {
        const neighbour = start3 ? node.prev : node.next;
        if (isNonNullable(neighbour) || isNullable(node.parent)) {
          return false;
        }
        return isBlock2(node.parent) && (node.parent !== root2 || args.isRootContent === true);
      };
      const preprocess2 = (node) => {
        var _a;
        if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text3 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
            text3 = text3.replace(allWhiteSpaceRegExp, " ");
            if (isLineBreakNode(node.prev, isBlock2) || isAtEdgeOfBlock(node, true)) {
              text3 = text3.replace(startWhiteSpaceRegExp, "");
            }
            if (text3.length === 0) {
              node.remove();
            } else {
              node.value = text3;
            }
          }
        }
      };
      const postprocess = (node) => {
        var _a;
        if (node.type === 1) {
          const elementRule = schema.getElementRule(node.name);
          if (validate2 && elementRule) {
            const isNodeEmpty = isEmpty2(schema, nonEmptyElements, whitespaceElements, node);
            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {
              paddEmptyNode(args, isBlock2, node);
            } else if (elementRule.removeEmpty && isNodeEmpty) {
              if (isBlock2(node)) {
                node.remove();
              } else {
                node.unwrap();
              }
            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {
              paddEmptyNode(args, isBlock2, node);
            }
          }
        } else if (node.type === 3) {
          if (!hasWhitespaceParent(node)) {
            let text3 = (_a = node.value) !== null && _a !== void 0 ? _a : "";
            if (node.next && isBlock2(node.next) || isAtEdgeOfBlock(node, false)) {
              text3 = text3.replace(endWhiteSpaceRegExp, "");
            }
            if (text3.length === 0) {
              node.remove();
            } else {
              node.value = text3;
            }
          }
        }
      };
      return [
        preprocess2,
        postprocess
      ];
    };
    const getRootBlockName = (settings, args) => {
      var _a;
      const name3 = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;
      if (name3 === false) {
        return "";
      } else if (name3 === true) {
        return "p";
      } else {
        return name3;
      }
    };
    const DomParser = (settings = {}, schema = Schema()) => {
      const nodeFilterRegistry = create$82();
      const attributeFilterRegistry = create$82();
      const defaultedSettings = {
        validate: true,
        root_name: "body",
        sanitize: true,
        ...settings
      };
      const parser = new DOMParser();
      const sanitize = getSanitizer(defaultedSettings, schema);
      const parseAndSanitizeWithContext = (html2, rootName, format = "html") => {
        const mimeType = format === "xhtml" ? "application/xhtml+xml" : "text/html";
        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());
        const content = isSpecialRoot ? `<${rootName}>${html2}</${rootName}>` : html2;
        const wrappedHtml = format === "xhtml" ? `<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>${content}</body></html>` : `<body>${content}</body>`;
        const body = parser.parseFromString(wrappedHtml, mimeType).body;
        sanitize(body, mimeType);
        return isSpecialRoot ? body.firstChild : body;
      };
      const addNodeFilter = nodeFilterRegistry.addFilter;
      const getNodeFilters = nodeFilterRegistry.getFilters;
      const removeNodeFilter = nodeFilterRegistry.removeFilter;
      const addAttributeFilter = attributeFilterRegistry.addFilter;
      const getAttributeFilters = attributeFilterRegistry.getFilters;
      const removeAttributeFilter = attributeFilterRegistry.removeFilter;
      const findInvalidChildren = (node, invalidChildren) => {
        if (isInvalid(schema, node)) {
          invalidChildren.push(node);
        }
      };
      const isWrappableNode = (blockElements, node) => {
        const isInternalElement = isString2(node.attr(internalElementAttr));
        const isInlineElement2 = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node));
        return node.type === 3 || isInlineElement2 && !isInternalElement;
      };
      const addRootBlocks2 = (rootNode, rootBlockName) => {
        const blockElements = extend$1(makeMap("script,style,head,html,body,title,meta,param"), schema.getBlockElements());
        const startWhiteSpaceRegExp = /^[ \t\r\n]+/;
        const endWhiteSpaceRegExp = /[ \t\r\n]+$/;
        let node = rootNode.firstChild, rootBlockNode = null;
        const trim3 = (rootBlock) => {
          var _a, _b;
          if (rootBlock) {
            node = rootBlock.firstChild;
            if (node && node.type === 3) {
              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, "");
            }
            node = rootBlock.lastChild;
            if (node && node.type === 3) {
              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, "");
            }
          }
        };
        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
          return;
        }
        while (node) {
          const next2 = node.next;
          if (isWrappableNode(blockElements, node)) {
            if (!rootBlockNode) {
              rootBlockNode = new AstNode(rootBlockName, 1);
              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);
              rootNode.insert(rootBlockNode, node);
              rootBlockNode.append(node);
            } else {
              rootBlockNode.append(node);
            }
          } else {
            trim3(rootBlockNode);
            rootBlockNode = null;
          }
          node = next2;
        }
        trim3(rootBlockNode);
      };
      const parse2 = (html2, args = {}) => {
        var _a;
        const validate2 = defaultedSettings.validate;
        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;
        const element = parseAndSanitizeWithContext(html2, rootName, args.format);
        updateChildren(schema, element);
        const rootNode = new AstNode(rootName, 11);
        transferChildren(rootNode, element, schema.getSpecialElements());
        element.innerHTML = "";
        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);
        const invalidChildren = [];
        const invalidFinder = validate2 ? (node) => findInvalidChildren(node, invalidChildren) : noop2;
        const matches = {
          nodes: {},
          attributes: {}
        };
        const matchFinder = (node) => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);
        walkTree(rootNode, [
          whitespacePre,
          matchFinder
        ], [
          whitespacePost,
          invalidFinder
        ]);
        invalidChildren.reverse();
        if (validate2 && invalidChildren.length > 0) {
          if (args.context) {
            const {
              pass: topLevelChildren,
              fail: otherChildren
            } = partition$2(invalidChildren, (child2) => child2.parent === rootNode);
            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);
            args.invalid = topLevelChildren.length > 0;
          } else {
            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);
          }
        }
        const rootBlockName = getRootBlockName(defaultedSettings, args);
        if (rootBlockName && (rootNode.name === "body" || args.isRootContent)) {
          addRootBlocks2(rootNode, rootBlockName);
        }
        if (!args.invalid) {
          runFilters(matches, args);
        }
        return rootNode;
      };
      const exports = {
        schema,
        addAttributeFilter,
        getAttributeFilters,
        removeAttributeFilter,
        addNodeFilter,
        getNodeFilters,
        removeNodeFilter,
        parse: parse2
      };
      register$4(exports, defaultedSettings);
      register$5(exports, defaultedSettings, schema);
      return exports;
    };
    const serializeContent = (content) => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;
    const withSerializedContent = (content, fireEvent2, sanitize) => {
      const serializedContent = serializeContent(content);
      const eventArgs = fireEvent2(serializedContent);
      if (eventArgs.isDefaultPrevented()) {
        return eventArgs;
      } else if (isTreeNode(content)) {
        if (eventArgs.content !== serializedContent) {
          const rootNode = DomParser({
            validate: false,
            forced_root_block: false,
            sanitize
          }).parse(eventArgs.content, { context: content.name });
          return {
            ...eventArgs,
            content: rootNode
          };
        } else {
          return {
            ...eventArgs,
            content
          };
        }
      } else {
        return eventArgs;
      }
    };
    const preProcessGetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const eventArgs = fireBeforeGetContent(editor, args);
        if (eventArgs.isDefaultPrevented()) {
          return Result.error(fireGetContent(editor, {
            content: "",
            ...eventArgs
          }).content);
        } else {
          return Result.value(eventArgs);
        }
      }
    };
    const postProcessGetContent = (editor, content, args) => {
      if (args.no_events) {
        return content;
      } else {
        const processedEventArgs = withSerializedContent(content, (content2) => fireGetContent(editor, {
          ...args,
          content: content2
        }), shouldSanitizeXss(editor));
        return processedEventArgs.content;
      }
    };
    const preProcessSetContent = (editor, args) => {
      if (args.no_events) {
        return Result.value(args);
      } else {
        const processedEventArgs = withSerializedContent(args.content, (content) => fireBeforeSetContent(editor, {
          ...args,
          content
        }), shouldSanitizeXss(editor));
        if (processedEventArgs.isDefaultPrevented()) {
          fireSetContent(editor, processedEventArgs);
          return Result.error(void 0);
        } else {
          return Result.value(processedEventArgs);
        }
      }
    };
    const postProcessSetContent = (editor, content, args) => {
      if (!args.no_events) {
        fireSetContent(editor, {
          ...args,
          content
        });
      }
    };
    const tableModel = (element, width2, rows) => ({
      element,
      width: width2,
      rows
    });
    const tableRow = (element, cells2) => ({
      element,
      cells: cells2
    });
    const cellPosition = (x, y) => ({
      x,
      y
    });
    const getSpan = (td, key) => {
      return getOpt(td, key).bind(toInt2).getOr(1);
    };
    const fillout = (table2, x, y, tr, td) => {
      const rowspan = getSpan(td, "rowspan");
      const colspan = getSpan(td, "colspan");
      const rows = table2.rows;
      for (let y2 = y; y2 < y + rowspan; y2++) {
        if (!rows[y2]) {
          rows[y2] = tableRow(deep$1(tr), []);
        }
        for (let x2 = x; x2 < x + colspan; x2++) {
          const cells2 = rows[y2].cells;
          cells2[x2] = y2 === y && x2 === x ? td : shallow$1(td);
        }
      }
    };
    const cellExists = (table2, x, y) => {
      const rows = table2.rows;
      const cells2 = rows[y] ? rows[y].cells : [];
      return !!cells2[x];
    };
    const skipCellsX = (table2, x, y) => {
      while (cellExists(table2, x, y)) {
        x++;
      }
      return x;
    };
    const getWidth = (rows) => {
      return foldl(rows, (acc, row) => {
        return row.cells.length > acc ? row.cells.length : acc;
      }, 0);
    };
    const findElementPos = (table2, element) => {
      const rows = table2.rows;
      for (let y = 0; y < rows.length; y++) {
        const cells2 = rows[y].cells;
        for (let x = 0; x < cells2.length; x++) {
          if (eq(cells2[x], element)) {
            return Optional.some(cellPosition(x, y));
          }
        }
      }
      return Optional.none();
    };
    const extractRows = (table2, sx, sy, ex, ey) => {
      const newRows = [];
      const rows = table2.rows;
      for (let y = sy; y <= ey; y++) {
        const cells2 = rows[y].cells;
        const slice = sx < ex ? cells2.slice(sx, ex + 1) : cells2.slice(ex, sx + 1);
        newRows.push(tableRow(rows[y].element, slice));
      }
      return newRows;
    };
    const subTable = (table2, startPos, endPos) => {
      const sx = startPos.x, sy = startPos.y;
      const ex = endPos.x, ey = endPos.y;
      const newRows = sy < ey ? extractRows(table2, sx, sy, ex, ey) : extractRows(table2, sx, ey, ex, sy);
      return tableModel(table2.element, getWidth(newRows), newRows);
    };
    const createDomTable = (table2, rows) => {
      const tableElement = shallow$1(table2.element);
      const tableBody = SugarElement.fromTag("tbody");
      append2(tableBody, rows);
      append$1(tableElement, tableBody);
      return tableElement;
    };
    const modelRowsToDomRows = (table2) => {
      return map$3(table2.rows, (row) => {
        const cells2 = map$3(row.cells, (cell2) => {
          const td = deep$1(cell2);
          remove$b(td, "colspan");
          remove$b(td, "rowspan");
          return td;
        });
        const tr = shallow$1(row.element);
        append2(tr, cells2);
        return tr;
      });
    };
    const fromDom = (tableElm) => {
      const table2 = tableModel(shallow$1(tableElm), 0, []);
      each$e(descendants(tableElm, "tr"), (tr, y) => {
        each$e(descendants(tr, "td,th"), (td, x) => {
          fillout(table2, skipCellsX(table2, x, y), y, tr, td);
        });
      });
      return tableModel(table2.element, getWidth(table2.rows), table2.rows);
    };
    const toDom = (table2) => {
      return createDomTable(table2, modelRowsToDomRows(table2));
    };
    const subsection = (table2, startElement, endElement) => {
      return findElementPos(table2, startElement).bind((startPos) => {
        return findElementPos(table2, endElement).map((endPos) => {
          return subTable(table2, startPos, endPos);
        });
      });
    };
    const findParentListContainer = (parents2) => find$2(parents2, (elm) => name2(elm) === "ul" || name2(elm) === "ol");
    const getFullySelectedListWrappers = (parents2, rng) => find$2(parents2, (elm) => name2(elm) === "li" && hasAllContentsSelected(elm, rng)).fold(constant([]), (_li) => findParentListContainer(parents2).map((listCont) => {
      const listElm = SugarElement.fromTag(name2(listCont));
      const listStyles = filter$4(getAllRaw(listCont), (_style, name3) => startsWith(name3, "list-style"));
      setAll(listElm, listStyles);
      return [
        SugarElement.fromTag("li"),
        listElm
      ];
    }).getOr([]));
    const wrap = (innerElm, elms) => {
      const wrapped = foldl(elms, (acc, elm) => {
        append$1(elm, acc);
        return elm;
      }, innerElm);
      return elms.length > 0 ? fromElements([wrapped]) : wrapped;
    };
    const directListWrappers = (commonAnchorContainer) => {
      if (isListItem$1(commonAnchorContainer)) {
        return parent(commonAnchorContainer).filter(isList).fold(constant([]), (listElm) => [
          commonAnchorContainer,
          listElm
        ]);
      } else {
        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];
      }
    };
    const getWrapElements = (rootNode, rng) => {
      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);
      const parents2 = parentsAndSelf(commonAnchorContainer, rootNode);
      const wrapElements = filter$5(parents2, isWrapElement);
      const listWrappers = getFullySelectedListWrappers(parents2, rng);
      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));
      return map$3(allWrappers, shallow$1);
    };
    const emptyFragment = () => fromElements([]);
    const getFragmentFromRange = (rootNode, rng) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng));
    const getParentTable = (rootElm, cell2) => ancestor$3(cell2, "table", curry(eq, rootElm));
    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind((tableElm) => {
      const firstCell = selectedTableCells[0];
      const lastCell = selectedTableCells[selectedTableCells.length - 1];
      const fullTableModel = fromDom(tableElm);
      return subsection(fullTableModel, firstCell, lastCell).map((sectionedTableModel) => fromElements([toDom(sectionedTableModel)]));
    }).getOrThunk(emptyFragment);
    const getSelectionFragment = (rootNode, ranges) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0]);
    const read$3 = (rootNode, ranges) => {
      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);
      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges);
    };
    const isCollapsibleWhitespace = (text3, index) => index >= 0 && index < text3.length && isWhiteSpace(text3.charAt(index));
    const getInnerText = (bin) => {
      return trim$12(bin.innerText);
    };
    const getContextNodeName = (parentBlockOpt) => parentBlockOpt.map((block) => block.nodeName).getOr("div").toLowerCase();
    const getTextContent = (editor) => Optional.from(editor.selection.getRng()).map((rng) => {
      var _a;
      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));
      const body = editor.getBody();
      const contextNodeName = getContextNodeName(parentBlockOpt);
      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());
      cleanupBogusElements(rangeContentClone);
      cleanupInputNames(rangeContentClone);
      const bin = editor.dom.add(body, contextNodeName, {
        "data-mce-bogus": "all",
        "style": "overflow: hidden; opacity: 0;"
      }, rangeContentClone.dom);
      const text3 = getInnerText(bin);
      const nonRenderedText = trim$12((_a = bin.textContent) !== null && _a !== void 0 ? _a : "");
      editor.dom.remove(bin);
      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {
        const parentBlock = parentBlockOpt.getOr(body);
        const parentBlockText = getInnerText(parentBlock);
        const textIndex = parentBlockText.indexOf(text3);
        if (textIndex === -1) {
          return text3;
        } else {
          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);
          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text3.length);
          return (hasProceedingSpace ? " " : "") + text3 + (hasTrailingSpace ? " " : "");
        }
      } else {
        return text3;
      }
    }).getOr("");
    const getSerializedContent = (editor, args) => {
      const rng = editor.selection.getRng(), tmpElm = editor.dom.create("body");
      const sel = editor.selection.getSel();
      const ranges = processRanges(editor, getRanges$1(sel));
      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges).dom : rng.cloneContents();
      if (fragment) {
        tmpElm.appendChild(fragment);
      }
      return editor.selection.serializer.serialize(tmpElm, args);
    };
    const extractSelectedContent = (editor, args) => {
      if (args.format === "text") {
        return getTextContent(editor);
      } else {
        const content = getSerializedContent(editor, args);
        if (args.format === "tree") {
          return content;
        } else {
          return editor.selection.isCollapsed() ? "" : content;
        }
      }
    };
    const setupArgs$3 = (args, format) => ({
      ...args,
      format,
      get: true,
      selection: true,
      getInner: true
    });
    const getSelectedContentInternal = (editor, format, args = {}) => {
      const defaultedArgs = setupArgs$3(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
        const content = extractSelectedContent(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };
    const KEEP = 0, INSERT = 1, DELETE = 2;
    const diff = (left2, right2) => {
      const size = left2.length + right2.length + 2;
      const vDown = new Array(size);
      const vUp = new Array(size);
      const snake = (start3, end3, diag) => {
        return {
          start: start3,
          end: end3,
          diag
        };
      };
      const buildScript = (start1, end1, start22, end22, script2) => {
        const middle = getMiddleSnake(start1, end1, start22, end22);
        if (middle === null || middle.start === end1 && middle.diag === end1 - end22 || middle.end === start1 && middle.diag === start1 - start22) {
          let i = start1;
          let j = start22;
          while (i < end1 || j < end22) {
            if (i < end1 && j < end22 && left2[i] === right2[j]) {
              script2.push([
                KEEP,
                left2[i]
              ]);
              ++i;
              ++j;
            } else {
              if (end1 - start1 > end22 - start22) {
                script2.push([
                  DELETE,
                  left2[i]
                ]);
                ++i;
              } else {
                script2.push([
                  INSERT,
                  right2[j]
                ]);
                ++j;
              }
            }
          }
        } else {
          buildScript(start1, middle.start, start22, middle.start - middle.diag, script2);
          for (let i2 = middle.start; i2 < middle.end; ++i2) {
            script2.push([
              KEEP,
              left2[i2]
            ]);
          }
          buildScript(middle.end, end1, middle.end - middle.diag, end22, script2);
        }
      };
      const buildSnake = (start3, diag, end1, end22) => {
        let end3 = start3;
        while (end3 - diag < end22 && end3 < end1 && left2[end3] === right2[end3 - diag]) {
          ++end3;
        }
        return snake(start3, end3, diag);
      };
      const getMiddleSnake = (start1, end1, start22, end22) => {
        const m = end1 - start1;
        const n = end22 - start22;
        if (m === 0 || n === 0) {
          return null;
        }
        const delta = m - n;
        const sum = n + m;
        const offset2 = (sum % 2 === 0 ? sum : sum + 1) / 2;
        vDown[1 + offset2] = start1;
        vUp[1 + offset2] = end1 + 1;
        let d, k, i, x, y;
        for (d = 0; d <= offset2; ++d) {
          for (k = -d; k <= d; k += 2) {
            i = k + offset2;
            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {
              vDown[i] = vDown[i + 1];
            } else {
              vDown[i] = vDown[i - 1] + 1;
            }
            x = vDown[i];
            y = x - start1 + start22 - k;
            while (x < end1 && y < end22 && left2[x] === right2[y]) {
              vDown[i] = ++x;
              ++y;
            }
            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {
              if (vUp[i - delta] <= vDown[i]) {
                return buildSnake(vUp[i - delta], k + start1 - start22, end1, end22);
              }
            }
          }
          for (k = delta - d; k <= delta + d; k += 2) {
            i = k + offset2 - delta;
            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {
              vUp[i] = vUp[i + 1] - 1;
            } else {
              vUp[i] = vUp[i - 1];
            }
            x = vUp[i] - 1;
            y = x - start1 + start22 - k;
            while (x >= start1 && y >= start22 && left2[x] === right2[y]) {
              vUp[i] = x--;
              y--;
            }
            if (delta % 2 === 0 && -d <= k && k <= d) {
              if (vUp[i] <= vDown[i + delta]) {
                return buildSnake(vUp[i], k + start1 - start22, end1, end22);
              }
            }
          }
        }
        return null;
      };
      const script = [];
      buildScript(0, left2.length, 0, right2.length, script);
      return script;
    };
    const getOuterHtml = (elm) => {
      if (isElement$6(elm)) {
        return elm.outerHTML;
      } else if (isText$a(elm)) {
        return Entities.encodeRaw(elm.data, false);
      } else if (isComment(elm)) {
        return "<!--" + elm.data + "-->";
      }
      return "";
    };
    const createFragment = (html2) => {
      let node;
      const container = document.createElement("div");
      const frag = document.createDocumentFragment();
      if (html2) {
        container.innerHTML = html2;
      }
      while (node = container.firstChild) {
        frag.appendChild(node);
      }
      return frag;
    };
    const insertAt = (elm, html2, index) => {
      const fragment = createFragment(html2);
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.insertBefore(fragment, target);
      } else {
        elm.appendChild(fragment);
      }
    };
    const removeAt = (elm, index) => {
      if (elm.hasChildNodes() && index < elm.childNodes.length) {
        const target = elm.childNodes[index];
        elm.removeChild(target);
      }
    };
    const applyDiff = (diff2, elm) => {
      let index = 0;
      each$e(diff2, (action2) => {
        if (action2[0] === KEEP) {
          index++;
        } else if (action2[0] === INSERT) {
          insertAt(elm, action2[1], index);
          index++;
        } else if (action2[0] === DELETE) {
          removeAt(elm, index);
        }
      });
    };
    const read$2 = (elm) => {
      return filter$5(map$3(from(elm.childNodes), getOuterHtml), (item2) => {
        return item2.length > 0;
      });
    };
    const write2 = (fragments, elm) => {
      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);
      applyDiff(diff(currentFragments, fragments), elm);
      return elm;
    };
    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument("undo"));
    const hasIframes = (html2) => {
      return html2.indexOf("</iframe>") !== -1;
    };
    const createFragmentedLevel = (fragments) => {
      return {
        type: "fragmented",
        fragments,
        content: "",
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createCompleteLevel = (content) => {
      return {
        type: "complete",
        fragments: null,
        content,
        bookmark: null,
        beforeBookmark: null
      };
    };
    const createFromEditor = (editor) => {
      const fragments = read$2(editor.getBody());
      const trimmedFragments = bind$3(fragments, (html2) => {
        const trimmed = trimInternal(editor.serializer, html2);
        return trimmed.length > 0 ? [trimmed] : [];
      });
      const content = trimmedFragments.join("");
      return hasIframes(content) ? createFragmentedLevel(trimmedFragments) : createCompleteLevel(content);
    };
    const applyToEditor = (editor, level, before2) => {
      const bookmark = before2 ? level.beforeBookmark : level.bookmark;
      if (level.type === "fragmented") {
        write2(level.fragments, editor.getBody());
      } else {
        editor.setContent(level.content, {
          format: "raw",
          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
        });
      }
      if (bookmark) {
        editor.selection.moveToBookmark(bookmark);
        editor.selection.scrollIntoView();
      }
    };
    const getLevelContent = (level) => {
      return level.type === "fragmented" ? level.fragments.join("") : level.content;
    };
    const getCleanLevelContent = (level) => {
      const elm = SugarElement.fromTag("body", lazyTempDocument());
      set$1(elm, getLevelContent(level));
      each$e(descendants(elm, "*[data-mce-bogus]"), unwrap);
      return get$6(elm);
    };
    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);
    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);
    const isEq$1 = (level1, level2) => {
      if (!level1 || !level2) {
        return false;
      } else if (hasEqualContent(level1, level2)) {
        return true;
      } else {
        return hasEqualCleanedContent(level1, level2);
      }
    };
    const isUnlocked = (locks) => locks.get() === 0;
    const setTyping = (undoManager, typing, locks) => {
      if (isUnlocked(locks)) {
        undoManager.typing = typing;
      }
    };
    const endTyping = (undoManager, locks) => {
      if (undoManager.typing) {
        setTyping(undoManager, false, locks);
        undoManager.add();
      }
    };
    const endTypingLevelIgnoreLocks = (undoManager) => {
      if (undoManager.typing) {
        undoManager.typing = false;
        undoManager.add();
      }
    };
    const beforeChange$1 = (editor, locks, beforeBookmark) => {
      if (isUnlocked(locks)) {
        beforeBookmark.set(getUndoBookmark(editor.selection));
      }
    };
    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {
      const currentLevel = createFromEditor(editor);
      const newLevel = Tools.extend(level || {}, currentLevel);
      if (!isUnlocked(locks) || editor.removed) {
        return null;
      }
      const lastLevel = undoManager.data[index.get()];
      if (editor.dispatch("BeforeAddUndo", {
        level: newLevel,
        lastLevel,
        originalEvent: event
      }).isDefaultPrevented()) {
        return null;
      }
      if (lastLevel && isEq$1(lastLevel, newLevel)) {
        return null;
      }
      if (undoManager.data[index.get()]) {
        beforeBookmark.get().each((bm) => {
          undoManager.data[index.get()].beforeBookmark = bm;
        });
      }
      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);
      if (customUndoRedoLevels) {
        if (undoManager.data.length > customUndoRedoLevels) {
          for (let i = 0; i < undoManager.data.length - 1; i++) {
            undoManager.data[i] = undoManager.data[i + 1];
          }
          undoManager.data.length--;
          index.set(undoManager.data.length);
        }
      }
      newLevel.bookmark = getUndoBookmark(editor.selection);
      if (index.get() < undoManager.data.length - 1) {
        undoManager.data.length = index.get() + 1;
      }
      undoManager.data.push(newLevel);
      index.set(undoManager.data.length - 1);
      const args = {
        level: newLevel,
        lastLevel,
        originalEvent: event
      };
      if (index.get() > 0) {
        editor.setDirty(true);
        editor.dispatch("AddUndo", args);
        editor.dispatch("change", args);
      } else {
        editor.dispatch("AddUndo", args);
      }
      return newLevel;
    };
    const clear$12 = (editor, undoManager, index) => {
      undoManager.data = [];
      index.set(0);
      undoManager.typing = false;
      editor.dispatch("ClearUndos");
    };
    const extra$1 = (editor, undoManager, index, callback1, callback2) => {
      if (undoManager.transact(callback1)) {
        const bookmark = undoManager.data[index.get()].bookmark;
        const lastLevel = undoManager.data[index.get() - 1];
        applyToEditor(editor, lastLevel, true);
        if (undoManager.transact(callback2)) {
          undoManager.data[index.get() - 1].beforeBookmark = bookmark;
        }
      }
    };
    const redo$1 = (editor, index, data3) => {
      let level;
      if (index.get() < data3.length - 1) {
        index.set(index.get() + 1);
        level = data3[index.get()];
        applyToEditor(editor, level, false);
        editor.setDirty(true);
        editor.dispatch("Redo", { level });
      }
      return level;
    };
    const undo$1 = (editor, undoManager, locks, index) => {
      let level;
      if (undoManager.typing) {
        undoManager.add();
        undoManager.typing = false;
        setTyping(undoManager, false, locks);
      }
      if (index.get() > 0) {
        index.set(index.get() - 1);
        level = undoManager.data[index.get()];
        applyToEditor(editor, level, true);
        editor.setDirty(true);
        editor.dispatch("Undo", { level });
      }
      return level;
    };
    const reset$1 = (undoManager) => {
      undoManager.clear();
      undoManager.add();
    };
    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);
    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;
    const transact$1 = (undoManager, locks, callback) => {
      endTyping(undoManager, locks);
      undoManager.beforeChange();
      undoManager.ignore(callback);
      return undoManager.add();
    };
    const ignore$1 = (locks, callback) => {
      try {
        locks.set(locks.get() + 1);
        callback();
      } finally {
        locks.set(locks.get() - 1);
      }
    };
    const addVisualInternal = (editor, elm) => {
      const dom2 = editor.dom;
      const scope = isNonNullable(elm) ? elm : editor.getBody();
      each$e(dom2.select("table,a", scope), (matchedElm) => {
        switch (matchedElm.nodeName) {
          case "TABLE":
            const cls = getVisualAidsTableClass(editor);
            const value2 = dom2.getAttrib(matchedElm, "border");
            if ((!value2 || value2 === "0") && editor.hasVisual) {
              dom2.addClass(matchedElm, cls);
            } else {
              dom2.removeClass(matchedElm, cls);
            }
            break;
          case "A":
            if (!dom2.getAttrib(matchedElm, "href")) {
              const value3 = dom2.getAttrib(matchedElm, "name") || matchedElm.id;
              const cls2 = getVisualAidsAnchorClass(editor);
              if (value3 && editor.hasVisual) {
                dom2.addClass(matchedElm, cls2);
              } else {
                dom2.removeClass(matchedElm, cls2);
              }
            }
            break;
        }
      });
      editor.dispatch("VisualAid", {
        element: elm,
        hasVisual: editor.hasVisual
      });
    };
    const makePlainAdaptor = (editor) => ({
      init: { bindEvents: noop2 },
      undoManager: {
        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),
        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),
        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),
        redo: (index, data3) => redo$1(editor, index, data3),
        clear: (undoManager, index) => clear$12(editor, undoManager, index),
        reset: (undoManager) => reset$1(undoManager),
        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),
        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),
        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),
        ignore: (locks, callback) => ignore$1(locks, callback),
        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)
      },
      formatter: {
        match: (name3, vars, node, similar) => match$2(editor, name3, vars, node, similar),
        matchAll: (names, vars) => matchAll2(editor, names, vars),
        matchNode: (node, name3, vars, similar) => matchNode(editor, node, name3, vars, similar),
        canApply: (name3) => canApply(editor, name3),
        closest: (names) => closest(editor, names),
        apply: (name3, vars, node) => applyFormat$1(editor, name3, vars, node),
        remove: (name3, vars, node, similar) => remove$2(editor, name3, vars, node, similar),
        toggle: (name3, vars, node) => toggle(editor, name3, vars, node),
        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)
      },
      editor: {
        getContent: (args) => getContentInternal(editor, args),
        setContent: (content, args) => setContentInternal(editor, content, args),
        insertContent: (value2, details) => insertHtmlAtCaret(editor, value2, details),
        addVisual: (elm) => addVisualInternal(editor, elm)
      },
      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },
      autocompleter: {
        addDecoration: (range2) => create$92(editor, range2),
        removeDecoration: () => remove$3(editor, SugarElement.fromDom(editor.getBody()))
      },
      raw: { getModel: () => Optional.none() }
    });
    const makeRtcAdaptor = (rtcEditor) => {
      const defaultVars = (vars) => isObject2(vars) ? vars : {};
      const { init: init2, undoManager, formatter, editor, selection, autocompleter, raw } = rtcEditor;
      return {
        init: { bindEvents: init2.bindEvents },
        undoManager: {
          beforeChange: undoManager.beforeChange,
          add: undoManager.add,
          undo: undoManager.undo,
          redo: undoManager.redo,
          clear: undoManager.clear,
          reset: undoManager.reset,
          hasUndo: undoManager.hasUndo,
          hasRedo: undoManager.hasRedo,
          transact: (_undoManager, _locks, fn3) => undoManager.transact(fn3),
          ignore: (_locks, callback) => undoManager.ignore(callback),
          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)
        },
        formatter: {
          match: (name3, vars, _node, similar) => formatter.match(name3, defaultVars(vars), similar),
          matchAll: formatter.matchAll,
          matchNode: formatter.matchNode,
          canApply: (name3) => formatter.canApply(name3),
          closest: (names) => formatter.closest(names),
          apply: (name3, vars, _node) => formatter.apply(name3, defaultVars(vars)),
          remove: (name3, vars, _node, _similar) => formatter.remove(name3, defaultVars(vars)),
          toggle: (name3, vars, _node) => formatter.toggle(name3, defaultVars(vars)),
          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)
        },
        editor: {
          getContent: (args) => editor.getContent(args),
          setContent: (content, args) => {
            return {
              content: editor.setContent(content, args),
              html: ""
            };
          },
          insertContent: (content, _details) => {
            editor.insertContent(content);
            return "";
          },
          addVisual: editor.addVisual
        },
        selection: { getContent: (_format, args) => selection.getContent(args) },
        autocompleter: {
          addDecoration: autocompleter.addDecoration,
          removeDecoration: autocompleter.removeDecoration
        },
        raw: { getModel: () => Optional.some(raw.getRawModel()) }
      };
    };
    const makeNoopAdaptor = () => {
      const nul = constant(null);
      const empty2 = constant("");
      return {
        init: { bindEvents: noop2 },
        undoManager: {
          beforeChange: noop2,
          add: nul,
          undo: nul,
          redo: nul,
          clear: noop2,
          reset: noop2,
          hasUndo: never,
          hasRedo: never,
          transact: nul,
          ignore: noop2,
          extra: noop2
        },
        formatter: {
          match: never,
          matchAll: constant([]),
          matchNode: constant(void 0),
          canApply: never,
          closest: empty2,
          apply: noop2,
          remove: noop2,
          toggle: noop2,
          formatChanged: constant({ unbind: noop2 })
        },
        editor: {
          getContent: empty2,
          setContent: constant({
            content: "",
            html: ""
          }),
          insertContent: constant(""),
          addVisual: noop2
        },
        selection: { getContent: empty2 },
        autocompleter: {
          addDecoration: noop2,
          removeDecoration: noop2
        },
        raw: { getModel: constant(Optional.none()) }
      };
    };
    const isRtc = (editor) => has$2(editor.plugins, "rtc");
    const getRtcSetup = (editor) => get$a(editor.plugins, "rtc").bind((rtcPlugin) => Optional.from(rtcPlugin.setup));
    const setup$s = (editor) => {
      const editorCast = editor;
      return getRtcSetup(editor).fold(() => {
        editorCast.rtcInstance = makePlainAdaptor(editor);
        return Optional.none();
      }, (setup2) => {
        editorCast.rtcInstance = makeNoopAdaptor();
        return Optional.some(() => setup2().then((rtcEditor) => {
          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);
          return rtcEditor.rtc.isRemote;
        }));
      });
    };
    const getRtcInstanceWithFallback = (editor) => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);
    const getRtcInstanceWithError = (editor) => {
      const rtcInstance = editor.rtcInstance;
      if (!rtcInstance) {
        throw new Error("Failed to get RTC instance not yet initialized.");
      } else {
        return rtcInstance;
      }
    };
    const beforeChange = (editor, locks, beforeBookmark) => {
      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);
    };
    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);
    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);
    const redo = (editor, index, data3) => getRtcInstanceWithError(editor).undoManager.redo(index, data3);
    const clear2 = (editor, undoManager, index) => {
      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);
    };
    const reset = (editor, undoManager) => {
      getRtcInstanceWithError(editor).undoManager.reset(undoManager);
    };
    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);
    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);
    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);
    const ignore = (editor, locks, callback) => {
      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);
    };
    const extra = (editor, undoManager, index, callback1, callback2) => {
      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);
    };
    const matchFormat = (editor, name3, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name3, vars, node, similar);
    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);
    const matchNodeFormat = (editor, node, name3, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name3, vars, similar);
    const canApplyFormat = (editor, name3) => getRtcInstanceWithError(editor).formatter.canApply(name3);
    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);
    const applyFormat = (editor, name3, vars, node) => {
      getRtcInstanceWithError(editor).formatter.apply(name3, vars, node);
    };
    const removeFormat = (editor, name3, vars, node, similar) => {
      getRtcInstanceWithError(editor).formatter.remove(name3, vars, node, similar);
    };
    const toggleFormat = (editor, name3, vars, node) => {
      getRtcInstanceWithError(editor).formatter.toggle(name3, vars, node);
    };
    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);
    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);
    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);
    const insertContent$1 = (editor, value2, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value2, details);
    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);
    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);
    const bindEvents = (editor) => getRtcInstanceWithError(editor).init.bindEvents();
    const addAutocompleterDecoration = (editor, range2) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range2);
    const removeAutocompleterDecoration = (editor) => getRtcInstanceWithError(editor).autocompleter.removeDecoration();
    const getContent$1 = (editor, args = {}) => {
      const format = args.format ? args.format : "html";
      return getSelectedContent(editor, format, args);
    };
    const removeEmpty = (text3) => {
      if (text3.dom.length === 0) {
        remove$6(text3);
        return Optional.none();
      } else {
        return Optional.some(text3);
      }
    };
    const walkPastBookmark = (node, start3) => node.filter((elm) => BookmarkManager.isBookmarkNode(elm.dom)).bind(start3 ? nextSibling : prevSibling);
    const merge$1 = (outer, inner, rng, start3) => {
      const outerElm = outer.dom;
      const innerElm = inner.dom;
      const oldLength = start3 ? outerElm.length : innerElm.length;
      if (start3) {
        mergeTextNodes(outerElm, innerElm, false, !start3);
        rng.setStart(innerElm, oldLength);
      } else {
        mergeTextNodes(innerElm, outerElm, false, !start3);
        rng.setEnd(innerElm, oldLength);
      }
    };
    const normalizeTextIfRequired = (inner, start3) => {
      parent(inner).each((root2) => {
        const text3 = inner.dom;
        if (start3 && needsToBeNbspLeft(root2, CaretPosition(text3, 0))) {
          normalizeWhitespaceAfter(text3, 0);
        } else if (!start3 && needsToBeNbspRight(root2, CaretPosition(text3, text3.length))) {
          normalizeWhitespaceBefore(text3, text3.length);
        }
      });
    };
    const mergeAndNormalizeText = (outerNode, innerNode, rng, start3) => {
      outerNode.bind((outer) => {
        const normalizer = start3 ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;
        normalizer(outer.dom, start3 ? outer.dom.length : 0);
        return innerNode.filter(isText$b).map((inner) => merge$1(outer, inner, rng, start3));
      }).orThunk(() => {
        const innerTextNode = walkPastBookmark(innerNode, start3).or(innerNode).filter(isText$b);
        return innerTextNode.map((inner) => normalizeTextIfRequired(inner, start3));
      });
    };
    const rngSetContent = (rng, fragment) => {
      const firstChild2 = Optional.from(fragment.firstChild).map(SugarElement.fromDom);
      const lastChild2 = Optional.from(fragment.lastChild).map(SugarElement.fromDom);
      rng.deleteContents();
      rng.insertNode(fragment);
      const prevText = firstChild2.bind(prevSibling).filter(isText$b).bind(removeEmpty);
      const nextText = lastChild2.bind(nextSibling).filter(isText$b).bind(removeEmpty);
      mergeAndNormalizeText(prevText, firstChild2, rng, true);
      mergeAndNormalizeText(nextText, lastChild2, rng, false);
      rng.collapse(false);
    };
    const setupArgs$2 = (args, content) => ({
      format: "html",
      ...args,
      set: true,
      selection: true,
      content
    });
    const cleanContent = (editor, args) => {
      if (args.format !== "raw") {
        const rng = editor.selection.getRng();
        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);
        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};
        const node = editor.parser.parse(args.content, {
          forced_root_block: false,
          ...contextArgs,
          ...args
        });
        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);
      } else {
        return args.content;
      }
    };
    const setContent$1 = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs$2(args, content);
      preProcessSetContent(editor, defaultedArgs).each((updatedArgs) => {
        const cleanedContent = cleanContent(editor, updatedArgs);
        const rng = editor.selection.getRng();
        rngSetContent(rng, rng.createContextualFragment(cleanedContent));
        editor.selection.setRng(rng);
        scrollRangeIntoView(editor, rng);
        postProcessSetContent(editor, cleanedContent, updatedArgs);
      });
    };
    const deleteFromCallbackMap = (callbackMap, selector, callback) => {
      if (has$2(callbackMap, selector)) {
        const newCallbacks = filter$5(callbackMap[selector], (cb) => cb !== callback);
        if (newCallbacks.length === 0) {
          delete callbackMap[selector];
        } else {
          callbackMap[selector] = newCallbacks;
        }
      }
    };
    var SelectorChanged = (dom2, editor) => {
      let selectorChangedData;
      let currentSelectors;
      const findMatchingNode = (selector, nodes) => find$2(nodes, (node) => dom2.is(node, selector));
      const getParents2 = (elem) => dom2.getParents(elem, void 0, dom2.getRoot());
      const setup2 = () => {
        selectorChangedData = {};
        currentSelectors = {};
        editor.on("NodeChange", (e) => {
          const node = e.element;
          const parents2 = getParents2(node);
          const matchedSelectors = {};
          each$d(selectorChangedData, (callbacks, selector) => {
            findMatchingNode(selector, parents2).each((node2) => {
              if (!currentSelectors[selector]) {
                each$e(callbacks, (callback) => {
                  callback(true, {
                    node: node2,
                    selector,
                    parents: parents2
                  });
                });
                currentSelectors[selector] = callbacks;
              }
              matchedSelectors[selector] = callbacks;
            });
          });
          each$d(currentSelectors, (callbacks, selector) => {
            if (!matchedSelectors[selector]) {
              delete currentSelectors[selector];
              each$e(callbacks, (callback) => {
                callback(false, {
                  node,
                  selector,
                  parents: parents2
                });
              });
            }
          });
        });
      };
      return {
        selectorChangedWithUnbind: (selector, callback) => {
          if (!selectorChangedData) {
            setup2();
          }
          if (!selectorChangedData[selector]) {
            selectorChangedData[selector] = [];
          }
          selectorChangedData[selector].push(callback);
          findMatchingNode(selector, getParents2(editor.selection.getStart())).each(() => {
            currentSelectors[selector] = selectorChangedData[selector];
          });
          return {
            unbind: () => {
              deleteFromCallbackMap(selectorChangedData, selector, callback);
              deleteFromCallbackMap(currentSelectors, selector, callback);
            }
          };
        }
      };
    };
    const isAttachedToDom = (node) => {
      return !!(node && node.ownerDocument) && contains2(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));
    };
    const isValidRange = (rng) => {
      if (!rng) {
        return false;
      } else {
        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);
      }
    };
    const EditorSelection = (dom2, win, serializer, editor) => {
      let selectedRange;
      let explicitRange;
      const { selectorChangedWithUnbind } = SelectorChanged(dom2, editor);
      const setCursorLocation = (node, offset2) => {
        const rng = dom2.createRng();
        if (isNonNullable(node) && isNonNullable(offset2)) {
          rng.setStart(node, offset2);
          rng.setEnd(node, offset2);
          setRng(rng);
          collapse2(false);
        } else {
          moveEndPoint(dom2, rng, editor.getBody(), true);
          setRng(rng);
        }
      };
      const getContent2 = (args) => getContent$1(editor, args);
      const setContent2 = (content, args) => setContent$1(editor, content, args);
      const getStart$12 = (real) => getStart(editor.getBody(), getRng$1(), real);
      const getEnd2 = (real) => getEnd$1(editor.getBody(), getRng$1(), real);
      const getBookmark2 = (type2, normalized) => bookmarkManager.getBookmark(type2, normalized);
      const moveToBookmark2 = (bookmark) => bookmarkManager.moveToBookmark(bookmark);
      const select$1 = (node, content) => {
        select(dom2, node, content).each(setRng);
        return node;
      };
      const isCollapsed = () => {
        const rng = getRng$1(), sel = getSel();
        if (!rng || rng.item) {
          return false;
        }
        if (rng.compareEndPoints) {
          return rng.compareEndPoints("StartToEnd", rng) === 0;
        }
        return !sel || rng.collapsed;
      };
      const isEditable2 = () => {
        const rng = getRng$1();
        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected="1"]');
        if (fakeSelectedElements.length > 0) {
          return forall(fakeSelectedElements, (el) => dom2.isEditable(el.parentElement));
        } else if (rng.startContainer === rng.endContainer) {
          return dom2.isEditable(rng.startContainer);
        } else {
          return dom2.isEditable(rng.startContainer) && dom2.isEditable(rng.endContainer);
        }
      };
      const collapse2 = (toStart) => {
        const rng = getRng$1();
        rng.collapse(!!toStart);
        setRng(rng);
      };
      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;
      const getRng$1 = () => {
        let rng;
        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {
          try {
            return sourceRange.compareBoundaryPoints(how, destinationRange);
          } catch (ex) {
            return -1;
          }
        };
        const doc = win.document;
        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {
          const bookmark = getRng(editor);
          if (bookmark.isSome()) {
            return bookmark.map((r2) => processRanges(editor, [r2])[0]).getOr(doc.createRange());
          }
        }
        try {
          const selection = getSel();
          if (selection && !isRestrictedNode(selection.anchorNode)) {
            if (selection.rangeCount > 0) {
              rng = selection.getRangeAt(0);
            } else {
              rng = doc.createRange();
            }
            rng = processRanges(editor, [rng])[0];
          }
        } catch (ex) {
        }
        if (!rng) {
          rng = doc.createRange();
        }
        if (isDocument$1(rng.startContainer) && rng.collapsed) {
          const elm = dom2.getRoot();
          rng.setStart(elm, 0);
          rng.setEnd(elm, 0);
        }
        if (selectedRange && explicitRange) {
          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {
            rng = explicitRange;
          } else {
            selectedRange = null;
            explicitRange = null;
          }
        }
        return rng;
      };
      const setRng = (rng, forward) => {
        if (!isValidRange(rng)) {
          return;
        }
        const sel = getSel();
        const evt = editor.dispatch("SetSelectionRange", {
          range: rng,
          forward
        });
        rng = evt.range;
        if (sel) {
          explicitRange = rng;
          try {
            sel.removeAllRanges();
            sel.addRange(rng);
          } catch (ex) {
          }
          if (forward === false && sel.extend) {
            sel.collapse(rng.endContainer, rng.endOffset);
            sel.extend(rng.startContainer, rng.startOffset);
          }
          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
        }
        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {
          if (rng.endOffset - rng.startOffset < 2) {
            if (rng.startContainer.hasChildNodes()) {
              const node = rng.startContainer.childNodes[rng.startOffset];
              if (node && node.nodeName === "IMG") {
                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);
                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {
                  sel.setBaseAndExtent(node, 0, node, 1);
                }
              }
            }
          }
        }
        editor.dispatch("AfterSetSelectionRange", {
          range: rng,
          forward
        });
      };
      const setNode = (elm) => {
        setContent2(dom2.getOuterHTML(elm));
        return elm;
      };
      const getNode$12 = () => getNode(editor.getBody(), getRng$1());
      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom2, getRng$1(), startElm, endElm);
      const isForward = () => {
        const sel = getSel();
        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;
        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;
        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {
          return true;
        }
        const anchorRange = dom2.createRng();
        const focusRange = dom2.createRng();
        try {
          anchorRange.setStart(anchorNode, sel.anchorOffset);
          anchorRange.collapse(true);
          focusRange.setStart(focusNode, sel.focusOffset);
          focusRange.collapse(true);
        } catch (e) {
          return true;
        }
        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;
      };
      const normalize2 = () => {
        const rng = getRng$1();
        const sel = getSel();
        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {
          const normRng = normalize$2(dom2, rng);
          normRng.each((normRng2) => {
            setRng(normRng2, isForward());
          });
          return normRng.getOr(rng);
        }
        return rng;
      };
      const selectorChanged = (selector, callback) => {
        selectorChangedWithUnbind(selector, callback);
        return exports;
      };
      const getScrollContainer = () => {
        let scrollContainer;
        let node = dom2.getRoot();
        while (node && node.nodeName !== "BODY") {
          if (node.scrollHeight > node.clientHeight) {
            scrollContainer = node;
            break;
          }
          node = node.parentNode;
        }
        return scrollContainer;
      };
      const scrollIntoView = (elm, alignToTop) => {
        if (isNonNullable(elm)) {
          scrollElementIntoView(editor, elm, alignToTop);
        } else {
          scrollRangeIntoView(editor, getRng$1(), alignToTop);
        }
      };
      const placeCaretAt2 = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));
      const getBoundingClientRect3 = () => {
        const rng = getRng$1();
        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();
      };
      const destroy3 = () => {
        win = selectedRange = explicitRange = null;
        controlSelection.destroy();
      };
      const expand = (options = { type: "word" }) => setRng(RangeUtils(dom2).expand(getRng$1(), options));
      const exports = {
        dom: dom2,
        win,
        serializer,
        editor,
        expand,
        collapse: collapse2,
        setCursorLocation,
        getContent: getContent2,
        setContent: setContent2,
        getBookmark: getBookmark2,
        moveToBookmark: moveToBookmark2,
        select: select$1,
        isCollapsed,
        isEditable: isEditable2,
        isForward,
        setNode,
        getNode: getNode$12,
        getSel,
        setRng,
        getRng: getRng$1,
        getStart: getStart$12,
        getEnd: getEnd2,
        getSelectedBlocks: getSelectedBlocks$1,
        normalize: normalize2,
        selectorChanged,
        selectorChangedWithUnbind,
        getScrollContainer,
        scrollIntoView,
        placeCaretAt: placeCaretAt2,
        getBoundingClientRect: getBoundingClientRect3,
        destroy: destroy3
      };
      const bookmarkManager = BookmarkManager(exports);
      const controlSelection = ControlSelection(exports, editor);
      exports.bookmarkManager = bookmarkManager;
      exports.controlSelection = controlSelection;
      return exports;
    };
    const register$3 = (htmlParser, settings, dom2) => {
      htmlParser.addAttributeFilter("data-mce-tabindex", (nodes, name3) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          node.attr("tabindex", node.attr("data-mce-tabindex"));
          node.attr(name3, null);
        }
      });
      htmlParser.addAttributeFilter("src,href,style", (nodes, name3) => {
        const internalName = "data-mce-" + name3;
        const urlConverter = settings.url_converter;
        const urlConverterScope = settings.url_converter_scope;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value2 = node.attr(internalName);
          if (value2 !== void 0) {
            node.attr(name3, value2.length > 0 ? value2 : null);
            node.attr(internalName, null);
          } else {
            value2 = node.attr(name3);
            if (name3 === "style") {
              value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
            } else if (urlConverter) {
              value2 = urlConverter.call(urlConverterScope, value2, name3, node.name);
            }
            node.attr(name3, value2.length > 0 ? value2 : null);
          }
        }
      });
      htmlParser.addAttributeFilter("class", (nodes) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value2 = node.attr("class");
          if (value2) {
            value2 = value2.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, "");
            node.attr("class", value2.length > 0 ? value2 : null);
          }
        }
      });
      htmlParser.addAttributeFilter("data-mce-type", (nodes, name3, args) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.attr("data-mce-type") === "bookmark" && !args.cleanup) {
            const hasChildren = Optional.from(node.firstChild).exists((firstChild2) => {
              var _a;
              return !isZwsp((_a = firstChild2.value) !== null && _a !== void 0 ? _a : "");
            });
            if (hasChildren) {
              node.unwrap();
            } else {
              node.remove();
            }
          }
        }
      });
      htmlParser.addNodeFilter("noscript", (nodes) => {
        var _a;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i].firstChild;
          if (node) {
            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : "");
          }
        }
      });
      htmlParser.addNodeFilter("script,style", (nodes, name3) => {
        var _a;
        const trim3 = (value2) => {
          return value2.replace(/(<!--\[CDATA\[|\]\]-->)/g, "\n").replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
        };
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const firstChild2 = node.firstChild;
          const value2 = (_a = firstChild2 === null || firstChild2 === void 0 ? void 0 : firstChild2.value) !== null && _a !== void 0 ? _a : "";
          if (name3 === "script") {
            const type2 = node.attr("type");
            if (type2) {
              node.attr("type", type2 === "mce-no/type" ? null : type2.replace(/^mce\-/, ""));
            }
            if (settings.element_format === "xhtml" && firstChild2 && value2.length > 0) {
              firstChild2.value = "// <![CDATA[\n" + trim3(value2) + "\n// ]]>";
            }
          } else {
            if (settings.element_format === "xhtml" && firstChild2 && value2.length > 0) {
              firstChild2.value = "<!--\n" + trim3(value2) + "\n-->";
            }
          }
        }
      });
      htmlParser.addNodeFilter("#comment", (nodes) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const value2 = node.value;
          if (settings.preserve_cdata && (value2 === null || value2 === void 0 ? void 0 : value2.indexOf("[CDATA[")) === 0) {
            node.name = "#cdata";
            node.type = 4;
            node.value = dom2.decode(value2.replace(/^\[CDATA\[|\]\]$/g, ""));
          } else if ((value2 === null || value2 === void 0 ? void 0 : value2.indexOf("mce:protected ")) === 0) {
            node.name = "#text";
            node.type = 3;
            node.raw = true;
            node.value = unescape(value2).substr(14);
          }
        }
      });
      htmlParser.addNodeFilter("xml:namespace,input", (nodes, name3) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (node.type === 7) {
            node.remove();
          } else if (node.type === 1) {
            if (name3 === "input" && !node.attr("type")) {
              node.attr("type", "text");
            }
          }
        }
      });
      htmlParser.addAttributeFilter("data-mce-type", (nodes) => {
        each$e(nodes, (node) => {
          if (node.attr("data-mce-type") === "format-caret") {
            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {
              node.remove();
            } else {
              node.unwrap();
            }
          }
        });
      });
      htmlParser.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (nodes, name3) => {
        let i = nodes.length;
        while (i--) {
          nodes[i].attr(name3, null);
        }
      });
    };
    const trimTrailingBr = (rootNode) => {
      const isBr2 = (node) => {
        return (node === null || node === void 0 ? void 0 : node.name) === "br";
      };
      const brNode1 = rootNode.lastChild;
      if (isBr2(brNode1)) {
        const brNode2 = brNode1.prev;
        if (isBr2(brNode2)) {
          brNode1.remove();
          brNode2.remove();
        }
      }
    };
    const preProcess$1 = (editor, node, args) => {
      let oldDoc;
      const dom2 = editor.dom;
      let clonedNode = node.cloneNode(true);
      const impl = document.implementation;
      if (impl.createHTMLDocument) {
        const doc = impl.createHTMLDocument("");
        Tools.each(clonedNode.nodeName === "BODY" ? clonedNode.childNodes : [clonedNode], (node2) => {
          doc.body.appendChild(doc.importNode(node2, true));
        });
        if (clonedNode.nodeName !== "BODY") {
          clonedNode = doc.body.firstChild;
        } else {
          clonedNode = doc.body;
        }
        oldDoc = dom2.doc;
        dom2.doc = doc;
      }
      firePreProcess(editor, {
        ...args,
        node: clonedNode
      });
      if (oldDoc) {
        dom2.doc = oldDoc;
      }
      return clonedNode;
    };
    const shouldFireEvent = (editor, args) => {
      return isNonNullable(editor) && editor.hasEventListeners("PreProcess") && !args.no_events;
    };
    const process$1 = (editor, node, args) => {
      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;
    };
    const addTempAttr = (htmlParser, tempAttrs, name3) => {
      if (Tools.inArray(tempAttrs, name3) === -1) {
        htmlParser.addAttributeFilter(name3, (nodes, name4) => {
          let i = nodes.length;
          while (i--) {
            nodes[i].attr(name4, null);
          }
        });
        tempAttrs.push(name3);
      }
    };
    const postProcess = (editor, args, content) => {
      if (!args.no_events && editor) {
        const outArgs = firePostProcess(editor, {
          ...args,
          content
        });
        return outArgs.content;
      } else {
        return content;
      }
    };
    const getHtmlFromNode = (dom2, node, args) => {
      const html2 = trim$12(args.getInner ? node.innerHTML : dom2.getOuterHTML(node));
      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html2 : Tools.trim(html2);
    };
    const parseHtml = (htmlParser, html2, args) => {
      const parserArgs = args.selection ? {
        forced_root_block: false,
        ...args
      } : args;
      const rootNode = htmlParser.parse(html2, parserArgs);
      trimTrailingBr(rootNode);
      return rootNode;
    };
    const serializeNode = (settings, schema, node) => {
      const htmlSerializer = HtmlSerializer(settings, schema);
      return htmlSerializer.serialize(node);
    };
    const toHtml = (editor, settings, schema, rootNode, args) => {
      const content = serializeNode(settings, schema, rootNode);
      return postProcess(editor, args, content);
    };
    const DomSerializerImpl = (settings, editor) => {
      const tempAttrs = ["data-mce-selected"];
      const dom2 = editor && editor.dom ? editor.dom : DOMUtils.DOM;
      const schema = editor && editor.schema ? editor.schema : Schema(settings);
      settings.entity_encoding = settings.entity_encoding || "named";
      settings.remove_trailing_brs = "remove_trailing_brs" in settings ? settings.remove_trailing_brs : true;
      const htmlParser = DomParser(settings, schema);
      register$3(htmlParser, settings, dom2);
      const serialize = (node, parserArgs = {}) => {
        const args = {
          format: "html",
          ...parserArgs
        };
        const targetNode = process$1(editor, node, args);
        const html2 = getHtmlFromNode(dom2, targetNode, args);
        const rootNode = parseHtml(htmlParser, html2, args);
        return args.format === "tree" ? rootNode : toHtml(editor, settings, schema, rootNode, args);
      };
      return {
        schema,
        addNodeFilter: htmlParser.addNodeFilter,
        addAttributeFilter: htmlParser.addAttributeFilter,
        serialize,
        addRules: schema.addValidElements,
        setRules: schema.setValidElements,
        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),
        getTempAttrs: constant(tempAttrs),
        getNodeFilters: htmlParser.getNodeFilters,
        getAttributeFilters: htmlParser.getAttributeFilters,
        removeNodeFilter: htmlParser.removeNodeFilter,
        removeAttributeFilter: htmlParser.removeAttributeFilter
      };
    };
    const DomSerializer = (settings, editor) => {
      const domSerializer = DomSerializerImpl(settings, editor);
      return {
        schema: domSerializer.schema,
        addNodeFilter: domSerializer.addNodeFilter,
        addAttributeFilter: domSerializer.addAttributeFilter,
        serialize: domSerializer.serialize,
        addRules: domSerializer.addRules,
        setRules: domSerializer.setRules,
        addTempAttr: domSerializer.addTempAttr,
        getTempAttrs: domSerializer.getTempAttrs,
        getNodeFilters: domSerializer.getNodeFilters,
        getAttributeFilters: domSerializer.getAttributeFilters,
        removeNodeFilter: domSerializer.removeNodeFilter,
        removeAttributeFilter: domSerializer.removeAttributeFilter
      };
    };
    const defaultFormat$1 = "html";
    const setupArgs$1 = (args, format) => ({
      ...args,
      format,
      get: true,
      getInner: true
    });
    const getContent = (editor, args = {}) => {
      const format = args.format ? args.format : defaultFormat$1;
      const defaultedArgs = setupArgs$1(args, format);
      return preProcessGetContent(editor, defaultedArgs).fold(identity, (updatedArgs) => {
        const content = getContent$2(editor, updatedArgs);
        return postProcessGetContent(editor, content, updatedArgs);
      });
    };
    const defaultFormat = "html";
    const setupArgs = (args, content) => ({
      format: defaultFormat,
      ...args,
      set: true,
      content
    });
    const setContent = (editor, content, args = {}) => {
      const defaultedArgs = setupArgs(args, content);
      return preProcessSetContent(editor, defaultedArgs).map((updatedArgs) => {
        const result = setContent$2(editor, updatedArgs.content, updatedArgs);
        postProcessSetContent(editor, result.html, updatedArgs);
        return result.content;
      }).getOr(content);
    };
    const removedOptions = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists".split(",");
    const deprecatedOptions = "template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(",");
    const removedPlugins = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor".split(",");
    const deprecatedPlugins = [{
      name: "template",
      replacedWith: "Advanced Template"
    }];
    const getMatchingOptions = (options, searchingFor) => {
      const settingNames = filter$5(searchingFor, (setting) => has$2(options, setting));
      return sort(settingNames);
    };
    const getRemovedOptions = (options) => {
      const settingNames = getMatchingOptions(options, removedOptions);
      const forcedRootBlock = options.forced_root_block;
      if (forcedRootBlock === false || forcedRootBlock === "") {
        settingNames.push("forced_root_block (false only)");
      }
      return sort(settingNames);
    };
    const getDeprecatedOptions = (options) => getMatchingOptions(options, deprecatedOptions);
    const getMatchingPlugins = (options, searchingFor) => {
      const plugins = Tools.makeMap(options.plugins, " ");
      const hasPlugin = (plugin2) => has$2(plugins, plugin2);
      const pluginNames = filter$5(searchingFor, hasPlugin);
      return sort(pluginNames);
    };
    const getRemovedPlugins = (options) => getMatchingPlugins(options, removedPlugins);
    const getDeprecatedPlugins = (options) => getMatchingPlugins(options, deprecatedPlugins.map((entry) => entry.name));
    const logRemovedWarnings = (rawOptions, normalizedOptions) => {
      const removedOptions2 = getRemovedOptions(rawOptions);
      const removedPlugins2 = getRemovedPlugins(normalizedOptions);
      const hasRemovedPlugins = removedPlugins2.length > 0;
      const hasRemovedOptions = removedOptions2.length > 0;
      const isLegacyMobileTheme = normalizedOptions.theme === "mobile";
      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {
        const listJoiner = "\n- ";
        const themesMessage = isLegacyMobileTheme ? `

Themes:${listJoiner}mobile` : "";
        const pluginsMessage = hasRemovedPlugins ? `

Plugins:${listJoiner}${removedPlugins2.join(listJoiner)}` : "";
        const optionsMessage = hasRemovedOptions ? `

Options:${listJoiner}${removedOptions2.join(listJoiner)}` : "";
        console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information." + themesMessage + pluginsMessage + optionsMessage);
      }
    };
    const getPluginDescription = (name3) => find$2(deprecatedPlugins, (entry) => entry.name === name3).fold(() => name3, (entry) => `${name3}, replaced by ${entry.replacedWith}`);
    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {
      const deprecatedOptions2 = getDeprecatedOptions(rawOptions);
      const deprecatedPlugins2 = getDeprecatedPlugins(normalizedOptions);
      const hasDeprecatedPlugins = deprecatedPlugins2.length > 0;
      const hasDeprecatedOptions = deprecatedOptions2.length > 0;
      if (hasDeprecatedPlugins || hasDeprecatedOptions) {
        const listJoiner = "\n- ";
        const pluginsMessage = hasDeprecatedPlugins ? `

Plugins:${listJoiner}${deprecatedPlugins2.map(getPluginDescription).join(listJoiner)}` : "";
        const optionsMessage = hasDeprecatedOptions ? `

Options:${listJoiner}${deprecatedOptions2.join(listJoiner)}` : "";
        console.warn("The following deprecated features are currently enabled but will be removed soon." + pluginsMessage + optionsMessage);
      }
    };
    const logWarnings = (rawOptions, normalizedOptions) => {
      logRemovedWarnings(rawOptions, normalizedOptions);
      logDeprecatedWarnings(rawOptions, normalizedOptions);
    };
    const DOM$8 = DOMUtils.DOM;
    const restoreOriginalStyles = (editor) => {
      DOM$8.setStyle(editor.id, "display", editor.orgDisplay);
    };
    const safeDestroy = (x) => Optional.from(x).each((x2) => x2.destroy());
    const clearDomReferences = (editor) => {
      const ed = editor;
      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;
      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;
      ed.iframeElement = ed.targetElm = null;
      const selection = editor.selection;
      if (selection) {
        const dom2 = selection.dom;
        ed.selection = selection.win = selection.dom = dom2.doc = null;
      }
    };
    const restoreForm = (editor) => {
      const form = editor.formElement;
      if (form) {
        if (form._mceOldSubmit) {
          form.submit = form._mceOldSubmit;
          delete form._mceOldSubmit;
        }
        DOM$8.unbind(form, "submit reset", editor.formEventDelegate);
      }
    };
    const remove$1 = (editor) => {
      if (!editor.removed) {
        const { _selectionOverrides, editorUpload } = editor;
        const body = editor.getBody();
        const element = editor.getElement();
        if (body) {
          editor.save({ is_removing: true });
        }
        editor.removed = true;
        editor.unbindAllNativeEvents();
        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {
          DOM$8.remove(element.nextSibling);
        }
        fireRemove(editor);
        editor.editorManager.remove(editor);
        if (!editor.inline && body) {
          restoreOriginalStyles(editor);
        }
        fireDetach(editor);
        DOM$8.remove(editor.getContainer());
        safeDestroy(_selectionOverrides);
        safeDestroy(editorUpload);
        editor.destroy();
      }
    };
    const destroy2 = (editor, automatic) => {
      const { selection, dom: dom2 } = editor;
      if (editor.destroyed) {
        return;
      }
      if (!automatic && !editor.removed) {
        editor.remove();
        return;
      }
      if (!automatic) {
        editor.editorManager.off("beforeunload", editor._beforeUnload);
        if (editor.theme && editor.theme.destroy) {
          editor.theme.destroy();
        }
        safeDestroy(selection);
        safeDestroy(dom2);
      }
      restoreForm(editor);
      clearDomReferences(editor);
      editor.destroyed = true;
    };
    const CreateIconManager = () => {
      const lookup2 = {};
      const add2 = (id, iconPack) => {
        lookup2[id] = iconPack;
      };
      const get2 = (id) => {
        if (lookup2[id]) {
          return lookup2[id];
        } else {
          return { icons: {} };
        }
      };
      const has2 = (id) => has$2(lookup2, id);
      return {
        add: add2,
        get: get2,
        has: has2
      };
    };
    const IconManager = CreateIconManager();
    const ModelManager = AddOnManager.ModelManager;
    const getProp = (propName, elm) => {
      const rawElm = elm.dom;
      return rawElm[propName];
    };
    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);
    const getClientWidth = curry(getProp, "clientWidth");
    const getClientHeight = curry(getProp, "clientHeight");
    const getMarginTop = curry(getComputedSizeProp, "margin-top");
    const getMarginLeft = curry(getComputedSizeProp, "margin-left");
    const getBoundingClientRect2 = (elm) => elm.dom.getBoundingClientRect();
    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {
      const clientWidth = getClientWidth(bodyElm);
      const clientHeight = getClientHeight(bodyElm);
      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;
    };
    const transpose = (inline, elm, clientX, clientY) => {
      const clientRect = getBoundingClientRect2(elm);
      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;
      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;
      const x = clientX - deltaX;
      const y = clientY - deltaY;
      return {
        x,
        y
      };
    };
    const isXYInContentArea = (editor, clientX, clientY) => {
      const bodyElm = SugarElement.fromDom(editor.getBody());
      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);
      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);
      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);
    };
    const fromDomSafe = (node) => Optional.from(node).map(SugarElement.fromDom);
    const isEditorAttachedToDom = (editor) => {
      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();
      return fromDomSafe(rawContainer).map(inBody).getOr(false);
    };
    var NotificationManagerImpl = () => {
      const unimplemented = () => {
        throw new Error("Theme did not provide a NotificationManager implementation.");
      };
      return {
        open: unimplemented,
        close: unimplemented,
        getArgs: unimplemented
      };
    };
    const NotificationManager = (editor) => {
      const notifications = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();
      };
      const getTopNotification = () => {
        return Optional.from(notifications[0]);
      };
      const isEqual2 = (a, b) => {
        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;
      };
      const reposition2 = () => {
        each$e(notifications, (notification) => {
          notification.reposition();
        });
      };
      const addNotification = (notification) => {
        notifications.push(notification);
      };
      const closeNotification = (notification) => {
        findIndex$2(notifications, (otherNotification) => {
          return otherNotification === notification;
        }).each((index) => {
          notifications.splice(index, 1);
        });
      };
      const open = (spec, fireEvent2 = true) => {
        if (editor.removed || !isEditorAttachedToDom(editor)) {
          return {};
        }
        if (fireEvent2) {
          editor.dispatch("BeforeOpenNotification", { notification: spec });
        }
        return find$2(notifications, (notification) => {
          return isEqual2(getImplementation().getArgs(notification), spec);
        }).getOrThunk(() => {
          editor.editorManager.setActive(editor);
          const notification = getImplementation().open(spec, () => {
            closeNotification(notification);
            reposition2();
            getTopNotification().fold(() => editor.focus(), (top2) => focus$1(SugarElement.fromDom(top2.getEl())));
          });
          addNotification(notification);
          reposition2();
          editor.dispatch("OpenNotification", { notification: { ...notification } });
          return notification;
        });
      };
      const close = () => {
        getTopNotification().each((notification) => {
          getImplementation().close(notification);
          closeNotification(notification);
          reposition2();
        });
      };
      const getNotifications = constant(notifications);
      const registerEvents2 = (editor2) => {
        editor2.on("SkinLoaded", () => {
          const serviceMessage = getServiceMessage(editor2);
          if (serviceMessage) {
            open({
              text: serviceMessage,
              type: "warning",
              timeout: 0
            }, false);
          }
          reposition2();
        });
        editor2.on("show ResizeEditor ResizeWindow NodeChange", () => {
          requestAnimationFrame(reposition2);
        });
        editor2.on("remove", () => {
          each$e(notifications.slice(), (notification) => {
            getImplementation().close(notification);
          });
        });
      };
      registerEvents2(editor);
      return {
        open,
        close,
        getNotifications
      };
    };
    const PluginManager = AddOnManager.PluginManager;
    const ThemeManager = AddOnManager.ThemeManager;
    var WindowManagerImpl = () => {
      const unimplemented = () => {
        throw new Error("Theme did not provide a WindowManager implementation.");
      };
      return {
        open: unimplemented,
        openUrl: unimplemented,
        alert: unimplemented,
        confirm: unimplemented,
        close: unimplemented
      };
    };
    const WindowManager = (editor) => {
      let dialogs = [];
      const getImplementation = () => {
        const theme = editor.theme;
        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();
      };
      const funcBind = (scope, f) => {
        return (...args) => {
          return f ? f.apply(scope, args) : void 0;
        };
      };
      const fireOpenEvent = (dialog) => {
        editor.dispatch("OpenWindow", { dialog });
      };
      const fireCloseEvent = (dialog) => {
        editor.dispatch("CloseWindow", { dialog });
      };
      const addDialog = (dialog) => {
        dialogs.push(dialog);
        fireOpenEvent(dialog);
      };
      const closeDialog = (dialog) => {
        fireCloseEvent(dialog);
        dialogs = filter$5(dialogs, (otherDialog) => {
          return otherDialog !== dialog;
        });
        if (dialogs.length === 0) {
          editor.focus();
        }
      };
      const getTopDialog = () => {
        return Optional.from(dialogs[dialogs.length - 1]);
      };
      const storeSelectionAndOpenDialog = (openDialog) => {
        editor.editorManager.setActive(editor);
        store(editor);
        editor.ui.show();
        const dialog = openDialog();
        addDialog(dialog);
        return dialog;
      };
      const open = (args, params) => {
        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));
      };
      const openUrl = (args) => {
        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));
      };
      const alert = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const confirm = (message, callback, scope) => {
        const windowManagerImpl = getImplementation();
        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));
      };
      const close = () => {
        getTopDialog().each((dialog) => {
          getImplementation().close(dialog);
          closeDialog(dialog);
        });
      };
      editor.on("remove", () => {
        each$e(dialogs, (dialog) => {
          getImplementation().close(dialog);
        });
      });
      return {
        open,
        openUrl,
        alert,
        confirm,
        close
      };
    };
    const displayNotification = (editor, message) => {
      editor.notificationManager.open({
        type: "error",
        text: message
      });
    };
    const displayError = (editor, message) => {
      if (editor._skinLoaded) {
        displayNotification(editor, message);
      } else {
        editor.on("SkinLoaded", () => {
          displayNotification(editor, message);
        });
      }
    };
    const uploadError = (editor, message) => {
      displayError(editor, I18n.translate([
        "Failed to upload image: {0}",
        message
      ]));
    };
    const logError = (editor, errorType, msg) => {
      fireError(editor, errorType, { message: msg });
      console.error(msg);
    };
    const createLoadError = (type2, url, name3) => name3 ? `Failed to load ${type2}: ${name3} from url ${url}` : `Failed to load ${type2} url: ${url}`;
    const pluginLoadError = (editor, url, name3) => {
      logError(editor, "PluginLoadError", createLoadError("plugin", url, name3));
    };
    const iconsLoadError = (editor, url, name3) => {
      logError(editor, "IconsLoadError", createLoadError("icons", url, name3));
    };
    const languageLoadError = (editor, url, name3) => {
      logError(editor, "LanguageLoadError", createLoadError("language", url, name3));
    };
    const themeLoadError = (editor, url, name3) => {
      logError(editor, "ThemeLoadError", createLoadError("theme", url, name3));
    };
    const modelLoadError = (editor, url, name3) => {
      logError(editor, "ModelLoadError", createLoadError("model", url, name3));
    };
    const pluginInitError = (editor, name3, err) => {
      const message = I18n.translate([
        "Failed to initialize plugin: {0}",
        name3
      ]);
      fireError(editor, "PluginLoadError", { message });
      initError(message, err);
      displayError(editor, message);
    };
    const initError = (message, ...x) => {
      const console2 = window.console;
      if (console2) {
        if (console2.error) {
          console2.error(message, ...x);
        } else {
          console2.log(message, ...x);
        }
      }
    };
    const isContentCssSkinName = (url) => /^[a-z0-9\-]+$/i.test(url);
    const getContentCssUrls = (editor) => {
      return transformToUrls(editor, getContentCss(editor));
    };
    const getFontCssUrls = (editor) => {
      return transformToUrls(editor, getFontCss(editor));
    };
    const transformToUrls = (editor, cssLinks) => {
      const skinUrl = editor.editorManager.baseURL + "/skins/content";
      const suffix = editor.editorManager.suffix;
      const contentCssFile = `content${suffix}.css`;
      return map$3(cssLinks, (url) => {
        if (isContentCssSkinName(url) && !editor.inline) {
          return `${skinUrl}/${url}/${contentCssFile}`;
        } else {
          return editor.documentBaseURI.toAbsolute(url);
        }
      });
    };
    const appendContentCssFromSettings = (editor) => {
      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));
    };
    const getAllImages = (elm) => {
      return elm ? from(elm.getElementsByTagName("img")) : [];
    };
    const ImageScanner = (uploadStatus, blobCache) => {
      const cachedPromises = {};
      const findAll2 = (elm, predicate = always) => {
        const images2 = filter$5(getAllImages(elm), (img) => {
          const src = img.src;
          if (img.hasAttribute("data-mce-bogus")) {
            return false;
          }
          if (img.hasAttribute("data-mce-placeholder")) {
            return false;
          }
          if (!src || src === Env.transparentSrc) {
            return false;
          }
          if (startsWith(src, "blob:")) {
            return !uploadStatus.isUploaded(src) && predicate(img);
          }
          if (startsWith(src, "data:")) {
            return predicate(img);
          }
          return false;
        });
        const promises = map$3(images2, (img) => {
          const imageSrc = img.src;
          if (has$2(cachedPromises, imageSrc)) {
            return cachedPromises[imageSrc].then((imageInfo) => {
              if (isString2(imageInfo)) {
                return imageInfo;
              } else {
                return {
                  image: img,
                  blobInfo: imageInfo.blobInfo
                };
              }
            });
          } else {
            const newPromise = imageToBlobInfo(blobCache, imageSrc).then((blobInfo) => {
              delete cachedPromises[imageSrc];
              return {
                image: img,
                blobInfo
              };
            }).catch((error3) => {
              delete cachedPromises[imageSrc];
              return error3;
            });
            cachedPromises[imageSrc] = newPromise;
            return newPromise;
          }
        });
        return Promise.all(promises);
      };
      return { findAll: findAll2 };
    };
    const UploadStatus = () => {
      const PENDING = 1, UPLOADED = 2;
      let blobUriStatuses = {};
      const createStatus = (status, resultUri) => {
        return {
          status,
          resultUri
        };
      };
      const hasBlobUri = (blobUri) => {
        return blobUri in blobUriStatuses;
      };
      const getResultUri = (blobUri) => {
        const result = blobUriStatuses[blobUri];
        return result ? result.resultUri : null;
      };
      const isPending = (blobUri) => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;
      };
      const isUploaded = (blobUri) => {
        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;
      };
      const markPending = (blobUri) => {
        blobUriStatuses[blobUri] = createStatus(PENDING, null);
      };
      const markUploaded = (blobUri, resultUri) => {
        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);
      };
      const removeFailed = (blobUri) => {
        delete blobUriStatuses[blobUri];
      };
      const destroy3 = () => {
        blobUriStatuses = {};
      };
      return {
        hasBlobUri,
        getResultUri,
        isPending,
        isUploaded,
        markPending,
        markUploaded,
        removeFailed,
        destroy: destroy3
      };
    };
    let count = 0;
    const seed = () => {
      const rnd = () => {
        return Math.round(Math.random() * 4294967295).toString(36);
      };
      const now = (/* @__PURE__ */ new Date()).getTime();
      return "s" + now.toString(36) + rnd() + rnd() + rnd();
    };
    const uuid = (prefix) => {
      return prefix + count++ + seed();
    };
    const BlobCache = () => {
      let cache = [];
      const mimeToExt = (mime) => {
        const mimes = {
          "image/jpeg": "jpg",
          "image/jpg": "jpg",
          "image/gif": "gif",
          "image/png": "png",
          "image/apng": "apng",
          "image/avif": "avif",
          "image/svg+xml": "svg",
          "image/webp": "webp",
          "image/bmp": "bmp",
          "image/tiff": "tiff"
        };
        return mimes[mime.toLowerCase()] || "dat";
      };
      const create3 = (o, blob2, base64, name3, filename) => {
        if (isString2(o)) {
          const id = o;
          return toBlobInfo({
            id,
            name: name3,
            filename,
            blob: blob2,
            base64
          });
        } else if (isObject2(o)) {
          return toBlobInfo(o);
        } else {
          throw new Error("Unknown input type");
        }
      };
      const toBlobInfo = (o) => {
        if (!o.blob || !o.base64) {
          throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
        }
        const id = o.id || uuid("blobid");
        const name3 = o.name || id;
        const blob2 = o.blob;
        return {
          id: constant(id),
          name: constant(name3),
          filename: constant(o.filename || name3 + "." + mimeToExt(blob2.type)),
          blob: constant(blob2),
          base64: constant(o.base64),
          blobUri: constant(o.blobUri || URL.createObjectURL(blob2)),
          uri: constant(o.uri)
        };
      };
      const add2 = (blobInfo) => {
        if (!get2(blobInfo.id())) {
          cache.push(blobInfo);
        }
      };
      const findFirst = (predicate) => find$2(cache, predicate).getOrUndefined();
      const get2 = (id) => findFirst((cachedBlobInfo) => cachedBlobInfo.id() === id);
      const getByUri = (blobUri) => findFirst((blobInfo) => blobInfo.blobUri() === blobUri);
      const getByData = (base64, type2) => findFirst((blobInfo) => blobInfo.base64() === base64 && blobInfo.blob().type === type2);
      const removeByUri = (blobUri) => {
        cache = filter$5(cache, (blobInfo) => {
          if (blobInfo.blobUri() === blobUri) {
            URL.revokeObjectURL(blobInfo.blobUri());
            return false;
          }
          return true;
        });
      };
      const destroy3 = () => {
        each$e(cache, (cachedBlobInfo) => {
          URL.revokeObjectURL(cachedBlobInfo.blobUri());
        });
        cache = [];
      };
      return {
        create: create3,
        add: add2,
        get: get2,
        getByUri,
        getByData,
        findFirst,
        removeByUri,
        destroy: destroy3
      };
    };
    const Uploader = (uploadStatus, settings) => {
      const pendingPromises = {};
      const pathJoin = (path1, path2) => {
        if (path1) {
          return path1.replace(/\/$/, "") + "/" + path2.replace(/^\//, "");
        }
        return path2;
      };
      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {
        const xhr = new XMLHttpRequest();
        xhr.open("POST", settings.url);
        xhr.withCredentials = settings.credentials;
        xhr.upload.onprogress = (e) => {
          progress(e.loaded / e.total * 100);
        };
        xhr.onerror = () => {
          failure("Image upload failed due to a XHR Transport error. Code: " + xhr.status);
        };
        xhr.onload = () => {
          if (xhr.status < 200 || xhr.status >= 300) {
            failure("HTTP Error: " + xhr.status);
            return;
          }
          const json = JSON.parse(xhr.responseText);
          if (!json || !isString2(json.location)) {
            failure("Invalid JSON: " + xhr.responseText);
            return;
          }
          success(pathJoin(settings.basePath, json.location));
        };
        const formData = new FormData();
        formData.append("file", blobInfo.blob(), blobInfo.filename());
        xhr.send(formData);
      });
      const uploadHandler = isFunction2(settings.handler) ? settings.handler : defaultHandler;
      const noUpload = () => new Promise((resolve2) => {
        resolve2([]);
      });
      const handlerSuccess = (blobInfo, url) => ({
        url,
        blobInfo,
        status: true
      });
      const handlerFailure = (blobInfo, error3) => ({
        url: "",
        blobInfo,
        status: false,
        error: error3
      });
      const resolvePending = (blobUri, result) => {
        Tools.each(pendingPromises[blobUri], (resolve2) => {
          resolve2(result);
        });
        delete pendingPromises[blobUri];
      };
      const uploadBlobInfo = (blobInfo, handler, openNotification2) => {
        uploadStatus.markPending(blobInfo.blobUri());
        return new Promise((resolve2) => {
          let notification;
          let progress;
          try {
            const closeNotification = () => {
              if (notification) {
                notification.close();
                progress = noop2;
              }
            };
            const success = (url) => {
              closeNotification();
              uploadStatus.markUploaded(blobInfo.blobUri(), url);
              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));
              resolve2(handlerSuccess(blobInfo, url));
            };
            const failure = (error3) => {
              closeNotification();
              uploadStatus.removeFailed(blobInfo.blobUri());
              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error3));
              resolve2(handlerFailure(blobInfo, error3));
            };
            progress = (percent) => {
              if (percent < 0 || percent > 100) {
                return;
              }
              Optional.from(notification).orThunk(() => Optional.from(openNotification2).map(apply$1)).each((n) => {
                notification = n;
                n.progressBar.value(percent);
              });
            };
            handler(blobInfo, progress).then(success, (err) => {
              failure(isString2(err) ? { message: err } : err);
            });
          } catch (ex) {
            resolve2(handlerFailure(blobInfo, ex));
          }
        });
      };
      const isDefaultHandler = (handler) => handler === defaultHandler;
      const pendingUploadBlobInfo = (blobInfo) => {
        const blobUri = blobInfo.blobUri();
        return new Promise((resolve2) => {
          pendingPromises[blobUri] = pendingPromises[blobUri] || [];
          pendingPromises[blobUri].push(resolve2);
        });
      };
      const uploadBlobs = (blobInfos, openNotification2) => {
        blobInfos = Tools.grep(blobInfos, (blobInfo) => !uploadStatus.isUploaded(blobInfo.blobUri()));
        return Promise.all(Tools.map(blobInfos, (blobInfo) => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification2)));
      };
      const upload = (blobInfos, openNotification2) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification2);
      return { upload };
    };
    const openNotification = (editor) => () => editor.notificationManager.open({
      text: editor.translate("Image uploading..."),
      type: "info",
      timeout: -1,
      progressBar: true
    });
    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {
      url: getImageUploadUrl(editor),
      basePath: getImageUploadBasePath(editor),
      credentials: getImagesUploadCredentials(editor),
      handler: getImagesUploadHandler(editor)
    });
    const ImageUploader = (editor) => {
      const uploadStatus = UploadStatus();
      const uploader = createUploader(editor, uploadStatus);
      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : void 0) };
    };
    const EditorUpload = (editor) => {
      const blobCache = BlobCache();
      let uploader, imageScanner;
      const uploadStatus = UploadStatus();
      const urlFilters = [];
      const aliveGuard = (callback) => {
        return (result) => {
          if (editor.selection) {
            return callback(result);
          }
          return [];
        };
      };
      const cacheInvalidator = (url) => url + (url.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime();
      const replaceString = (content, search2, replace) => {
        let index = 0;
        do {
          index = content.indexOf(search2, index);
          if (index !== -1) {
            content = content.substring(0, index) + replace + content.substr(index + search2.length);
            index += replace.length - search2.length + 1;
          }
        } while (index !== -1);
        return content;
      };
      const replaceImageUrl = (content, targetUrl, replacementUrl) => {
        const replacementString = `src="${replacementUrl}"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
        content = replaceString(content, `src="${targetUrl}"`, replacementString);
        content = replaceString(content, 'data-mce-src="' + targetUrl + '"', 'data-mce-src="' + replacementUrl + '"');
        return content;
      };
      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {
        each$e(editor.undoManager.data, (level) => {
          if (level.type === "fragmented") {
            level.fragments = map$3(level.fragments, (fragment) => replaceImageUrl(fragment, targetUrl, replacementUrl));
          } else {
            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);
          }
        });
      };
      const replaceImageUriInView = (image, resultUri) => {
        const src = editor.convertURL(resultUri, "src");
        replaceUrlInUndoStack(image.src, resultUri);
        setAll$1(SugarElement.fromDom(image), {
          "src": shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,
          "data-mce-src": src
        });
      };
      const uploadImages = () => {
        if (!uploader) {
          uploader = createUploader(editor, uploadStatus);
        }
        return scanForImages().then(aliveGuard((imageInfos) => {
          const blobInfos = map$3(imageInfos, (imageInfo) => imageInfo.blobInfo);
          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard((result) => {
            const imagesToRemove = [];
            let shouldDispatchChange = false;
            const filteredResult = map$3(result, (uploadInfo, index) => {
              const { blobInfo, image } = imageInfos[index];
              let removed = false;
              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {
                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {
                  shouldDispatchChange = true;
                }
                blobCache.removeByUri(image.src);
                if (isRtc(editor))
                  ;
                else {
                  replaceImageUriInView(image, uploadInfo.url);
                }
              } else if (uploadInfo.error) {
                if (uploadInfo.error.remove) {
                  replaceUrlInUndoStack(image.src, Env.transparentSrc);
                  imagesToRemove.push(image);
                  removed = true;
                }
                uploadError(editor, uploadInfo.error.message);
              }
              return {
                element: image,
                status: uploadInfo.status,
                uploadUri: uploadInfo.url,
                blobInfo,
                removed
              };
            });
            if (imagesToRemove.length > 0 && !isRtc(editor)) {
              editor.undoManager.transact(() => {
                each$e(imagesToRemove, (element) => {
                  editor.dom.remove(element);
                  blobCache.removeByUri(element.src);
                });
              });
            } else if (shouldDispatchChange) {
              editor.undoManager.dispatchChange();
            }
            return filteredResult;
          }));
        }));
      };
      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);
      const isValidDataUriImage = (imgElm) => forall(urlFilters, (filter3) => filter3(imgElm));
      const addFilter2 = (filter3) => {
        urlFilters.push(filter3);
      };
      const scanForImages = () => {
        if (!imageScanner) {
          imageScanner = ImageScanner(uploadStatus, blobCache);
        }
        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard((result) => {
          const filteredResult = filter$5(result, (resultItem) => {
            if (isString2(resultItem)) {
              displayError(editor, resultItem);
              return false;
            } else {
              return true;
            }
          });
          if (isRtc(editor))
            ;
          else {
            each$e(filteredResult, (resultItem) => {
              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());
              resultItem.image.src = resultItem.blobInfo.blobUri();
              resultItem.image.removeAttribute("data-mce-src");
            });
          }
          return filteredResult;
        }));
      };
      const destroy3 = () => {
        blobCache.destroy();
        uploadStatus.destroy();
        imageScanner = uploader = null;
      };
      const replaceBlobUris = (content) => {
        return content.replace(/src="(blob:[^"]+)"/g, (match2, blobUri) => {
          const resultUri = uploadStatus.getResultUri(blobUri);
          if (resultUri) {
            return 'src="' + resultUri + '"';
          }
          let blobInfo = blobCache.getByUri(blobUri);
          if (!blobInfo) {
            blobInfo = foldl(editor.editorManager.get(), (result, editor2) => {
              return result || editor2.editorUpload && editor2.editorUpload.blobCache.getByUri(blobUri);
            }, void 0);
          }
          if (blobInfo) {
            const blob2 = blobInfo.blob();
            return 'src="data:' + blob2.type + ";base64," + blobInfo.base64() + '"';
          }
          return match2;
        });
      };
      editor.on("SetContent", () => {
        if (isAutomaticUploadsEnabled(editor)) {
          uploadImagesAuto();
        } else {
          scanForImages();
        }
      });
      editor.on("RawSaveContent", (e) => {
        e.content = replaceBlobUris(e.content);
      });
      editor.on("GetContent", (e) => {
        if (e.source_view || e.format === "raw" || e.format === "tree") {
          return;
        }
        e.content = replaceBlobUris(e.content);
      });
      editor.on("PostRender", () => {
        editor.parser.addNodeFilter("img", (images2) => {
          each$e(images2, (img) => {
            const src = img.attr("src");
            if (!src || blobCache.getByUri(src)) {
              return;
            }
            const resultUri = uploadStatus.getResultUri(src);
            if (resultUri) {
              img.attr("src", resultUri);
            }
          });
        });
      });
      return {
        blobCache,
        addFilter: addFilter2,
        uploadImages,
        uploadImagesAuto,
        scanForImages,
        destroy: destroy3
      };
    };
    const get$1 = (editor) => {
      const dom2 = editor.dom;
      const schemaType = editor.schema.type;
      const formats = {
        valigntop: [{
          selector: "td,th",
          styles: { verticalAlign: "top" }
        }],
        valignmiddle: [{
          selector: "td,th",
          styles: { verticalAlign: "middle" }
        }],
        valignbottom: [{
          selector: "td,th",
          styles: { verticalAlign: "bottom" }
        }],
        alignleft: [
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-left",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "left" },
            inherit: false,
            preview: false
          },
          {
            selector: "img,audio,video",
            collapsed: false,
            styles: { float: "left" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: false,
            styles: {
              marginLeft: "0px",
              marginRight: "auto"
            },
            onformat: (table2) => {
              dom2.setStyle(table2, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: true,
            styles: { float: "left" }
          }
        ],
        aligncenter: [
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "center" },
            inherit: false,
            preview: "font-family font-size"
          },
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-center",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: false,
            styles: {
              display: "block",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: false
          },
          {
            selector: "table",
            collapsed: false,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object",
            ceFalseOverride: true,
            styles: {
              display: "table",
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: false
          },
          {
            selector: "[data-ephox-embed-iri]",
            ceFalseOverride: true,
            styles: {
              marginLeft: "auto",
              marginRight: "auto"
            },
            preview: false
          }
        ],
        alignright: [
          {
            selector: "figure.image",
            collapsed: false,
            classes: "align-right",
            ceFalseOverride: true,
            preview: "font-family font-size"
          },
          {
            selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
            styles: { textAlign: "right" },
            inherit: false,
            preview: "font-family font-size"
          },
          {
            selector: "img,audio,video",
            collapsed: false,
            styles: { float: "right" },
            preview: "font-family font-size"
          },
          {
            selector: "table",
            collapsed: false,
            styles: {
              marginRight: "0px",
              marginLeft: "auto"
            },
            onformat: (table2) => {
              dom2.setStyle(table2, "float", null);
            },
            preview: "font-family font-size"
          },
          {
            selector: ".mce-preview-object,[data-ephox-embed-iri]",
            ceFalseOverride: true,
            styles: { float: "right" },
            preview: false
          }
        ],
        alignjustify: [{
          selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
          styles: { textAlign: "justify" },
          inherit: false,
          preview: "font-family font-size"
        }],
        bold: [
          {
            inline: "strong",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontWeight: "bold" }
          },
          {
            inline: "b",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        italic: [
          {
            inline: "em",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          },
          {
            inline: "span",
            styles: { fontStyle: "italic" }
          },
          {
            inline: "i",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        underline: [
          {
            inline: "span",
            styles: { textDecoration: "underline" },
            exact: true
          },
          {
            inline: "u",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          }
        ],
        strikethrough: (() => {
          const span = {
            inline: "span",
            styles: { textDecoration: "line-through" },
            exact: true
          };
          const strike = {
            inline: "strike",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          const s = {
            inline: "s",
            remove: "all",
            preserve_attributes: [
              "class",
              "style"
            ]
          };
          return schemaType !== "html4" ? [
            s,
            span,
            strike
          ] : [
            span,
            s,
            strike
          ];
        })(),
        forecolor: {
          inline: "span",
          styles: { color: "%value" },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        hilitecolor: {
          inline: "span",
          styles: { backgroundColor: "%value" },
          links: true,
          remove_similar: true,
          clear_child_styles: true
        },
        fontname: {
          inline: "span",
          toggle: false,
          styles: { fontFamily: "%value" },
          clear_child_styles: true
        },
        fontsize: {
          inline: "span",
          toggle: false,
          styles: { fontSize: "%value" },
          clear_child_styles: true
        },
        lineheight: {
          selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div",
          styles: { lineHeight: "%value" }
        },
        fontsize_class: {
          inline: "span",
          attributes: { class: "%value" }
        },
        blockquote: {
          block: "blockquote",
          wrapper: true,
          remove: "all"
        },
        subscript: { inline: "sub" },
        superscript: { inline: "sup" },
        code: { inline: "code" },
        link: {
          inline: "a",
          selector: "a",
          remove: "all",
          split: true,
          deep: true,
          onmatch: (node, _fmt, _itemName) => {
            return isElement$6(node) && node.hasAttribute("href");
          },
          onformat: (elm, _fmt, vars) => {
            Tools.each(vars, (value2, key) => {
              dom2.setAttrib(elm, key, value2);
            });
          }
        },
        lang: {
          inline: "span",
          clear_child_styles: true,
          remove_similar: true,
          attributes: {
            "lang": "%value",
            "data-mce-lang": (vars) => {
              var _a;
              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        },
        removeformat: [
          {
            selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
            remove: "all",
            split: true,
            expand: false,
            block_expand: true,
            deep: true
          },
          {
            selector: "span",
            attributes: [
              "style",
              "class"
            ],
            remove: "empty",
            split: true,
            expand: false,
            deep: true
          },
          {
            selector: "*",
            attributes: [
              "style",
              "class"
            ],
            split: false,
            expand: false,
            deep: true
          }
        ]
      };
      Tools.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd samp".split(/\s/), (name3) => {
        formats[name3] = {
          block: name3,
          remove: "all"
        };
      });
      return formats;
    };
    const genericBase = {
      remove_similar: true,
      inherit: false
    };
    const cellBase = {
      selector: "td,th",
      ...genericBase
    };
    const cellFormats = {
      tablecellbackgroundcolor: {
        styles: { backgroundColor: "%value" },
        ...cellBase
      },
      tablecellverticalalign: {
        styles: { "vertical-align": "%value" },
        ...cellBase
      },
      tablecellbordercolor: {
        styles: { borderColor: "%value" },
        ...cellBase
      },
      tablecellclass: {
        classes: ["%value"],
        ...cellBase
      },
      tableclass: {
        selector: "table",
        classes: ["%value"],
        ...genericBase
      },
      tablecellborderstyle: {
        styles: { borderStyle: "%value" },
        ...cellBase
      },
      tablecellborderwidth: {
        styles: { borderWidth: "%value" },
        ...cellBase
      }
    };
    const get = constant(cellFormats);
    const FormatRegistry = (editor) => {
      const formats = {};
      const get$22 = (name3) => isNonNullable(name3) ? formats[name3] : formats;
      const has2 = (name3) => has$2(formats, name3);
      const register2 = (name3, format) => {
        if (name3) {
          if (!isString2(name3)) {
            each$d(name3, (format2, name4) => {
              register2(name4, format2);
            });
          } else {
            if (!isArray$12(format)) {
              format = [format];
            }
            each$e(format, (format2) => {
              if (isUndefined2(format2.deep)) {
                format2.deep = !isSelectorFormat(format2);
              }
              if (isUndefined2(format2.split)) {
                format2.split = !isSelectorFormat(format2) || isInlineFormat(format2);
              }
              if (isUndefined2(format2.remove) && isSelectorFormat(format2) && !isInlineFormat(format2)) {
                format2.remove = "none";
              }
              if (isSelectorFormat(format2) && isInlineFormat(format2)) {
                format2.mixed = true;
                format2.block_expand = true;
              }
              if (isString2(format2.classes)) {
                format2.classes = format2.classes.split(/\s+/);
              }
            });
            formats[name3] = format;
          }
        }
      };
      const unregister = (name3) => {
        if (name3 && formats[name3]) {
          delete formats[name3];
        }
        return formats;
      };
      register2(get$1(editor));
      register2(get());
      register2(getFormats(editor));
      return {
        get: get$22,
        has: has2,
        register: register2,
        unregister
      };
    };
    const each$3 = Tools.each;
    const dom = DOMUtils.DOM;
    const isPreviewItem = (item2) => isNonNullable(item2) && isObject2(item2);
    const parsedSelectorToHtml = (ancestry, editor) => {
      const schema = editor && editor.schema || Schema({});
      const decorate = (elm, item2) => {
        if (item2.classes.length > 0) {
          dom.addClass(elm, item2.classes.join(" "));
        }
        dom.setAttribs(elm, item2.attrs);
      };
      const createElement2 = (sItem) => {
        const item2 = isString2(sItem) ? {
          name: sItem,
          classes: [],
          attrs: {}
        } : sItem;
        const elm = dom.create(item2.name);
        decorate(elm, item2);
        return elm;
      };
      const getRequiredParent = (elm, candidate) => {
        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());
        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;
        if (parentsRequired && parentsRequired.length) {
          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];
        } else {
          return false;
        }
      };
      const wrapInHtml = (elm, ancestors, siblings2) => {
        let parentCandidate;
        const ancestor2 = ancestors[0];
        const ancestorName = isPreviewItem(ancestor2) ? ancestor2.name : void 0;
        const parentRequired = getRequiredParent(elm, ancestorName);
        if (parentRequired) {
          if (ancestorName === parentRequired) {
            parentCandidate = ancestor2;
            ancestors = ancestors.slice(1);
          } else {
            parentCandidate = parentRequired;
          }
        } else if (ancestor2) {
          parentCandidate = ancestor2;
          ancestors = ancestors.slice(1);
        } else if (!siblings2) {
          return elm;
        }
        const parent2 = parentCandidate ? createElement2(parentCandidate) : dom.create("div");
        parent2.appendChild(elm);
        if (siblings2) {
          Tools.each(siblings2, (sibling2) => {
            const siblingElm = createElement2(sibling2);
            parent2.insertBefore(siblingElm, elm);
          });
        }
        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : void 0;
        return wrapInHtml(parent2, ancestors, parentSiblings);
      };
      const fragment = dom.create("div");
      if (ancestry.length > 0) {
        const item2 = ancestry[0];
        const elm = createElement2(item2);
        const siblings2 = isPreviewItem(item2) ? item2.siblings : void 0;
        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings2));
      }
      return fragment;
    };
    const parseSelectorItem = (item2) => {
      item2 = Tools.trim(item2);
      let tagName = "div";
      const obj = {
        name: tagName,
        classes: [],
        attrs: {},
        selector: item2
      };
      if (item2 !== "*") {
        tagName = item2.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, ($0, $1, $2, $3, $4) => {
          switch ($1) {
            case "#":
              obj.attrs.id = $2;
              break;
            case ".":
              obj.classes.push($2);
              break;
            case ":":
              if (Tools.inArray("checked disabled enabled read-only required".split(" "), $2) !== -1) {
                obj.attrs[$2] = $2;
              }
              break;
          }
          if ($3 === "[") {
            const m = $4.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            if (m) {
              obj.attrs[m[1]] = m[2];
            }
          }
          return "";
        });
      }
      obj.name = tagName || "div";
      return obj;
    };
    const parseSelector2 = (selector) => {
      if (!isString2(selector)) {
        return [];
      }
      selector = selector.split(/\s*,\s*/)[0];
      selector = selector.replace(/\s*(~\+|~|\+|>)\s*/g, "$1");
      return Tools.map(selector.split(/(?:>|\s+(?![^\[\]]+\]))/), (item2) => {
        const siblings2 = Tools.map(item2.split(/(?:~\+|~|\+)/), parseSelectorItem);
        const obj = siblings2.pop();
        if (siblings2.length) {
          obj.siblings = siblings2;
        }
        return obj;
      }).reverse();
    };
    const getCssText = (editor, format) => {
      let previewCss = "";
      let previewStyles = getPreviewStyles(editor);
      if (previewStyles === "") {
        return "";
      }
      const removeVars = (val) => {
        return isString2(val) ? val.replace(/%(\w+)/g, "") : "";
      };
      const getComputedStyle2 = (name4, elm) => {
        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name4, true);
      };
      if (isString2(format)) {
        const formats = editor.formatter.get(format);
        if (!formats) {
          return "";
        }
        format = formats[0];
      }
      if ("preview" in format) {
        const preview = format.preview;
        if (preview === false) {
          return "";
        } else {
          previewStyles = preview || previewStyles;
        }
      }
      let name3 = format.block || format.inline || "span";
      let previewFrag;
      const items = parseSelector2(format.selector);
      if (items.length > 0) {
        if (!items[0].name) {
          items[0].name = name3;
        }
        name3 = format.selector;
        previewFrag = parsedSelectorToHtml(items, editor);
      } else {
        previewFrag = parsedSelectorToHtml([name3], editor);
      }
      const previewElm = dom.select(name3, previewFrag)[0] || previewFrag.firstChild;
      each$3(format.styles, (value2, name4) => {
        const newValue = removeVars(value2);
        if (newValue) {
          dom.setStyle(previewElm, name4, newValue);
        }
      });
      each$3(format.attributes, (value2, name4) => {
        const newValue = removeVars(value2);
        if (newValue) {
          dom.setAttrib(previewElm, name4, newValue);
        }
      });
      each$3(format.classes, (value2) => {
        const newValue = removeVars(value2);
        if (!dom.hasClass(previewElm, newValue)) {
          dom.addClass(previewElm, newValue);
        }
      });
      editor.dispatch("PreviewFormats");
      dom.setStyles(previewFrag, {
        position: "absolute",
        left: -65535
      });
      editor.getBody().appendChild(previewFrag);
      const rawParentFontSize = getComputedStyle2("fontSize");
      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;
      each$3(previewStyles.split(" "), (name4) => {
        let value2 = getComputedStyle2(name4, previewElm);
        if (name4 === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(value2)) {
          value2 = getComputedStyle2(name4);
          if (rgbaToHexString(value2).toLowerCase() === "#ffffff") {
            return;
          }
        }
        if (name4 === "color") {
          if (rgbaToHexString(value2).toLowerCase() === "#000000") {
            return;
          }
        }
        if (name4 === "font-size") {
          if (/em|%$/.test(value2)) {
            if (parentFontSize === 0) {
              return;
            }
            const numValue = parseFloat(value2) / (/%$/.test(value2) ? 100 : 1);
            value2 = numValue * parentFontSize + "px";
          }
        }
        if (name4 === "border" && value2) {
          previewCss += "padding:0 2px;";
        }
        previewCss += name4 + ":" + value2 + ";";
      });
      editor.dispatch("AfterPreviewFormats");
      dom.remove(previewFrag);
      return previewCss;
    };
    const setup$r = (editor) => {
      editor.addShortcut("meta+b", "", "Bold");
      editor.addShortcut("meta+i", "", "Italic");
      editor.addShortcut("meta+u", "", "Underline");
      for (let i = 1; i <= 6; i++) {
        editor.addShortcut("access+" + i, "", [
          "FormatBlock",
          false,
          "h" + i
        ]);
      }
      editor.addShortcut("access+7", "", [
        "FormatBlock",
        false,
        "p"
      ]);
      editor.addShortcut("access+8", "", [
        "FormatBlock",
        false,
        "div"
      ]);
      editor.addShortcut("access+9", "", [
        "FormatBlock",
        false,
        "address"
      ]);
    };
    const Formatter = (editor) => {
      const formats = FormatRegistry(editor);
      const formatChangeState = Cell({});
      setup$r(editor);
      setup$u(editor);
      if (!isRtc(editor)) {
        setup$t(formatChangeState, editor);
      }
      return {
        get: formats.get,
        has: formats.has,
        register: formats.register,
        unregister: formats.unregister,
        apply: (name3, vars, node) => {
          applyFormat(editor, name3, vars, node);
        },
        remove: (name3, vars, node, similar) => {
          removeFormat(editor, name3, vars, node, similar);
        },
        toggle: (name3, vars, node) => {
          toggleFormat(editor, name3, vars, node);
        },
        match: (name3, vars, node, similar) => matchFormat(editor, name3, vars, node, similar),
        closest: (names) => closestFormat(editor, names),
        matchAll: (names, vars) => matchAllFormats(editor, names, vars),
        matchNode: (node, name3, vars, similar) => matchNodeFormat(editor, node, name3, vars, similar),
        canApply: (name3) => canApplyFormat(editor, name3),
        formatChanged: (formats2, callback, similar, vars) => formatChanged(editor, formatChangeState, formats2, callback, similar, vars),
        getCssText: curry(getCssText, editor)
      };
    };
    const shouldIgnoreCommand = (cmd) => {
      switch (cmd.toLowerCase()) {
        case "undo":
        case "redo":
        case "mcefocus":
          return true;
        default:
          return false;
      }
    };
    const registerEvents = (editor, undoManager, locks) => {
      const isFirstTypedCharacter = Cell(false);
      const addNonTypingUndoLevel = (e) => {
        setTyping(undoManager, false, locks);
        undoManager.add({}, e);
      };
      editor.on("init", () => {
        undoManager.add();
      });
      editor.on("BeforeExecCommand", (e) => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          endTyping(undoManager, locks);
          undoManager.beforeChange();
        }
      });
      editor.on("ExecCommand", (e) => {
        const cmd = e.command;
        if (!shouldIgnoreCommand(cmd)) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on("ObjectResizeStart cut", () => {
        undoManager.beforeChange();
      });
      editor.on("SaveContent ObjectResized blur", addNonTypingUndoLevel);
      editor.on("dragend", addNonTypingUndoLevel);
      editor.on("keyup", (e) => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey) {
          addNonTypingUndoLevel();
          editor.nodeChanged();
        }
        if (keyCode === 46 || keyCode === 8) {
          editor.nodeChanged();
        }
        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {
          if (!editor.isDirty()) {
            editor.setDirty(true);
          }
          editor.dispatch("TypingUndo");
          isFirstTypedCharacter.set(false);
          editor.nodeChanged();
        }
      });
      editor.on("keydown", (e) => {
        const keyCode = e.keyCode;
        if (e.isDefaultPrevented()) {
          return;
        }
        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {
          if (undoManager.typing) {
            addNonTypingUndoLevel(e);
          }
          return;
        }
        const modKey = e.ctrlKey && !e.altKey || e.metaKey;
        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {
          undoManager.beforeChange();
          setTyping(undoManager, true, locks);
          undoManager.add({}, e);
          isFirstTypedCharacter.set(true);
        }
      });
      editor.on("mousedown", (e) => {
        if (undoManager.typing) {
          addNonTypingUndoLevel(e);
        }
      });
      const isInsertReplacementText = (event) => event.inputType === "insertReplacementText";
      const isInsertTextDataNull = (event) => event.inputType === "insertText" && event.data === null;
      const isInsertFromPasteOrDrop = (event) => event.inputType === "insertFromPaste" || event.inputType === "insertFromDrop";
      editor.on("input", (e) => {
        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {
          addNonTypingUndoLevel(e);
        }
      });
      editor.on("AddUndo Undo Redo ClearUndos", (e) => {
        if (!e.isDefaultPrevented()) {
          editor.nodeChanged();
        }
      });
    };
    const addKeyboardShortcuts = (editor) => {
      editor.addShortcut("meta+z", "", "Undo");
      editor.addShortcut("meta+y,meta+shift+z", "", "Redo");
    };
    const UndoManager = (editor) => {
      const beforeBookmark = value$2();
      const locks = Cell(0);
      const index = Cell(0);
      const undoManager = {
        data: [],
        typing: false,
        beforeChange: () => {
          beforeChange(editor, locks, beforeBookmark);
        },
        add: (level, event) => {
          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);
        },
        dispatchChange: () => {
          editor.setDirty(true);
          const level = createFromEditor(editor);
          level.bookmark = getUndoBookmark(editor.selection);
          editor.dispatch("change", {
            level,
            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()
          });
        },
        undo: () => {
          return undo(editor, undoManager, locks, index);
        },
        redo: () => {
          return redo(editor, index, undoManager.data);
        },
        clear: () => {
          clear2(editor, undoManager, index);
        },
        reset: () => {
          reset(editor, undoManager);
        },
        hasUndo: () => {
          return hasUndo(editor, undoManager, index);
        },
        hasRedo: () => {
          return hasRedo(editor, undoManager, index);
        },
        transact: (callback) => {
          return transact(editor, undoManager, locks, callback);
        },
        ignore: (callback) => {
          ignore(editor, locks, callback);
        },
        extra: (callback1, callback2) => {
          extra(editor, undoManager, index, callback1, callback2);
        }
      };
      if (!isRtc(editor)) {
        registerEvents(editor, undoManager, locks);
      }
      addKeyboardShortcuts(editor);
      return undoManager;
    };
    const nonTypingKeycodes = [
      9,
      27,
      VK.HOME,
      VK.END,
      19,
      20,
      44,
      144,
      145,
      33,
      34,
      45,
      16,
      17,
      18,
      91,
      92,
      93,
      VK.DOWN,
      VK.UP,
      VK.LEFT,
      VK.RIGHT
    ].concat(Env.browser.isFirefox() ? [224] : []);
    const placeholderAttr = "data-mce-placeholder";
    const isKeyboardEvent = (e) => e.type === "keydown" || e.type === "keyup";
    const isDeleteEvent = (e) => {
      const keyCode = e.keyCode;
      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;
    };
    const isNonTypingKeyboardEvent = (e) => {
      if (isKeyboardEvent(e)) {
        const keyCode = e.keyCode;
        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));
      } else {
        return false;
      }
    };
    const isTypingKeyboardEvent = (e) => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === "keyup" && e.keyCode === 229);
    const isVisuallyEmpty = (dom2, rootElm, forcedRootBlock) => {
      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {
        const firstElement2 = rootElm.firstElementChild;
        if (!firstElement2) {
          return true;
        } else if (dom2.getStyle(rootElm.firstElementChild, "padding-left") || dom2.getStyle(rootElm.firstElementChild, "padding-right")) {
          return false;
        } else {
          return forcedRootBlock === firstElement2.nodeName.toLowerCase();
        }
      } else {
        return false;
      }
    };
    const setup$q = (editor) => {
      var _a;
      const dom2 = editor.dom;
      const rootBlock = getForcedRootBlock(editor);
      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : "";
      const updatePlaceholder = (e, initial) => {
        if (isNonTypingKeyboardEvent(e)) {
          return;
        }
        const body = editor.getBody();
        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom2, body, rootBlock);
        const isPlaceholderShown = dom2.getAttrib(body, placeholderAttr) !== "";
        if (isPlaceholderShown !== showPlaceholder || initial) {
          dom2.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);
          dom2.setAttrib(body, "aria-placeholder", showPlaceholder ? placeholder : null);
          firePlaceholderToggle(editor, showPlaceholder);
          editor.on(showPlaceholder ? "keydown" : "keyup", updatePlaceholder);
          editor.off(showPlaceholder ? "keyup" : "keydown", updatePlaceholder);
        }
      };
      if (isNotEmpty(placeholder)) {
        editor.on("init", (e) => {
          updatePlaceholder(e, true);
          editor.on("change SetContent ExecCommand", updatePlaceholder);
          editor.on("paste", (e2) => Delay.setEditorTimeout(editor, () => updatePlaceholder(e2)));
        });
      }
    };
    const blockPosition = (block, position) => ({
      block,
      position
    });
    const blockBoundary = (from2, to2) => ({
      from: from2,
      to: to2
    });
    const getBlockPosition = (rootNode, pos) => {
      const rootElm = SugarElement.fromDom(rootNode);
      const containerElm = SugarElement.fromDom(pos.container());
      return getParentBlock$2(rootElm, containerElm).map((block) => blockPosition(block, pos));
    };
    const isDifferentBlocks = (blockBoundary2) => !eq(blockBoundary2.from.block, blockBoundary2.to.block);
    const getClosestHost = (root2, scope) => {
      const isRoot2 = (node) => eq(node, root2);
      const isHost = (node) => isTableCell$2(node) || isContentEditableTrue$3(node.dom);
      return closest$4(scope, isHost, isRoot2).filter(isElement$7).getOr(root2);
    };
    const hasSameHost = (rootNode, blockBoundary2) => {
      const root2 = SugarElement.fromDom(rootNode);
      return eq(getClosestHost(root2, blockBoundary2.from.block), getClosestHost(root2, blockBoundary2.to.block));
    };
    const isEditable$1 = (blockBoundary2) => isContentEditableFalse$b(blockBoundary2.from.block.dom) === false && isContentEditableFalse$b(blockBoundary2.to.block.dom) === false;
    const hasValidBlocks = (blockBoundary2) => {
      const isValidBlock = (block) => isTextBlock$2(block) || hasBlockAttr(block.dom);
      return isValidBlock(blockBoundary2.from.block) && isValidBlock(blockBoundary2.to.block);
    };
    const skipLastBr = (rootNode, forward, blockPosition2) => {
      if (isBr$6(blockPosition2.position.getNode()) && !isEmpty$2(blockPosition2.block)) {
        return positionIn(false, blockPosition2.block.dom).bind((lastPositionInBlock) => {
          if (lastPositionInBlock.isEqual(blockPosition2.position)) {
            return fromPosition(forward, rootNode, lastPositionInBlock).bind((to2) => getBlockPosition(rootNode, to2));
          } else {
            return Optional.some(blockPosition2);
          }
        }).getOr(blockPosition2);
      } else {
        return blockPosition2;
      }
    };
    const readFromRange = (rootNode, forward, rng) => {
      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));
      const toBlockPos = fromBlockPos.bind((blockPos) => fromPosition(forward, rootNode, blockPos.position).bind((to2) => getBlockPosition(rootNode, to2).map((blockPos2) => skipLastBr(rootNode, forward, blockPos2))));
      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter((blockBoundary2) => isDifferentBlocks(blockBoundary2) && hasSameHost(rootNode, blockBoundary2) && isEditable$1(blockBoundary2) && hasValidBlocks(blockBoundary2));
    };
    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();
    const getChildrenUntilBlockBoundary = (block) => {
      const children2 = children$1(block);
      return findIndex$2(children2, isBlock$2).fold(constant(children2), (index) => children2.slice(0, index));
    };
    const extractChildren = (block) => {
      const children2 = getChildrenUntilBlockBoundary(block);
      each$e(children2, remove$6);
      return children2;
    };
    const removeEmptyRoot = (rootNode, block) => {
      const parents2 = parentsAndSelf(block, rootNode);
      return find$2(parents2.reverse(), (element) => isEmpty$2(element)).each(remove$6);
    };
    const isEmptyBefore = (el) => filter$5(prevSiblings(el), (el2) => !isEmpty$2(el2)).length === 0;
    const nestedBlockMerge = (rootNode, fromBlock, toBlock, insertionPoint) => {
      if (isEmpty$2(toBlock)) {
        fillWithPaddingBr(toBlock);
        return firstPositionIn(toBlock.dom);
      }
      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {
        before$3(insertionPoint, SugarElement.fromTag("br"));
      }
      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));
      each$e(extractChildren(fromBlock), (child2) => {
        before$3(insertionPoint, child2);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const sidelongBlockMerge = (rootNode, fromBlock, toBlock) => {
      if (isEmpty$2(toBlock)) {
        if (isEmpty$2(fromBlock)) {
          const getInlineToBlockDescendants = (el) => {
            const helper = (node, elements) => firstChild(node).fold(() => elements, (child2) => isInline$1(child2) ? helper(child2, elements.concat(shallow$1(child2))) : elements);
            return helper(el, []);
          };
          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant2) => {
            wrap$2(element, descendant2);
            return descendant2;
          }, createPaddingBr());
          empty(fromBlock);
          append$1(fromBlock, newFromBlockDescendants);
        }
        remove$6(toBlock);
        return firstPositionIn(fromBlock.dom);
      }
      const position = lastPositionIn(toBlock.dom);
      each$e(extractChildren(fromBlock), (child2) => {
        append$1(toBlock, child2);
      });
      removeEmptyRoot(rootNode, fromBlock);
      return position;
    };
    const findInsertionPoint = (toBlock, block) => {
      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);
      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);
    };
    const getInsertionPoint = (fromBlock, toBlock) => contains2(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();
    const trimBr = (first2, block) => {
      positionIn(first2, block.dom).bind((position) => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$6);
    };
    const mergeBlockInto = (rootNode, fromBlock, toBlock) => {
      trimBr(true, fromBlock);
      trimBr(false, toBlock);
      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock), curry(nestedBlockMerge, rootNode, fromBlock, toBlock));
    };
    const mergeBlocks = (rootNode, forward, block1, block2) => forward ? mergeBlockInto(rootNode, block2, block1) : mergeBlockInto(rootNode, block1, block2);
    const backspaceDelete$8 = (editor, forward) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map((blockBoundary2) => () => {
        mergeBlocks(rootNode, forward, blockBoundary2.from.block, blockBoundary2.to.block).each((pos) => {
          editor.selection.setRng(pos.toRange());
        });
      });
      return position;
    };
    const deleteRangeMergeBlocks = (rootNode, selection) => {
      const rng = selection.getRng();
      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {
        if (!eq(block1, block2)) {
          return Optional.some(() => {
            rng.deleteContents();
            mergeBlocks(rootNode, true, block1, block2).each((pos) => {
              selection.setRng(pos.toRange());
            });
          });
        } else {
          return Optional.none();
        }
      }).getOr(Optional.none());
    };
    const isRawNodeInTable = (root2, rawNode) => {
      const node = SugarElement.fromDom(rawNode);
      const isRoot2 = curry(eq, root2);
      return ancestor$4(node, isTableCell$2, isRoot2).isSome();
    };
    const isSelectionInTable = (root2, rng) => isRawNodeInTable(root2, rng.startContainer) || isRawNodeInTable(root2, rng.endContainer);
    const isEverythingSelected = (root2, rng) => {
      const noPrevious = prevPosition(root2.dom, CaretPosition.fromRangeStart(rng)).isNone();
      const noNext = nextPosition(root2.dom, CaretPosition.fromRangeEnd(rng)).isNone();
      return !isSelectionInTable(root2, rng) && noPrevious && noNext;
    };
    const emptyEditor = (editor) => {
      return Optional.some(() => {
        editor.setContent("");
        editor.selection.setCursorLocation();
      });
    };
    const deleteRange$2 = (editor) => {
      const rootNode = SugarElement.fromDom(editor.getBody());
      const rng = editor.selection.getRng();
      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection);
    };
    const backspaceDelete$7 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);
    const showCaret = (direction, editor, node, before2, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before2, scrollIntoView));
    const getNodeRange = (node) => {
      const rng = node.ownerDocument.createRange();
      rng.selectNode(node);
      return rng;
    };
    const selectNode = (editor, node) => {
      const e = editor.dispatch("BeforeObjectSelected", { target: node });
      if (e.isDefaultPrevented()) {
        return Optional.none();
      }
      return Optional.some(getNodeRange(node));
    };
    const renderCaretAtRange = (editor, range2, scrollIntoView) => {
      const normalizedRange = normalizeRange(1, editor.getBody(), range2);
      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);
      const caretPositionNode = caretPosition.getNode();
      if (isInlineFakeCaretTarget(caretPositionNode)) {
        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);
      }
      const caretPositionBeforeNode = caretPosition.getNode(true);
      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {
        return showCaret(1, editor, caretPositionBeforeNode, false, false);
      }
      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());
      if (isInlineFakeCaretTarget(ceRoot)) {
        return showCaret(1, editor, ceRoot, false, scrollIntoView);
      }
      return Optional.none();
    };
    const renderRangeCaret = (editor, range2, scrollIntoView) => range2.collapsed ? renderCaretAtRange(editor, range2, scrollIntoView).getOr(range2) : range2;
    const isBeforeBoundary = (pos) => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);
    const isAfterBoundary = (pos) => isAfterContentEditableFalse(pos) || isAfterMedia(pos);
    const trimEmptyTextNode = (dom2, node) => {
      if (isText$a(node) && node.data.length === 0) {
        dom2.remove(node);
      }
    };
    const deleteContentAndShowCaret = (editor, range2, node, direction, forward, peekCaretPosition) => {
      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each((caretRange) => {
        if (range2.collapsed) {
          const deleteRange2 = range2.cloneRange();
          if (forward) {
            deleteRange2.setEnd(caretRange.startContainer, caretRange.startOffset);
          } else {
            deleteRange2.setStart(caretRange.endContainer, caretRange.endOffset);
          }
          deleteRange2.deleteContents();
        } else {
          range2.deleteContents();
        }
        editor.selection.setRng(caretRange);
      });
      trimEmptyTextNode(editor.dom, node);
    };
    const deleteBoundaryText = (editor, forward) => {
      const range2 = editor.selection.getRng();
      if (!isText$a(range2.commonAncestorContainer)) {
        return Optional.none();
      }
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      const nextCaretPosition = getNextPosFn(caretPosition);
      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;
      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {
        return Optional.none();
      } else if (isBeforeFn(normalizedNextCaretPosition)) {
        return Optional.some(() => deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));
      }
      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {
          return Optional.some(() => deleteContentAndShowCaret(editor, range2, caretPosition.getNode(), direction, forward, peekCaretPosition));
        }
      }
      return Optional.none();
    };
    const backspaceDelete$6 = (editor, forward) => deleteBoundaryText(editor, forward);
    const getEdgeCefPosition = (editor, atStart) => {
      const root2 = editor.getBody();
      return atStart ? firstPositionIn(root2).filter(isBeforeContentEditableFalse) : lastPositionIn(root2).filter(isAfterContentEditableFalse);
    };
    const isCefAtEdgeSelected = (editor) => {
      const rng = editor.selection.getRng();
      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists((pos) => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists((pos) => pos.isEqual(CaretPosition.fromRangeEnd(rng))));
    };
    const isCompoundElement = (node) => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));
    const DeleteAction = Adt.generate([
      { remove: ["element"] },
      { moveToElement: ["element"] },
      { moveToPosition: ["position"] }
    ]);
    const isAtContentEditableBlockCaret = (forward, from2) => {
      const elm = from2.getNode(!forward);
      const caretLocation = forward ? "after" : "before";
      return isElement$6(elm) && elm.getAttribute("data-mce-caret") === caretLocation;
    };
    const isDeleteFromCefDifferentBlocks = (root2, forward, from2, to2) => {
      const inSameBlock = (elm) => isInline$1(SugarElement.fromDom(elm)) && !isInSameBlock(from2, to2, root2);
      return getRelativeCefElm(!forward, from2).fold(() => getRelativeCefElm(forward, to2).fold(never, inSameBlock), inSameBlock);
    };
    const deleteEmptyBlockOrMoveToCef = (root2, forward, from2, to2) => {
      const toCefElm = to2.getNode(!forward);
      return getParentBlock$2(SugarElement.fromDom(root2), SugarElement.fromDom(from2.getNode())).map((blockElm) => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));
    };
    const findCefPosition = (root2, forward, from2) => fromPosition(forward, root2, from2).bind((to2) => {
      if (isCompoundElement(to2.getNode())) {
        return Optional.none();
      } else if (isDeleteFromCefDifferentBlocks(root2, forward, from2, to2)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(to2.getNode())) {
        return deleteEmptyBlockOrMoveToCef(root2, forward, from2, to2);
      } else if (!forward && isContentEditableFalse$b(to2.getNode(true))) {
        return deleteEmptyBlockOrMoveToCef(root2, forward, from2, to2);
      } else if (forward && isAfterContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.moveToPosition(to2));
      } else if (!forward && isBeforeContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.moveToPosition(to2));
      } else {
        return Optional.none();
      }
    });
    const getContentEditableBlockAction = (forward, elm) => {
      if (isNullable(elm)) {
        return Optional.none();
      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));
      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {
        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));
      } else {
        return Optional.none();
      }
    };
    const skipMoveToActionFromInlineCefToContent = (root2, from2, deleteAction2) => deleteAction2.fold((elm) => Optional.some(DeleteAction.remove(elm)), (elm) => Optional.some(DeleteAction.moveToElement(elm)), (to2) => {
      if (isInSameBlock(from2, to2, root2)) {
        return Optional.none();
      } else {
        return Optional.some(DeleteAction.moveToPosition(to2));
      }
    });
    const getContentEditableAction = (root2, forward, from2) => {
      if (isAtContentEditableBlockCaret(forward, from2)) {
        return getContentEditableBlockAction(forward, from2.getNode(!forward)).orThunk(() => findCefPosition(root2, forward, from2));
      } else {
        return findCefPosition(root2, forward, from2).bind((deleteAction2) => skipMoveToActionFromInlineCefToContent(root2, from2, deleteAction2));
      }
    };
    const read2 = (root2, forward, rng) => {
      const normalizedRange = normalizeRange(forward ? 1 : -1, root2, rng);
      const from2 = CaretPosition.fromRangeStart(normalizedRange);
      const rootElement = SugarElement.fromDom(root2);
      if (!forward && isAfterContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.remove(from2.getNode(true)));
      } else if (forward && isBeforeContentEditableFalse(from2)) {
        return Optional.some(DeleteAction.remove(from2.getNode()));
      } else if (!forward && isBeforeContentEditableFalse(from2) && isAfterBr(rootElement, from2)) {
        return findPreviousBr(rootElement, from2).map((br) => DeleteAction.remove(br.getNode()));
      } else if (forward && isAfterContentEditableFalse(from2) && isBeforeBr$1(rootElement, from2)) {
        return findNextBr(rootElement, from2).map((br) => DeleteAction.remove(br.getNode()));
      } else {
        return getContentEditableAction(root2, forward, from2);
      }
    };
    const deleteElement$1 = (editor, forward) => (element) => {
      editor._selectionOverrides.hideFakeCaret();
      deleteElement$2(editor, forward, SugarElement.fromDom(element));
      return true;
    };
    const moveToElement = (editor, forward) => (element) => {
      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const moveToPosition = (editor) => (pos) => {
      editor.selection.setRng(pos.toRange());
      return true;
    };
    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));
    const backspaceDeleteCaret = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read2(editor.getBody(), forward, editor.selection.getRng()).map((deleteAction2) => () => deleteAction2.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop2));
    };
    const deleteOffscreenSelection = (rootElement) => {
      each$e(descendants(rootElement, ".mce-offscreen-selection"), remove$6);
    };
    const backspaceDeleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {
        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);
        return hasCefAncestor.fold(() => Optional.some(() => {
          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));
          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));
          paddEmptyBody(editor);
        }), () => Optional.some(noop2));
      }
      if (isCefAtEdgeSelected(editor)) {
        return Optional.some(() => {
          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));
        });
      }
      return Optional.none();
    };
    const paddEmptyElement = (editor) => {
      const dom2 = editor.dom, selection = editor.selection;
      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());
      if (isContentEditableTrue$3(ceRoot) && dom2.isBlock(ceRoot) && dom2.isEmpty(ceRoot)) {
        const br = dom2.create("br", { "data-mce-bogus": "1" });
        dom2.setHTML(ceRoot, "");
        ceRoot.appendChild(br);
        selection.setRng(CaretPosition.before(br).toRange());
      }
      return true;
    };
    const backspaceDelete$5 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return backspaceDeleteCaret(editor, forward);
      } else {
        return backspaceDeleteRange(editor, forward);
      }
    };
    const deleteCaret$2 = (editor, forward) => {
      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return fromPosition(forward, editor.getBody(), fromPos).filter((pos) => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind((pos) => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map((elm) => () => editor.selection.select(elm));
    };
    const backspaceDelete$4 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();
    const isText$2 = isText$a;
    const startsWithCaretContainer = (node) => isText$2(node) && node.data[0] === ZWSP$1;
    const endsWithCaretContainer = (node) => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;
    const createZwsp = (node) => {
      var _a;
      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;
      return doc.createTextNode(ZWSP$1);
    };
    const insertBefore2 = (node) => {
      var _a;
      if (isText$2(node.previousSibling)) {
        if (endsWithCaretContainer(node.previousSibling)) {
          return node.previousSibling;
        } else {
          node.previousSibling.appendData(ZWSP$1);
          return node.previousSibling;
        }
      } else if (isText$2(node)) {
        if (startsWithCaretContainer(node)) {
          return node;
        } else {
          node.insertData(0, ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);
        return newNode;
      }
    };
    const insertAfter2 = (node) => {
      var _a, _b;
      if (isText$2(node.nextSibling)) {
        if (startsWithCaretContainer(node.nextSibling)) {
          return node.nextSibling;
        } else {
          node.nextSibling.insertData(0, ZWSP$1);
          return node.nextSibling;
        }
      } else if (isText$2(node)) {
        if (endsWithCaretContainer(node)) {
          return node;
        } else {
          node.appendData(ZWSP$1);
          return node;
        }
      } else {
        const newNode = createZwsp(node);
        if (node.nextSibling) {
          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);
        } else {
          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);
        }
        return newNode;
      }
    };
    const insertInline = (before2, node) => before2 ? insertBefore2(node) : insertAfter2(node);
    const insertInlineBefore = curry(insertInline, true);
    const insertInlineAfter = curry(insertInline, false);
    const insertInlinePos = (pos, before2) => {
      if (isText$a(pos.container())) {
        return insertInline(before2, pos.container());
      } else {
        return insertInline(before2, pos.getNode());
      }
    };
    const isPosCaretContainer = (pos, caret) => {
      const caretNode = caret.get();
      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);
    };
    const renderCaret = (caret, location2) => location2.fold((element) => {
      remove$4(caret.get());
      const text3 = insertInlineBefore(element);
      caret.set(text3);
      return Optional.some(CaretPosition(text3, text3.length - 1));
    }, (element) => firstPositionIn(element).map((pos) => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$4(caret.get());
        const text3 = insertInlinePos(pos, true);
        caret.set(text3);
        return CaretPosition(text3, 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, 1);
      }
    }), (element) => lastPositionIn(element).map((pos) => {
      if (!isPosCaretContainer(pos, caret)) {
        remove$4(caret.get());
        const text3 = insertInlinePos(pos, false);
        caret.set(text3);
        return CaretPosition(text3, text3.length - 1);
      } else {
        const node = caret.get();
        return CaretPosition(node, node.length - 1);
      }
    }), (element) => {
      remove$4(caret.get());
      const text3 = insertInlineAfter(element);
      caret.set(text3);
      return Optional.some(CaretPosition(text3, 1));
    });
    const evaluateUntil = (fns, args) => {
      for (let i = 0; i < fns.length; i++) {
        const result = fns[i].apply(null, args);
        if (result.isSome()) {
          return result;
        }
      }
      return Optional.none();
    };
    const Location = Adt.generate([
      { before: ["element"] },
      { start: ["element"] },
      { end: ["element"] },
      { after: ["element"] }
    ]);
    const rescope$1 = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const before = (isInlineTarget2, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget2, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map((inline) => Location.before(inline)), Optional.none);
    };
    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;
    const findInsideRootInline = (isInlineTarget2, rootNode, pos) => findRootInline(isInlineTarget2, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));
    const start$1 = (isInlineTarget2, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind((inline) => {
        const prevPos = prevPosition(inline, nPos);
        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();
      });
    };
    const end2 = (isInlineTarget2, rootNode, pos) => {
      const nPos = normalizeForwards(pos);
      return findInsideRootInline(isInlineTarget2, rootNode, nPos).bind((inline) => {
        const nextPos = nextPosition(inline, nPos);
        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();
      });
    };
    const after = (isInlineTarget2, rootNode, pos) => {
      const nPos = normalizeBackwards(pos);
      const scope = rescope$1(rootNode, nPos.container());
      return findRootInline(isInlineTarget2, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget2, scope)).map((inline) => Location.after(inline)), Optional.none);
    };
    const isValidLocation = (location2) => !isRtl(getElement2(location2));
    const readLocation = (isInlineTarget2, rootNode, pos) => {
      const location2 = evaluateUntil([
        before,
        start$1,
        end2,
        after
      ], [
        isInlineTarget2,
        rootNode,
        pos
      ]);
      return location2.filter(isValidLocation);
    };
    const getElement2 = (location2) => location2.fold(identity, identity, identity, identity);
    const getName = (location2) => location2.fold(constant("before"), constant("start"), constant("end"), constant("after"));
    const outside = (location2) => location2.fold(Location.before, Location.before, Location.after, Location.after);
    const inside = (location2) => location2.fold(Location.start, Location.start, Location.end, Location.end);
    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement2(location1) === getElement2(location2);
    const betweenInlines = (forward, isInlineTarget2, rootNode, from2, to2, location2) => lift2(findRootInline(isInlineTarget2, rootNode, from2), findRootInline(isInlineTarget2, rootNode, to2), (fromInline, toInline) => {
      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {
        return Location.after(forward ? fromInline : toInline);
      } else {
        return location2;
      }
    }).getOr(location2);
    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, (fromLocation2) => !isEq(fromLocation2, toLocation));
    const findLocationTraverse = (forward, isInlineTarget2, rootNode, fromLocation, pos) => {
      const from2 = normalizePosition(forward, pos);
      const to2 = fromPosition(forward, rootNode, from2).map(curry(normalizePosition, forward));
      const location2 = to2.fold(() => fromLocation.map(outside), (to3) => readLocation(isInlineTarget2, rootNode, to3).map(curry(betweenInlines, forward, isInlineTarget2, rootNode, from2, to3)).filter(curry(skipNoMovement, fromLocation)));
      return location2.filter(isValidLocation);
    };
    const findLocationSimple = (forward, location2) => {
      if (forward) {
        return location2.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);
      } else {
        return location2.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));
      }
    };
    const findLocation$1 = (forward, isInlineTarget2, rootNode, pos) => {
      const from2 = normalizePosition(forward, pos);
      const fromLocation = readLocation(isInlineTarget2, rootNode, from2);
      return readLocation(isInlineTarget2, rootNode, from2).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget2, rootNode, fromLocation, pos));
    };
    const hasSelectionModifyApi = (editor) => {
      return isFunction2(editor.selection.getSel().modify);
    };
    const moveRel = (forward, selection, pos) => {
      const delta = forward ? 1 : -1;
      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());
      selection.getSel().modify("move", forward ? "forward" : "backward", "word");
      return true;
    };
    const moveByWord = (forward, editor) => {
      const rng = editor.selection.getRng();
      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      if (!hasSelectionModifyApi(editor)) {
        return false;
      } else if (forward && isBeforeInline(pos)) {
        return moveRel(true, editor.selection, pos);
      } else if (!forward && isAfterInline(pos)) {
        return moveRel(false, editor.selection, pos);
      } else {
        return false;
      }
    };
    var BreakType;
    (function(BreakType2) {
      BreakType2[BreakType2["Br"] = 0] = "Br";
      BreakType2[BreakType2["Block"] = 1] = "Block";
      BreakType2[BreakType2["Wrap"] = 2] = "Wrap";
      BreakType2[BreakType2["Eol"] = 3] = "Eol";
    })(BreakType || (BreakType = {}));
    const flip2 = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;
    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);
    const getBreakType = (scope, direction, currentPos, nextPos) => {
      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {
        return BreakType.Br;
      } else if (isInSameBlock(currentPos, nextPos) === false) {
        return BreakType.Block;
      } else {
        return BreakType.Wrap;
      }
    };
    const getPositionsUntil = (predicate, direction, scope, start3) => {
      const caretWalker = CaretWalker(scope);
      let currentPos = start3;
      const positions = [];
      while (currentPos) {
        const nextPos = walk$1(direction, caretWalker, currentPos);
        if (!nextPos) {
          break;
        }
        if (isBr$6(nextPos.getNode(false))) {
          if (direction === HDirection.Forwards) {
            return {
              positions: flip2(direction, positions).concat([nextPos]),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          } else {
            return {
              positions: flip2(direction, positions),
              breakType: BreakType.Br,
              breakAt: Optional.some(nextPos)
            };
          }
        }
        if (!nextPos.isVisible()) {
          currentPos = nextPos;
          continue;
        }
        if (predicate(currentPos, nextPos)) {
          const breakType = getBreakType(scope, direction, currentPos, nextPos);
          return {
            positions: flip2(direction, positions),
            breakType,
            breakAt: Optional.some(nextPos)
          };
        }
        positions.push(nextPos);
        currentPos = nextPos;
      }
      return {
        positions: flip2(direction, positions),
        breakType: BreakType.Eol,
        breakAt: Optional.none()
      };
    };
    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start3) => getPositionsUntilBreak(scope, start3).breakAt.map((pos) => {
      const positions = getPositionsUntilBreak(scope, pos).positions;
      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);
    }).getOr([]);
    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), (lastPos) => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {
      const lastDist = Math.abs(x - lastRect.left);
      const newDist = Math.abs(x - newRect.left);
      return newDist <= lastDist ? newPos : lastPos;
    }).or(acc)), Optional.none());
    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind((targetRect) => findClosestHorizontalPositionFromPoint(positions, targetRect.left));
    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);
    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);
    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);
    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);
    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();
    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();
    const getFirstLinePositions = (scope) => firstPositionIn(scope).map((pos) => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);
    const getLastLinePositions = (scope) => lastPositionIn(scope).map((pos) => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);
    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);
    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);
    const isContentEditableFalse$4 = isContentEditableFalse$b;
    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isNodeClientRect = (rect) => hasNonNullableKey(rect, "node");
    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {
      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));
      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));
      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {
        return clientRect;
      }
      if (newDistance < oldDistance) {
        return clientRect;
      }
      return oldClientRect;
    });
    const getNodeClientRects = (node) => {
      const toArrayWithNode = (clientRects) => {
        return map$3(clientRects, (rect) => {
          const clientRect = clone$1(rect);
          clientRect.node = node;
          return clientRect;
        });
      };
      if (isElement$6(node)) {
        return toArrayWithNode(node.getClientRects());
      } else if (isText$a(node)) {
        const rng = node.ownerDocument.createRange();
        rng.setStart(node, 0);
        rng.setEnd(node, node.data.length);
        return toArrayWithNode(rng.getClientRects());
      } else {
        return [];
      }
    };
    const getClientRects = (nodes) => bind$3(nodes, getNodeClientRects);
    var VDirection;
    (function(VDirection2) {
      VDirection2[VDirection2["Up"] = -1] = "Up";
      VDirection2[VDirection2["Down"] = 1] = "Down";
    })(VDirection || (VDirection = {}));
    const findUntil = (direction, root2, predicateFn, node) => {
      let currentNode = node;
      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root2)) {
        if (predicateFn(currentNode)) {
          return;
        }
      }
    };
    const walkUntil = (direction, isAboveFn, isBeflowFn, root2, predicateFn, caretPosition) => {
      let line = 0;
      const result = [];
      const add2 = (node2) => {
        let clientRects = getClientRects([node2]);
        if (direction === -1) {
          clientRects = clientRects.reverse();
        }
        for (let i = 0; i < clientRects.length; i++) {
          const clientRect = clientRects[i];
          if (isBeflowFn(clientRect, targetClientRect)) {
            continue;
          }
          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {
            line++;
          }
          clientRect.line = line;
          if (predicateFn(clientRect)) {
            return true;
          }
          result.push(clientRect);
        }
        return false;
      };
      const targetClientRect = last$2(caretPosition.getClientRects());
      if (!targetClientRect) {
        return result;
      }
      const node = caretPosition.getNode();
      if (node) {
        add2(node);
        findUntil(direction, root2, add2, node);
      }
      return result;
    };
    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;
    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;
    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);
    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);
    const getLastClientRect = (caretPosition) => {
      return last$2(caretPosition.getClientRects());
    };
    const positionsUntil = (direction, root2, predicateFn, node) => {
      const caretWalker = CaretWalker(root2);
      let walkFn;
      let isBelowFn;
      let isAboveFn;
      let caretPosition;
      const result = [];
      let line = 0;
      if (direction === 1) {
        walkFn = caretWalker.next;
        isBelowFn = isBelow$1;
        isAboveFn = isAbove$1;
        caretPosition = CaretPosition.after(node);
      } else {
        walkFn = caretWalker.prev;
        isBelowFn = isAbove$1;
        isAboveFn = isBelow$1;
        caretPosition = CaretPosition.before(node);
      }
      const targetClientRect = getLastClientRect(caretPosition);
      do {
        if (!caretPosition.isVisible()) {
          continue;
        }
        const rect = getLastClientRect(caretPosition);
        if (isAboveFn(rect, targetClientRect)) {
          continue;
        }
        if (result.length > 0 && isBelowFn(rect, last$2(result))) {
          line++;
        }
        const clientRect = clone$1(rect);
        clientRect.position = caretPosition;
        clientRect.line = line;
        if (predicateFn(clientRect)) {
          return result;
        }
        result.push(clientRect);
      } while (caretPosition = walkFn(caretPosition));
      return result;
    };
    const isAboveLine = (lineNumber) => (clientRect) => aboveLineNumber(lineNumber, clientRect);
    const isLine = (lineNumber) => (clientRect) => isLineNumber(lineNumber, clientRect);
    const moveToRange = (editor, rng) => {
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, editor.selection.getRng());
    };
    const renderRangeCaretOpt = (editor, range2, scrollIntoView) => Optional.some(renderRangeCaret(editor, range2, scrollIntoView));
    const moveHorizontally = (editor, direction, range2, isBefore, isAfter, isElement3) => {
      const forwards = direction === HDirection.Forwards;
      const caretWalker = CaretWalker(editor.getBody());
      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);
      const isBeforeFn = forwards ? isBefore : isAfter;
      if (!range2.collapsed) {
        const node = getSelectedNode(range2);
        if (isElement3(node)) {
          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);
        } else if (isCefAtEdgeSelected(editor)) {
          const newRange = range2.cloneRange();
          newRange.collapse(direction === HDirection.Backwards);
          return Optional.from(newRange);
        }
      }
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      if (isBeforeFn(caretPosition)) {
        return selectNode(editor, caretPosition.getNode(!forwards));
      }
      let nextCaretPosition = getNextPosFn(caretPosition);
      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range2);
      if (!nextCaretPosition) {
        return rangeIsInContainerBlock ? Optional.some(range2) : Optional.none();
      } else {
        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);
      }
      if (isBeforeFn(nextCaretPosition)) {
        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);
      }
      const peekCaretPosition = getNextPosFn(nextCaretPosition);
      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {
        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {
          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);
        }
      }
      if (rangeIsInContainerBlock) {
        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);
      }
      return Optional.none();
    };
    const moveVertically = (editor, direction, range2, isBefore, isAfter, isElement3) => {
      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range2);
      const caretClientRect = last$2(caretPosition.getClientRects());
      const forwards = direction === VDirection.Down;
      const root2 = editor.getBody();
      if (!caretClientRect) {
        return Optional.none();
      }
      if (isCefAtEdgeSelected(editor)) {
        const caretPosition2 = forwards ? CaretPosition.fromRangeEnd(range2) : CaretPosition.fromRangeStart(range2);
        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;
        return getClosestFn(root2, caretPosition2).orThunk(() => Optional.from(caretPosition2)).map((pos) => pos.toRange());
      }
      const walkerFn = forwards ? downUntil : upUntil;
      const linePositions = walkerFn(root2, isAboveLine(1), caretPosition);
      const nextLinePositions = filter$5(linePositions, isLine(1));
      const clientX = caretClientRect.left;
      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);
      if (nextLineRect && isElement3(nextLineRect.node)) {
        const dist1 = Math.abs(clientX - nextLineRect.left);
        const dist2 = Math.abs(clientX - nextLineRect.right);
        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);
      }
      let currentNode;
      if (isBefore(caretPosition)) {
        currentNode = caretPosition.getNode();
      } else if (isAfter(caretPosition)) {
        currentNode = caretPosition.getNode(true);
      } else {
        currentNode = getSelectedNode(range2);
      }
      if (currentNode) {
        const caretPositions = positionsUntil(direction, root2, isAboveLine(1), currentNode);
        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));
        if (closestNextLineRect) {
          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);
        }
      }
      if (nextLinePositions.length === 0) {
        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map((pos) => renderRangeCaret(editor, pos.toRange(), false));
      }
      return Optional.none();
    };
    const getLineEndPoint = (editor, forward) => {
      const rng = editor.selection.getRng();
      const from2 = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
      const host = getEditingHost(from2.container(), editor.getBody());
      if (forward) {
        const lineInfo = getPositionsUntilNextLine(host, from2);
        return last$3(lineInfo.positions);
      } else {
        const lineInfo = getPositionsUntilPreviousLine(host, from2);
        return head(lineInfo.positions);
      }
    };
    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists((pos) => {
      editor.selection.setRng(pos.toRange());
      return true;
    });
    const setCaretPosition = (editor, pos) => {
      const rng = editor.dom.createRng();
      rng.setStart(pos.container(), pos.offset());
      rng.setEnd(pos.container(), pos.offset());
      editor.selection.setRng(rng);
    };
    const setSelected = (state2, elm) => {
      if (state2) {
        elm.setAttribute("data-mce-selected", "inline-boundary");
      } else {
        elm.removeAttribute("data-mce-selected");
      }
    };
    const renderCaretLocation = (editor, caret, location2) => renderCaret(caret, location2).map((pos) => {
      setCaretPosition(editor, pos);
      return location2;
    });
    const getPositionFromRange = (range2, root2, forward) => {
      const start3 = CaretPosition.fromRangeStart(range2);
      if (range2.collapsed) {
        return start3;
      } else {
        const end3 = CaretPosition.fromRangeEnd(range2);
        return forward ? prevPosition(root2, end3).getOr(end3) : nextPosition(root2, start3).getOr(start3);
      }
    };
    const findLocation = (editor, caret, forward) => {
      const rootNode = editor.getBody();
      const from2 = getPositionFromRange(editor.selection.getRng(), rootNode, forward);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const location2 = findLocation$1(forward, isInlineTarget$1, rootNode, from2);
      return location2.bind((location3) => renderCaretLocation(editor, caret, location3));
    };
    const toggleInlines = (isInlineTarget2, dom2, elms) => {
      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom2.getRoot()), '*[data-mce-selected="inline-boundary"]'), (e) => e.dom);
      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget2);
      const targetInlines = filter$5(elms, isInlineTarget2);
      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));
      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));
    };
    const safeRemoveCaretContainer = (editor, caret) => {
      const caretValue = caret.get();
      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {
        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {
          setCaretPosition(editor, removeAndReposition(caretValue, pos));
          caret.set(null);
        }
      }
    };
    const renderInsideInlineCaret = (isInlineTarget2, editor, caret, elms) => {
      if (editor.selection.isCollapsed()) {
        const inlines = filter$5(elms, isInlineTarget2);
        each$e(inlines, (_inline) => {
          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
          readLocation(isInlineTarget2, editor.getBody(), pos).bind((location2) => renderCaretLocation(editor, caret, location2));
        });
      }
    };
    const move$2 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;
    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;
    const setupSelectedState = (editor) => {
      const caret = Cell(null);
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.on("NodeChange", (e) => {
        if (isInlineBoundariesEnabled(editor)) {
          toggleInlines(isInlineTarget$1, editor.dom, e.parents);
          safeRemoveCaretContainer(editor, caret);
          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);
        }
      });
      return caret;
    };
    const moveNextWord = curry(moveWord, true);
    const movePrevWord = curry(moveWord, false);
    const moveToLineEndPoint$2 = (editor, forward, caret) => {
      if (isInlineBoundariesEnabled(editor)) {
        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {
          const rng = editor.selection.getRng();
          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);
        });
        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists((loc) => {
          const outsideLoc = outside(loc);
          return renderCaret(caret, outsideLoc).exists((pos) => {
            setCaretPosition(editor, pos);
            return true;
          });
        });
      } else {
        return false;
      }
    };
    const rangeFromPositions = (from2, to2) => {
      const range2 = document.createRange();
      range2.setStart(from2.container(), from2.offset());
      range2.setEnd(to2.container(), to2.offset());
      return range2;
    };
    const hasOnlyTwoOrLessPositionsLeft = (elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {
      const normalizedFirstPos = normalizePosition(true, firstPos);
      const normalizedLastPos = normalizePosition(false, lastPos);
      return nextPosition(elm, normalizedFirstPos).forall((pos) => pos.isEqual(normalizedLastPos));
    }).getOr(true);
    const setCaretLocation = (editor, caret) => (location2) => renderCaret(caret, location2).map((pos) => () => setCaretPosition(editor, pos));
    const deleteFromTo = (editor, caret, from2, to2) => {
      const rootNode = editor.getBody();
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      editor.undoManager.ignore(() => {
        editor.selection.setRng(rangeFromPositions(from2, to2));
        execNativeDeleteCommand(editor);
        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);
      });
      editor.nodeChanged();
    };
    const rescope = (rootNode, node) => {
      const parentBlock = getParentBlock$3(node, rootNode);
      return parentBlock ? parentBlock : rootNode;
    };
    const backspaceDeleteCollapsed = (editor, caret, forward, from2) => {
      const rootNode = rescope(editor.getBody(), from2.container());
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const fromLocation = readLocation(isInlineTarget$1, rootNode, from2);
      const location2 = fromLocation.bind((location3) => {
        if (forward) {
          return location3.fold(constant(Optional.some(inside(location3))), Optional.none, constant(Optional.some(outside(location3))), Optional.none);
        } else {
          return location3.fold(Optional.none, constant(Optional.some(outside(location3))), Optional.none, constant(Optional.some(inside(location3))));
        }
      });
      return location2.map(setCaretLocation(editor, caret)).getOrThunk(() => {
        const toPosition = navigate(forward, rootNode, from2);
        const toLocation = toPosition.bind((pos) => readLocation(isInlineTarget$1, rootNode, pos));
        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from2).bind((elm) => {
          if (hasOnlyTwoOrLessPositionsLeft(elm)) {
            return Optional.some(() => {
              deleteElement$2(editor, forward, SugarElement.fromDom(elm));
            });
          } else {
            return Optional.none();
          }
        })).getOrThunk(() => toLocation.bind(() => toPosition.map((to2) => {
          return () => {
            if (forward) {
              deleteFromTo(editor, caret, from2, to2);
            } else {
              deleteFromTo(editor, caret, to2, from2);
            }
          };
        })));
      });
    };
    const backspaceDelete$3 = (editor, caret, forward) => {
      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {
        const from2 = CaretPosition.fromRangeStart(editor.selection.getRng());
        return backspaceDeleteCollapsed(editor, caret, forward, from2);
      }
      return Optional.none();
    };
    const hasMultipleChildren = (elm) => childNodesCount(elm) > 1;
    const getParentsUntil = (editor, pred) => {
      const rootElm = SugarElement.fromDom(editor.getBody());
      const startElm = SugarElement.fromDom(editor.selection.getStart());
      const parents2 = parentsAndSelf(startElm, rootElm);
      return findIndex$2(parents2, pred).fold(constant(parents2), (index) => parents2.slice(0, index));
    };
    const getParentInlinesUntilMultichildInline = (editor) => getParentsUntil(editor, (elm) => isBlock$2(elm) || hasMultipleChildren(elm));
    const getParentInlines = (editor) => getParentsUntil(editor, isBlock$2);
    const getFormatNodes = (editor, parentInlines) => {
      const isFormatElement$1 = curry(isFormatElement, editor);
      return bind$3(parentInlines, (elm) => isFormatElement$1(elm) ? [elm.dom] : []);
    };
    const getFormatNodesAtStart = (editor) => {
      const parentInlines = getParentInlines(editor);
      return getFormatNodes(editor, parentInlines);
    };
    const deleteLastPosition = (forward, editor, target, parentInlines) => {
      const formatNodes = getFormatNodes(editor, parentInlines);
      if (formatNodes.length === 0) {
        deleteElement$2(editor, forward, target);
      } else {
        const pos = replaceWithCaretFormat(target.dom, formatNodes);
        editor.selection.setRng(pos.toRange());
      }
    };
    const deleteCaret$1 = (editor, forward) => {
      const parentInlines = getParentInlinesUntilMultichildInline(editor);
      return last$3(parentInlines).bind((target) => {
        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());
        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {
          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));
        } else {
          return Optional.none();
        }
      });
    };
    const isBrInEmptyElement = (editor, elm) => {
      const parentElm = elm.parentElement;
      return isBr$6(elm) && !isNull2(parentElm) && editor.dom.isEmpty(parentElm);
    };
    const isEmptyCaret = (elm) => isEmptyCaretFormatElement(SugarElement.fromDom(elm));
    const createCaretFormatAtStart = (editor, formatNodes) => {
      const startElm = editor.selection.getStart();
      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor, formatNodes);
      editor.selection.setRng(pos.toRange());
    };
    const updateCaretFormat = (editor, updateFormats) => {
      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));
      if (missingFormats.length > 0) {
        createCaretFormatAtStart(editor, missingFormats);
      }
    };
    const rangeStartsAtTextContainer = (rng) => isText$a(rng.startContainer);
    const rangeStartsAtStartOfTextContainer = (rng) => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);
    const rangeStartParentIsFormatElement = (editor, rng) => {
      const startParent = rng.startContainer.parentElement;
      return !isNull2(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));
    };
    const rangeStartAndEndHaveSameParent = (rng) => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      return !isNull2(startParent) && !isNull2(endParent) && startParent.isEqualNode(endParent);
    };
    const rangeEndsAtEndOfEndContainer = (rng) => {
      const endContainer = rng.endContainer;
      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);
    };
    const rangeEndsAtEndOfStartContainer = (rng) => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);
    const rangeEndsAfterEndOfStartContainer = (rng) => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);
    const rangeEndsAtOrAfterEndOfStartContainer = (rng) => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);
    const requiresDeleteRangeOverride = (editor) => {
      const rng = editor.selection.getRng();
      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);
    };
    const deleteRange$1 = (editor) => {
      if (requiresDeleteRangeOverride(editor)) {
        const formatNodes = getFormatNodesAtStart(editor);
        return Optional.some(() => {
          execNativeDeleteCommand(editor);
          updateCaretFormat(editor, formatNodes);
        });
      } else {
        return Optional.none();
      }
    };
    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);
    const hasAncestorInlineCaret = (elm) => ancestor$1(elm, (node) => isCaretNode(node.dom), isBlock$2);
    const hasAncestorInlineCaretAtStart = (editor) => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()));
    const requiresRefreshCaretOverride = (editor) => {
      const rng = editor.selection.getRng();
      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);
    };
    const refreshCaret = (editor) => {
      if (requiresRefreshCaretOverride(editor)) {
        createCaretFormatAtStart(editor, []);
      }
      return true;
    };
    const deleteElement = (editor, forward, element) => {
      if (isNonNullable(element)) {
        return Optional.some(() => {
          editor._selectionOverrides.hideFakeCaret();
          deleteElement$2(editor, forward, SugarElement.fromDom(element));
        });
      } else {
        return Optional.none();
      }
    };
    const deleteCaret = (editor, forward) => {
      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());
      if (isNearMedia(fromPos)) {
        return deleteElement(editor, forward, fromPos.getNode(!forward));
      } else {
        return Optional.from(normalizePosition(forward, fromPos)).filter((pos) => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind((pos) => deleteElement(editor, forward, pos.getNode(!forward)));
      }
    };
    const deleteRange = (editor, forward) => {
      const selectedNode = editor.selection.getNode();
      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();
    };
    const backspaceDelete$1 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);
    const isEditable = (target) => closest$4(target, (elm) => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists((elm) => isContentEditableTrue$3(elm.dom));
    const parseIndentValue = (value2) => toInt2(value2 !== null && value2 !== void 0 ? value2 : "").getOr(0);
    const getIndentStyleName = (useMargin, element) => {
      const indentStyleName = useMargin || isTable$1(element) ? "margin" : "padding";
      const suffix = get$7(element, "direction") === "rtl" ? "-right" : "-left";
      return indentStyleName + suffix;
    };
    const indentElement = (dom2, command, useMargin, value2, unit, element) => {
      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));
      const parsedValue = parseIndentValue(dom2.getStyle(element, indentStyleName));
      if (command === "outdent") {
        const styleValue = Math.max(0, parsedValue - value2);
        dom2.setStyle(element, indentStyleName, styleValue ? styleValue + unit : "");
      } else {
        const styleValue = parsedValue + value2 + unit;
        dom2.setStyle(element, indentStyleName, styleValue);
      }
    };
    const validateBlocks = (editor, blocks2) => forall(blocks2, (block) => {
      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);
      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);
      const contentEditable = editor.dom.getContentEditable(block.dom);
      return contentEditable !== "false" && intentValue > 0;
    });
    const canOutdent = (editor) => {
      const blocks2 = getBlocksToIndent(editor);
      return !editor.mode.isReadOnly() && (blocks2.length > 1 || validateBlocks(editor, blocks2));
    };
    const isListComponent = (el) => isList(el) || isListItem$1(el);
    const parentIsListComponent = (el) => parent(el).exists(isListComponent);
    const getBlocksToIndent = (editor) => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), (el) => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));
    const handle = (editor, command) => {
      var _a, _b;
      const { dom: dom2 } = editor;
      const indentation = getIndentation(editor);
      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : "px";
      const indentValue = parseIndentValue(indentation);
      const useMargin = shouldIndentUseMargin(editor);
      each$e(getBlocksToIndent(editor), (block) => {
        indentElement(dom2, command, useMargin, indentValue, indentUnit, block.dom);
      });
    };
    const indent = (editor) => handle(editor, "indent");
    const outdent = (editor) => handle(editor, "outdent");
    const backspaceDelete = (editor) => {
      if (editor.selection.isCollapsed() && canOutdent(editor)) {
        const dom2 = editor.dom;
        const rng = editor.selection.getRng();
        const pos = CaretPosition.fromRangeStart(rng);
        const block = dom2.getParent(rng.startContainer, dom2.isBlock);
        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos)) {
          return Optional.some(() => outdent(editor));
        }
      }
      return Optional.none();
    };
    const findAction = (editor, caret, forward) => findMap([
      backspaceDelete,
      backspaceDelete$5,
      backspaceDelete$6,
      (editor2, forward2) => backspaceDelete$3(editor2, caret, forward2),
      backspaceDelete$8,
      backspaceDelete$9,
      backspaceDelete$4,
      backspaceDelete$1,
      backspaceDelete$7,
      backspaceDelete$2
    ], (item2) => item2(editor, forward)).filter((_2) => editor.selection.isEditable());
    const deleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, false);
      result.fold(() => {
        execNativeDeleteCommand(editor);
        paddEmptyBody(editor);
      }, call);
    };
    const forwardDeleteCommand = (editor, caret) => {
      const result = findAction(editor, caret, true);
      result.fold(() => execNativeForwardDeleteCommand(editor), call);
    };
    const setup$p = (editor, caret) => {
      editor.addCommand("delete", () => {
        deleteCommand(editor, caret);
      });
      editor.addCommand("forwardDelete", () => {
        forwardDeleteCommand(editor, caret);
      });
    };
    const SIGNIFICANT_MOVE = 5;
    const LONGPRESS_DELAY = 400;
    const getTouch = (event) => {
      if (event.touches === void 0 || event.touches.length !== 1) {
        return Optional.none();
      }
      return Optional.some(event.touches[0]);
    };
    const isFarEnough = (touch, data3) => {
      const distX = Math.abs(touch.clientX - data3.x);
      const distY = Math.abs(touch.clientY - data3.y);
      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    };
    const setup$o = (editor) => {
      const startData = value$2();
      const longpressFired = Cell(false);
      const debounceLongpress = last$1((e) => {
        editor.dispatch("longpress", {
          ...e,
          type: "longpress"
        });
        longpressFired.set(true);
      }, LONGPRESS_DELAY);
      editor.on("touchstart", (e) => {
        getTouch(e).each((touch) => {
          debounceLongpress.cancel();
          const data3 = {
            x: touch.clientX,
            y: touch.clientY,
            target: e.target
          };
          debounceLongpress.throttle(e);
          longpressFired.set(false);
          startData.set(data3);
        });
      }, true);
      editor.on("touchmove", (e) => {
        debounceLongpress.cancel();
        getTouch(e).each((touch) => {
          startData.on((data3) => {
            if (isFarEnough(touch, data3)) {
              startData.clear();
              longpressFired.set(false);
              editor.dispatch("longpresscancel");
            }
          });
        });
      }, true);
      editor.on("touchend touchcancel", (e) => {
        debounceLongpress.cancel();
        if (e.type === "touchcancel") {
          return;
        }
        startData.get().filter((data3) => data3.target.isEqualNode(e.target)).each(() => {
          if (longpressFired.get()) {
            e.preventDefault();
          } else {
            editor.dispatch("tap", {
              ...e,
              type: "tap"
            });
          }
        });
      }, true);
    };
    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);
    const isValidTarget = (schema, node) => {
      if (isText$a(node)) {
        return true;
      } else if (isElement$6(node)) {
        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node);
      } else {
        return false;
      }
    };
    const hasBlockParent = (blockElements, root2, node) => {
      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root2)), (elm) => {
        return isBlockElement(blockElements, elm.dom);
      });
    };
    const shouldRemoveTextNode = (blockElements, node) => {
      if (isText$a(node)) {
        if (node.data.length === 0) {
          return true;
        } else if (/^\s+$/.test(node.data) && (!node.nextSibling || isBlockElement(blockElements, node.nextSibling))) {
          return true;
        }
      }
      return false;
    };
    const createRootBlock = (editor) => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
    const addRootBlocks = (editor) => {
      const dom2 = editor.dom, selection = editor.selection;
      const schema = editor.schema;
      const blockElements = schema.getBlockElements();
      const startNode = selection.getStart();
      const rootNode = editor.getBody();
      let rootBlockNode;
      let tempNode;
      let wrapped = false;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!startNode || !isElement$6(startNode)) {
        return;
      }
      const rootNodeName = rootNode.nodeName.toLowerCase();
      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {
        return;
      }
      const rng = selection.getRng();
      const { startContainer, startOffset, endContainer, endOffset } = rng;
      const restoreSelection = hasFocus(editor);
      let node = rootNode.firstChild;
      while (node) {
        if (isElement$6(node)) {
          updateElement(schema, node);
        }
        if (isValidTarget(schema, node)) {
          if (shouldRemoveTextNode(blockElements, node)) {
            tempNode = node;
            node = node.nextSibling;
            dom2.remove(tempNode);
            continue;
          }
          if (!rootBlockNode) {
            rootBlockNode = createRootBlock(editor);
            rootNode.insertBefore(rootBlockNode, node);
            wrapped = true;
          }
          tempNode = node;
          node = node.nextSibling;
          rootBlockNode.appendChild(tempNode);
        } else {
          rootBlockNode = null;
          node = node.nextSibling;
        }
      }
      if (wrapped && restoreSelection) {
        rng.setStart(startContainer, startOffset);
        rng.setEnd(endContainer, endOffset);
        selection.setRng(rng);
        editor.nodeChanged();
      }
    };
    const insertEmptyLine = (editor, root2, insertBlock2) => {
      const block = SugarElement.fromDom(createRootBlock(editor));
      const br = createPaddingBr();
      append$1(block, br);
      insertBlock2(root2, block);
      const rng = document.createRange();
      rng.setStartBefore(br.dom);
      rng.setEndBefore(br.dom);
      return rng;
    };
    const setup$n = (editor) => {
      editor.on("NodeChange", curry(addRootBlocks, editor));
    };
    const hasClass = (checkClassName) => (node) => (" " + node.attr("class") + " ").indexOf(checkClassName) !== -1;
    const replaceMatchWithSpan = (editor, content, cls) => {
      return function(match2) {
        const args = arguments, index = args[args.length - 2];
        const prevChar = index > 0 ? content.charAt(index - 1) : "";
        if (prevChar === '"') {
          return match2;
        }
        if (prevChar === ">") {
          const findStartTagIndex = content.lastIndexOf("<", index);
          if (findStartTagIndex !== -1) {
            const tagHtml = content.substring(findStartTagIndex, index);
            if (tagHtml.indexOf('contenteditable="false"') !== -1) {
              return match2;
            }
          }
        }
        return '<span class="' + cls + '" data-mce-content="' + editor.dom.encode(args[0]) + '">' + editor.dom.encode(typeof args[1] === "string" ? args[1] : args[0]) + "</span>";
      };
    };
    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {
      let i = nonEditableRegExps.length, content = e.content;
      if (e.format === "raw") {
        return;
      }
      while (i--) {
        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));
      }
      e.content = content;
    };
    const setup$m = (editor) => {
      const contentEditableAttrName = "contenteditable";
      const editClass = " " + Tools.trim(getEditableClass(editor)) + " ";
      const nonEditClass = " " + Tools.trim(getNonEditableClass(editor)) + " ";
      const hasEditClass = hasClass(editClass);
      const hasNonEditClass = hasClass(nonEditClass);
      const nonEditableRegExps = getNonEditableRegExps(editor);
      if (nonEditableRegExps.length > 0) {
        editor.on("BeforeSetContent", (e) => {
          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);
        });
      }
      editor.parser.addAttributeFilter("class", (nodes) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (hasEditClass(node)) {
            node.attr(contentEditableAttrName, "true");
          } else if (hasNonEditClass(node)) {
            node.attr(contentEditableAttrName, "false");
          }
        }
      });
      editor.serializer.addAttributeFilter(contentEditableAttrName, (nodes) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          if (!hasEditClass(node) && !hasNonEditClass(node)) {
            continue;
          }
          if (nonEditableRegExps.length > 0 && node.attr("data-mce-content")) {
            node.name = "#text";
            node.type = 3;
            node.raw = true;
            node.value = node.attr("data-mce-content");
          } else {
            node.attr(contentEditableAttrName, null);
          }
        }
      });
    };
    const findBlockCaretContainer = (editor) => descendant(SugarElement.fromDom(editor.getBody()), "*[data-mce-caret]").map((elm) => elm.dom).getOrNull();
    const showBlockCaretContainer = (editor, blockCaretContainer) => {
      if (blockCaretContainer.hasAttribute("data-mce-caret")) {
        showCaretContainerBlock(blockCaretContainer);
        editor.selection.setRng(editor.selection.getRng());
        editor.selection.scrollIntoView(blockCaretContainer);
      }
    };
    const handleBlockContainer = (editor, e) => {
      const blockCaretContainer = findBlockCaretContainer(editor);
      if (!blockCaretContainer) {
        return;
      }
      if (e.type === "compositionstart") {
        e.preventDefault();
        e.stopPropagation();
        showBlockCaretContainer(editor, blockCaretContainer);
        return;
      }
      if (hasContent(blockCaretContainer)) {
        showBlockCaretContainer(editor, blockCaretContainer);
        editor.undoManager.add();
      }
    };
    const setup$l = (editor) => {
      editor.on("keyup compositionstart", curry(handleBlockContainer, editor));
    };
    const isContentEditableFalse$3 = isContentEditableFalse$b;
    const moveToCeFalseHorizontally = (direction, editor, range2) => moveHorizontally(editor, direction, range2, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);
    const moveToCeFalseVertically = (direction, editor, range2) => {
      const isBefore = (caretPosition) => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);
      const isAfter = (caretPosition) => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);
      return moveVertically(editor, direction, range2, isBefore, isAfter, isContentEditableFalse$3);
    };
    const createTextBlock = (editor) => {
      const textBlock = editor.dom.create(getForcedRootBlock(editor));
      textBlock.innerHTML = '<br data-mce-bogus="1">';
      return textBlock;
    };
    const exitPreBlock = (editor, direction, range2) => {
      const caretWalker = CaretWalker(editor.getBody());
      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);
      if (range2.collapsed) {
        const pre = editor.dom.getParent(range2.startContainer, "PRE");
        if (!pre) {
          return;
        }
        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range2));
        if (!caretPos) {
          const newBlock = SugarElement.fromDom(createTextBlock(editor));
          if (direction === 1) {
            after$4(SugarElement.fromDom(pre), newBlock);
          } else {
            before$3(SugarElement.fromDom(pre), newBlock);
          }
          editor.selection.select(newBlock.dom, true);
          editor.selection.collapse();
        }
      }
    };
    const getHorizontalRange = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range2 = editor.selection.getRng();
      return moveToCeFalseHorizontally(direction, editor, range2).orThunk(() => {
        exitPreBlock(editor, direction, range2);
        return Optional.none();
      });
    };
    const getVerticalRange = (editor, down) => {
      const direction = down ? 1 : -1;
      const range2 = editor.selection.getRng();
      return moveToCeFalseVertically(direction, editor, range2).orThunk(() => {
        exitPreBlock(editor, direction, range2);
        return Optional.none();
      });
    };
    const moveH$2 = (editor, forward) => getHorizontalRange(editor, forward).exists((newRange) => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveV$3 = (editor, down) => getVerticalRange(editor, down).exists((newRange) => {
      moveToRange(editor, newRange);
      return true;
    });
    const moveToLineEndPoint$1 = (editor, forward) => {
      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;
      return moveToLineEndPoint$3(editor, forward, isCefPosition);
    };
    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map((pos) => {
      const rng = pos.toRange();
      const curRng = editor.selection.getRng();
      if (forward) {
        rng.setStart(curRng.startContainer, curRng.startOffset);
      } else {
        rng.setEnd(curRng.endContainer, curRng.endOffset);
      }
      return rng;
    }).exists((rng) => {
      moveToRange(editor, rng);
      return true;
    });
    const isTarget = (node) => contains$2(["figcaption"], name2(node));
    const getClosestTargetBlock = (pos, root2) => {
      const isRoot2 = curry(eq, root2);
      return closest$4(SugarElement.fromDom(pos.container()), isBlock$2, isRoot2).filter(isTarget);
    };
    const isAtFirstOrLastLine = (root2, forward, pos) => forward ? isAtLastLine(root2.dom, pos) : isAtFirstLine(root2.dom, pos);
    const moveCaretToNewEmptyLine = (editor, forward) => {
      const root2 = SugarElement.fromDom(editor.getBody());
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      return getClosestTargetBlock(pos, root2).exists(() => {
        if (isAtFirstOrLastLine(root2, forward, pos)) {
          const insertFn = forward ? append$1 : prepend;
          const rng = insertEmptyLine(editor, root2, insertFn);
          editor.selection.setRng(rng);
          return true;
        } else {
          return false;
        }
      });
    };
    const moveV$2 = (editor, forward) => {
      if (editor.selection.isCollapsed()) {
        return moveCaretToNewEmptyLine(editor, forward);
      } else {
        return false;
      }
    };
    const baseKeyPattern = {
      shiftKey: false,
      altKey: false,
      ctrlKey: false,
      metaKey: false,
      keyCode: 0
    };
    const defaultPatterns = (patterns) => map$3(patterns, (pattern) => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const defaultDelayedPatterns = (patterns) => map$3(patterns, (pattern) => ({
      ...baseKeyPattern,
      ...pattern
    }));
    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;
    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), (pattern) => matchesEvent(pattern, evt) ? [pattern] : []);
    const action = (f, ...x) => () => f.apply(null, x);
    const execute2 = (patterns, evt) => find$2(match$1(patterns, evt), (pattern) => pattern.action());
    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), (pattern) => pattern.action());
    const moveH$1 = (editor, forward) => {
      const direction = forward ? HDirection.Forwards : HDirection.Backwards;
      const range2 = editor.selection.getRng();
      return moveHorizontally(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveV$1 = (editor, down) => {
      const direction = down ? 1 : -1;
      const range2 = editor.selection.getRng();
      return moveVertically(editor, direction, range2, isBeforeMedia, isAfterMedia, isMedia$2).exists((newRange) => {
        moveToRange(editor, newRange);
        return true;
      });
    };
    const moveToLineEndPoint = (editor, forward) => {
      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;
      return moveToLineEndPoint$3(editor, forward, isNearMedia);
    };
    const adt = Adt.generate([
      { none: ["current"] },
      { first: ["current"] },
      {
        middle: [
          "current",
          "target"
        ]
      },
      { last: ["current"] }
    ]);
    const none = (current) => adt.none(current);
    const CellLocation = {
      ...adt,
      none
    };
    const firstLayer = (scope, selector) => {
      return filterFirstLayer(scope, selector, always);
    };
    const filterFirstLayer = (scope, selector, predicate) => {
      return bind$3(children$1(scope), (x) => {
        if (is$1(x, selector)) {
          return predicate(x) ? [x] : [];
        } else {
          return filterFirstLayer(x, selector, predicate);
        }
      });
    };
    const lookup$1 = (tags, element, isRoot2 = never) => {
      if (isRoot2(element)) {
        return Optional.none();
      }
      if (contains$2(tags, name2(element))) {
        return Optional.some(element);
      }
      const isRootOrUpperTable = (elm) => is$1(elm, "table") || isRoot2(elm);
      return ancestor$3(element, tags.join(","), isRootOrUpperTable);
    };
    const cell = (element, isRoot2) => lookup$1([
      "td",
      "th"
    ], element, isRoot2);
    const cells = (ancestor2) => firstLayer(ancestor2, "th,td");
    const table = (element, isRoot2) => closest$3(element, "table", isRoot2);
    const walk = (all3, current, index, direction, isEligible = always) => {
      const forwards = direction === 1;
      if (!forwards && index <= 0) {
        return CellLocation.first(all3[0]);
      } else if (forwards && index >= all3.length - 1) {
        return CellLocation.last(all3[all3.length - 1]);
      } else {
        const newIndex = index + direction;
        const elem = all3[newIndex];
        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all3, current, newIndex, direction, isEligible);
      }
    };
    const detect = (current, isRoot2) => {
      return table(current, isRoot2).bind((table2) => {
        const all3 = cells(table2);
        const index = findIndex$2(all3, (x) => eq(current, x));
        return index.map((index2) => ({
          index: index2,
          all: all3
        }));
      });
    };
    const next = (current, isEligible, isRoot2) => {
      const detection = detect(current, isRoot2);
      return detection.fold(() => {
        return CellLocation.none(current);
      }, (info) => {
        return walk(info.all, current, info.index, 1, isEligible);
      });
    };
    const prev = (current, isEligible, isRoot2) => {
      const detection = detect(current, isRoot2);
      return detection.fold(() => {
        return CellLocation.none();
      }, (info) => {
        return walk(info.all, current, info.index, -1, isEligible);
      });
    };
    const deflate = (rect, delta) => ({
      left: rect.left - delta,
      top: rect.top - delta,
      right: rect.right + delta * 2,
      bottom: rect.bottom + delta * 2,
      width: rect.width + delta,
      height: rect.height + delta
    });
    const getCorners = (getYAxisValue, tds) => bind$3(tds, (td) => {
      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);
      return [
        {
          x: rect.left,
          y: getYAxisValue(rect),
          cell: td
        },
        {
          x: rect.right,
          y: getYAxisValue(rect),
          cell: td
        }
      ];
    });
    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), (oldCorner) => {
      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));
      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));
      return Optional.some(newDist < oldDist ? newCorner : oldCorner);
    }), Optional.none());
    const getClosestCell = (getYAxisValue, isTargetCorner, table2, x, y) => {
      const cells2 = descendants(SugarElement.fromDom(table2), "td,th,caption").map((e) => e.dom);
      const corners = filter$5(getCorners(getYAxisValue, cells2), (corner) => isTargetCorner(corner, y));
      return findClosestCorner(corners, x, y).map((corner) => corner.cell);
    };
    const getBottomValue = (rect) => rect.bottom;
    const getTopValue = (rect) => rect.top;
    const isAbove = (corner, y) => corner.y < y;
    const isBelow = (corner, y) => corner.y > y;
    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);
    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);
    const findClosestPositionInAboveCell = (table2, pos) => head(pos.getClientRects()).bind((rect) => getClosestCellAbove(table2, rect.left, rect.top)).bind((cell2) => findClosestHorizontalPosition(getLastLinePositions(cell2), pos));
    const findClosestPositionInBelowCell = (table2, pos) => last$3(pos.getClientRects()).bind((rect) => getClosestCellBelow(table2, rect.left, rect.top)).bind((cell2) => findClosestHorizontalPosition(getFirstLinePositions(cell2), pos));
    const hasNextBreak = (getPositionsUntil2, scope, lineInfo) => lineInfo.breakAt.exists((breakPos) => getPositionsUntil2(scope, breakPos).breakAt.isSome());
    const startsWithWrapBreak = (lineInfo) => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;
    const startsWithBrBreak = (lineInfo) => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;
    const isAtTableCellLine = (getPositionsUntil2, scope, pos) => {
      const lineInfo = getPositionsUntil2(scope, pos);
      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {
        return !hasNextBreak(getPositionsUntil2, scope, lineInfo);
      } else {
        return lineInfo.breakAt.isNone();
      }
    };
    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);
    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);
    const isCaretAtStartOrEndOfTable = (forward, rng, table2) => {
      const caretPos = CaretPosition.fromRangeStart(rng);
      return positionIn(!forward, table2).exists((pos) => pos.isEqual(caretPos));
    };
    const navigateHorizontally = (editor, forward, table2, _td) => {
      const rng = editor.selection.getRng();
      const direction = forward ? 1 : -1;
      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table2)) {
        showCaret(direction, editor, table2, !forward, false).each((newRng) => {
          moveToRange(editor, newRng);
        });
        return true;
      }
      return false;
    };
    const getClosestAbovePosition = (root2, table2, start3) => findClosestPositionInAboveCell(table2, start3).orThunk(() => head(start3.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsAbove(root2, CaretPosition.before(table2)), rect.left))).getOr(CaretPosition.before(table2));
    const getClosestBelowPosition = (root2, table2, start3) => findClosestPositionInBelowCell(table2, start3).orThunk(() => head(start3.getClientRects()).bind((rect) => findClosestHorizontalPositionFromPoint(getPositionsBelow(root2, CaretPosition.after(table2)), rect.left))).getOr(CaretPosition.after(table2));
    const getTable = (previous, pos) => {
      const node = pos.getNode(previous);
      return isTable$2(node) ? Optional.some(node) : Optional.none();
    };
    const renderBlock = (down, editor, table2) => {
      editor.undoManager.transact(() => {
        const insertFn = down ? after$4 : before$3;
        const rng = insertEmptyLine(editor, SugarElement.fromDom(table2), insertFn);
        moveToRange(editor, rng);
      });
    };
    const moveCaret = (editor, down, pos) => {
      const table2 = down ? getTable(true, pos) : getTable(false, pos);
      const last2 = down === false;
      table2.fold(() => moveToRange(editor, pos.toRange()), (table3) => positionIn(last2, editor.getBody()).filter((lastPos) => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), (_2) => renderBlock(down, editor, table3)));
    };
    const navigateVertically = (editor, down, table2, td) => {
      const rng = editor.selection.getRng();
      const pos = CaretPosition.fromRangeStart(rng);
      const root2 = editor.getBody();
      if (!down && isAtFirstTableCellLine(td, pos)) {
        const newPos = getClosestAbovePosition(root2, table2, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else if (down && isAtLastTableCellLine(td, pos)) {
        const newPos = getClosestBelowPosition(root2, table2, pos);
        moveCaret(editor, down, newPos);
        return true;
      } else {
        return false;
      }
    };
    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), "td,th")).bind((td) => Optional.from(editor.dom.getParent(td, "table")).map((table2) => mover(editor, forward, table2, td))).getOr(false);
    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);
    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);
    const getCellFirstCursorPosition = (cell2) => {
      const selection = SimSelection.exact(cell2, 0, cell2, 0);
      return toNative(selection);
    };
    const tabGo = (editor, isRoot2, cell2) => {
      return cell2.fold(Optional.none, Optional.none, (_current, next2) => {
        return first(next2).map((cell3) => {
          return getCellFirstCursorPosition(cell3);
        });
      }, (current) => {
        editor.execCommand("mceTableInsertRowAfter");
        return tabForward(editor, isRoot2, current);
      });
    };
    const tabForward = (editor, isRoot2, cell2) => tabGo(editor, isRoot2, next(cell2, isEditable$3));
    const tabBackward = (editor, isRoot2, cell2) => tabGo(editor, isRoot2, prev(cell2, isEditable$3));
    const handleTab = (editor, forward) => {
      const rootElements = [
        "table",
        "li",
        "dl"
      ];
      const body = SugarElement.fromDom(editor.getBody());
      const isRoot2 = (element) => {
        const name$1 = name2(element);
        return eq(element, body) || contains$2(rootElements, name$1);
      };
      const rng = editor.selection.getRng();
      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);
      return cell(container, isRoot2).map((cell2) => {
        table(cell2, isRoot2).each((table2) => {
          editor.model.table.clearSelectedCells(table2.dom);
        });
        editor.selection.collapse(!forward);
        const navigation = !forward ? tabBackward : tabForward;
        const rng2 = navigation(editor, isRoot2, cell2);
        rng2.each((range2) => {
          editor.selection.setRng(range2);
        });
        return true;
      }).getOr(false);
    };
    const executeKeydownOverride$4 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute2([
        {
          keyCode: VK.RIGHT,
          action: action(moveH$2, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$2, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$3, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$3, editor, true)
        },
        ...isMac ? [
          {
            keyCode: VK.UP,
            action: action(selectToEndPoint, editor, false),
            metaKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.DOWN,
            action: action(selectToEndPoint, editor, true),
            metaKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.RIGHT,
          action: action(moveH, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(moveH$1, editor, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(moveH$1, editor, false)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$1, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$1, editor, true)
        },
        {
          keyCode: VK.RIGHT,
          action: action(move$2, editor, caret, true)
        },
        {
          keyCode: VK.LEFT,
          action: action(move$2, editor, caret, false)
        },
        {
          keyCode: VK.RIGHT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(moveNextWord, editor, caret)
        },
        {
          keyCode: VK.LEFT,
          ctrlKey: !isMac,
          altKey: isMac,
          action: action(movePrevWord, editor, caret)
        },
        {
          keyCode: VK.UP,
          action: action(moveV$2, editor, false)
        },
        {
          keyCode: VK.DOWN,
          action: action(moveV$2, editor, true)
        }
      ], evt).each((_2) => {
        evt.preventDefault();
      });
    };
    const setup$k = (editor, caret) => {
      editor.on("keydown", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$4(editor, caret, evt);
        }
      });
    };
    const point = (container, offset2) => ({
      container,
      offset: offset2
    });
    const DOM$7 = DOMUtils.DOM;
    const alwaysNext = (startNode) => (node) => startNode === node ? -1 : 0;
    const isBoundary = (dom2) => (node) => dom2.isBlock(node) || contains$2([
      "BR",
      "IMG",
      "HR",
      "INPUT"
    ], node.nodeName) || dom2.getContentEditable(node) === "false";
    const textBefore = (node, offset2, rootNode) => {
      if (isText$a(node) && offset2 >= 0) {
        return Optional.some(point(node, offset2));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset2, alwaysNext(node), rootNode)).map((prev2) => point(prev2.container, prev2.container.data.length));
      }
    };
    const textAfter = (node, offset2, rootNode) => {
      if (isText$a(node) && offset2 >= node.length) {
        return Optional.some(point(node, offset2));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset2, alwaysNext(node), rootNode)).map((prev2) => point(prev2.container, 0));
      }
    };
    const scanLeft = (node, offset2, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text3 = node.data;
      if (offset2 >= 0 && offset2 <= text3.length) {
        return Optional.some(point(node, offset2));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.backwards(node, offset2, alwaysNext(node), rootNode)).bind((prev2) => {
          const prevText = prev2.container.data;
          return scanLeft(prev2.container, offset2 + prevText.length, rootNode);
        });
      }
    };
    const scanRight = (node, offset2, rootNode) => {
      if (!isText$a(node)) {
        return Optional.none();
      }
      const text3 = node.data;
      if (offset2 <= text3.length) {
        return Optional.some(point(node, offset2));
      } else {
        const textSeeker = TextSeeker(DOM$7);
        return Optional.from(textSeeker.forwards(node, offset2, alwaysNext(node), rootNode)).bind((next2) => scanRight(next2.container, offset2 - text3.length, rootNode));
      }
    };
    const repeatLeft = (dom2, node, offset2, process2, rootNode) => {
      const search2 = TextSeeker(dom2, isBoundary(dom2));
      return Optional.from(search2.backwards(node, offset2, process2, rootNode));
    };
    const isValidTextRange = (rng) => rng.collapsed && isText$a(rng.startContainer);
    const getText = (rng) => trim$12(rng.toString().replace(/\u00A0/g, " "));
    const isWhitespace = (chr) => chr !== "" && "  \f\n\r	\v".indexOf(chr) !== -1;
    const stripTrigger = (text3, trigger) => text3.substring(trigger.length);
    const findTrigger = (text3, index, trigger) => {
      let i;
      const firstChar = trigger.charAt(0);
      for (i = index - 1; i >= 0; i--) {
        const char = text3.charAt(i);
        if (isWhitespace(char)) {
          return Optional.none();
        }
        if (firstChar === char && contains$1(text3, trigger, i, index)) {
          break;
        }
      }
      return Optional.some(i);
    };
    const findStart = (dom2, initRange, trigger, minChars = 0) => {
      if (!isValidTextRange(initRange)) {
        return Optional.none();
      }
      const buffer = {
        text: "",
        offset: 0
      };
      const findTriggerIndex = (element, offset2, text3) => {
        buffer.text = text3 + buffer.text;
        buffer.offset += offset2;
        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset2);
      };
      const root2 = dom2.getParent(initRange.startContainer, dom2.isBlock) || dom2.getRoot();
      return repeatLeft(dom2, initRange.startContainer, initRange.startOffset, findTriggerIndex, root2).bind((spot) => {
        const range2 = initRange.cloneRange();
        range2.setStart(spot.container, spot.offset);
        range2.setEnd(initRange.endContainer, initRange.endOffset);
        if (range2.collapsed) {
          return Optional.none();
        }
        const text3 = getText(range2);
        const triggerIndex = text3.lastIndexOf(trigger);
        if (triggerIndex !== 0 || stripTrigger(text3, trigger).length < minChars) {
          return Optional.none();
        } else {
          return Optional.some({
            text: stripTrigger(text3, trigger),
            range: range2,
            trigger
          });
        }
      });
    };
    const getContext = (dom2, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom2, initRange, trigger, minChars), (elm) => {
      const range2 = dom2.createRng();
      range2.selectNode(elm.dom);
      const text3 = getText(range2);
      return Optional.some({
        range: range2,
        text: stripTrigger(text3, trigger),
        trigger
      });
    });
    const isText$1 = (node) => node.nodeType === TEXT;
    const isElement2 = (node) => node.nodeType === ELEMENT;
    const toLast = (node) => {
      if (isText$1(node)) {
        return point(node, node.data.length);
      } else {
        const children2 = node.childNodes;
        return children2.length > 0 ? toLast(children2[children2.length - 1]) : point(node, children2.length);
      }
    };
    const toLeaf = (node, offset2) => {
      const children2 = node.childNodes;
      if (children2.length > 0 && offset2 < children2.length) {
        return toLeaf(children2[offset2], 0);
      } else if (children2.length > 0 && isElement2(node) && children2.length === offset2) {
        return toLast(children2[children2.length - 1]);
      } else {
        return point(node, offset2);
      }
    };
    const isPreviousCharContent = (dom2, leaf) => {
      var _a;
      const root2 = (_a = dom2.getParent(leaf.container, dom2.isBlock)) !== null && _a !== void 0 ? _a : dom2.getRoot();
      return repeatLeft(dom2, leaf.container, leaf.offset, (_element, offset2) => offset2 === 0 ? -1 : offset2, root2).filter((spot) => {
        const char = spot.container.data.charAt(spot.offset - 1);
        return !isWhitespace(char);
      }).isSome();
    };
    const isStartOfWord = (dom2) => (rng) => {
      const leaf = toLeaf(rng.startContainer, rng.startOffset);
      return !isPreviousCharContent(dom2, leaf);
    };
    const getTriggerContext = (dom2, initRange, database) => findMap(database.triggers, (trigger) => getContext(dom2, initRange, trigger));
    const lookup = (editor, getDatabase) => {
      const database = getDatabase();
      const rng = editor.selection.getRng();
      return getTriggerContext(editor.dom, rng, database).bind((context2) => lookupWithContext(editor, getDatabase, context2));
    };
    const lookupWithContext = (editor, getDatabase, context2, fetchOptions = {}) => {
      var _a;
      const database = getDatabase();
      const rng = editor.selection.getRng();
      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : "";
      const autocompleters = filter$5(database.lookupByTrigger(context2.trigger), (autocompleter) => context2.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context2.range, startText, context2.text));
      if (autocompleters.length === 0) {
        return Optional.none();
      }
      const lookupData = Promise.all(map$3(autocompleters, (ac) => {
        const fetchResult = ac.fetch(context2.text, ac.maxResults, fetchOptions);
        return fetchResult.then((results) => ({
          matchText: context2.text,
          items: results,
          columns: ac.columns,
          onAction: ac.onAction,
          highlightOn: ac.highlightOn
        }));
      }));
      return Optional.some({
        lookupData,
        context: context2
      });
    };
    var SimpleResultType;
    (function(SimpleResultType2) {
      SimpleResultType2[SimpleResultType2["Error"] = 0] = "Error";
      SimpleResultType2[SimpleResultType2["Value"] = 1] = "Value";
    })(SimpleResultType || (SimpleResultType = {}));
    const fold$1 = (res2, onError, onValue) => res2.stype === SimpleResultType.Error ? onError(res2.serror) : onValue(res2.svalue);
    const partition = (results) => {
      const values2 = [];
      const errors = [];
      each$e(results, (obj) => {
        fold$1(obj, (err) => errors.push(err), (val) => values2.push(val));
      });
      return {
        values: values2,
        errors
      };
    };
    const mapError = (res2, f) => {
      if (res2.stype === SimpleResultType.Error) {
        return {
          stype: SimpleResultType.Error,
          serror: f(res2.serror)
        };
      } else {
        return res2;
      }
    };
    const map2 = (res2, f) => {
      if (res2.stype === SimpleResultType.Value) {
        return {
          stype: SimpleResultType.Value,
          svalue: f(res2.svalue)
        };
      } else {
        return res2;
      }
    };
    const bind$1 = (res2, f) => {
      if (res2.stype === SimpleResultType.Value) {
        return f(res2.svalue);
      } else {
        return res2;
      }
    };
    const bindError = (res2, f) => {
      if (res2.stype === SimpleResultType.Error) {
        return f(res2.serror);
      } else {
        return res2;
      }
    };
    const svalue = (v) => ({
      stype: SimpleResultType.Value,
      svalue: v
    });
    const serror = (e) => ({
      stype: SimpleResultType.Error,
      serror: e
    });
    const toResult = (res2) => fold$1(res2, Result.error, Result.value);
    const fromResult = (res2) => res2.fold(serror, svalue);
    const SimpleResult = {
      fromResult,
      toResult,
      svalue,
      partition,
      serror,
      bind: bind$1,
      bindError,
      map: map2,
      mapError,
      fold: fold$1
    };
    const formatObj = (input) => {
      return isObject2(input) && keys(input).length > 100 ? " removed due to size" : JSON.stringify(input, null, 2);
    };
    const formatErrors = (errors) => {
      const es = errors.length > 10 ? errors.slice(0, 10).concat([{
        path: [],
        getErrorInfo: constant("... (only showing first ten failures)")
      }]) : errors;
      return map$3(es, (e) => {
        return "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo();
      });
    };
    const nu = (path2, getErrorInfo) => {
      return SimpleResult.serror([{
        path: path2,
        getErrorInfo
      }]);
    };
    const missingRequired = (path2, key, obj) => nu(path2, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
    const missingKey = (path2, key) => nu(path2, () => 'Choice schema did not contain choice key: "' + key + '"');
    const missingBranch = (path2, branches, branch) => nu(path2, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
    const custom = (path2, err) => nu(path2, constant(err));
    const chooseFrom = (path2, input, branches, ch) => {
      const fields = get$a(branches, ch);
      return fields.fold(() => missingBranch(path2, branches, ch), (vp) => vp.extract(path2.concat(["branch: " + ch]), input));
    };
    const choose$1 = (key, branches) => {
      const extract = (path2, input) => {
        const choice = get$a(input, key);
        return choice.fold(() => missingKey(path2, key), (chosen) => chooseFrom(path2, input, branches, chosen));
      };
      const toString3 = () => "chooseOn(" + key + "). Possible values: " + keys(branches);
      return {
        extract,
        toString: toString3
      };
    };
    const shallow = (old, nu2) => {
      return nu2;
    };
    const deep = (old, nu2) => {
      const bothObjects = isPlainObject2(old) && isPlainObject2(nu2);
      return bothObjects ? deepMerge(old, nu2) : nu2;
    };
    const baseMerge = (merger) => {
      return (...objects) => {
        if (objects.length === 0) {
          throw new Error(`Can't merge zero objects`);
        }
        const ret = {};
        for (let j = 0; j < objects.length; j++) {
          const curObject = objects[j];
          for (const key in curObject) {
            if (has$2(curObject, key)) {
              ret[key] = merger(ret[key], curObject[key]);
            }
          }
        }
        return ret;
      };
    };
    const deepMerge = baseMerge(deep);
    const merge2 = baseMerge(shallow);
    const required = () => ({
      tag: "required",
      process: {}
    });
    const defaultedThunk = (fallbackThunk) => ({
      tag: "defaultedThunk",
      process: fallbackThunk
    });
    const defaulted$1 = (fallback2) => defaultedThunk(constant(fallback2));
    const asOption = () => ({
      tag: "option",
      process: {}
    });
    const mergeValues = (values2, base) => values2.length > 0 ? SimpleResult.svalue(deepMerge(base, merge2.apply(void 0, values2))) : SimpleResult.svalue(base);
    const mergeErrors = (errors) => compose(SimpleResult.serror, flatten)(errors);
    const consolidateObj = (objects, base) => {
      const partition2 = SimpleResult.partition(objects);
      return partition2.errors.length > 0 ? mergeErrors(partition2.errors) : mergeValues(partition2.values, base);
    };
    const consolidateArr = (objects) => {
      const partitions = SimpleResult.partition(objects);
      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);
    };
    const ResultCombine = {
      consolidateObj,
      consolidateArr
    };
    const field$1 = (key, newKey, presence, prop) => ({
      tag: "field",
      key,
      newKey,
      presence,
      prop
    });
    const customField$1 = (newKey, instantiator) => ({
      tag: "custom",
      newKey,
      instantiator
    });
    const fold = (value2, ifField, ifCustom) => {
      switch (value2.tag) {
        case "field":
          return ifField(value2.key, value2.newKey, value2.presence, value2.prop);
        case "custom":
          return ifCustom(value2.newKey, value2.instantiator);
      }
    };
    const value = (validator2) => {
      const extract = (path2, val) => {
        return SimpleResult.bindError(validator2(val), (err) => custom(path2, err));
      };
      const toString3 = constant("val");
      return {
        extract,
        toString: toString3
      };
    };
    const anyValue$1 = value(SimpleResult.svalue);
    const requiredAccess = (path2, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path2, key, obj), bundle);
    const fallbackAccess = (obj, key, fallback2, bundle) => {
      const v = get$a(obj, key).getOrThunk(() => fallback2(obj));
      return bundle(v);
    };
    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));
    const optionDefaultedAccess = (obj, key, fallback2, bundle) => {
      const opt = get$a(obj, key).map((val) => val === true ? fallback2(obj) : val);
      return bundle(opt);
    };
    const extractField = (field2, path2, obj, key, prop) => {
      const bundle = (av) => prop.extract(path2.concat([key]), av);
      const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
        const result = prop.extract(path2.concat([key]), ov);
        return SimpleResult.map(result, Optional.some);
      });
      switch (field2.tag) {
        case "required":
          return requiredAccess(path2, obj, key, bundle);
        case "defaultedThunk":
          return fallbackAccess(obj, key, field2.process, bundle);
        case "option":
          return optionAccess(obj, key, bundleAsOption);
        case "defaultedOptionThunk":
          return optionDefaultedAccess(obj, key, field2.process, bundleAsOption);
        case "mergeWithThunk": {
          return fallbackAccess(obj, key, constant({}), (v) => {
            const result = deepMerge(field2.process(obj), v);
            return bundle(result);
          });
        }
      }
    };
    const extractFields = (path2, obj, fields) => {
      const success = {};
      const errors = [];
      for (const field2 of fields) {
        fold(field2, (key, newKey, presence, prop) => {
          const result = extractField(presence, path2, obj, key, prop);
          SimpleResult.fold(result, (err) => {
            errors.push(...err);
          }, (res2) => {
            success[newKey] = res2;
          });
        }, (newKey, instantiator) => {
          success[newKey] = instantiator(obj);
        });
      }
      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
    };
    const objOf = (values2) => {
      const extract = (path2, o) => extractFields(path2, o, values2);
      const toString3 = () => {
        const fieldStrings = map$3(values2, (value2) => fold(value2, (key, _okey, _presence, prop) => key + " -> " + prop.toString(), (newKey, _instantiator) => "state(" + newKey + ")"));
        return "obj{\n" + fieldStrings.join("\n") + "}";
      };
      return {
        extract,
        toString: toString3
      };
    };
    const arrOf = (prop) => {
      const extract = (path2, array) => {
        const results = map$3(array, (a, i) => prop.extract(path2.concat(["[" + i + "]"]), a));
        return ResultCombine.consolidateArr(results);
      };
      const toString3 = () => "array(" + prop.toString() + ")";
      return {
        extract,
        toString: toString3
      };
    };
    const valueOf = (validator2) => value((v) => validator2(v).fold(SimpleResult.serror, SimpleResult.svalue));
    const extractValue = (label, prop, obj) => {
      const res2 = prop.extract([label], obj);
      return SimpleResult.mapError(res2, (errs) => ({
        input: obj,
        errors: errs
      }));
    };
    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));
    const formatError = (errInfo) => {
      return "Errors: \n" + formatErrors(errInfo.errors).join("\n") + "\n\nInput object: " + formatObj(errInfo.input);
    };
    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));
    const anyValue = constant(anyValue$1);
    const typedValue = (validator2, expectedType) => value((a) => {
      const actualType = typeof a;
      return validator2(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
    });
    const number = typedValue(isNumber2, "number");
    const string = typedValue(isString2, "string");
    const boolean = typedValue(isBoolean2, "boolean");
    const functionProcessor = typedValue(isFunction2, "function");
    const field = field$1;
    const customField = customField$1;
    const validateEnum = (values2) => valueOf((value2) => contains$2(values2, value2) ? Result.value(value2) : Result.error(`Unsupported value: "${value2}", choose one of "${values2.join(", ")}".`));
    const requiredOf = (key, schema) => field(key, key, required(), schema);
    const requiredString = (key) => requiredOf(key, string);
    const requiredFunction = (key) => requiredOf(key, functionProcessor);
    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));
    const optionOf = (key, schema) => field(key, key, asOption(), schema);
    const optionString = (key) => optionOf(key, string);
    const optionFunction = (key) => optionOf(key, functionProcessor);
    const defaulted = (key, fallback2) => field(key, key, defaulted$1(fallback2), anyValue());
    const defaultedOf = (key, fallback2, schema) => field(key, key, defaulted$1(fallback2), schema);
    const defaultedNumber = (key, fallback2) => defaultedOf(key, fallback2, number);
    const defaultedString = (key, fallback2) => defaultedOf(key, fallback2, string);
    const defaultedStringEnum = (key, fallback2, values2) => defaultedOf(key, fallback2, validateEnum(values2));
    const defaultedBoolean = (key, fallback2) => defaultedOf(key, fallback2, boolean);
    const defaultedFunction = (key, fallback2) => defaultedOf(key, fallback2, functionProcessor);
    const defaultedArrayOf = (key, fallback2, schema) => defaultedOf(key, fallback2, arrOf(schema));
    const type = requiredString("type");
    const fetch$1 = requiredFunction("fetch");
    const onAction = requiredFunction("onAction");
    const onSetup = defaultedFunction("onSetup", () => noop2);
    const optionalText = optionString("text");
    const optionalIcon = optionString("icon");
    const optionalTooltip = optionString("tooltip");
    const optionalLabel = optionString("label");
    const active = defaultedBoolean("active", false);
    const enabled = defaultedBoolean("enabled", true);
    const primary = defaultedBoolean("primary", false);
    const defaultedColumns = (num) => defaulted("columns", num);
    const defaultedType = (type2) => defaultedString("type", type2);
    const autocompleterSchema = objOf([
      type,
      requiredString("trigger"),
      defaultedNumber("minChars", 1),
      defaultedColumns(1),
      defaultedNumber("maxResults", 10),
      optionFunction("matches"),
      fetch$1,
      onAction,
      defaultedArrayOf("highlightOn", [], string)
    ]);
    const createAutocompleter = (spec) => asRaw("Autocompleter", autocompleterSchema, {
      trigger: spec.ch,
      ...spec
    });
    const baseToolbarButtonFields = [
      enabled,
      optionalTooltip,
      optionalIcon,
      optionalText,
      onSetup
    ];
    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);
    const contextBarFields = [
      defaultedFunction("predicate", never),
      defaultedStringEnum("scope", "node", [
        "node",
        "editor"
      ]),
      defaultedStringEnum("position", "selection", [
        "node",
        "selection",
        "line"
      ])
    ];
    const contextButtonFields = baseToolbarButtonFields.concat([
      defaultedType("contextformbutton"),
      primary,
      onAction,
      customField("original", identity)
    ]);
    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
      defaultedType("contextformbutton"),
      primary,
      onAction,
      customField("original", identity)
    ]);
    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType("contextformbutton")]);
    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType("contextformtogglebutton")]);
    const toggleOrNormal = choose("type", {
      contextformbutton: contextButtonFields,
      contextformtogglebutton: contextToggleButtonFields
    });
    objOf([
      defaultedType("contextform"),
      defaultedFunction("initValue", constant("")),
      optionalLabel,
      requiredArrayOf("commands", toggleOrNormal),
      optionOf("launch", choose("type", {
        contextformbutton: launchButtonFields,
        contextformtogglebutton: launchToggleButtonFields
      }))
    ].concat(contextBarFields));
    const register$2 = (editor) => {
      const popups = editor.ui.registry.getAll().popups;
      const dataset = map$2(popups, (popup) => createAutocompleter(popup).fold((err) => {
        throw new Error(formatError(err));
      }, identity));
      const triggers = stringArray(mapToArray(dataset, (v) => v.trigger));
      const datasetValues = values(dataset);
      const lookupByTrigger = (trigger) => filter$5(datasetValues, (dv) => dv.trigger === trigger);
      return {
        dataset,
        triggers,
        lookupByTrigger
      };
    };
    const setupEditorInput = (editor, api2) => {
      const update = last$1(api2.load, 50);
      editor.on("keypress compositionend", (e) => {
        if (e.which === 27) {
          return;
        }
        update.throttle();
      });
      editor.on("keydown", (e) => {
        const keyCode = e.which;
        if (keyCode === 8) {
          update.throttle();
        } else if (keyCode === 27) {
          api2.cancelIfNecessary();
        }
      });
      editor.on("remove", update.cancel);
    };
    const setup$j = (editor) => {
      const activeAutocompleter = value$2();
      const uiActive = Cell(false);
      const isActive = activeAutocompleter.isSet;
      const cancelIfNecessary = () => {
        if (isActive()) {
          removeAutocompleterDecoration(editor);
          fireAutocompleterEnd(editor);
          uiActive.set(false);
          activeAutocompleter.clear();
        }
      };
      const commenceIfNecessary = (context2) => {
        if (!isActive()) {
          addAutocompleterDecoration(editor, context2.range);
          activeAutocompleter.set({
            trigger: context2.trigger,
            matchLength: context2.text.length
          });
        }
      };
      const getAutocompleters = cached(() => register$2(editor));
      const doLookup = (fetchOptions) => activeAutocompleter.get().map((ac) => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind((newContext) => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));
      const load = (fetchOptions) => {
        doLookup(fetchOptions).fold(cancelIfNecessary, (lookupInfo) => {
          commenceIfNecessary(lookupInfo.context);
          lookupInfo.lookupData.then((lookupData) => {
            activeAutocompleter.get().map((ac) => {
              const context2 = lookupInfo.context;
              if (ac.trigger === context2.trigger) {
                if (context2.text.length - ac.matchLength >= 10) {
                  cancelIfNecessary();
                } else {
                  activeAutocompleter.set({
                    ...ac,
                    matchLength: context2.text.length
                  });
                  if (uiActive.get()) {
                    fireAutocompleterUpdate(editor, { lookupData });
                  } else {
                    uiActive.set(true);
                    fireAutocompleterStart(editor, { lookupData });
                  }
                }
              }
            });
          });
        });
      };
      editor.addCommand("mceAutocompleterReload", (_ui, value2) => {
        const fetchOptions = isObject2(value2) ? value2.fetchOptions : {};
        load(fetchOptions);
      });
      editor.addCommand("mceAutocompleterClose", cancelIfNecessary);
      setupEditorInput(editor, {
        cancelIfNecessary,
        load
      });
    };
    const createAndFireInputEvent = (eventType) => (editor, inputType, specifics = {}) => {
      const target = editor.getBody();
      const overrides = {
        bubbles: true,
        composed: true,
        data: null,
        isComposing: false,
        detail: 0,
        view: null,
        target,
        currentTarget: target,
        eventPhase: Event.AT_TARGET,
        originalTarget: target,
        explicitOriginalTarget: target,
        isTrusted: false,
        srcElement: target,
        cancelable: false,
        preventDefault: noop2,
        inputType
      };
      const input = clone$3(new InputEvent(eventType));
      return editor.dispatch(eventType, {
        ...input,
        ...overrides,
        ...specifics
      });
    };
    const fireFakeInputEvent = createAndFireInputEvent("input");
    const fireFakeBeforeInputEvent = createAndFireInputEvent("beforeinput");
    const executeKeydownOverride$3 = (editor, caret, evt) => {
      const inputType = evt.keyCode === VK.BACKSPACE ? "deleteContentBackward" : "deleteContentForward";
      executeWithDelayedAction([
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete, editor)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$5, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$5, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$6, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$6, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$3, editor, caret, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$3, editor, caret, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$9, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$9, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$4, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$4, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$1, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$1, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$7, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$7, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$8, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$8, editor, true)
        },
        {
          keyCode: VK.BACKSPACE,
          action: action(backspaceDelete$2, editor, false)
        },
        {
          keyCode: VK.DELETE,
          action: action(backspaceDelete$2, editor, true)
        }
      ], evt).filter((_2) => editor.selection.isEditable()).each((applyAction) => {
        evt.preventDefault();
        const beforeInput = fireFakeBeforeInputEvent(editor, inputType);
        if (!beforeInput.isDefaultPrevented()) {
          applyAction();
          fireFakeInputEvent(editor, inputType);
        }
      });
    };
    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => {
      const platform3 = detect$2();
      const os2 = platform3.os;
      const browser3 = platform3.browser;
      const multiDeleteKeyPatterns = os2.isMacOS() ? [
        {
          keyCode: VK.BACKSPACE,
          altKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          altKey: true,
          action: action(refreshCaret, editor)
        }
      ] : [
        {
          keyCode: VK.BACKSPACE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        },
        {
          keyCode: VK.DELETE,
          ctrlKey: true,
          action: action(refreshCaret, editor)
        }
      ];
      if (os2.isMacOS() && isBackspaceKeydown) {
        multiDeleteKeyPatterns.push({
          keyCode: browser3.isFirefox() ? 224 : 91,
          action: action(refreshCaret, editor)
        });
      }
      execute2([
        {
          keyCode: VK.BACKSPACE,
          action: action(paddEmptyElement, editor)
        },
        {
          keyCode: VK.DELETE,
          action: action(paddEmptyElement, editor)
        },
        ...multiDeleteKeyPatterns
      ], evt);
    };
    const setup$i = (editor, caret) => {
      let isBackspaceKeydown = false;
      editor.on("keydown", (evt) => {
        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$3(editor, caret, evt);
        }
      });
      editor.on("keyup", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupOverride(editor, evt, isBackspaceKeydown);
        }
        isBackspaceKeydown = false;
      });
    };
    const firstNonWhiteSpaceNodeSibling = (node) => {
      while (node) {
        if (isElement$6(node) || isText$a(node) && node.data && /[\r\n\s]/.test(node.data)) {
          return node;
        }
        node = node.nextSibling;
      }
      return null;
    };
    const moveToCaretPosition = (editor, root2) => {
      const dom2 = editor.dom;
      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();
      if (!root2) {
        return;
      }
      if (/^(LI|DT|DD)$/.test(root2.nodeName)) {
        const firstChild2 = firstNonWhiteSpaceNodeSibling(root2.firstChild);
        if (firstChild2 && /^(UL|OL|DL)$/.test(firstChild2.nodeName)) {
          root2.insertBefore(dom2.doc.createTextNode(nbsp), root2.firstChild);
        }
      }
      const rng = dom2.createRng();
      root2.normalize();
      if (root2.hasChildNodes()) {
        const walker = new DomTreeWalker(root2, root2);
        let lastNode = root2;
        let node;
        while (node = walker.current()) {
          if (isText$a(node)) {
            rng.setStart(node, 0);
            rng.setEnd(node, 0);
            break;
          }
          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {
            rng.setStartBefore(node);
            rng.setEndBefore(node);
            break;
          }
          lastNode = node;
          node = walker.next();
        }
        if (!node) {
          rng.setStart(lastNode, 0);
          rng.setEnd(lastNode, 0);
        }
      } else {
        if (isBr$6(root2)) {
          if (root2.nextSibling && dom2.isBlock(root2.nextSibling)) {
            rng.setStartBefore(root2);
            rng.setEndBefore(root2);
          } else {
            rng.setStartAfter(root2);
            rng.setEndAfter(root2);
          }
        } else {
          rng.setStart(root2, 0);
          rng.setEnd(root2, 0);
        }
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const getEditableRoot = (dom2, node) => {
      const root2 = dom2.getRoot();
      let editableRoot;
      let parent2 = node;
      while (parent2 !== root2 && parent2 && dom2.getContentEditable(parent2) !== "false") {
        if (dom2.getContentEditable(parent2) === "true") {
          editableRoot = parent2;
        }
        parent2 = parent2.parentNode;
      }
      return parent2 !== root2 ? editableRoot : root2;
    };
    const getParentBlock$1 = (editor) => {
      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));
    };
    const getParentBlockName = (editor) => {
      return getParentBlock$1(editor).fold(constant(""), (parentBlock) => {
        return parentBlock.nodeName.toUpperCase();
      });
    };
    const isListItemParentBlock = (editor) => {
      return getParentBlock$1(editor).filter((elm) => {
        return isListItem$1(SugarElement.fromDom(elm));
      }).isSome();
    };
    const hasFirstChild = (elm, name3) => {
      return elm.firstChild && elm.firstChild.nodeName === name3;
    };
    const isFirstChild = (elm) => {
      var _a;
      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;
    };
    const hasParent = (elm, parentName) => {
      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;
      return isNonNullable(parentNode) && parentNode.nodeName === parentName;
    };
    const isListBlock = (elm) => {
      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);
    };
    const isListItem = (elm) => {
      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);
    };
    const isNestedList = (elm) => {
      return isListBlock(elm) && isListBlock(elm.parentNode);
    };
    const getContainerBlock = (containerBlock) => {
      const containerBlockParent = containerBlock.parentNode;
      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;
    };
    const isFirstOrLastLi = (containerBlock, parentBlock, first2) => {
      let node = containerBlock[first2 ? "firstChild" : "lastChild"];
      while (node) {
        if (isElement$6(node)) {
          break;
        }
        node = node[first2 ? "nextSibling" : "previousSibling"];
      }
      return node === parentBlock;
    };
    const insert$3 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {
      const dom2 = editor.dom;
      const rng = editor.selection.getRng();
      const containerParent = containerBlock.parentNode;
      if (containerBlock === editor.getBody() || !containerParent) {
        return;
      }
      if (isNestedList(containerBlock)) {
        newBlockName = "LI";
      }
      let newBlock = createNewBlock(newBlockName);
      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {
        if (hasParent(containerBlock, "LI")) {
          const containerBlockParent = getContainerBlock(containerBlock);
          dom2.insertAfter(newBlock, containerBlockParent);
          if (isFirstChild(containerBlock)) {
            dom2.remove(containerBlockParent);
          } else {
            dom2.remove(containerBlock);
          }
        } else {
          dom2.replace(newBlock, containerBlock);
        }
      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {
        if (hasParent(containerBlock, "LI")) {
          dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
          newBlock.appendChild(dom2.doc.createTextNode(" "));
          newBlock.appendChild(containerBlock);
        } else {
          containerParent.insertBefore(newBlock, containerBlock);
        }
        dom2.remove(parentBlock);
      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {
        dom2.insertAfter(newBlock, getContainerBlock(containerBlock));
        dom2.remove(parentBlock);
      } else {
        containerBlock = getContainerBlock(containerBlock);
        const tmpRng = rng.cloneRange();
        tmpRng.setStartAfter(parentBlock);
        tmpRng.setEndAfter(containerBlock);
        const fragment = tmpRng.extractContents();
        if (newBlockName === "LI" && hasFirstChild(fragment, "LI")) {
          newBlock = fragment.firstChild;
          dom2.insertAfter(fragment, containerBlock);
        } else {
          dom2.insertAfter(fragment, containerBlock);
          dom2.insertAfter(newBlock, containerBlock);
        }
        dom2.remove(parentBlock);
      }
      moveToCaretPosition(editor, newBlock);
    };
    const trimZwsp = (fragment) => {
      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), (text3) => {
        const rawNode = text3.dom;
        rawNode.nodeValue = trim$12(rawNode.data);
      });
    };
    const isWithinNonEditableList = (editor, node) => {
      const parentList = editor.dom.getParent(node, "ol,ul,dl");
      return parentList !== null && editor.dom.getContentEditableParent(parentList) === "false";
    };
    const isEmptyAnchor = (dom2, elm) => {
      return elm && elm.nodeName === "A" && dom2.isEmpty(elm);
    };
    const emptyBlock = (elm) => {
      elm.innerHTML = '<br data-mce-bogus="1">';
    };
    const containerAndSiblingName = (container, nodeName) => {
      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;
    };
    const canSplitBlock = (dom2, node) => {
      return isNonNullable(node) && dom2.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom2.isEditable(node.parentNode) && dom2.getContentEditable(node) !== "false";
    };
    const trimInlineElementsOnLeftSideOfBlock = (dom2, nonEmptyElementsMap, block) => {
      var _a;
      const firstChilds = [];
      if (!block) {
        return;
      }
      let currentNode = block;
      while (currentNode = currentNode.firstChild) {
        if (dom2.isBlock(currentNode)) {
          return;
        }
        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {
          firstChilds.push(currentNode);
        }
      }
      let i = firstChilds.length;
      while (i--) {
        currentNode = firstChilds[i];
        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === "") {
          dom2.remove(currentNode);
        } else {
          if (isEmptyAnchor(dom2, currentNode)) {
            dom2.remove(currentNode);
          }
        }
      }
    };
    const normalizeZwspOffset = (start3, container, offset2) => {
      if (!isText$a(container)) {
        return offset2;
      } else if (start3) {
        return offset2 === 1 && container.data.charAt(offset2 - 1) === ZWSP$1 ? 0 : offset2;
      } else {
        return offset2 === container.data.length - 1 && container.data.charAt(offset2) === ZWSP$1 ? container.data.length : offset2;
      }
    };
    const includeZwspInRange = (rng) => {
      const newRng = rng.cloneRange();
      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));
      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));
      return newRng;
    };
    const trimLeadingLineBreaks = (node) => {
      let currentNode = node;
      do {
        if (isText$a(currentNode)) {
          currentNode.data = currentNode.data.replace(/^[\r\n]+/, "");
        }
        currentNode = currentNode.firstChild;
      } while (currentNode);
    };
    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {
      const dom2 = editor.dom;
      Optional.from(forcedRootBlockAttrs.style).map(dom2.parseStyle).each((attrStyles) => {
        const currentStyles = getAllRaw(SugarElement.fromDom(node));
        const newStyles = {
          ...currentStyles,
          ...attrStyles
        };
        dom2.setStyles(node, newStyles);
      });
      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map((attrClasses) => attrClasses.split(/\s+/));
      const currentClassesOpt = Optional.from(node.className).map((currentClasses) => filter$5(currentClasses.split(/\s+/), (clazz) => clazz !== ""));
      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {
        const filteredClasses = filter$5(currentClasses, (clazz) => !contains$2(attrClasses, clazz));
        const newClasses = [
          ...attrClasses,
          ...filteredClasses
        ];
        dom2.setAttrib(node, "class", newClasses.join(" "));
      });
      const appliedAttrs = [
        "style",
        "class"
      ];
      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_2, attrs) => !contains$2(appliedAttrs, attrs));
      dom2.setAttribs(node, remainingAttrs);
    };
    const setForcedBlockAttrs = (editor, node) => {
      const forcedRootBlockName = getForcedRootBlock(editor);
      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {
        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);
        applyAttributes(editor, node, forcedRootBlockAttrs);
      }
    };
    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset2) => {
      var _a, _b;
      const dom2 = editor.dom;
      const editableRoot = (_a = getEditableRoot(dom2, container)) !== null && _a !== void 0 ? _a : dom2.getRoot();
      let parentBlock = dom2.getParent(container, dom2.isBlock);
      if (!parentBlock || !canSplitBlock(dom2, parentBlock)) {
        parentBlock = parentBlock || editableRoot;
        if (!parentBlock.hasChildNodes()) {
          const newBlock = dom2.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          parentBlock.appendChild(newBlock);
          rng.setStart(newBlock, 0);
          rng.setEnd(newBlock, 0);
          return newBlock;
        }
        let node = container;
        while (node && node.parentNode !== parentBlock) {
          node = node.parentNode;
        }
        let startNode;
        while (node && !dom2.isBlock(node)) {
          startNode = node;
          node = node.previousSibling;
        }
        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;
        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {
          const startNodeParent = startNode.parentNode;
          const newBlock = dom2.create(newBlockName);
          setForcedBlockAttrs(editor, newBlock);
          startNodeParent.insertBefore(newBlock, startNode);
          node = startNode;
          while (node && !dom2.isBlock(node)) {
            const next2 = node.nextSibling;
            newBlock.appendChild(node);
            node = next2;
          }
          rng.setStart(container, offset2);
          rng.setEnd(container, offset2);
        }
      }
      return container;
    };
    const addBrToBlockIfNeeded = (dom2, block) => {
      block.normalize();
      const lastChild2 = block.lastChild;
      if (!lastChild2 || isElement$6(lastChild2) && /^(left|right)$/gi.test(dom2.getStyle(lastChild2, "float", true))) {
        dom2.add(block, "br");
      }
    };
    const shouldEndContainer = (editor, container) => {
      const optionValue = shouldEndContainerOnEmptyBlock(editor);
      if (isNullable(container)) {
        return false;
      } else if (isString2(optionValue)) {
        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());
      } else {
        return optionValue;
      }
    };
    const insert$2 = (editor, evt) => {
      let container;
      let offset2;
      let parentBlockName;
      let containerBlock;
      let isAfterLastNodeInContainer = false;
      const dom2 = editor.dom;
      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();
      const rng = editor.selection.getRng();
      const newBlockName = getForcedRootBlock(editor);
      const createNewBlock = (name3) => {
        let node = container;
        const textInlineElements = schema.getTextInlineElements();
        let block;
        if (name3 || parentBlockName === "TABLE" || parentBlockName === "HR") {
          block = dom2.create(name3 || newBlockName);
        } else {
          block = parentBlock.cloneNode(false);
        }
        let caretNode = block;
        if (shouldKeepStyles(editor) === false) {
          dom2.setAttrib(block, "style", null);
          dom2.setAttrib(block, "class", null);
        } else {
          do {
            if (textInlineElements[node.nodeName]) {
              if (isCaretNode(node) || isBookmarkNode$1(node)) {
                continue;
              }
              const clonedNode = node.cloneNode(false);
              dom2.setAttrib(clonedNode, "id", "");
              if (block.hasChildNodes()) {
                clonedNode.appendChild(block.firstChild);
                block.appendChild(clonedNode);
              } else {
                caretNode = clonedNode;
                block.appendChild(clonedNode);
              }
            }
          } while ((node = node.parentNode) && node !== editableRoot);
        }
        setForcedBlockAttrs(editor, block);
        emptyBlock(caretNode);
        return block;
      };
      const isCaretAtStartOrEndOfBlock = (start3) => {
        const normalizedOffset = normalizeZwspOffset(start3, container, offset2);
        if (isText$a(container) && (start3 ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {
          return false;
        }
        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start3) {
          return true;
        }
        if (start3 && isElement$6(container) && container === parentBlock.firstChild) {
          return true;
        }
        if (containerAndSiblingName(container, "TABLE") || containerAndSiblingName(container, "HR")) {
          return isAfterLastNodeInContainer && !start3 || !isAfterLastNodeInContainer && start3;
        }
        const walker = new DomTreeWalker(container, parentBlock);
        if (isText$a(container)) {
          if (start3 && normalizedOffset === 0) {
            walker.prev();
          } else if (!start3 && normalizedOffset === container.data.length) {
            walker.next();
          }
        }
        let node;
        while (node = walker.current()) {
          if (isElement$6(node)) {
            if (!node.getAttribute("data-mce-bogus")) {
              const name3 = node.nodeName.toLowerCase();
              if (nonEmptyElementsMap[name3] && name3 !== "br") {
                return false;
              }
            }
          } else if (isText$a(node) && !isWhitespaceText(node.data)) {
            return false;
          }
          if (start3) {
            walker.prev();
          } else {
            walker.next();
          }
        }
        return true;
      };
      const insertNewBlockAfter = () => {
        let block;
        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== "HGROUP") {
          block = createNewBlock(newBlockName);
        } else {
          block = createNewBlock();
        }
        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom2, containerBlock) && dom2.isEmpty(parentBlock)) {
          block = dom2.split(containerBlock, parentBlock);
        } else {
          dom2.insertAfter(block, parentBlock);
        }
        moveToCaretPosition(editor, block);
        return block;
      };
      normalize$2(dom2, rng).each((normRng) => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      container = rng.startContainer;
      offset2 = rng.startOffset;
      const shiftKey = !!(evt && evt.shiftKey);
      const ctrlKey = !!(evt && evt.ctrlKey);
      if (isElement$6(container) && container.hasChildNodes()) {
        isAfterLastNodeInContainer = offset2 > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset2, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset2 = container.data.length;
        } else {
          offset2 = 0;
        }
      }
      const editableRoot = getEditableRoot(dom2, container);
      if (!editableRoot || isWithinNonEditableList(editor, container)) {
        return;
      }
      if (!shiftKey) {
        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset2);
      }
      let parentBlock = dom2.getParent(container, dom2.isBlock) || dom2.getRoot();
      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : "";
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
      if (containerBlockName === "LI" && !ctrlKey) {
        const liBlock = containerBlock;
        parentBlock = liBlock;
        containerBlock = liBlock.parentNode;
        parentBlockName = containerBlockName;
      }
      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {
        if (dom2.isEmpty(parentBlock)) {
          insert$3(editor, createNewBlock, containerBlock, parentBlock, newBlockName);
          return;
        }
      }
      if (parentBlock === editor.getBody() || !canSplitBlock(dom2, parentBlock)) {
        return;
      }
      const parentBlockParent = parentBlock.parentNode;
      let newBlock;
      if (isCaretContainerBlock$1(parentBlock)) {
        newBlock = showCaretContainerBlock(parentBlock);
        if (dom2.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        setForcedBlockAttrs(editor, newBlock);
        moveToCaretPosition(editor, newBlock);
      } else if (isCaretAtStartOrEndOfBlock(false)) {
        newBlock = insertNewBlockAfter();
      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {
        newBlock = parentBlockParent.insertBefore(createNewBlock(), parentBlock);
        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, "HR") ? newBlock : parentBlock);
      } else {
        const tmpRng = includeZwspInRange(rng).cloneRange();
        tmpRng.setEndAfter(parentBlock);
        const fragment = tmpRng.extractContents();
        trimZwsp(fragment);
        trimLeadingLineBreaks(fragment);
        newBlock = fragment.firstChild;
        dom2.insertAfter(fragment, parentBlock);
        trimInlineElementsOnLeftSideOfBlock(dom2, nonEmptyElementsMap, newBlock);
        addBrToBlockIfNeeded(dom2, parentBlock);
        if (dom2.isEmpty(parentBlock)) {
          emptyBlock(parentBlock);
        }
        newBlock.normalize();
        if (dom2.isEmpty(newBlock)) {
          dom2.remove(newBlock);
          insertNewBlockAfter();
        } else {
          setForcedBlockAttrs(editor, newBlock);
          moveToCaretPosition(editor, newBlock);
        }
      }
      dom2.setAttrib(newBlock, "id", "");
      editor.dispatch("NewBlock", { newBlock });
    };
    const fakeEventName$1 = "insertParagraph";
    const blockbreak = {
      insert: insert$2,
      fakeEventName: fakeEventName$1
    };
    const hasRightSideContent = (schema, container, parentBlock) => {
      const walker = new DomTreeWalker(container, parentBlock);
      let node;
      const nonEmptyElementsMap = schema.getNonEmptyElements();
      while (node = walker.next()) {
        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {
          return true;
        }
      }
      return false;
    };
    const moveSelectionToBr = (editor, brElm, extraBr) => {
      const rng = editor.dom.createRng();
      if (!extraBr) {
        rng.setStartAfter(brElm);
        rng.setEndAfter(brElm);
      } else {
        rng.setStartBefore(brElm);
        rng.setEndBefore(brElm);
      }
      editor.selection.setRng(rng);
      scrollRangeIntoView(editor, rng);
    };
    const insertBrAtCaret = (editor, evt) => {
      const selection = editor.selection;
      const dom2 = editor.dom;
      const rng = selection.getRng();
      let brElm;
      let extraBr = false;
      normalize$2(dom2, rng).each((normRng) => {
        rng.setStart(normRng.startContainer, normRng.startOffset);
        rng.setEnd(normRng.endContainer, normRng.endOffset);
      });
      let offset2 = rng.startOffset;
      let container = rng.startContainer;
      if (isElement$6(container) && container.hasChildNodes()) {
        const isAfterLastNodeInContainer = offset2 > container.childNodes.length - 1;
        container = container.childNodes[Math.min(offset2, container.childNodes.length - 1)] || container;
        if (isAfterLastNodeInContainer && isText$a(container)) {
          offset2 = container.data.length;
        } else {
          offset2 = 0;
        }
      }
      let parentBlock = dom2.getParent(container, dom2.isBlock);
      const containerBlock = parentBlock && parentBlock.parentNode ? dom2.getParent(parentBlock.parentNode, dom2.isBlock) : null;
      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : "";
      const isControlKey = !!(evt && evt.ctrlKey);
      if (containerBlockName === "LI" && !isControlKey) {
        parentBlock = containerBlock;
      }
      if (isText$a(container) && offset2 >= container.data.length) {
        if (!hasRightSideContent(editor.schema, container, parentBlock || dom2.getRoot())) {
          brElm = dom2.create("br");
          rng.insertNode(brElm);
          rng.setStartAfter(brElm);
          rng.setEndAfter(brElm);
          extraBr = true;
        }
      }
      brElm = dom2.create("br");
      rangeInsertNode(dom2, rng, brElm);
      moveSelectionToBr(editor, brElm, extraBr);
      editor.undoManager.add();
    };
    const insertBrBefore = (editor, inline) => {
      const br = SugarElement.fromTag("br");
      before$3(SugarElement.fromDom(inline), br);
      editor.undoManager.add();
    };
    const insertBrAfter = (editor, inline) => {
      if (!hasBrAfter(editor.getBody(), inline)) {
        after$4(SugarElement.fromDom(inline), SugarElement.fromTag("br"));
      }
      const br = SugarElement.fromTag("br");
      after$4(SugarElement.fromDom(inline), br);
      moveSelectionToBr(editor, br.dom, false);
      editor.undoManager.add();
    };
    const isBeforeBr = (pos) => {
      return isBr$6(pos.getNode());
    };
    const hasBrAfter = (rootNode, startNode) => {
      if (isBeforeBr(CaretPosition.after(startNode))) {
        return true;
      } else {
        return nextPosition(rootNode, CaretPosition.after(startNode)).map((pos) => {
          return isBr$6(pos.getNode());
        }).getOr(false);
      }
    };
    const isAnchorLink = (elm) => {
      return elm && elm.nodeName === "A" && "href" in elm;
    };
    const isInsideAnchor = (location2) => {
      return location2.fold(never, isAnchorLink, isAnchorLink, never);
    };
    const readInlineAnchorLocation = (editor) => {
      const isInlineTarget$1 = curry(isInlineTarget, editor);
      const position = CaretPosition.fromRangeStart(editor.selection.getRng());
      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);
    };
    const insertBrOutsideAnchor = (editor, location2) => {
      location2.fold(noop2, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop2);
    };
    const insert$1 = (editor, evt) => {
      const anchorLocation = readInlineAnchorLocation(editor);
      if (anchorLocation.isSome()) {
        anchorLocation.each(curry(insertBrOutsideAnchor, editor));
      } else {
        insertBrAtCaret(editor, evt);
      }
    };
    const fakeEventName = "insertLineBreak";
    const linebreak = {
      insert: insert$1,
      fakeEventName
    };
    const matchesSelector = (editor, selector) => {
      return getParentBlock$1(editor).filter((parentBlock) => {
        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);
      }).isSome();
    };
    const shouldInsertBr = (editor) => {
      return matchesSelector(editor, getBrNewLineSelector(editor));
    };
    const shouldBlockNewLine$1 = (editor) => {
      return matchesSelector(editor, getNoNewLineSelector(editor));
    };
    const newLineAction = Adt.generate([
      { br: [] },
      { block: [] },
      { none: [] }
    ]);
    const shouldBlockNewLine = (editor, _shiftKey) => {
      return shouldBlockNewLine$1(editor);
    };
    const inListBlock = (requiredState) => {
      return (editor, _shiftKey) => {
        return isListItemParentBlock(editor) === requiredState;
      };
    };
    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {
      const state2 = getParentBlockName(editor) === blockName.toUpperCase();
      return state2 === requiredState;
    };
    const inCefBlock = (editor) => {
      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNullable(editableRoot);
    };
    const inPreBlock = (requiredState) => inBlock("pre", requiredState);
    const inSummaryBlock = () => inBlock("summary", true);
    const shouldPutBrInPre = (requiredState) => {
      return (editor, _shiftKey) => {
        return shouldPutBrInPre$1(editor) === requiredState;
      };
    };
    const inBrContext = (editor, _shiftKey) => {
      return shouldInsertBr(editor);
    };
    const hasShiftKey = (_editor, shiftKey) => {
      return shiftKey;
    };
    const canInsertIntoEditableRoot = (editor) => {
      const forcedRootBlock = getForcedRootBlock(editor);
      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());
      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);
    };
    const match = (predicates2, action2) => {
      return (editor, shiftKey) => {
        const isMatch = foldl(predicates2, (res2, p) => {
          return res2 && p(editor, shiftKey);
        }, true);
        return isMatch ? Optional.some(action2) : Optional.none();
      };
    };
    const getAction = (editor, evt) => {
      return evaluateUntil([
        match([shouldBlockNewLine], newLineAction.none()),
        match([
          inPreBlock(true),
          inCefBlock
        ], newLineAction.none()),
        match([inSummaryBlock()], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false),
          hasShiftKey
        ], newLineAction.br()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(false)
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true),
          hasShiftKey
        ], newLineAction.block()),
        match([
          inPreBlock(true),
          shouldPutBrInPre(true)
        ], newLineAction.br()),
        match([
          inListBlock(true),
          hasShiftKey
        ], newLineAction.br()),
        match([inListBlock(true)], newLineAction.block()),
        match([inBrContext], newLineAction.br()),
        match([hasShiftKey], newLineAction.br()),
        match([canInsertIntoEditableRoot], newLineAction.block())
      ], [
        editor,
        !!(evt && evt.shiftKey)
      ]).getOr(newLineAction.none());
    };
    const insertBreak = (breakType, editor, evt) => {
      if (!editor.selection.isCollapsed()) {
        execEditorDeleteCommand(editor);
      }
      if (isNonNullable(evt)) {
        const event = fireFakeBeforeInputEvent(editor, breakType.fakeEventName);
        if (event.isDefaultPrevented()) {
          return;
        }
      }
      breakType.insert(editor, evt);
      if (isNonNullable(evt)) {
        fireFakeInputEvent(editor, breakType.fakeEventName);
      }
    };
    const insert = (editor, evt) => {
      const br = () => insertBreak(linebreak, editor, evt);
      const block = () => insertBreak(blockbreak, editor, evt);
      const logicalAction = getAction(editor, evt);
      switch (getNewlineBehavior(editor)) {
        case "linebreak":
          logicalAction.fold(br, br, noop2);
          break;
        case "block":
          logicalAction.fold(block, block, noop2);
          break;
        case "invert":
          logicalAction.fold(block, br, noop2);
          break;
        default:
          logicalAction.fold(br, block, noop2);
          break;
      }
    };
    const handleEnterKeyEvent = (editor, event) => {
      if (event.isDefaultPrevented()) {
        return;
      }
      event.preventDefault();
      endTypingLevelIgnoreLocks(editor.undoManager);
      editor.undoManager.transact(() => {
        insert(editor, event);
      });
    };
    const setup$h = (editor) => {
      editor.on("keydown", (event) => {
        if (event.keyCode === VK.ENTER) {
          handleEnterKeyEvent(editor, event);
        }
      });
    };
    const executeKeydownOverride$2 = (editor, caret, evt) => {
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      execute2([
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$1, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$1, editor, false)
        },
        ...!isMac ? [
          {
            keyCode: VK.HOME,
            action: action(selectToEndPoint, editor, false),
            ctrlKey: true,
            shiftKey: true
          },
          {
            keyCode: VK.END,
            action: action(selectToEndPoint, editor, true),
            ctrlKey: true,
            shiftKey: true
          }
        ] : [],
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint, editor, true)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint, editor, false)
        },
        {
          keyCode: VK.END,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        },
        {
          keyCode: VK.HOME,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        }
      ], evt).each((_2) => {
        evt.preventDefault();
      });
    };
    const setup$g = (editor, caret) => {
      editor.on("keydown", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$2(editor, caret, evt);
        }
      });
    };
    const setup$f = (editor) => {
      editor.on("input", (e) => {
        if (!e.isComposing) {
          normalizeNbspsInEditor(editor);
        }
      });
    };
    const platform2 = detect$2();
    const executeKeyupAction = (editor, caret, evt) => {
      execute2([
        {
          keyCode: VK.PAGE_UP,
          action: action(moveToLineEndPoint$2, editor, false, caret)
        },
        {
          keyCode: VK.PAGE_DOWN,
          action: action(moveToLineEndPoint$2, editor, true, caret)
        }
      ], evt);
    };
    const stopImmediatePropagation = (e) => e.stopImmediatePropagation();
    const isPageUpDown = (evt) => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;
    const setNodeChangeBlocker = (blocked, editor, block) => {
      if (block && !blocked.get()) {
        editor.on("NodeChange", stopImmediatePropagation, true);
      } else if (!block && blocked.get()) {
        editor.off("NodeChange", stopImmediatePropagation);
      }
      blocked.set(block);
    };
    const setup$e = (editor, caret) => {
      if (platform2.os.isMacOS()) {
        return;
      }
      const blocked = Cell(false);
      editor.on("keydown", (evt) => {
        if (isPageUpDown(evt)) {
          setNodeChangeBlocker(blocked, editor, true);
        }
      });
      editor.on("keyup", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeyupAction(editor, caret, evt);
        }
        if (isPageUpDown(evt) && blocked.get()) {
          setNodeChangeBlocker(blocked, editor, false);
          editor.nodeChanged();
        }
      });
    };
    const insertTextAtPosition = (text3, pos) => {
      const container = pos.container();
      const offset2 = pos.offset();
      if (isText$a(container)) {
        container.insertData(offset2, text3);
        return Optional.some(CaretPosition(container, offset2 + text3.length));
      } else {
        return getElementFromPosition(pos).map((elm) => {
          const textNode = SugarElement.fromText(text3);
          if (pos.isAtEnd()) {
            after$4(elm, textNode);
          } else {
            before$3(elm, textNode);
          }
          return CaretPosition(textNode.dom, text3.length);
        });
      }
    };
    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);
    const insertSpaceAtPosition = curry(insertTextAtPosition, " ");
    const locationToCaretPosition = (root2) => (location2) => location2.fold((element) => prevPosition(root2.dom, CaretPosition.before(element)), (element) => firstPositionIn(element), (element) => lastPositionIn(element), (element) => nextPosition(root2.dom, CaretPosition.after(element)));
    const insertInlineBoundarySpaceOrNbsp = (root2, pos) => (checkPos) => needsToHaveNbsp(root2, checkPos) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);
    const setSelection = (editor) => (pos) => {
      editor.selection.setRng(pos.toRange());
      editor.nodeChanged();
      return true;
    };
    const insertSpaceOrNbspAtSelection = (editor) => {
      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());
      const root2 = SugarElement.fromDom(editor.getBody());
      if (editor.selection.isCollapsed()) {
        const isInlineTarget$1 = curry(isInlineTarget, editor);
        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());
        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root2)).map((checkPos) => () => insertInlineBoundarySpaceOrNbsp(root2, pos)(checkPos).each(setSelection(editor)));
      } else {
        return Optional.none();
      }
    };
    const executeKeydownOverride$1 = (editor, evt) => {
      executeWithDelayedAction([{
        keyCode: VK.SPACEBAR,
        action: action(insertSpaceOrNbspAtSelection, editor)
      }], evt).each((applyAction) => {
        evt.preventDefault();
        const event = fireFakeBeforeInputEvent(editor, "insertText", { data: " " });
        if (!event.isDefaultPrevented()) {
          applyAction();
          fireFakeInputEvent(editor, "insertText", { data: " " });
        }
      });
    };
    const setup$d = (editor) => {
      editor.on("keydown", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride$1(editor, evt);
        }
      });
    };
    const tableTabNavigation = (editor) => {
      if (hasTableTabNavigation(editor)) {
        return [
          {
            keyCode: VK.TAB,
            action: action(handleTab, editor, true)
          },
          {
            keyCode: VK.TAB,
            shiftKey: true,
            action: action(handleTab, editor, false)
          }
        ];
      } else {
        return [];
      }
    };
    const executeKeydownOverride = (editor, evt) => {
      execute2([...tableTabNavigation(editor)], evt).each((_2) => {
        evt.preventDefault();
      });
    };
    const setup$c = (editor) => {
      editor.on("keydown", (evt) => {
        if (!evt.isDefaultPrevented()) {
          executeKeydownOverride(editor, evt);
        }
      });
    };
    const setup$b = (editor) => {
      editor.addShortcut("Meta+P", "", "mcePrint");
      setup$j(editor);
      if (isRtc(editor)) {
        return Cell(null);
      } else {
        const caret = setupSelectedState(editor);
        setup$l(editor);
        setup$k(editor, caret);
        setup$i(editor, caret);
        setup$h(editor);
        setup$d(editor);
        setup$f(editor);
        setup$c(editor);
        setup$g(editor, caret);
        setup$e(editor, caret);
        return caret;
      }
    };
    class NodeChange {
      constructor(editor) {
        this.lastPath = [];
        this.editor = editor;
        let lastRng;
        const self2 = this;
        if (!("onselectionchange" in editor.getDoc())) {
          editor.on("NodeChange click mouseup keyup focus", (e) => {
            const nativeRng = editor.selection.getRng();
            const fakeRng = {
              startContainer: nativeRng.startContainer,
              startOffset: nativeRng.startOffset,
              endContainer: nativeRng.endContainer,
              endOffset: nativeRng.endOffset
            };
            if (e.type === "nodechange" || !isEq$4(fakeRng, lastRng)) {
              editor.dispatch("SelectionChange");
            }
            lastRng = fakeRng;
          });
        }
        editor.on("contextmenu", () => {
          editor.dispatch("SelectionChange");
        });
        editor.on("SelectionChange", () => {
          const startElm = editor.selection.getStart(true);
          if (!startElm) {
            return;
          }
          if (hasAnyRanges(editor) && !self2.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {
            editor.nodeChanged({ selectionChange: true });
          }
        });
        editor.on("mouseup", (e) => {
          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {
            if (editor.selection.getNode().nodeName === "IMG") {
              Delay.setEditorTimeout(editor, () => {
                editor.nodeChanged();
              });
            } else {
              editor.nodeChanged();
            }
          }
        });
      }
      nodeChanged(args = {}) {
        const selection = this.editor.selection;
        let node;
        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {
          const root2 = this.editor.getBody();
          node = selection.getStart(true) || root2;
          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root2)) {
            node = root2;
          }
          const parents2 = [];
          this.editor.dom.getParent(node, (node2) => {
            if (node2 === root2) {
              return true;
            } else {
              parents2.push(node2);
              return false;
            }
          });
          this.editor.dispatch("NodeChange", {
            ...args,
            element: node,
            parents: parents2
          });
        }
      }
      isSameElementPath(startElm) {
        let i;
        const editor = this.editor;
        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));
        if (currentPath.length === this.lastPath.length) {
          for (i = currentPath.length; i >= 0; i--) {
            if (currentPath[i] !== this.lastPath[i]) {
              break;
            }
          }
          if (i === -1) {
            this.lastPath = currentPath;
            return true;
          }
        }
        this.lastPath = currentPath;
        return false;
      }
    }
    const internalMimeType = "x-tinymce/html";
    const internalHtmlMime = constant(internalMimeType);
    const internalMark = "<!-- " + internalMimeType + " -->";
    const mark = (html2) => internalMark + html2;
    const unmark = (html2) => html2.replace(internalMark, "");
    const isMarked = (html2) => html2.indexOf(internalMark) !== -1;
    const isPlainText = (text3) => {
      return !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(text3);
    };
    const openContainer = (rootTag, rootAttrs) => {
      let tag = "<" + rootTag;
      const attrs = mapToArray(rootAttrs, (value2, key) => key + '="' + Entities.encodeAllRaw(value2) + '"');
      if (attrs.length) {
        tag += " " + attrs.join(" ");
      }
      return tag + ">";
    };
    const toBlockElements = (text3, rootTag, rootAttrs) => {
      const blocks2 = text3.split(/\n\n/);
      const tagOpen = openContainer(rootTag, rootAttrs);
      const tagClose = "</" + rootTag + ">";
      const paragraphs = map$3(blocks2, (p) => {
        return p.split(/\n/).join("<br />");
      });
      const stitch = (p) => {
        return tagOpen + p + tagClose;
      };
      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join("");
    };
    const pasteBinDefaultContent = "%MCEPASTEBIN%";
    const create$62 = (editor, lastRngCell) => {
      const { dom: dom2, selection } = editor;
      const body = editor.getBody();
      lastRngCell.set(selection.getRng());
      const pasteBinElm = dom2.add(editor.getBody(), "div", {
        "id": "mcepastebin",
        "class": "mce-pastebin",
        "contentEditable": true,
        "data-mce-bogus": "all",
        "style": "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
      }, pasteBinDefaultContent);
      if (Env.browser.isFirefox()) {
        dom2.setStyle(pasteBinElm, "left", dom2.getStyle(body, "direction", true) === "rtl" ? 65535 : -65535);
      }
      dom2.bind(pasteBinElm, "beforedeactivate focusin focusout", (e) => {
        e.stopPropagation();
      });
      pasteBinElm.focus();
      selection.select(pasteBinElm, true);
    };
    const remove = (editor, lastRngCell) => {
      const dom2 = editor.dom;
      if (getEl(editor)) {
        let pasteBinClone;
        const lastRng = lastRngCell.get();
        while (pasteBinClone = getEl(editor)) {
          dom2.remove(pasteBinClone);
          dom2.unbind(pasteBinClone);
        }
        if (lastRng) {
          editor.selection.setRng(lastRng);
        }
      }
      lastRngCell.set(null);
    };
    const getEl = (editor) => editor.dom.get("mcepastebin");
    const isPasteBin = (elm) => isNonNullable(elm) && elm.id === "mcepastebin";
    const getHtml = (editor) => {
      const dom2 = editor.dom;
      const copyAndRemove = (toElm, fromElm) => {
        toElm.appendChild(fromElm);
        dom2.remove(fromElm, true);
      };
      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);
      each$e(pasteBinClones, (pasteBinClone) => {
        copyAndRemove(pasteBinElm, pasteBinClone);
      });
      const dirtyWrappers = dom2.select("div[id=mcepastebin]", pasteBinElm);
      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {
        const cleanWrapper = dom2.create("div");
        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);
        copyAndRemove(cleanWrapper, dirtyWrappers[i]);
      }
      return pasteBinElm ? pasteBinElm.innerHTML : "";
    };
    const isDefaultPasteBinContent = (content) => content === pasteBinDefaultContent;
    const PasteBin = (editor) => {
      const lastRng = Cell(null);
      return {
        create: () => create$62(editor, lastRng),
        remove: () => remove(editor, lastRng),
        getEl: () => getEl(editor),
        getHtml: () => getHtml(editor),
        getLastRng: lastRng.get
      };
    };
    const filter$1 = (content, items) => {
      Tools.each(items, (v) => {
        if (is$4(v, RegExp)) {
          content = content.replace(v, "");
        } else {
          content = content.replace(v[0], v[1]);
        }
      });
      return content;
    };
    const innerText = (html2) => {
      const schema = Schema();
      const domParser = DomParser({}, schema);
      let text3 = "";
      const voidElements = schema.getVoidElements();
      const ignoreElements = Tools.makeMap("script noscript style textarea video audio iframe object", " ");
      const blockElements = schema.getBlockElements();
      const walk2 = (node) => {
        const name3 = node.name, currentNode = node;
        if (name3 === "br") {
          text3 += "\n";
          return;
        }
        if (name3 === "wbr") {
          return;
        }
        if (voidElements[name3]) {
          text3 += " ";
        }
        if (ignoreElements[name3]) {
          text3 += " ";
          return;
        }
        if (node.type === 3) {
          text3 += node.value;
        }
        if (!(node.name in schema.getVoidElements())) {
          let currentNode2 = node.firstChild;
          if (currentNode2) {
            do {
              walk2(currentNode2);
            } while (currentNode2 = currentNode2.next);
          }
        }
        if (blockElements[name3] && currentNode.next) {
          text3 += "\n";
          if (name3 === "p") {
            text3 += "\n";
          }
        }
      };
      html2 = filter$1(html2, [/<!\[[^\]]+\]>/g]);
      walk2(domParser.parse(html2));
      return text3;
    };
    const trimHtml = (html2) => {
      const trimSpaces = (all3, s1, s2) => {
        if (!s1 && !s2) {
          return " ";
        }
        return nbsp;
      };
      html2 = filter$1(html2, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        /<!--StartFragment-->|<!--EndFragment-->/g,
        [
          /( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g,
          trimSpaces
        ],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
      ]);
      return html2;
    };
    const createIdGenerator = (prefix) => {
      let count2 = 0;
      return () => {
        return prefix + count2++;
      };
    };
    const getImageMimeType = (ext) => {
      const lowerExt = ext.toLowerCase();
      const mimeOverrides = {
        jpg: "jpeg",
        jpe: "jpeg",
        jfi: "jpeg",
        jif: "jpeg",
        jfif: "jpeg",
        pjpeg: "jpeg",
        pjp: "jpeg",
        svg: "svg+xml"
      };
      return Tools.hasOwn(mimeOverrides, lowerExt) ? "image/" + mimeOverrides[lowerExt] : "image/" + lowerExt;
    };
    const preProcess = (editor, html2) => {
      const parser = DomParser({ sanitize: shouldSanitizeXss(editor) }, editor.schema);
      parser.addNodeFilter("meta", (nodes) => {
        Tools.each(nodes, (node) => {
          node.remove();
        });
      });
      const fragment = parser.parse(html2, {
        forced_root_block: false,
        isRootContent: true
      });
      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);
    };
    const processResult = (content, cancelled) => ({
      content,
      cancelled
    });
    const postProcessFilter = (editor, html2, internal) => {
      const tempBody = editor.dom.create("div", { style: "display:none" }, html2);
      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);
      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());
    };
    const filterContent = (editor, content, internal) => {
      const preProcessArgs = firePastePreProcess(editor, content, internal);
      const filteredContent = preProcess(editor, preProcessArgs.content);
      if (editor.hasEventListeners("PastePostProcess") && !preProcessArgs.isDefaultPrevented()) {
        return postProcessFilter(editor, filteredContent, internal);
      } else {
        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());
      }
    };
    const process = (editor, html2, internal) => {
      return filterContent(editor, html2, internal);
    };
    const pasteHtml$1 = (editor, html2) => {
      editor.insertContent(html2, {
        merge: shouldPasteMergeFormats(editor),
        paste: true
      });
      return true;
    };
    const isAbsoluteUrl = (url) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(url);
    const isImageUrl = (editor, url) => {
      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), (type2) => endsWith2(url.toLowerCase(), `.${type2.toLowerCase()}`));
    };
    const createImage2 = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.insertContent('<img src="' + url + '">');
      });
      return true;
    };
    const createLink = (editor, url, pasteHtmlFn) => {
      editor.undoManager.extra(() => {
        pasteHtmlFn(editor, url);
      }, () => {
        editor.execCommand("mceInsertLink", false, url);
      });
      return true;
    };
    const linkSelection = (editor, html2, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html2) ? createLink(editor, html2, pasteHtmlFn) : false;
    const insertImage = (editor, html2, pasteHtmlFn) => isImageUrl(editor, html2) ? createImage2(editor, html2, pasteHtmlFn) : false;
    const smartInsertContent = (editor, html2) => {
      Tools.each([
        linkSelection,
        insertImage,
        pasteHtml$1
      ], (action2) => {
        return !action2(editor, html2, pasteHtml$1);
      });
    };
    const insertContent = (editor, html2, pasteAsText) => {
      if (pasteAsText || !isSmartPasteEnabled(editor)) {
        pasteHtml$1(editor, html2);
      } else {
        smartInsertContent(editor, html2);
      }
    };
    const uniqueId = createIdGenerator("mceclip");
    const doPaste = (editor, content, internal, pasteAsText) => {
      const args = process(editor, content, internal);
      if (!args.cancelled) {
        insertContent(editor, args.content, pasteAsText);
      }
    };
    const pasteHtml = (editor, html2, internalFlag) => {
      const internal = internalFlag ? internalFlag : isMarked(html2);
      doPaste(editor, unmark(html2), internal, false);
    };
    const pasteText = (editor, text3) => {
      const encodedText = editor.dom.encode(text3).replace(/\r\n/g, "\n");
      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));
      const html2 = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));
      doPaste(editor, html2, false, true);
    };
    const getDataTransferItems = (dataTransfer) => {
      const items = {};
      if (dataTransfer && dataTransfer.types) {
        for (let i = 0; i < dataTransfer.types.length; i++) {
          const contentType = dataTransfer.types[i];
          try {
            items[contentType] = dataTransfer.getData(contentType);
          } catch (ex) {
            items[contentType] = "";
          }
        }
      }
      return items;
    };
    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;
    const hasHtmlOrText = (content) => hasContentType(content, "text/html") || hasContentType(content, "text/plain");
    const extractFilename = (editor, str) => {
      const m = str.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
      return isNonNullable(m) ? editor.dom.encode(m[1]) : void 0;
    };
    const createBlobInfo = (editor, blobCache, file2, base64) => {
      const id = uniqueId();
      const useFileName = shouldReuseFileName(editor) && isNonNullable(file2.name);
      const name3 = useFileName ? extractFilename(editor, file2.name) : id;
      const filename = useFileName ? file2.name : void 0;
      const blobInfo = blobCache.create(id, file2, base64, name3, filename);
      blobCache.add(blobInfo);
      return blobInfo;
    };
    const pasteImage = (editor, imageItem) => {
      parseDataUri(imageItem.uri).each(({ data: data3, type: type2, base64Encoded }) => {
        const base64 = base64Encoded ? data3 : btoa(data3);
        const file2 = imageItem.file;
        const blobCache = editor.editorUpload.blobCache;
        const existingBlobInfo = blobCache.getByData(base64, type2);
        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file2, base64);
        pasteHtml(editor, `<img src="${blobInfo.blobUri()}">`, false);
      });
    };
    const isClipboardEvent = (event) => event.type === "paste";
    const readFilesAsDataUris = (items) => Promise.all(map$3(items, (file2) => {
      return blobToDataUri(file2).then((uri) => ({
        file: file2,
        uri
      }));
    }));
    const isImage2 = (editor) => {
      const allowedExtensions = getAllowedImageFileTypes(editor);
      return (file2) => startsWith(file2.type, "image/") && exists(allowedExtensions, (extension) => {
        return getImageMimeType(extension) === file2.type;
      });
    };
    const getImagesFromDataTransfer = (editor, dataTransfer) => {
      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), (item2) => {
        return item2.kind === "file" ? [item2.getAsFile()] : [];
      }) : [];
      const files = dataTransfer.files ? from(dataTransfer.files) : [];
      return filter$5(items.length > 0 ? items : files, isImage2(editor));
    };
    const pasteImageData = (editor, e, rng) => {
      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;
      if (shouldPasteDataImages(editor) && dataTransfer) {
        const images2 = getImagesFromDataTransfer(editor, dataTransfer);
        if (images2.length > 0) {
          e.preventDefault();
          readFilesAsDataUris(images2).then((fileResults) => {
            if (rng) {
              editor.selection.setRng(rng);
            }
            each$e(fileResults, (result) => {
              pasteImage(editor, result);
            });
          });
          return true;
        }
      }
      return false;
    };
    const isBrokenAndroidClipboardEvent = (e) => {
      var _a, _b;
      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;
    };
    const isKeyboardPasteEvent = (e) => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;
    const insertClipboardContent = (editor, clipboardContent, html2, plainTextMode) => {
      let content = trimHtml(html2);
      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html2);
      const isPlainTextHtml = !isInternal && isPlainText(content);
      const isAbsoluteUrl$1 = isAbsoluteUrl(content);
      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {
        plainTextMode = true;
      }
      if (plainTextMode || isAbsoluteUrl$1) {
        if (hasContentType(clipboardContent, "text/plain") && isPlainTextHtml) {
          content = clipboardContent["text/plain"];
        } else {
          content = innerText(content);
        }
      }
      if (isDefaultPasteBinContent(content)) {
        return;
      }
      if (plainTextMode) {
        pasteText(editor, content);
      } else {
        pasteHtml(editor, content, isInternal);
      }
    };
    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {
      let keyboardPastePlainTextState;
      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();
      editor.on("keydown", (e) => {
        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {
          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;
        }
      });
      editor.on("paste", (e) => {
        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {
          return;
        }
        const plainTextMode = pasteFormat.get() === "text" || keyboardPastePlainTextState;
        keyboardPastePlainTextState = false;
        const clipboardContent = getDataTransferItems(e.clipboardData);
        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {
          return;
        }
        if (hasContentType(clipboardContent, "text/html")) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent["text/html"], plainTextMode);
        } else if (hasContentType(clipboardContent, "text/plain") && hasContentType(clipboardContent, "text/uri-list")) {
          e.preventDefault();
          insertClipboardContent(editor, clipboardContent, clipboardContent["text/plain"], plainTextMode);
        } else {
          pasteBin.create();
          Delay.setEditorTimeout(editor, () => {
            const html2 = pasteBin.getHtml();
            pasteBin.remove();
            insertClipboardContent(editor, clipboardContent, html2, plainTextMode);
          }, 0);
        }
      });
    };
    const registerDataImageFilter = (editor) => {
      const isWebKitFakeUrl = (src) => startsWith(src, "webkit-fake-url");
      const isDataUri = (src) => startsWith(src, "data:");
      const isPasteInsert = (args) => {
        var _a;
        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;
      };
      editor.parser.addNodeFilter("img", (nodes, name3, args) => {
        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {
          for (const node of nodes) {
            const src = node.attr("src");
            if (isString2(src) && !node.attr("data-mce-object") && src !== Env.transparentSrc) {
              if (isWebKitFakeUrl(src)) {
                node.remove();
              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {
                node.remove();
              }
            }
          }
        }
      });
    };
    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {
      registerEventHandlers(editor, pasteBin, pasteFormat);
      registerDataImageFilter(editor);
    };
    const togglePlainTextPaste = (editor, pasteFormat) => {
      if (pasteFormat.get() === "text") {
        pasteFormat.set("html");
        firePastePlainTextToggle(editor, false);
      } else {
        pasteFormat.set("text");
        firePastePlainTextToggle(editor, true);
      }
      editor.focus();
    };
    const register$1 = (editor, pasteFormat) => {
      editor.addCommand("mceTogglePlainTextPaste", () => {
        togglePlainTextPaste(editor, pasteFormat);
      });
      editor.addCommand("mceInsertClipboardContent", (ui, value2) => {
        if (value2.html) {
          pasteHtml(editor, value2.html, value2.internal);
        }
        if (value2.text) {
          pasteText(editor, value2.text);
        }
      });
    };
    const setHtml5Clipboard = (clipboardData, html2, text3) => {
      if (clipboardData) {
        try {
          clipboardData.clearData();
          clipboardData.setData("text/html", html2);
          clipboardData.setData("text/plain", text3);
          clipboardData.setData(internalHtmlMime(), html2);
          return true;
        } catch (e) {
          return false;
        }
      } else {
        return false;
      }
    };
    const setClipboardData = (evt, data3, fallback2, done) => {
      if (setHtml5Clipboard(evt.clipboardData, data3.html, data3.text)) {
        evt.preventDefault();
        done();
      } else {
        fallback2(data3.html, done);
      }
    };
    const fallback$1 = (editor) => (html2, done) => {
      const { dom: dom2, selection } = editor;
      const outer = dom2.create("div", {
        "contenteditable": "false",
        "data-mce-bogus": "all"
      });
      const inner = dom2.create("div", { contenteditable: "true" }, html2);
      dom2.setStyles(outer, {
        position: "fixed",
        top: "0",
        left: "-3000px",
        width: "1000px",
        overflow: "hidden"
      });
      outer.appendChild(inner);
      dom2.add(editor.getBody(), outer);
      const range2 = selection.getRng();
      inner.focus();
      const offscreenRange = dom2.createRng();
      offscreenRange.selectNodeContents(inner);
      selection.setRng(offscreenRange);
      Delay.setEditorTimeout(editor, () => {
        selection.setRng(range2);
        dom2.remove(outer);
        done();
      }, 0);
    };
    const getData = (editor) => ({
      html: mark(editor.selection.getContent({ contextual: true })),
      text: editor.selection.getContent({ format: "text" })
    });
    const isTableSelection = (editor) => !!editor.dom.getParent(editor.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", editor.getBody());
    const hasSelectedContent = (editor) => !editor.selection.isCollapsed() || isTableSelection(editor);
    const cut = (editor) => (evt) => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback$1(editor), () => {
          if (Env.browser.isChromium() || Env.browser.isFirefox()) {
            const rng = editor.selection.getRng();
            Delay.setEditorTimeout(editor, () => {
              editor.selection.setRng(rng);
              editor.execCommand("Delete");
            }, 0);
          } else {
            editor.execCommand("Delete");
          }
        });
      }
    };
    const copy = (editor) => (evt) => {
      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {
        setClipboardData(evt, getData(editor), fallback$1(editor), noop2);
      }
    };
    const register = (editor) => {
      editor.on("cut", cut(editor));
      editor.on("copy", copy(editor));
    };
    const getCaretRangeFromEvent = (editor, e) => {
      var _a, _b;
      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());
    };
    const isPlainTextFileUrl = (content) => {
      const plainTextContent = content["text/plain"];
      return plainTextContent ? plainTextContent.indexOf("file://") === 0 : false;
    };
    const setFocusedRange = (editor, rng) => {
      editor.focus();
      if (rng) {
        editor.selection.setRng(rng);
      }
    };
    const hasImage = (dataTransfer) => exists(dataTransfer.files, (file2) => /^image\//.test(file2.type));
    const isTransparentBlockDrop = (dom2, schema, target, dropContent) => {
      const parentTransparent = dom2.getParent(target, (node) => isTransparentBlock(schema, node));
      if (parentTransparent && has$2(dropContent, "text/html")) {
        const fragment = new DOMParser().parseFromString(dropContent["text/html"], "text/html").body;
        return !isNull2(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));
      } else {
        return false;
      }
    };
    const setup$a = (editor, draggingInternallyState) => {
      if (shouldPasteBlockDrop(editor)) {
        editor.on("dragend dragover draggesture dragdrop drop drag", (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      }
      if (!shouldPasteDataImages(editor)) {
        editor.on("drop", (e) => {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && hasImage(dataTransfer)) {
            e.preventDefault();
          }
        });
      }
      editor.on("drop", (e) => {
        if (e.isDefaultPrevented()) {
          return;
        }
        const rng = getCaretRangeFromEvent(editor, e);
        if (isNullable(rng)) {
          return;
        }
        const dropContent = getDataTransferItems(e.dataTransfer);
        const internal = hasContentType(dropContent, internalHtmlMime());
        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {
          return;
        }
        const internalContent = dropContent[internalHtmlMime()];
        const content = internalContent || dropContent["text/html"] || dropContent["text/plain"];
        const transparentElementDrop = isTransparentBlockDrop(editor.dom, editor.schema, rng.startContainer, dropContent);
        if (draggingInternallyState.get() && !transparentElementDrop) {
          return;
        }
        if (content) {
          e.preventDefault();
          Delay.setEditorTimeout(editor, () => {
            editor.undoManager.transact(() => {
              if (internalContent) {
                editor.execCommand("Delete");
              }
              setFocusedRange(editor, rng);
              const trimmedContent = trimHtml(content);
              if (dropContent["text/html"]) {
                pasteHtml(editor, trimmedContent, internal);
              } else {
                pasteText(editor, trimmedContent);
              }
            });
          });
        }
      });
      editor.on("dragstart", (_e) => {
        draggingInternallyState.set(true);
      });
      editor.on("dragover dragend", (e) => {
        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {
          e.preventDefault();
          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));
        }
        if (e.type === "dragend") {
          draggingInternallyState.set(false);
        }
      });
    };
    const setup$9 = (editor) => {
      const processEvent = (f) => (e) => {
        f(editor, e);
      };
      const preProcess2 = getPastePreProcess(editor);
      if (isFunction2(preProcess2)) {
        editor.on("PastePreProcess", processEvent(preProcess2));
      }
      const postProcess2 = getPastePostProcess(editor);
      if (isFunction2(postProcess2)) {
        editor.on("PastePostProcess", processEvent(postProcess2));
      }
    };
    const addPreProcessFilter = (editor, filterFunc) => {
      editor.on("PastePreProcess", (e) => {
        e.content = filterFunc(editor, e.content, e.internal);
      });
    };
    const rgbRegExp = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi;
    const rgbToHex = (value2) => Tools.trim(value2).replace(rgbRegExp, rgbaToHexString).toLowerCase();
    const removeWebKitStyles = (editor, content, internal) => {
      const webKitStylesOption = getPasteWebkitStyles(editor);
      if (internal || webKitStylesOption === "all" || !shouldPasteRemoveWebKitStyles(editor)) {
        return content;
      }
      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];
      if (webKitStyles && webKitStylesOption !== "none") {
        const dom2 = editor.dom, node = editor.selection.getNode();
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (all3, before2, value2, after2) => {
          const inputStyles = dom2.parseStyle(dom2.decode(value2));
          const outputStyles = {};
          for (let i = 0; i < webKitStyles.length; i++) {
            const inputValue = inputStyles[webKitStyles[i]];
            let compareInput = inputValue;
            let currentValue = dom2.getStyle(node, webKitStyles[i], true);
            if (/color/.test(webKitStyles[i])) {
              compareInput = rgbToHex(compareInput);
              currentValue = rgbToHex(currentValue);
            }
            if (currentValue !== compareInput) {
              outputStyles[webKitStyles[i]] = inputValue;
            }
          }
          const outputStyle = dom2.serializeStyle(outputStyles, "span");
          if (outputStyle) {
            return before2 + ' style="' + outputStyle + '"' + after2;
          }
          return before2 + after2;
        });
      } else {
        content = content.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
      }
      content = content.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (all3, before2, value2, after2) => {
        return before2 + ' style="' + value2 + '"' + after2;
      });
      return content;
    };
    const setup$8 = (editor) => {
      if (Env.browser.isChromium() || Env.browser.isSafari()) {
        addPreProcessFilter(editor, removeWebKitStyles);
      }
    };
    const setup$7 = (editor) => {
      const draggingInternallyState = Cell(false);
      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? "text" : "html");
      const pasteBin = PasteBin(editor);
      setup$8(editor);
      register$1(editor, pasteFormat);
      setup$9(editor);
      editor.on("PreInit", () => {
        register(editor);
        setup$a(editor, draggingInternallyState);
        registerEventsAndFilters(editor, pasteBin, pasteFormat);
      });
    };
    const preventSummaryToggle = (editor) => {
      editor.on("click", (e) => {
        if (editor.dom.getParent(e.target, "details")) {
          e.preventDefault();
        }
      });
    };
    const filterDetails = (editor) => {
      editor.parser.addNodeFilter("details", (elms) => {
        each$e(elms, (details) => {
          details.attr("data-mce-open", details.attr("open"));
          details.attr("open", "open");
        });
      });
      editor.serializer.addNodeFilter("details", (elms) => {
        each$e(elms, (details) => {
          const open = details.attr("data-mce-open");
          details.attr("open", isString2(open) ? open : null);
          details.attr("data-mce-open", null);
        });
      });
    };
    const setup$6 = (editor) => {
      preventSummaryToggle(editor);
      filterDetails(editor);
    };
    const isBr = isBr$6;
    const isText = isText$a;
    const isContentEditableFalse$2 = (elm) => isContentEditableFalse$b(elm.dom);
    const isContentEditableTrue = (elm) => isContentEditableTrue$3(elm.dom);
    const isRoot = (rootNode) => (elm) => eq(SugarElement.fromDom(rootNode), elm);
    const getClosestScope = (node, rootNode) => closest$4(SugarElement.fromDom(node), (elm) => isContentEditableTrue(elm) || isBlock$2(elm), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;
    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));
    const findEdgeCaretCandidate = (startNode, scope, forward) => {
      const walker = new DomTreeWalker(startNode, scope);
      const next2 = forward ? walker.next.bind(walker) : walker.prev.bind(walker);
      let result = startNode;
      for (let current = forward ? startNode : next2(); current && !isBr(current); current = next2()) {
        if (isCaretCandidate$3(current)) {
          result = current;
        }
      }
      return result;
    };
    const findClosestBlockRange = (startRng, rootNode) => {
      const startPos = CaretPosition.fromRangeStart(startRng);
      const clickNode = startPos.getNode();
      const scope = getClosestScope(clickNode, rootNode);
      const startNode = findEdgeCaretCandidate(clickNode, scope, false);
      const endNode = findEdgeCaretCandidate(clickNode, scope, true);
      const rng = document.createRange();
      getClosestCef(startNode, scope).fold(() => {
        if (isText(startNode)) {
          rng.setStart(startNode, 0);
        } else {
          rng.setStartBefore(startNode);
        }
      }, (cef) => rng.setStartBefore(cef.dom));
      getClosestCef(endNode, scope).fold(() => {
        if (isText(endNode)) {
          rng.setEnd(endNode, endNode.data.length);
        } else {
          rng.setEndAfter(endNode);
        }
      }, (cef) => rng.setEndAfter(cef.dom));
      return rng;
    };
    const onTripleClickSelect = (editor) => {
      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody());
      editor.selection.setRng(normalize(rng));
    };
    const setup$5 = (editor) => {
      editor.on("mousedown", (e) => {
        if (e.detail >= 3) {
          e.preventDefault();
          onTripleClickSelect(editor);
        }
      });
    };
    var FakeCaretPosition;
    (function(FakeCaretPosition2) {
      FakeCaretPosition2["Before"] = "before";
      FakeCaretPosition2["After"] = "after";
    })(FakeCaretPosition || (FakeCaretPosition = {}));
    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);
    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);
    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;
    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;
    const isOverlapping = (r1, r2) => {
      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);
      return collidesY(r1, r2) && overlap > 0.5;
    };
    const splitRectsPerAxis = (rects, y) => {
      const intersectingRects = filter$5(rects, (rect) => isInsideY(y, rect));
      return boundingClientRectFromRects(intersectingRects).fold(() => [
        [],
        rects
      ], (boundingRect) => {
        const {
          pass: horizontal,
          fail: vertical
        } = partition$2(rects, (rect) => isOverlapping(rect, boundingRect));
        return [
          horizontal,
          vertical
        ];
      });
    };
    const clientInfo = (rect, clientX) => {
      return {
        node: rect.node,
        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After
      };
    };
    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));
    const closestChildCaretCandidateNodeRect = (children2, clientX, clientY) => {
      const caretCandidateRect = (rect) => {
        if (isCaretCandidate$3(rect.node)) {
          return Optional.some(rect);
        } else if (isElement$6(rect.node)) {
          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY);
        } else {
          return Optional.none();
        }
      };
      const getClosestTextNode = (rects, distance) => {
        if (rects.length >= 2) {
          const r1 = caretCandidateRect(rects[0]).getOr(rects[0]);
          const r2 = caretCandidateRect(rects[1]).getOr(rects[1]);
          const deltaDistance = Math.abs(distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
          if (deltaDistance < 2) {
            if (isText$a(r1.node)) {
              return Optional.some(r1);
            } else if (isText$a(r2.node)) {
              return Optional.some(r2);
            }
          }
        }
        return Optional.none();
      };
      const findClosestCaretCandidateNodeRect = (rects, distance) => {
        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));
        return getClosestTextNode(sortedRects, distance).orThunk(() => findMap(sortedRects, caretCandidateRect));
      };
      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children2), clientY);
      const {
        pass: above,
        fail: below
      } = partition$2(verticalRects, (rect) => rect.top < clientY);
      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));
    };
    const traverseUp = (rootElm, scope, clientX, clientY) => {
      const helper = (scope2, prevScope) => {
        const isDragGhostContainer = (node) => isElement$6(node) && node.classList.contains("mce-drag-container");
        const childNodesWithoutGhost = filter$5(scope2.dom.childNodes, not(isDragGhostContainer));
        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY), (prevScope2) => {
          const uncheckedChildren = filter$5(childNodesWithoutGhost, (node) => node !== prevScope2.dom);
          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY);
        }).orThunk(() => {
          const parent2 = eq(scope2, rootElm) ? Optional.none() : parentElement(scope2);
          return parent2.bind((newScope) => helper(newScope, Optional.some(scope2)));
        });
      };
      return helper(scope, Optional.none());
    };
    const closestCaretCandidateNodeRect = (root2, clientX, clientY) => {
      const rootElm = SugarElement.fromDom(root2);
      const ownerDoc = documentOrOwner(rootElm);
      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter((elm) => contains2(rootElm, elm));
      const element = elementAtPoint.getOr(rootElm);
      return traverseUp(rootElm, element, clientX, clientY);
    };
    const closestFakeCaretCandidate = (root2, clientX, clientY) => closestCaretCandidateNodeRect(root2, clientX, clientY).filter((rect) => isFakeCaretTarget(rect.node)).map((rect) => clientInfo(rect, clientX));
    const getAbsolutePosition = (elm) => {
      var _a, _b;
      const clientRect = elm.getBoundingClientRect();
      const doc = elm.ownerDocument;
      const docElem = doc.documentElement;
      const win = doc.defaultView;
      return {
        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,
        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft
      };
    };
    const getBodyPosition = (editor) => editor.inline ? getAbsolutePosition(editor.getBody()) : {
      left: 0,
      top: 0
    };
    const getScrollPosition = (editor) => {
      const body = editor.getBody();
      return editor.inline ? {
        left: body.scrollLeft,
        top: body.scrollTop
      } : {
        left: 0,
        top: 0
      };
    };
    const getBodyScroll = (editor) => {
      const body = editor.getBody(), docElm = editor.getDoc().documentElement;
      const inlineScroll = {
        left: body.scrollLeft,
        top: body.scrollTop
      };
      const iframeScroll = {
        left: body.scrollLeft || docElm.scrollLeft,
        top: body.scrollTop || docElm.scrollTop
      };
      return editor.inline ? inlineScroll : iframeScroll;
    };
    const getMousePosition = (editor, event) => {
      if (event.target.ownerDocument !== editor.getDoc()) {
        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());
        const scrollPosition = getBodyScroll(editor);
        return {
          left: event.pageX - iframePosition.left + scrollPosition.left,
          top: event.pageY - iframePosition.top + scrollPosition.top
        };
      }
      return {
        left: event.pageX,
        top: event.pageY
      };
    };
    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({
      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,
      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top
    });
    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));
    const makeDndEventFromMouseEvent = (type2, mouseEvent, extra2) => ({
      ...mouseEvent,
      dataTransfer: null,
      type: type2,
      ...extra2
    });
    const makeDndEvent = (type2, props) => {
      const fail = die("Function not supported on simulated event.");
      const event = {
        bubbles: true,
        cancelBubble: false,
        cancelable: true,
        composed: false,
        currentTarget: null,
        defaultPrevented: false,
        eventPhase: 0,
        isTrusted: true,
        returnValue: false,
        srcElement: null,
        target: null,
        timeStamp: 0,
        type: type2,
        composedPath: fail,
        initEvent: fail,
        preventDefault: noop2,
        stopImmediatePropagation: noop2,
        stopPropagation: noop2,
        AT_TARGET: window.Event.AT_TARGET,
        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
        NONE: window.Event.NONE,
        altKey: false,
        button: 0,
        buttons: 0,
        clientX: 0,
        clientY: 0,
        ctrlKey: false,
        metaKey: false,
        movementX: 0,
        movementY: 0,
        offsetX: 0,
        offsetY: 0,
        pageX: 0,
        pageY: 0,
        relatedTarget: null,
        screenX: 0,
        screenY: 0,
        shiftKey: false,
        x: 0,
        y: 0,
        detail: 0,
        view: null,
        which: 0,
        initUIEvent: fail,
        initMouseEvent: fail,
        getModifierState: fail,
        dataTransfer: null,
        ...props
      };
      return event;
    };
    const fallback = (target) => ({
      target,
      srcElement: target
    });
    const dndEvent = (type2) => (target) => makeDndEvent(type2, fallback(target));
    const dndEventFromMouseEvent = (type2) => (mouseEvent, target) => makeDndEventFromMouseEvent(type2, mouseEvent, fallback(target));
    const makeDragstartEventFromMouseEvent = dndEventFromMouseEvent("dragstart");
    const makeDropEventFromMouseEvent = dndEventFromMouseEvent("drop");
    const makeDragendEvent = dndEvent("dragend");
    const makeDragendEventFromMouseEvent = dndEventFromMouseEvent("dragend");
    const scrollPixelsPerInterval = 32;
    const scrollIntervalValue = 100;
    const mouseRangeToTriggerScrollInsideEditor = 8;
    const mouseRangeToTriggerScrollOutsideEditor = 16;
    const isContentEditableFalse$1 = isContentEditableFalse$b;
    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);
    const isDraggable = (dom2, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom2.isEditable(elm.parentElement);
    const isValidDropTarget = (editor, targetElement, dragElement) => {
      if (isNullable(targetElement)) {
        return false;
      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {
        return false;
      } else {
        return editor.dom.isEditable(targetElement);
      }
    };
    const cloneElement = (elm) => {
      const cloneElm = elm.cloneNode(true);
      cloneElm.removeAttribute("data-mce-selected");
      return cloneElm;
    };
    const createGhost = (editor, elm, width2, height2) => {
      const dom2 = editor.dom;
      const clonedElm = elm.cloneNode(true);
      dom2.setStyles(clonedElm, {
        width: width2,
        height: height2
      });
      dom2.setAttrib(clonedElm, "data-mce-selected", null);
      const ghostElm = dom2.create("div", {
        "class": "mce-drag-container",
        "data-mce-bogus": "all",
        "unselectable": "on",
        "contenteditable": "false"
      });
      dom2.setStyles(ghostElm, {
        position: "absolute",
        opacity: 0.5,
        overflow: "hidden",
        border: 0,
        padding: 0,
        margin: 0,
        width: width2,
        height: height2
      });
      dom2.setStyles(clonedElm, {
        margin: 0,
        boxSizing: "border-box"
      });
      ghostElm.appendChild(clonedElm);
      return ghostElm;
    };
    const appendGhostToBody = (ghostElm, bodyElm) => {
      if (ghostElm.parentNode !== bodyElm) {
        bodyElm.appendChild(ghostElm);
      }
    };
    const scrollEditor = (direction, amount) => (win) => () => {
      const current = direction === "left" ? win.scrollX : win.scrollY;
      win.scroll({
        [direction]: current + amount,
        behavior: "smooth"
      });
    };
    const scrollLeft = scrollEditor("left", -scrollPixelsPerInterval);
    const scrollRight = scrollEditor("left", scrollPixelsPerInterval);
    const scrollUp = scrollEditor("top", -scrollPixelsPerInterval);
    const scrollDown = scrollEditor("top", scrollPixelsPerInterval);
    const moveGhost = (ghostElm, position, width2, height2, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state2, mouseEventOriginatedFromWithinTheEditor) => {
      let overflowX = 0, overflowY = 0;
      ghostElm.style.left = position.pageX + "px";
      ghostElm.style.top = position.pageY + "px";
      if (position.pageX + width2 > maxX) {
        overflowX = position.pageX + width2 - maxX;
      }
      if (position.pageY + height2 > maxY) {
        overflowY = position.pageY + height2 - maxY;
      }
      ghostElm.style.width = width2 - overflowX + "px";
      ghostElm.style.height = height2 - overflowY + "px";
      const clientHeight = contentAreaContainer.clientHeight;
      const clientWidth = contentAreaContainer.clientWidth;
      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;
      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;
      state2.on((state3) => {
        state3.intervalId.clear();
        if (state3.dragging && mouseEventOriginatedFromWithinTheEditor) {
          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {
            state3.intervalId.set(scrollDown(win));
          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state3.intervalId.set(scrollUp(win));
          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {
            state3.intervalId.set(scrollRight(win));
          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {
            state3.intervalId.set(scrollLeft(win));
          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {
            state3.intervalId.set(scrollDown(window));
          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state3.intervalId.set(scrollUp(window));
          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {
            state3.intervalId.set(scrollRight(window));
          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {
            state3.intervalId.set(scrollLeft(window));
          }
        }
      });
    };
    const removeElement = (elm) => {
      if (elm && elm.parentNode) {
        elm.parentNode.removeChild(elm);
      }
    };
    const removeElementWithPadding = (dom2, elm) => {
      const parentBlock = dom2.getParent(elm.parentNode, dom2.isBlock);
      removeElement(elm);
      if (parentBlock && parentBlock !== dom2.getRoot() && dom2.isEmpty(parentBlock)) {
        fillWithPaddingBr(SugarElement.fromDom(parentBlock));
      }
    };
    const isLeftMouseButtonPressed = (e) => e.button === 0;
    const applyRelPos = (state2, position) => ({
      pageX: position.pageX - state2.relX,
      pageY: position.pageY + 5
    });
    const start2 = (state2, editor) => (e) => {
      if (isLeftMouseButtonPressed(e)) {
        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);
        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {
          const elmPos = editor.dom.getPos(ceElm);
          const bodyElm = editor.getBody();
          const docElm = editor.getDoc().documentElement;
          state2.set({
            element: ceElm,
            dragging: false,
            screenX: e.screenX,
            screenY: e.screenY,
            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,
            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,
            relX: e.pageX - elmPos.x,
            relY: e.pageY - elmPos.y,
            width: ceElm.offsetWidth,
            height: ceElm.offsetHeight,
            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),
            intervalId: repeatable(scrollIntervalValue)
          });
        }
      }
    };
    const placeCaretAt = (editor, clientX, clientY) => {
      editor._selectionOverrides.hideFakeCaret();
      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), (caretInfo) => {
        const range2 = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
        if (range2) {
          editor.selection.setRng(range2);
        } else {
          editor.selection.placeCaretAt(clientX, clientY);
        }
      });
    };
    const move = (state2, editor) => {
      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);
      editor.on("remove", throttledPlaceCaretAt.cancel);
      const state_ = state2;
      return (e) => state2.on((state3) => {
        const movement = Math.max(Math.abs(e.screenX - state3.screenX), Math.abs(e.screenY - state3.screenY));
        if (!state3.dragging && movement > 10) {
          const args = editor.dispatch("dragstart", makeDragstartEventFromMouseEvent(e, state3.element));
          if (args.isDefaultPrevented()) {
            return;
          }
          state3.dragging = true;
          editor.focus();
        }
        if (state3.dragging) {
          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;
          const targetPos = applyRelPos(state3, calc(editor, e));
          appendGhostToBody(state3.ghost, editor.getBody());
          moveGhost(state3.ghost, targetPos, state3.width, state3.height, state3.maxX, state3.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);
          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);
        }
      });
    };
    const getRawTarget = (selection) => {
      const sel = selection.getSel();
      if (isNonNullable(sel)) {
        const rng = sel.getRangeAt(0);
        const startContainer = rng.startContainer;
        return isText$a(startContainer) ? startContainer.parentNode : startContainer;
      } else {
        return null;
      }
    };
    const drop2 = (state2, editor) => (e) => {
      state2.on((state3) => {
        var _a;
        state3.intervalId.clear();
        if (state3.dragging) {
          if (isValidDropTarget(editor, getRawTarget(editor.selection), state3.element)) {
            const targetClone = cloneElement(state3.element);
            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();
            const args = editor.dispatch("drop", makeDropEventFromMouseEvent(e, dropTarget));
            if (!args.isDefaultPrevented()) {
              editor.undoManager.transact(() => {
                removeElementWithPadding(editor.dom, state3.element);
                editor.insertContent(editor.dom.getOuterHTML(targetClone));
                editor._selectionOverrides.hideFakeCaret();
              });
            }
          }
          editor.dispatch("dragend", makeDragendEventFromMouseEvent(e, editor.getBody()));
        }
      });
      removeDragState(state2);
    };
    const stopDragging = (state2, editor, e) => {
      state2.on((state3) => {
        state3.intervalId.clear();
        if (state3.dragging) {
          const event = e.fold(() => makeDragendEvent(state3.element), (mouseEvent) => makeDragendEventFromMouseEvent(mouseEvent, state3.element));
          editor.dispatch("dragend", event);
        }
      });
      removeDragState(state2);
    };
    const stop = (state2, editor) => (e) => stopDragging(state2, editor, Optional.some(e));
    const removeDragState = (state2) => {
      state2.on((state3) => {
        state3.intervalId.clear();
        removeElement(state3.ghost);
      });
      state2.clear();
    };
    const bindFakeDragEvents = (editor) => {
      const state2 = value$2();
      const pageDom = DOMUtils.DOM;
      const rootDocument = document;
      const dragStartHandler = start2(state2, editor);
      const dragHandler = move(state2, editor);
      const dropHandler = drop2(state2, editor);
      const dragEndHandler = stop(state2, editor);
      editor.on("mousedown", dragStartHandler);
      editor.on("mousemove", dragHandler);
      editor.on("mouseup", dropHandler);
      pageDom.bind(rootDocument, "mousemove", dragHandler);
      pageDom.bind(rootDocument, "mouseup", dragEndHandler);
      editor.on("remove", () => {
        pageDom.unbind(rootDocument, "mousemove", dragHandler);
        pageDom.unbind(rootDocument, "mouseup", dragEndHandler);
      });
      editor.on("keydown", (e) => {
        if (e.keyCode === VK.ESC) {
          stopDragging(state2, editor, Optional.none());
        }
      });
    };
    const blockUnsupportedFileDrop = (editor) => {
      const preventFileDrop = (e) => {
        if (!e.isDefaultPrevented()) {
          const dataTransfer = e.dataTransfer;
          if (dataTransfer && (contains$2(dataTransfer.types, "Files") || dataTransfer.files.length > 0)) {
            e.preventDefault();
            if (e.type === "drop") {
              displayError(editor, "Dropped file type is not supported");
            }
          }
        }
      };
      const preventFileDropIfUIElement = (e) => {
        if (isUIElement(editor, e.target)) {
          preventFileDrop(e);
        }
      };
      const setup2 = () => {
        const pageDom = DOMUtils.DOM;
        const dom2 = editor.dom;
        const doc = document;
        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();
        const eventNames = [
          "drop",
          "dragover"
        ];
        each$e(eventNames, (name3) => {
          pageDom.bind(doc, name3, preventFileDropIfUIElement);
          dom2.bind(editorRoot, name3, preventFileDrop);
        });
        editor.on("remove", () => {
          each$e(eventNames, (name3) => {
            pageDom.unbind(doc, name3, preventFileDropIfUIElement);
            dom2.unbind(editorRoot, name3, preventFileDrop);
          });
        });
      };
      editor.on("init", () => {
        Delay.setEditorTimeout(editor, setup2, 0);
      });
    };
    const init$2 = (editor) => {
      bindFakeDragEvents(editor);
      if (shouldBlockUnsupportedDrop(editor)) {
        blockUnsupportedFileDrop(editor);
      }
    };
    const setup$4 = (editor) => {
      const renderFocusCaret = first$1(() => {
        if (!editor.removed && editor.getBody().contains(document.activeElement)) {
          const rng = editor.selection.getRng();
          if (rng.collapsed) {
            const caretRange = renderRangeCaret(editor, rng, false);
            editor.selection.setRng(caretRange);
          }
        }
      }, 0);
      editor.on("focus", () => {
        renderFocusCaret.throttle();
      });
      editor.on("blur", () => {
        renderFocusCaret.cancel();
      });
    };
    const setup$3 = (editor) => {
      editor.on("init", () => {
        editor.on("focusin", (e) => {
          const target = e.target;
          if (isMedia$2(target)) {
            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);
            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;
            if (editor.selection.getNode() !== node) {
              selectNode(editor, node).each((rng) => editor.selection.setRng(rng));
            }
          }
        });
      });
    };
    const isContentEditableFalse = isContentEditableFalse$b;
    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);
    const SelectionOverrides = (editor) => {
      const selection = editor.selection, dom2 = editor.dom;
      const rootNode = editor.getBody();
      const fakeCaret = FakeCaret(editor, rootNode, dom2.isBlock, () => hasFocus(editor));
      const realSelectionId = "sel-" + dom2.uniqueId();
      const elementSelectionAttr2 = "data-mce-selected";
      let selectedElement;
      const isFakeSelectionElement = (node) => isNonNullable(node) && dom2.hasClass(node, "mce-offscreen-selection");
      const isFakeSelectionTargetElement = (node) => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom2.isChildOf(node, rootNode) && dom2.isEditable(node.parentNode);
      const setRange = (range2) => {
        if (range2) {
          selection.setRng(range2);
        }
      };
      const showCaret2 = (direction, node, before2, scrollIntoView = true) => {
        const e = editor.dispatch("ShowCaret", {
          target: node,
          direction,
          before: before2
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        if (scrollIntoView) {
          selection.scrollIntoView(node, direction === -1);
        }
        return fakeCaret.show(before2, node);
      };
      const showBlockCaretContainer2 = (blockCaretContainer) => {
        if (blockCaretContainer.hasAttribute("data-mce-caret")) {
          showCaretContainerBlock(blockCaretContainer);
          selection.scrollIntoView(blockCaretContainer);
        }
      };
      const registerEvents2 = () => {
        editor.on("click", (e) => {
          if (!dom2.isEditable(e.target)) {
            e.preventDefault();
            editor.focus();
          }
        });
        editor.on("blur NewBlock", removeElementSelection);
        editor.on("ResizeWindow FullscreenStateChanged", fakeCaret.reposition);
        editor.on("tap", (e) => {
          const targetElm = e.target;
          const contentEditableRoot = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(contentEditableRoot)) {
            e.preventDefault();
            selectNode(editor, contentEditableRoot).each(setElementSelection);
          } else if (isFakeSelectionTargetElement(targetElm)) {
            selectNode(editor, targetElm).each(setElementSelection);
          }
        }, true);
        editor.on("mousedown", (e) => {
          const targetElm = e.target;
          if (targetElm !== rootNode && targetElm.nodeName !== "HTML" && !dom2.isChildOf(targetElm, rootNode)) {
            return;
          }
          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {
            return;
          }
          removeElementSelection();
          hideFakeCaret();
          const closestContentEditable = getContentEditableRoot(editor, targetElm);
          if (isContentEditableFalse(closestContentEditable)) {
            e.preventDefault();
            selectNode(editor, closestContentEditable).each(setElementSelection);
          } else {
            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each((caretInfo) => {
              e.preventDefault();
              const range2 = showCaret2(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);
              setRange(range2);
              if (isElement$6(closestContentEditable)) {
                closestContentEditable.focus();
              } else {
                editor.getBody().focus();
              }
            });
          }
        });
        editor.on("keypress", (e) => {
          if (VK.modifierPressed(e)) {
            return;
          }
          if (isContentEditableFalse(selection.getNode())) {
            e.preventDefault();
          }
        });
        editor.on("GetSelectionRange", (e) => {
          let rng = e.range;
          if (selectedElement) {
            if (!selectedElement.parentNode) {
              selectedElement = null;
              return;
            }
            rng = rng.cloneRange();
            rng.selectNode(selectedElement);
            e.range = rng;
          }
        });
        editor.on("SetSelectionRange", (e) => {
          e.range = normalizeVoidElementSelection(e.range);
          const rng = setElementSelection(e.range, e.forward);
          if (rng) {
            e.range = rng;
          }
        });
        const isPasteBin2 = (node) => isElement$6(node) && node.id === "mcepastebin";
        editor.on("AfterSetSelectionRange", (e) => {
          const rng = e.range;
          const parent2 = rng.startContainer.parentElement;
          if (!isRangeInCaretContainer(rng) && !isPasteBin2(parent2)) {
            hideFakeCaret();
          }
          if (!isFakeSelectionElement(parent2)) {
            removeElementSelection();
          }
        });
        init$2(editor);
        setup$4(editor);
        setup$3(editor);
      };
      const isWithinCaretContainer = (node) => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);
      const isRangeInCaretContainer = (rng) => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);
      const normalizeVoidElementSelection = (rng) => {
        const voidElements = editor.schema.getVoidElements();
        const newRng = dom2.createRng();
        const startContainer = rng.startContainer;
        const startOffset = rng.startOffset;
        const endContainer = rng.endContainer;
        const endOffset = rng.endOffset;
        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {
          if (startOffset === 0) {
            newRng.setStartBefore(startContainer);
          } else {
            newRng.setStartAfter(startContainer);
          }
        } else {
          newRng.setStart(startContainer, startOffset);
        }
        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {
          if (endOffset === 0) {
            newRng.setEndBefore(endContainer);
          } else {
            newRng.setEndAfter(endContainer);
          }
        } else {
          newRng.setEnd(endContainer, endOffset);
        }
        return newRng;
      };
      const setupOffscreenSelection = (node, targetClone) => {
        const body = SugarElement.fromDom(editor.getBody());
        const doc = editor.getDoc();
        const realSelectionContainer = descendant(body, "#" + realSelectionId).getOrThunk(() => {
          const newContainer = SugarElement.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', doc);
          set$3(newContainer, "id", realSelectionId);
          append$1(body, newContainer);
          return newContainer;
        });
        const newRange = dom2.createRng();
        empty(realSelectionContainer);
        append2(realSelectionContainer, [
          SugarElement.fromText(nbsp, doc),
          SugarElement.fromDom(targetClone),
          SugarElement.fromText(nbsp, doc)
        ]);
        newRange.setStart(realSelectionContainer.dom.firstChild, 1);
        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);
        setAll(realSelectionContainer, { top: dom2.getPos(node, editor.getBody()).y + "px" });
        focus$1(realSelectionContainer);
        const sel = selection.getSel();
        if (sel) {
          sel.removeAllRanges();
          sel.addRange(newRange);
        }
        return newRange;
      };
      const selectElement = (elm) => {
        const targetClone = elm.cloneNode(true);
        const e = editor.dispatch("ObjectSelected", {
          target: elm,
          targetClone
        });
        if (e.isDefaultPrevented()) {
          return null;
        }
        const range2 = setupOffscreenSelection(elm, e.targetClone);
        const nodeElm = SugarElement.fromDom(elm);
        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr2}]`), (elm2) => {
          if (!eq(nodeElm, elm2)) {
            remove$b(elm2, elementSelectionAttr2);
          }
        });
        if (!dom2.getAttrib(elm, elementSelectionAttr2)) {
          elm.setAttribute(elementSelectionAttr2, "1");
        }
        selectedElement = elm;
        hideFakeCaret();
        return range2;
      };
      const setElementSelection = (range2, forward) => {
        if (!range2) {
          return null;
        }
        if (range2.collapsed) {
          if (!isRangeInCaretContainer(range2)) {
            const dir = forward ? 1 : -1;
            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range2);
            const beforeNode = caretPosition.getNode(!forward);
            if (isNonNullable(beforeNode)) {
              if (isFakeCaretTarget(beforeNode)) {
                return showCaret2(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);
              }
              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {
                const rng = dom2.createRng();
                rng.setStart(beforeNode, 0);
                rng.setEnd(beforeNode, 0);
                return rng;
              }
            }
            const afterNode = caretPosition.getNode(forward);
            if (isNonNullable(afterNode)) {
              if (isFakeCaretTarget(afterNode)) {
                return showCaret2(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);
              }
              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {
                const rng = dom2.createRng();
                rng.setStart(afterNode, 1);
                rng.setEnd(afterNode, 1);
                return rng;
              }
            }
          }
          return null;
        }
        let startContainer = range2.startContainer;
        let startOffset = range2.startOffset;
        const endOffset = range2.endOffset;
        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {
          startContainer = startContainer.parentNode;
          startOffset = dom2.nodeIndex(startContainer);
          startContainer = startContainer.parentNode;
        }
        if (!isElement$6(startContainer)) {
          return null;
        }
        if (endOffset === startOffset + 1 && startContainer === range2.endContainer) {
          const node = startContainer.childNodes[startOffset];
          if (isFakeSelectionTargetElement(node)) {
            return selectElement(node);
          }
        }
        return null;
      };
      const removeElementSelection = () => {
        if (selectedElement) {
          selectedElement.removeAttribute(elementSelectionAttr2);
        }
        descendant(SugarElement.fromDom(editor.getBody()), "#" + realSelectionId).each(remove$6);
        selectedElement = null;
      };
      const destroy3 = () => {
        fakeCaret.destroy();
        selectedElement = null;
      };
      const hideFakeCaret = () => {
        fakeCaret.hide();
      };
      if (!isRtc(editor)) {
        registerEvents2();
      }
      return {
        showCaret: showCaret2,
        showBlockCaretContainer: showBlockCaretContainer2,
        hideFakeCaret,
        destroy: destroy3
      };
    };
    const getNormalizedTextOffset = (container, offset2) => {
      let normalizedOffset = offset2;
      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {
        normalizedOffset += node.data.length;
      }
      return normalizedOffset;
    };
    const generatePath = (dom2, root2, node, offset2, normalized) => {
      if (isText$a(node) && (offset2 < 0 || offset2 > node.data.length)) {
        return [];
      }
      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset2)] : [offset2];
      let current = node;
      while (current !== root2 && current.parentNode) {
        p.push(dom2.nodeIndex(current, normalized));
        current = current.parentNode;
      }
      return current === root2 ? p.reverse() : [];
    };
    const generatePathRange = (dom2, root2, startNode, startOffset, endNode, endOffset, normalized = false) => {
      const start3 = generatePath(dom2, root2, startNode, startOffset, normalized);
      const end3 = generatePath(dom2, root2, endNode, endOffset, normalized);
      return {
        start: start3,
        end: end3
      };
    };
    const resolvePath = (root2, path2) => {
      const nodePath = path2.slice();
      const offset2 = nodePath.pop();
      if (!isNumber2(offset2)) {
        return Optional.none();
      } else {
        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind((node) => Optional.from(node.childNodes[index])), Optional.some(root2));
        return resolvedNode.bind((node) => {
          if (isText$a(node) && (offset2 < 0 || offset2 > node.data.length)) {
            return Optional.none();
          } else {
            return Optional.some({
              node,
              offset: offset2
            });
          }
        });
      }
    };
    const resolvePathRange = (root2, range2) => resolvePath(root2, range2.start).bind(({
      node: startNode,
      offset: startOffset
    }) => resolvePath(root2, range2.end).map(({
      node: endNode,
      offset: endOffset
    }) => {
      const rng = document.createRange();
      rng.setStart(startNode, startOffset);
      rng.setEnd(endNode, endOffset);
      return rng;
    }));
    const generatePathRangeFromRange = (dom2, root2, range2, normalized = false) => generatePathRange(dom2, root2, range2.startContainer, range2.startOffset, range2.endContainer, range2.endOffset, normalized);
    const cleanEmptyNodes = (dom2, node, isRoot2) => {
      if (node && dom2.isEmpty(node) && !isRoot2(node)) {
        const parent2 = node.parentNode;
        dom2.remove(node);
        cleanEmptyNodes(dom2, parent2, isRoot2);
      }
    };
    const deleteRng = (dom2, rng, isRoot2, clean = true) => {
      const startParent = rng.startContainer.parentNode;
      const endParent = rng.endContainer.parentNode;
      rng.deleteContents();
      if (clean && !isRoot2(rng.startContainer)) {
        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {
          dom2.remove(rng.startContainer);
        }
        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {
          dom2.remove(rng.endContainer);
        }
        cleanEmptyNodes(dom2, startParent, isRoot2);
        if (startParent !== endParent) {
          cleanEmptyNodes(dom2, endParent, isRoot2);
        }
      }
    };
    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));
    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {
      const dynamicPatterns = patternSet.dynamicPatternsLookup({
        text: beforeText,
        block
      });
      return {
        ...patternSet,
        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),
        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)
      };
    };
    const getBeforeText = (dom2, block, node, offset2) => {
      const rng = dom2.createRng();
      rng.setStart(block, 0);
      rng.setEnd(node, offset2);
      return rng.toString();
    };
    const startsWithSingleSpace = (s) => /^\s[^\s]/.test(s);
    const stripPattern = (dom2, block, pattern) => {
      const firstTextNode = textAfter(block, 0, block);
      firstTextNode.each((spot) => {
        const node = spot.container;
        scanRight(node, pattern.start.length, block).each((end3) => {
          const rng = dom2.createRng();
          rng.setStart(node, 0);
          rng.setEnd(end3.container, end3.offset);
          deleteRng(dom2, rng, (e) => e === block);
        });
        const text3 = SugarElement.fromDom(node);
        const textContent = get$3(text3);
        if (startsWithSingleSpace(textContent)) {
          set(text3, textContent.slice(1));
        }
      });
    };
    const applyPattern$1 = (editor, match2) => {
      const dom2 = editor.dom;
      const pattern = match2.pattern;
      const rng = resolvePathRange(dom2.getRoot(), match2.range).getOrDie("Unable to resolve path range");
      const isBlockFormatName = (name3, formatter) => {
        const formatSet = formatter.get(name3);
        return isArray$12(formatSet) && head(formatSet).exists((format) => has$2(format, "block"));
      };
      getParentBlock(editor, rng).each((block) => {
        if (pattern.type === "block-format") {
          if (isBlockFormatName(pattern.format, editor.formatter)) {
            editor.undoManager.transact(() => {
              stripPattern(editor.dom, block, pattern);
              editor.formatter.apply(pattern.format);
            });
          }
        } else if (pattern.type === "block-command") {
          editor.undoManager.transact(() => {
            stripPattern(editor.dom, block, pattern);
            editor.execCommand(pattern.cmd, false, pattern.value);
          });
        }
      });
      return true;
    };
    const sortPatterns$1 = (patterns) => sort(patterns, (a, b) => b.start.length - a.start.length);
    const findPattern$1 = (patterns, text3) => {
      const sortedPatterns = sortPatterns$1(patterns);
      const nuText = text3.replace(nbsp, " ");
      return find$2(sortedPatterns, (pattern) => text3.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);
    };
    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {
      var _a;
      const dom2 = editor.dom;
      const forcedRootBlock = getForcedRootBlock(editor);
      if (!dom2.is(block, forcedRootBlock)) {
        return [];
      }
      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : "";
      return findPattern$1(patternSet.blockPatterns, blockText).map((pattern) => {
        if (Tools.trim(blockText).length === pattern.start.length) {
          return [];
        }
        return [{
          pattern,
          range: generatePathRange(dom2, dom2.getRoot(), block, 0, block, 0, normalizedMatches)
        }];
      }).getOr([]);
    };
    const applyMatches$1 = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const bookmark = editor.selection.getBookmark();
      each$e(matches, (match2) => applyPattern$1(editor, match2));
      editor.selection.moveToBookmark(bookmark);
    };
    const newMarker = (dom2, id) => dom2.create("span", {
      "data-mce-type": "bookmark",
      id
    });
    const rangeFromMarker = (dom2, marker) => {
      const rng = dom2.createRng();
      rng.setStartAfter(marker.start);
      rng.setEndBefore(marker.end);
      return rng;
    };
    const createMarker = (dom2, markerPrefix, pathRange) => {
      const rng = resolvePathRange(dom2.getRoot(), pathRange).getOrDie("Unable to resolve path range");
      const startNode = rng.startContainer;
      const endNode = rng.endContainer;
      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);
      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);
      const startParentNode = textStart.parentNode;
      const endParentNode = textEnd.parentNode;
      return {
        prefix: markerPrefix,
        end: endParentNode.insertBefore(newMarker(dom2, markerPrefix + "-end"), textEnd),
        start: startParentNode.insertBefore(newMarker(dom2, markerPrefix + "-start"), textStart)
      };
    };
    const removeMarker = (dom2, marker, isRoot2) => {
      cleanEmptyNodes(dom2, dom2.get(marker.prefix + "-end"), isRoot2);
      cleanEmptyNodes(dom2, dom2.get(marker.prefix + "-start"), isRoot2);
    };
    const isReplacementPattern = (pattern) => pattern.start.length === 0;
    const matchesPattern = (patternContent) => (element, offset2) => {
      const text3 = element.data;
      const searchText = text3.substring(0, offset2);
      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));
      const startIndex = searchText.lastIndexOf(patternContent);
      if (startIndex !== -1) {
        return startIndex + patternContent.length;
      } else if (startEndIndex !== -1) {
        return startEndIndex + 1;
      } else {
        return -1;
      }
    };
    const findPatternStartFromSpot = (dom2, pattern, block, spot) => {
      const startPattern = pattern.start;
      const startSpot = repeatLeft(dom2, spot.container, spot.offset, matchesPattern(startPattern), block);
      return startSpot.bind((spot2) => {
        var _a, _b;
        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;
        const isCompleteMatch = startPatternIndex !== -1 && spot2.offset >= startPatternIndex + startPattern.length;
        if (isCompleteMatch) {
          const rng = dom2.createRng();
          rng.setStart(spot2.container, spot2.offset - startPattern.length);
          rng.setEnd(spot2.container, spot2.offset);
          return Optional.some(rng);
        } else {
          const offset2 = spot2.offset - startPattern.length;
          return scanLeft(spot2.container, offset2, block).map((nextSpot) => {
            const rng = dom2.createRng();
            rng.setStart(nextSpot.container, nextSpot.offset);
            rng.setEnd(spot2.container, spot2.offset);
            return rng;
          }).filter((rng) => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom2, pattern, block, point(spot2.container, 0)));
        }
      });
    };
    const findPatternStart = (dom2, pattern, node, offset2, block, requireGap = false) => {
      if (pattern.start.length === 0 && !requireGap) {
        const rng = dom2.createRng();
        rng.setStart(node, offset2);
        rng.setEnd(node, offset2);
        return Optional.some(rng);
      }
      return textBefore(node, offset2, block).bind((spot) => {
        const start3 = findPatternStartFromSpot(dom2, pattern, block, spot);
        return start3.bind((startRange) => {
          var _a;
          if (requireGap) {
            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {
              return Optional.none();
            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {
              return Optional.none();
            }
          }
          return Optional.some(startRange);
        });
      });
    };
    const findPattern = (editor, block, details, normalizedMatches) => {
      const dom2 = editor.dom;
      const root2 = dom2.getRoot();
      const pattern = details.pattern;
      const endNode = details.position.container;
      const endOffset = details.position.offset;
      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind((spot) => {
        const endPathRng = generatePathRange(dom2, root2, spot.container, spot.offset, endNode, endOffset, normalizedMatches);
        if (isReplacementPattern(pattern)) {
          return Optional.some({
            matches: [{
              pattern,
              startRng: endPathRng,
              endRng: endPathRng
            }],
            position: spot
          });
        } else {
          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);
          const results = resultsOpt.getOr({
            matches: [],
            position: spot
          });
          const pos = results.position;
          const start3 = findPatternStart(dom2, pattern, pos.container, pos.offset, block, resultsOpt.isNone());
          return start3.map((startRng) => {
            const startPathRng = generatePathRangeFromRange(dom2, root2, startRng, normalizedMatches);
            return {
              matches: results.matches.concat([{
                pattern,
                startRng: startPathRng,
                endRng: endPathRng
              }]),
              position: point(startRng.startContainer, startRng.startOffset)
            };
          });
        }
      });
    };
    const findPatternsRec = (editor, patterns, node, offset2, block, normalizedMatches) => {
      const dom2 = editor.dom;
      return textBefore(node, offset2, dom2.getRoot()).bind((endSpot) => {
        const text3 = getBeforeText(dom2, block, node, offset2);
        for (let i = 0; i < patterns.length; i++) {
          const pattern = patterns[i];
          if (!endsWith2(text3, pattern.end)) {
            continue;
          }
          const patternsWithoutCurrent = patterns.slice();
          patternsWithoutCurrent.splice(i, 1);
          const result = findPattern(editor, block, {
            pattern,
            remainingPatterns: patternsWithoutCurrent,
            position: endSpot
          }, normalizedMatches);
          if (result.isNone() && offset2 > 0) {
            return findPatternsRec(editor, patterns, node, offset2 - 1, block, normalizedMatches);
          }
          if (result.isSome()) {
            return result;
          }
        }
        return Optional.none();
      });
    };
    const applyPattern = (editor, pattern, patternRange) => {
      editor.selection.setRng(patternRange);
      if (pattern.type === "inline-format") {
        each$e(pattern.format, (format) => {
          editor.formatter.apply(format);
        });
      } else {
        editor.execCommand(pattern.cmd, false, pattern.value);
      }
    };
    const applyReplacementPattern = (editor, pattern, marker, isRoot2) => {
      const markerRange = rangeFromMarker(editor.dom, marker);
      deleteRng(editor.dom, markerRange, isRoot2);
      applyPattern(editor, pattern, markerRange);
    };
    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot2) => {
      const dom2 = editor.dom;
      const markerEndRange = rangeFromMarker(dom2, endMarker);
      const markerStartRange = rangeFromMarker(dom2, startMarker);
      deleteRng(dom2, markerStartRange, isRoot2);
      deleteRng(dom2, markerEndRange, isRoot2);
      const patternMarker = {
        prefix: startMarker.prefix,
        start: startMarker.end,
        end: endMarker.start
      };
      const patternRange = rangeFromMarker(dom2, patternMarker);
      applyPattern(editor, pattern, patternRange);
    };
    const addMarkers = (dom2, matches) => {
      const markerPrefix = generate$1("mce_textpattern");
      const matchesWithEnds = foldr(matches, (acc, match2) => {
        const endMarker = createMarker(dom2, markerPrefix + `_end${acc.length}`, match2.endRng);
        return acc.concat([{
          ...match2,
          endMarker
        }]);
      }, []);
      return foldr(matchesWithEnds, (acc, match2) => {
        const idx = matchesWithEnds.length - acc.length - 1;
        const startMarker = isReplacementPattern(match2.pattern) ? match2.endMarker : createMarker(dom2, markerPrefix + `_start${idx}`, match2.startRng);
        return acc.concat([{
          ...match2,
          startMarker
        }]);
      }, []);
    };
    const sortPatterns = (patterns) => sort(patterns, (a, b) => b.end.length - a.end.length);
    const getBestMatches = (matches, matchesWithSortedPatterns) => {
      const hasSameMatches = forall(matches, (match2) => exists(matchesWithSortedPatterns, (sortedMatch) => match2.pattern.start === sortedMatch.pattern.start && match2.pattern.end === sortedMatch.pattern.end));
      if (matches.length === matchesWithSortedPatterns.length) {
        if (hasSameMatches) {
          return matches;
        } else {
          return matchesWithSortedPatterns;
        }
      }
      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;
    };
    const findPatterns = (editor, block, node, offset2, patternSet, normalizedMatches) => {
      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset2, block, normalizedMatches).fold(() => [], (result) => result.matches);
      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset2, block, normalizedMatches).fold(() => [], (result) => result.matches);
      return getBestMatches(matches, matchesWithSortedPatterns);
    };
    const applyMatches = (editor, matches) => {
      if (matches.length === 0) {
        return;
      }
      const dom2 = editor.dom;
      const bookmark = editor.selection.getBookmark();
      const matchesWithMarkers = addMarkers(dom2, matches);
      each$e(matchesWithMarkers, (match2) => {
        const block = dom2.getParent(match2.startMarker.start, dom2.isBlock);
        const isRoot2 = (node) => node === block;
        if (isReplacementPattern(match2.pattern)) {
          applyReplacementPattern(editor, match2.pattern, match2.endMarker, isRoot2);
        } else {
          applyPatternWithContent(editor, match2.pattern, match2.startMarker, match2.endMarker, isRoot2);
        }
        removeMarker(dom2, match2.endMarker, isRoot2);
        removeMarker(dom2, match2.startMarker, isRoot2);
      });
      editor.selection.moveToBookmark(bookmark);
    };
    const handleEnter = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      return getParentBlock(editor, rng).map((block) => {
        var _a;
        const offset2 = Math.max(0, rng.startOffset);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : "");
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset2, dynamicPatternSet, true);
        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);
        if (blockMatches.length > 0 || inlineMatches.length > 0) {
          editor.undoManager.add();
          editor.undoManager.extra(() => {
            editor.execCommand("mceInsertNewLine");
          }, () => {
            editor.insertContent(zeroWidth);
            applyMatches(editor, inlineMatches);
            applyMatches$1(editor, blockMatches);
            const range2 = editor.selection.getRng();
            const spot = textBefore(range2.startContainer, range2.startOffset, editor.dom.getRoot());
            editor.execCommand("mceInsertNewLine");
            spot.each((s) => {
              const node = s.container;
              if (node.data.charAt(s.offset - 1) === zeroWidth) {
                node.deleteData(s.offset - 1, 1);
                cleanEmptyNodes(editor.dom, node.parentNode, (e) => e === editor.dom.getRoot());
              }
            });
          });
          return true;
        }
        return false;
      }).getOr(false);
    };
    const handleInlineKey = (editor, patternSet) => {
      const rng = editor.selection.getRng();
      getParentBlock(editor, rng).map((block) => {
        const offset2 = Math.max(0, rng.startOffset - 1);
        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset2);
        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);
        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset2, dynamicPatternSet, false);
        if (inlineMatches.length > 0) {
          editor.undoManager.transact(() => {
            applyMatches(editor, inlineMatches);
          });
        }
      });
    };
    const checkKeyEvent = (codes, event, predicate) => {
      for (let i = 0; i < codes.length; i++) {
        if (predicate(codes[i], event)) {
          return true;
        }
      }
      return false;
    };
    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event2) => {
      return code === event2.keyCode && !VK.modifierPressed(event2);
    });
    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event2) => {
      return chr.charCodeAt(0) === event2.charCode;
    });
    const setup$2 = (editor) => {
      const charCodes = [
        ",",
        ".",
        ";",
        ":",
        "!",
        "?"
      ];
      const keyCodes = [32];
      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));
      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);
      editor.on("keydown", (e) => {
        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns && handleEnter(editor, patternSet)) {
            e.preventDefault();
          }
        }
      }, true);
      const handleInlineTrigger = () => {
        if (editor.selection.isCollapsed()) {
          const patternSet = getPatternSet();
          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();
          if (hasPatterns) {
            handleInlineKey(editor, patternSet);
          }
        }
      };
      editor.on("keyup", (e) => {
        if (checkKeyCode(keyCodes, e)) {
          handleInlineTrigger();
        }
      });
      editor.on("keypress", (e) => {
        if (checkCharCode(charCodes, e)) {
          Delay.setEditorTimeout(editor, handleInlineTrigger);
        }
      });
    };
    const setup$1 = (editor) => {
      setup$2(editor);
    };
    const Quirks = (editor) => {
      const each2 = Tools.each;
      const BACKSPACE = VK.BACKSPACE, DELETE2 = VK.DELETE, dom2 = editor.dom, selection = editor.selection, parser = editor.parser;
      const browser3 = Env.browser;
      const isGecko = browser3.isFirefox();
      const isWebKit = browser3.isChromium() || browser3.isSafari();
      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      const setEditorCommandState2 = (cmd, state2) => {
        try {
          editor.getDoc().execCommand(cmd, false, String(state2));
        } catch (ex) {
        }
      };
      const isDefaultPrevented = (e) => {
        return e.isDefaultPrevented();
      };
      const emptyEditorWhenDeleting = () => {
        const serializeRng = (rng) => {
          const body = dom2.create("body");
          const contents = rng.cloneContents();
          body.appendChild(contents);
          return selection.serializer.serialize(body, { format: "html" });
        };
        const allContentsSelected = (rng) => {
          const selection2 = serializeRng(rng);
          const allRng = dom2.createRng();
          allRng.selectNode(editor.getBody());
          const allSelection = serializeRng(allRng);
          return selection2 === allSelection;
        };
        editor.on("keydown", (e) => {
          const keyCode = e.keyCode;
          if (!isDefaultPrevented(e) && (keyCode === DELETE2 || keyCode === BACKSPACE) && editor.selection.isEditable()) {
            const isCollapsed = editor.selection.isCollapsed();
            const body = editor.getBody();
            if (isCollapsed && !dom2.isEmpty(body)) {
              return;
            }
            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {
              return;
            }
            e.preventDefault();
            editor.setContent("");
            if (body.firstChild && dom2.isBlock(body.firstChild)) {
              editor.selection.setCursorLocation(body.firstChild, 0);
            } else {
              editor.selection.setCursorLocation(body, 0);
            }
            editor.nodeChanged();
          }
        });
      };
      const selectAll = () => {
        editor.shortcuts.add("meta+a", null, "SelectAll");
      };
      const documentElementEditingFocus = () => {
        if (!editor.inline) {
          dom2.bind(editor.getDoc(), "mousedown mouseup", (e) => {
            let rng;
            if (e.target === editor.getDoc().documentElement) {
              rng = selection.getRng();
              editor.getBody().focus();
              if (e.type === "mousedown") {
                if (isCaretContainer$2(rng.startContainer)) {
                  return;
                }
                selection.placeCaretAt(e.clientX, e.clientY);
              } else {
                selection.setRng(rng);
              }
            }
          });
        }
      };
      const removeHrOnBackspace = () => {
        editor.on("keydown", (e) => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (!editor.getBody().getElementsByTagName("hr").length) {
              return;
            }
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const node = selection.getNode();
              const previousSibling = node.previousSibling;
              if (node.nodeName === "HR") {
                dom2.remove(node);
                e.preventDefault();
                return;
              }
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "hr") {
                dom2.remove(previousSibling);
                e.preventDefault();
              }
            }
          }
        });
      };
      const focusBody2 = () => {
        if (!Range.prototype.getClientRects) {
          editor.on("mousedown", (e) => {
            if (!isDefaultPrevented(e) && e.target.nodeName === "HTML") {
              const body = editor.getBody();
              body.blur();
              Delay.setEditorTimeout(editor, () => {
                body.focus();
              });
            }
          });
        }
      };
      const selectControlElements = () => {
        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);
        editor.on("click", (e) => {
          const target = e.target;
          if (/^(IMG|HR)$/.test(target.nodeName) && dom2.isEditable(target.parentNode)) {
            e.preventDefault();
            editor.selection.select(target);
            editor.nodeChanged();
          }
          if (target.nodeName === "A" && dom2.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom2.isEditable(target.parentNode)) {
            e.preventDefault();
            selection.select(target);
          }
        });
      };
      const removeStylesWhenDeletingAcrossBlockElements = () => {
        const getAttributeApplyFunction = () => {
          const template = dom2.getAttribs(selection.getStart().cloneNode(false));
          return () => {
            const target = selection.getStart();
            if (target !== editor.getBody()) {
              dom2.setAttrib(target, "style", null);
              each2(template, (attr2) => {
                target.setAttributeNode(attr2.cloneNode(true));
              });
            }
          };
        };
        const isSelectionAcrossElements = () => {
          return !selection.isCollapsed() && dom2.getParent(selection.getStart(), dom2.isBlock) !== dom2.getParent(selection.getEnd(), dom2.isBlock);
        };
        editor.on("keypress", (e) => {
          let applyAttributes2;
          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {
            applyAttributes2 = getAttributeApplyFunction();
            editor.getDoc().execCommand("delete", false);
            applyAttributes2();
            e.preventDefault();
            return false;
          } else {
            return true;
          }
        });
        dom2.bind(editor.getDoc(), "cut", (e) => {
          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {
            const applyAttributes2 = getAttributeApplyFunction();
            Delay.setEditorTimeout(editor, () => {
              applyAttributes2();
            });
          }
        });
      };
      const disableBackspaceIntoATable = () => {
        editor.on("keydown", (e) => {
          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {
            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {
              const previousSibling = selection.getNode().previousSibling;
              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === "table") {
                e.preventDefault();
                return false;
              }
            }
          }
          return true;
        });
      };
      const removeBlockQuoteOnBackSpace = () => {
        editor.on("keydown", (e) => {
          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {
            return;
          }
          let rng = selection.getRng();
          const container = rng.startContainer;
          const offset2 = rng.startOffset;
          const root2 = dom2.getRoot();
          let parent2 = container;
          if (!rng.collapsed || offset2 !== 0) {
            return;
          }
          while (parent2.parentNode && parent2.parentNode.firstChild === parent2 && parent2.parentNode !== root2) {
            parent2 = parent2.parentNode;
          }
          if (parent2.nodeName === "BLOCKQUOTE") {
            editor.formatter.toggle("blockquote", void 0, parent2);
            rng = dom2.createRng();
            rng.setStart(container, 0);
            rng.setEnd(container, 0);
            selection.setRng(rng);
          }
        });
      };
      const setGeckoEditingOptions = () => {
        const setOpts = () => {
          setEditorCommandState2("StyleWithCSS", false);
          setEditorCommandState2("enableInlineTableEditing", false);
          if (!getObjectResizing(editor)) {
            setEditorCommandState2("enableObjectResizing", false);
          }
        };
        if (!isReadOnly$1(editor)) {
          editor.on("BeforeExecCommand mousedown", setOpts);
        }
      };
      const addBrAfterLastLinks = () => {
        const fixLinks = () => {
          each2(dom2.select("a:not([data-mce-block])"), (node) => {
            var _a;
            let parentNode = node.parentNode;
            const root2 = dom2.getRoot();
            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {
              while (parentNode && !dom2.isBlock(parentNode)) {
                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root2) {
                  return;
                }
                parentNode = parentNode.parentNode;
              }
              dom2.add(parentNode, "br", { "data-mce-bogus": 1 });
            }
          });
        };
        editor.on("SetContent ExecCommand", (e) => {
          if (e.type === "setcontent" || e.command === "mceInsertLink") {
            fixLinks();
          }
        });
      };
      const setDefaultBlockType = () => {
        editor.on("init", () => {
          setEditorCommandState2("DefaultParagraphSeparator", getForcedRootBlock(editor));
        });
      };
      const isAllContentSelected = (editor2) => {
        const body = editor2.getBody();
        const rng = editor2.selection.getRng();
        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;
      };
      const normalizeSelection2 = () => {
        editor.on("keyup focusin mouseup", (e) => {
          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {
            selection.normalize();
          }
        }, true);
      };
      const showBrokenImageIcon = () => {
        editor.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
      };
      const restoreFocusOnKeyDown = () => {
        if (!editor.inline) {
          editor.on("keydown", () => {
            if (document.activeElement === document.body) {
              editor.getWin().focus();
            }
          });
        }
      };
      const bodyHeight = () => {
        if (!editor.inline) {
          editor.contentStyles.push("body {min-height: 150px}");
          editor.on("click", (e) => {
            let rng;
            if (e.target.nodeName === "HTML") {
              rng = editor.selection.getRng();
              editor.getBody().focus();
              editor.selection.setRng(rng);
              editor.selection.normalize();
              editor.nodeChanged();
            }
          });
        }
      };
      const blockCmdArrowNavigation = () => {
        if (isMac) {
          editor.on("keydown", (e) => {
            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {
              e.preventDefault();
              const selection2 = editor.selection.getSel();
              selection2.modify("move", e.keyCode === 37 ? "backward" : "forward", "lineboundary");
            }
          });
        }
      };
      const tapLinksAndImages = () => {
        editor.on("click", (e) => {
          let elm = e.target;
          do {
            if (elm.tagName === "A") {
              e.preventDefault();
              return;
            }
          } while (elm = elm.parentNode);
        });
        editor.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
      };
      const blockFormSubmitInsideEditor = () => {
        editor.on("init", () => {
          editor.dom.bind(editor.getBody(), "submit", (e) => {
            e.preventDefault();
          });
        });
      };
      const removeAppleInterchangeBrs = () => {
        parser.addNodeFilter("br", (nodes) => {
          let i = nodes.length;
          while (i--) {
            if (nodes[i].attr("class") === "Apple-interchange-newline") {
              nodes[i].remove();
            }
          }
        });
      };
      const refreshContentEditable = noop2;
      const isHidden = () => {
        if (!isGecko || editor.removed) {
          return false;
        }
        const sel = editor.selection.getSel();
        return !sel || !sel.rangeCount || sel.rangeCount === 0;
      };
      const setupRtc = () => {
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          blockFormSubmitInsideEditor();
          selectAll();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          }
        }
        if (isGecko) {
          focusBody2();
          setGeckoEditingOptions();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
        }
      };
      const setup2 = () => {
        removeBlockQuoteOnBackSpace();
        emptyEditorWhenDeleting();
        if (!Env.windowsPhone) {
          normalizeSelection2();
        }
        if (isWebKit) {
          documentElementEditingFocus();
          selectControlElements();
          setDefaultBlockType();
          blockFormSubmitInsideEditor();
          disableBackspaceIntoATable();
          removeAppleInterchangeBrs();
          if (isiOS) {
            restoreFocusOnKeyDown();
            bodyHeight();
            tapLinksAndImages();
          } else {
            selectAll();
          }
        }
        if (isGecko) {
          removeHrOnBackspace();
          focusBody2();
          removeStylesWhenDeletingAcrossBlockElements();
          setGeckoEditingOptions();
          addBrAfterLastLinks();
          showBrokenImageIcon();
          blockCmdArrowNavigation();
          disableBackspaceIntoATable();
        }
      };
      if (isRtc(editor)) {
        setupRtc();
      } else {
        setup2();
      }
      return {
        refreshContentEditable,
        isHidden
      };
    };
    const DOM$6 = DOMUtils.DOM;
    const appendStyle = (editor, text3) => {
      const body = SugarElement.fromDom(editor.getBody());
      const container = getStyleContainer(getRootNode2(body));
      const style = SugarElement.fromTag("style");
      set$3(style, "type", "text/css");
      append$1(style, SugarElement.fromText(text3));
      append$1(container, style);
      editor.on("remove", () => {
        remove$6(style);
      });
    };
    const getRootName = (editor) => editor.inline ? editor.getElement().nodeName.toLowerCase() : void 0;
    const removeUndefined = (obj) => filter$4(obj, (v) => isUndefined2(v) === false);
    const mkParserSettings = (editor) => {
      const getOption2 = editor.options.get;
      const blobCache = editor.editorUpload.blobCache;
      return removeUndefined({
        allow_conditional_comments: getOption2("allow_conditional_comments"),
        allow_html_data_urls: getOption2("allow_html_data_urls"),
        allow_svg_data_urls: getOption2("allow_svg_data_urls"),
        allow_html_in_named_anchor: getOption2("allow_html_in_named_anchor"),
        allow_script_urls: getOption2("allow_script_urls"),
        allow_unsafe_link_target: getOption2("allow_unsafe_link_target"),
        convert_fonts_to_spans: getOption2("convert_fonts_to_spans"),
        fix_list_elements: getOption2("fix_list_elements"),
        font_size_legacy_values: getOption2("font_size_legacy_values"),
        forced_root_block: getOption2("forced_root_block"),
        forced_root_block_attrs: getOption2("forced_root_block_attrs"),
        preserve_cdata: getOption2("preserve_cdata"),
        remove_trailing_brs: getOption2("remove_trailing_brs"),
        inline_styles: getOption2("inline_styles"),
        root_name: getRootName(editor),
        sanitize: getOption2("xss_sanitization"),
        validate: true,
        blob_cache: blobCache,
        document: editor.getDoc()
      });
    };
    const mkSchemaSettings = (editor) => {
      const getOption2 = editor.options.get;
      return removeUndefined({
        custom_elements: getOption2("custom_elements"),
        extended_valid_elements: getOption2("extended_valid_elements"),
        invalid_elements: getOption2("invalid_elements"),
        invalid_styles: getOption2("invalid_styles"),
        schema: getOption2("schema"),
        valid_children: getOption2("valid_children"),
        valid_classes: getOption2("valid_classes"),
        valid_elements: getOption2("valid_elements"),
        valid_styles: getOption2("valid_styles"),
        verify_html: getOption2("verify_html"),
        padd_empty_block_inline_children: getOption2("format_empty_lines")
      });
    };
    const mkSerializerSettings = (editor) => {
      const getOption2 = editor.options.get;
      return {
        ...mkParserSettings(editor),
        ...mkSchemaSettings(editor),
        ...removeUndefined({
          url_converter: getOption2("url_converter"),
          url_converter_scope: getOption2("url_converter_scope"),
          element_format: getOption2("element_format"),
          entities: getOption2("entities"),
          entity_encoding: getOption2("entity_encoding"),
          indent: getOption2("indent"),
          indent_after: getOption2("indent_after"),
          indent_before: getOption2("indent_before")
        })
      };
    };
    const createParser = (editor) => {
      const parser = DomParser(mkParserSettings(editor), editor.schema);
      parser.addAttributeFilter("src,href,style,tabindex", (nodes, name3) => {
        const dom2 = editor.dom;
        const internalName = "data-mce-" + name3;
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          let value2 = node.attr(name3);
          if (value2 && !node.attr(internalName)) {
            if (value2.indexOf("data:") === 0 || value2.indexOf("blob:") === 0) {
              continue;
            }
            if (name3 === "style") {
              value2 = dom2.serializeStyle(dom2.parseStyle(value2), node.name);
              if (!value2.length) {
                value2 = null;
              }
              node.attr(internalName, value2);
              node.attr(name3, value2);
            } else if (name3 === "tabindex") {
              node.attr(internalName, value2);
              node.attr(name3, null);
            } else {
              node.attr(internalName, editor.convertURL(value2, name3, node.name));
            }
          }
        }
      });
      parser.addNodeFilter("script", (nodes) => {
        let i = nodes.length;
        while (i--) {
          const node = nodes[i];
          const type2 = node.attr("type") || "no/type";
          if (type2.indexOf("mce-") !== 0) {
            node.attr("type", "mce-" + type2);
          }
        }
      });
      if (shouldPreserveCData(editor)) {
        parser.addNodeFilter("#cdata", (nodes) => {
          var _a;
          let i = nodes.length;
          while (i--) {
            const node = nodes[i];
            node.type = 8;
            node.name = "#comment";
            node.value = "[CDATA[" + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : "") + "]]";
          }
        });
      }
      parser.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (nodes) => {
        let i = nodes.length;
        const nonEmptyElements = editor.schema.getNonEmptyElements();
        while (i--) {
          const node = nodes[i];
          if (node.isEmpty(nonEmptyElements) && node.getAll("br").length === 0) {
            node.append(new AstNode("br", 1));
          }
        }
      });
      return parser;
    };
    const autoFocus = (editor) => {
      const autoFocus2 = getAutoFocus(editor);
      if (autoFocus2) {
        Delay.setEditorTimeout(editor, () => {
          let focusEditor2;
          if (autoFocus2 === true) {
            focusEditor2 = editor;
          } else {
            focusEditor2 = editor.editorManager.get(autoFocus2);
          }
          if (focusEditor2 && !focusEditor2.destroyed) {
            focusEditor2.focus();
            focusEditor2.selection.scrollIntoView();
          }
        }, 100);
      }
    };
    const moveSelectionToFirstCaretPosition = (editor) => {
      const root2 = editor.dom.getRoot();
      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root2)) {
        firstPositionIn(root2).each((pos) => {
          const node = pos.getNode();
          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;
          editor.selection.setRng(caretPos.toRange());
        });
      }
    };
    const initEditor = (editor) => {
      editor.bindPendingEventDelegates();
      editor.initialized = true;
      fireInit(editor);
      editor.focus(true);
      moveSelectionToFirstCaretPosition(editor);
      editor.nodeChanged({ initial: true });
      const initInstanceCallback = getInitInstanceCallback(editor);
      if (isFunction2(initInstanceCallback)) {
        initInstanceCallback.call(editor, editor);
      }
      autoFocus(editor);
    };
    const getStyleSheetLoader$1 = (editor) => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;
    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {
      const promises = [getStyleSheetLoader$1(editor).loadAll(css)];
      if (editor.inline) {
        return promises;
      } else {
        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);
      }
    };
    const loadContentCss = (editor) => {
      const styleSheetLoader = getStyleSheetLoader$1(editor);
      const fontCss = getFontCss(editor);
      const css = editor.contentCSS;
      const removeCss = () => {
        styleSheetLoader.unloadAll(css);
        if (!editor.inline) {
          editor.ui.styleSheetLoader.unloadAll(fontCss);
        }
      };
      const loaded = () => {
        if (editor.removed) {
          removeCss();
        } else {
          editor.on("remove", removeCss);
        }
      };
      if (editor.contentStyles.length > 0) {
        let contentCssText = "";
        Tools.each(editor.contentStyles, (style) => {
          contentCssText += style + "\r\n";
        });
        editor.dom.addStyle(contentCssText);
      }
      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);
      const contentStyle = getContentStyle(editor);
      if (contentStyle) {
        appendStyle(editor, contentStyle);
      }
      return allStylesheets;
    };
    const preInit = (editor) => {
      const doc = editor.getDoc(), body = editor.getBody();
      firePreInit(editor);
      if (!shouldBrowserSpellcheck(editor)) {
        doc.body.spellcheck = false;
        DOM$6.setAttrib(body, "spellcheck", "false");
      }
      editor.quirks = Quirks(editor);
      firePostRender(editor);
      const directionality = getDirectionality(editor);
      if (directionality !== void 0) {
        body.dir = directionality;
      }
      const protect = getProtect(editor);
      if (protect) {
        editor.on("BeforeSetContent", (e) => {
          Tools.each(protect, (pattern) => {
            e.content = e.content.replace(pattern, (str) => {
              return "<!--mce:protected " + escape(str) + "-->";
            });
          });
        });
      }
      editor.on("SetContent", () => {
        editor.addVisual(editor.getBody());
      });
      editor.on("compositionstart compositionend", (e) => {
        editor.composing = e.type === "compositionstart";
      });
    };
    const loadInitialContent = (editor) => {
      if (!isRtc(editor)) {
        editor.load({
          initial: true,
          format: "html"
        });
      }
      editor.startContent = editor.getContent({ format: "raw" });
    };
    const initEditorWithInitialContent = (editor) => {
      if (editor.removed !== true) {
        loadInitialContent(editor);
        initEditor(editor);
      }
    };
    const contentBodyLoaded = (editor) => {
      const targetElm = editor.getElement();
      let doc = editor.getDoc();
      if (editor.inline) {
        DOM$6.addClass(targetElm, "mce-content-body");
        editor.contentDocument = doc = document;
        editor.contentWindow = window;
        editor.bodyElement = targetElm;
        editor.contentAreaContainer = targetElm;
      }
      const body = editor.getBody();
      body.disabled = true;
      editor.readonly = isReadOnly$1(editor);
      if (!editor.readonly) {
        if (editor.inline && DOM$6.getStyle(body, "position", true) === "static") {
          body.style.position = "relative";
        }
        body.contentEditable = "true";
      }
      body.disabled = false;
      editor.editorUpload = EditorUpload(editor);
      editor.schema = Schema(mkSchemaSettings(editor));
      editor.dom = DOMUtils(doc, {
        keep_values: true,
        url_converter: editor.convertURL,
        url_converter_scope: editor,
        update_styles: true,
        root_element: editor.inline ? editor.getBody() : null,
        collect: editor.inline,
        schema: editor.schema,
        contentCssCors: shouldUseContentCssCors(editor),
        referrerPolicy: getReferrerPolicy(editor),
        onSetAttrib: (e) => {
          editor.dispatch("SetAttrib", e);
        }
      });
      editor.parser = createParser(editor);
      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);
      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);
      editor.annotator = Annotator(editor);
      editor.formatter = Formatter(editor);
      editor.undoManager = UndoManager(editor);
      editor._nodeChangeDispatcher = new NodeChange(editor);
      editor._selectionOverrides = SelectionOverrides(editor);
      setup$o(editor);
      setup$6(editor);
      setup$m(editor);
      if (!isRtc(editor)) {
        setup$5(editor);
        setup$1(editor);
      }
      const caret = setup$b(editor);
      setup$p(editor, caret);
      setup$n(editor);
      setup$q(editor);
      setup$7(editor);
      const setupRtcThunk = setup$s(editor);
      preInit(editor);
      setupRtcThunk.fold(() => {
        loadContentCss(editor).then(() => initEditorWithInitialContent(editor));
      }, (setupRtc) => {
        editor.setProgressState(true);
        loadContentCss(editor).then(() => {
          setupRtc().then((_rtcMode) => {
            editor.setProgressState(false);
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          }, (err) => {
            editor.notificationManager.open({
              type: "error",
              text: String(err)
            });
            initEditorWithInitialContent(editor);
            bindEvents(editor);
          });
        });
      });
    };
    const filter2 = always;
    const bind2 = (element, event, handler) => bind$2(element, event, filter2, handler);
    const DOM$5 = DOMUtils.DOM;
    const createIframeElement = (id, title, customAttrs, tabindex) => {
      const iframe = SugarElement.fromTag("iframe");
      tabindex.each((t) => set$3(iframe, "tabindex", t));
      setAll$1(iframe, customAttrs);
      setAll$1(iframe, {
        id: id + "_ifr",
        frameBorder: "0",
        allowTransparency: "true",
        title
      });
      add$2(iframe, "tox-edit-area__iframe");
      return iframe;
    };
    const getIframeHtml = (editor) => {
      let iframeHTML = getDocType(editor) + "<html><head>";
      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {
        iframeHTML += '<base href="' + editor.documentBaseURI.getURI() + '" />';
      }
      iframeHTML += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
      const bodyId = getBodyId(editor);
      const bodyClass = getBodyClass(editor);
      const translatedAriaText = editor.translate(getIframeAriaText(editor));
      if (getContentSecurityPolicy(editor)) {
        iframeHTML += '<meta http-equiv="Content-Security-Policy" content="' + getContentSecurityPolicy(editor) + '" />';
      }
      iframeHTML += `</head><body id="${bodyId}" class="mce-content-body ${bodyClass}" data-id="${editor.id}" aria-label="${translatedAriaText}"><br></body></html>`;
      return iframeHTML;
    };
    const createIframe = (editor, boxInfo) => {
      const iframeTitle = editor.translate("Rich Text Area");
      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), "tabindex").bind(toInt2);
      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;
      ifr.onload = () => {
        ifr.onload = null;
        editor.dispatch("load");
      };
      editor.contentAreaContainer = boxInfo.iframeContainer;
      editor.iframeElement = ifr;
      editor.iframeHTML = getIframeHtml(editor);
      DOM$5.add(boxInfo.iframeContainer, ifr);
    };
    const setupIframeBody = (editor) => {
      const iframe = editor.iframeElement;
      const binder2 = bind2(SugarElement.fromDom(iframe), "load", () => {
        binder2.unbind();
        editor.contentDocument = iframe.contentDocument;
        contentBodyLoaded(editor);
      });
      if (Env.browser.isFirefox()) {
        const doc = editor.getDoc();
        doc.open();
        doc.write(editor.iframeHTML);
        doc.close();
      } else {
        iframe.srcdoc = editor.iframeHTML;
      }
    };
    const init$1 = (editor, boxInfo) => {
      createIframe(editor, boxInfo);
      if (boxInfo.editorContainer) {
        boxInfo.editorContainer.style.display = editor.orgDisplay;
        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);
      }
      editor.getElement().style.display = "none";
      DOM$5.setAttrib(editor.id, "aria-hidden", "true");
      editor.getElement().style.visibility = editor.orgVisibility;
      setupIframeBody(editor);
    };
    const DOM$4 = DOMUtils.DOM;
    const initPlugin = (editor, initializedPlugins, plugin2) => {
      const Plugin = PluginManager.get(plugin2);
      const pluginUrl = PluginManager.urls[plugin2] || editor.documentBaseUrl.replace(/\/$/, "");
      plugin2 = Tools.trim(plugin2);
      if (Plugin && Tools.inArray(initializedPlugins, plugin2) === -1) {
        if (editor.plugins[plugin2]) {
          return;
        }
        try {
          const pluginInstance = Plugin(editor, pluginUrl) || {};
          editor.plugins[plugin2] = pluginInstance;
          if (isFunction2(pluginInstance.init)) {
            pluginInstance.init(editor, pluginUrl);
            initializedPlugins.push(plugin2);
          }
        } catch (e) {
          pluginInitError(editor, plugin2, e);
        }
      }
    };
    const trimLegacyPrefix = (name3) => {
      return name3.replace(/^\-/, "");
    };
    const initPlugins = (editor) => {
      const initializedPlugins = [];
      each$e(getPlugins(editor), (name3) => {
        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name3));
      });
    };
    const initIcons = (editor) => {
      const iconPackName = Tools.trim(getIconPackName(editor));
      const currentIcons = editor.ui.registry.getAll().icons;
      const loadIcons2 = {
        ...IconManager.get("default").icons,
        ...IconManager.get(iconPackName).icons
      };
      each$d(loadIcons2, (svgData, icon) => {
        if (!has$2(currentIcons, icon)) {
          editor.ui.registry.addIcon(icon, svgData);
        }
      });
    };
    const initTheme = (editor) => {
      const theme = getTheme(editor);
      if (isString2(theme)) {
        const Theme = ThemeManager.get(theme);
        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};
        if (isFunction2(editor.theme.init)) {
          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\/$/, ""));
        }
      } else {
        editor.theme = {};
      }
    };
    const initModel = (editor) => {
      const model = getModel(editor);
      const Model = ModelManager.get(model);
      editor.model = Model(editor, ModelManager.urls[model]);
    };
    const renderFromLoadedTheme = (editor) => {
      const render2 = editor.theme.renderUI;
      return render2 ? render2() : renderThemeFalse(editor);
    };
    const renderFromThemeFunc = (editor) => {
      const elm = editor.getElement();
      const theme = getTheme(editor);
      const info = theme(editor, elm);
      if (info.editorContainer.nodeType) {
        info.editorContainer.id = info.editorContainer.id || editor.id + "_parent";
      }
      if (info.iframeContainer && info.iframeContainer.nodeType) {
        info.iframeContainer.id = info.iframeContainer.id || editor.id + "_iframecontainer";
      }
      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;
      return info;
    };
    const createThemeFalseResult = (element, iframe) => {
      return {
        editorContainer: element,
        iframeContainer: iframe,
        api: {}
      };
    };
    const renderThemeFalseIframe = (targetElement) => {
      const iframeContainer = DOM$4.create("div");
      DOM$4.insertAfter(iframeContainer, targetElement);
      return createThemeFalseResult(iframeContainer, iframeContainer);
    };
    const renderThemeFalse = (editor) => {
      const targetElement = editor.getElement();
      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);
    };
    const renderThemeUi = (editor) => {
      const elm = editor.getElement();
      editor.orgDisplay = elm.style.display;
      if (isString2(getTheme(editor))) {
        return renderFromLoadedTheme(editor);
      } else if (isFunction2(getTheme(editor))) {
        return renderFromThemeFunc(editor);
      } else {
        return renderThemeFalse(editor);
      }
    };
    const augmentEditorUiApi = (editor, api2) => {
      const uiApiFacade = {
        show: Optional.from(api2.show).getOr(noop2),
        hide: Optional.from(api2.hide).getOr(noop2),
        isEnabled: Optional.from(api2.isEnabled).getOr(always),
        setEnabled: (state2) => {
          if (!editor.mode.isReadOnly()) {
            Optional.from(api2.setEnabled).each((f) => f(state2));
          }
        }
      };
      editor.ui = {
        ...editor.ui,
        ...uiApiFacade
      };
    };
    const init = async (editor) => {
      editor.dispatch("ScriptsLoaded");
      initIcons(editor);
      initTheme(editor);
      initModel(editor);
      initPlugins(editor);
      const renderInfo = await renderThemeUi(editor);
      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));
      editor.editorContainer = renderInfo.editorContainer;
      appendContentCssFromSettings(editor);
      if (editor.inline) {
        contentBodyLoaded(editor);
      } else {
        init$1(editor, {
          editorContainer: renderInfo.editorContainer,
          iframeContainer: renderInfo.iframeContainer
        });
      }
    };
    const DOM$3 = DOMUtils.DOM;
    const hasSkipLoadPrefix = (name3) => name3.charAt(0) === "-";
    const loadLanguage = (scriptLoader, editor) => {
      const languageCode = getLanguageCode(editor);
      const languageUrl = getLanguageUrl(editor);
      if (!I18n.hasCode(languageCode) && languageCode !== "en") {
        const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;
        scriptLoader.add(url).catch(() => {
          languageLoadError(editor, url, languageCode);
        });
      }
    };
    const loadTheme = (editor, suffix) => {
      const theme = getTheme(editor);
      if (isString2(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {
        const themeUrl = getThemeUrl(editor);
        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;
        ThemeManager.load(theme, url).catch(() => {
          themeLoadError(editor, url, theme);
        });
      }
    };
    const loadModel = (editor, suffix) => {
      const model = getModel(editor);
      if (model !== "plugin" && !has$2(ModelManager.urls, model)) {
        const modelUrl = getModelUrl(editor);
        const url = isString2(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;
        ModelManager.load(model, url).catch(() => {
          modelLoadError(editor, url, model);
        });
      }
    };
    const getIconsUrlMetaFromUrl = (editor) => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map((url) => ({
      url,
      name: Optional.none()
    }));
    const getIconsUrlMetaFromName = (editor, name3, suffix) => Optional.from(name3).filter((name4) => isNotEmpty(name4) && !IconManager.has(name4)).map((name4) => ({
      url: `${editor.editorManager.baseURL}/icons/${name4}/icons${suffix}.js`,
      name: Optional.some(name4)
    }));
    const loadIcons = (scriptLoader, editor, suffix) => {
      const defaultIconsUrl = getIconsUrlMetaFromName(editor, "default", suffix);
      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ""));
      each$e(cat([
        defaultIconsUrl,
        customIconsUrl
      ]), (urlMeta) => {
        scriptLoader.add(urlMeta.url).catch(() => {
          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());
        });
      });
    };
    const loadPlugins = (editor, suffix) => {
      const loadPlugin = (name3, url) => {
        PluginManager.load(name3, url).catch(() => {
          pluginLoadError(editor, url, name3);
        });
      };
      each$d(getExternalPlugins$1(editor), (url, name3) => {
        loadPlugin(name3, url);
        editor.options.set("plugins", getPlugins(editor).concat(name3));
      });
      each$e(getPlugins(editor), (plugin2) => {
        plugin2 = Tools.trim(plugin2);
        if (plugin2 && !PluginManager.urls[plugin2] && !hasSkipLoadPrefix(plugin2)) {
          loadPlugin(plugin2, `plugins/${plugin2}/plugin${suffix}.js`);
        }
      });
    };
    const isThemeLoaded = (editor) => {
      const theme = getTheme(editor);
      return !isString2(theme) || isNonNullable(ThemeManager.get(theme));
    };
    const isModelLoaded = (editor) => {
      const model = getModel(editor);
      return isNonNullable(ModelManager.get(model));
    };
    const loadScripts = (editor, suffix) => {
      const scriptLoader = ScriptLoader.ScriptLoader;
      const initEditor2 = () => {
        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {
          init(editor);
        }
      };
      loadTheme(editor, suffix);
      loadModel(editor, suffix);
      loadLanguage(scriptLoader, editor);
      loadIcons(scriptLoader, editor, suffix);
      loadPlugins(editor, suffix);
      scriptLoader.loadQueue().then(initEditor2, initEditor2);
    };
    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {
      contentCssCors: hasContentCssCors(editor),
      referrerPolicy: getReferrerPolicy(editor)
    });
    const render = (editor) => {
      const id = editor.id;
      I18n.setCode(getLanguageCode(editor));
      const readyHandler = () => {
        DOM$3.unbind(window, "ready", readyHandler);
        editor.render();
      };
      if (!EventUtils.Event.domLoaded) {
        DOM$3.bind(window, "ready", readyHandler);
        return;
      }
      if (!editor.getElement()) {
        return;
      }
      const element = SugarElement.fromDom(editor.getElement());
      const snapshot = clone$4(element);
      editor.on("remove", () => {
        eachr(element.dom.attributes, (attr2) => remove$b(element, attr2.name));
        setAll$1(element, snapshot);
      });
      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);
      if (!isInline(editor)) {
        editor.orgVisibility = editor.getElement().style.visibility;
        editor.getElement().style.visibility = "hidden";
      } else {
        editor.inline = true;
      }
      const form = editor.getElement().form || DOM$3.getParent(id, "form");
      if (form) {
        editor.formElement = form;
        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {
          DOM$3.insertAfter(DOM$3.create("input", {
            type: "hidden",
            name: id
          }), id);
          editor.hasHiddenInput = true;
        }
        editor.formEventDelegate = (e) => {
          editor.dispatch(e.type, e);
        };
        DOM$3.bind(form, "submit reset", editor.formEventDelegate);
        editor.on("reset", () => {
          editor.resetContent();
        });
        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {
          form._mceOldSubmit = form.submit;
          form.submit = () => {
            editor.editorManager.triggerSave();
            editor.setDirty(false);
            return form._mceOldSubmit(form);
          };
        }
      }
      editor.windowManager = WindowManager(editor);
      editor.notificationManager = NotificationManager(editor);
      if (isEncodingXml(editor)) {
        editor.on("GetContent", (e) => {
          if (e.save) {
            e.content = DOM$3.encode(e.content);
          }
        });
      }
      if (shouldAddFormSubmitTrigger(editor)) {
        editor.on("submit", () => {
          if (editor.initialized) {
            editor.save();
          }
        });
      }
      if (shouldAddUnloadTrigger(editor)) {
        editor._beforeUnload = () => {
          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {
            editor.save({
              format: "raw",
              no_events: true,
              set_dirty: false
            });
          }
        };
        editor.editorManager.on("BeforeUnload", editor._beforeUnload);
      }
      editor.editorManager.add(editor);
      loadScripts(editor, editor.suffix);
    };
    const sectionResult = (sections, settings) => ({
      sections: constant(sections),
      options: constant(settings)
    });
    const deviceDetection = detect$2().deviceType;
    const isPhone = deviceDetection.isPhone();
    const isTablet = deviceDetection.isTablet();
    const normalizePlugins = (plugins) => {
      if (isNullable(plugins)) {
        return [];
      } else {
        const pluginNames = isArray$12(plugins) ? plugins : plugins.split(/[ ,]/);
        const trimmedPlugins = map$3(pluginNames, trim$3);
        return filter$5(trimmedPlugins, isNotEmpty);
      }
    };
    const extractSections = (keys2, options) => {
      const result = bifilter(options, (value2, key) => {
        return contains$2(keys2, key);
      });
      return sectionResult(result.t, result.f);
    };
    const getSection = (sectionResult2, name3, defaults2 = {}) => {
      const sections = sectionResult2.sections();
      const sectionOptions = get$a(sections, name3).getOr({});
      return Tools.extend({}, defaults2, sectionOptions);
    };
    const hasSection = (sectionResult2, name3) => {
      return has$2(sectionResult2.sections(), name3);
    };
    const getSectionConfig = (sectionResult2, name3) => {
      return hasSection(sectionResult2, name3) ? sectionResult2.sections()[name3] : {};
    };
    const getMobileOverrideOptions = (mobileOptions, isPhone2) => {
      const defaultMobileOptions = {
        table_grid: false,
        object_resizing: false,
        resize: false,
        toolbar_mode: get$a(mobileOptions, "toolbar_mode").getOr("scrolling"),
        toolbar_sticky: false
      };
      const defaultPhoneOptions = { menubar: false };
      return {
        ...defaultMobileOptions,
        ...isPhone2 ? defaultPhoneOptions : {}
      };
    };
    const getExternalPlugins = (overrideOptions, options) => {
      var _a;
      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};
      if (overrideOptions && overrideOptions.external_plugins) {
        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);
      } else {
        return userDefinedExternalPlugins;
      }
    };
    const combinePlugins = (forcedPlugins, plugins) => [
      ...normalizePlugins(forcedPlugins),
      ...normalizePlugins(plugins)
    ];
    const getPlatformPlugins = (isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins) => {
      if (isMobileDevice && hasSection(sectionResult2, "mobile")) {
        return mobilePlugins;
      } else {
        return desktopPlugins;
      }
    };
    const processPlugins = (isMobileDevice, sectionResult2, defaultOverrideOptions, options) => {
      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);
      const desktopPlugins = normalizePlugins(options.plugins);
      const mobileConfig = getSectionConfig(sectionResult2, "mobile");
      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;
      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult2, desktopPlugins, mobilePlugins);
      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);
      return Tools.extend(options, {
        forced_plugins: forcedPlugins,
        plugins: combinedPlugins
      });
    };
    const isOnMobile = (isMobileDevice, sectionResult2) => {
      return isMobileDevice && hasSection(sectionResult2, "mobile");
    };
    const combineOptions = (isMobileDevice, isPhone2, defaultOptions2, defaultOverrideOptions, options) => {
      var _a;
      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone2) } : {};
      const sectionResult2 = extractSections(["mobile"], deepMerge(deviceOverrideOptions, options));
      const extendedOptions = Tools.extend(defaultOptions2, defaultOverrideOptions, sectionResult2.options(), isOnMobile(isMobileDevice, sectionResult2) ? getSection(sectionResult2, "mobile") : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult2.options()) });
      return processPlugins(isMobileDevice, sectionResult2, defaultOverrideOptions, extendedOptions);
    };
    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);
    const addVisual = (editor, elm) => addVisual$1(editor, elm);
    const registerExecCommands$3 = (editor) => {
      const toggleFormat2 = (name3, value2) => {
        editor.formatter.toggle(name3, value2);
        editor.nodeChanged();
      };
      const toggleAlign = (align) => () => {
        each$e("left,center,right,justify".split(","), (name3) => {
          if (align !== name3) {
            editor.formatter.remove("align" + name3);
          }
        });
        if (align !== "none") {
          toggleFormat2("align" + align);
        }
      };
      editor.editorCommands.addCommands({
        JustifyLeft: toggleAlign("left"),
        JustifyCenter: toggleAlign("center"),
        JustifyRight: toggleAlign("right"),
        JustifyFull: toggleAlign("justify"),
        JustifyNone: toggleAlign("none")
      });
    };
    const registerQueryStateCommands$1 = (editor) => {
      const alignStates = (name3) => () => {
        const selection = editor.selection;
        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();
        return exists(nodes, (node) => isNonNullable(editor.formatter.matchNode(node, name3)));
      };
      editor.editorCommands.addCommands({
        JustifyLeft: alignStates("alignleft"),
        JustifyCenter: alignStates("aligncenter"),
        JustifyRight: alignStates("alignright"),
        JustifyFull: alignStates("alignjustify")
      }, "state");
    };
    const registerCommands$a = (editor) => {
      registerExecCommands$3(editor);
      registerQueryStateCommands$1(editor);
    };
    const registerCommands$9 = (editor) => {
      editor.editorCommands.addCommands({
        "Cut,Copy,Paste": (command) => {
          const doc = editor.getDoc();
          let failed;
          try {
            doc.execCommand(command);
          } catch (ex) {
            failed = true;
          }
          if (command === "paste" && !doc.queryCommandEnabled(command)) {
            failed = true;
          }
          if (failed || !doc.queryCommandSupported(command)) {
            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.`);
            if (Env.os.isMacOS() || Env.os.isiOS()) {
              msg = msg.replace(/Ctrl\+/g, "⌘+");
            }
            editor.notificationManager.open({
              text: msg,
              type: "error"
            });
          }
        }
      });
    };
    const trimOrPadLeftRight = (dom2, rng, html2) => {
      const root2 = SugarElement.fromDom(dom2.getRoot());
      if (needsToBeNbspLeft(root2, CaretPosition.fromRangeStart(rng))) {
        html2 = html2.replace(/^ /, "&nbsp;");
      } else {
        html2 = html2.replace(/^&nbsp;/, " ");
      }
      if (needsToBeNbspRight(root2, CaretPosition.fromRangeEnd(rng))) {
        html2 = html2.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;");
      } else {
        html2 = html2.replace(/&nbsp;(<br( \/)?>)?$/, " ");
      }
      return html2;
    };
    const processValue$1 = (value2) => {
      if (typeof value2 !== "string") {
        const details = Tools.extend({
          paste: value2.paste,
          data: { paste: value2.paste }
        }, value2);
        return {
          content: value2.content,
          details
        };
      }
      return {
        content: value2,
        details: {}
      };
    };
    const trimOrPad = (editor, value2) => {
      const selection = editor.selection;
      const dom2 = editor.dom;
      if (/^ | $/.test(value2)) {
        return trimOrPadLeftRight(dom2, selection.getRng(), value2);
      } else {
        return value2;
      }
    };
    const insertAtCaret = (editor, value2) => {
      if (editor.selection.isEditable()) {
        const { content, details } = processValue$1(value2);
        preProcessSetContent(editor, {
          ...details,
          content: trimOrPad(editor, content),
          format: "html",
          set: false,
          selection: true
        }).each((args) => {
          const insertedContent = insertContent$1(editor, args.content, details);
          postProcessSetContent(editor, insertedContent, args);
          editor.addVisual();
        });
      }
    };
    const registerCommands$8 = (editor) => {
      editor.editorCommands.addCommands({
        mceCleanup: () => {
          const bm = editor.selection.getBookmark();
          editor.setContent(editor.getContent());
          editor.selection.moveToBookmark(bm);
        },
        insertImage: (_command, _ui, value2) => {
          insertAtCaret(editor, editor.dom.createHTML("img", { src: value2 }));
        },
        insertHorizontalRule: () => {
          editor.execCommand("mceInsertContent", false, "<hr>");
        },
        insertText: (_command, _ui, value2) => {
          insertAtCaret(editor, editor.dom.encode(value2));
        },
        insertHTML: (_command, _ui, value2) => {
          insertAtCaret(editor, value2);
        },
        mceInsertContent: (_command, _ui, value2) => {
          insertAtCaret(editor, value2);
        },
        mceSetContent: (_command, _ui, value2) => {
          editor.setContent(value2);
        },
        mceReplaceContent: (_command, _ui, value2) => {
          editor.execCommand("mceInsertContent", false, value2.replace(/\{\$selection\}/g, editor.selection.getContent({ format: "text" })));
        },
        mceNewDocument: () => {
          editor.setContent("");
        }
      });
    };
    const legacyPropNames = {
      "font-size": "size",
      "font-family": "face"
    };
    const isFont = isTag("font");
    const getSpecifiedFontProp = (propName, rootElm, elm) => {
      const getProperty = (elm2) => getRaw(elm2, propName).orThunk(() => {
        if (isFont(elm2)) {
          return get$a(legacyPropNames, propName).bind((legacyPropName) => getOpt(elm2, legacyPropName));
        } else {
          return Optional.none();
        }
      });
      const isRoot2 = (elm2) => eq(SugarElement.fromDom(rootElm), elm2);
      return closest$1(SugarElement.fromDom(elm), (elm2) => getProperty(elm2), isRoot2);
    };
    const normalizeFontFamily = (fontFamily) => fontFamily.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",");
    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));
    const getFontProp = (propName) => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind((element) => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr("");
    const getFontSize = getFontProp("font-size");
    const getFontFamily = compose(normalizeFontFamily, getFontProp("font-family"));
    const findFirstCaretElement = (editor) => firstPositionIn(editor.getBody()).bind((caret) => {
      const container = caret.container();
      return Optional.from(isText$a(container) ? container.parentNode : container);
    });
    const getCaretElement = (editor) => Optional.from(editor.selection.getRng()).bind((rng) => {
      const root2 = editor.getBody();
      const atStartOfNode = rng.startContainer === root2 && rng.startOffset === 0;
      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));
    });
    const bindRange = (editor, binder2) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder2);
    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));
    const fromFontSizeNumber = (editor, value2) => {
      if (/^[0-9.]+$/.test(value2)) {
        const fontSizeNumber = parseInt(value2, 10);
        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {
          const fontSizes = getFontStyleValues(editor);
          const fontClasses = getFontSizeClasses(editor);
          if (fontClasses.length > 0) {
            return fontClasses[fontSizeNumber - 1] || value2;
          } else {
            return fontSizes[fontSizeNumber - 1] || value2;
          }
        } else {
          return value2;
        }
      } else {
        return value2;
      }
    };
    const normalizeFontNames = (font) => {
      const fonts = font.split(/\s*,\s*/);
      return map$3(fonts, (font2) => {
        if (font2.indexOf(" ") !== -1 && !(startsWith(font2, '"') || startsWith(font2, `'`))) {
          return `'${font2}'`;
        } else {
          return font2;
        }
      }).join(",");
    };
    const fontNameAction = (editor, value2) => {
      const font = fromFontSizeNumber(editor, value2);
      editor.formatter.toggle("fontname", { value: normalizeFontNames(font) });
      editor.nodeChanged();
    };
    const fontNameQuery = (editor) => mapRange(editor, (elm) => getFontFamily(editor.getBody(), elm.dom)).getOr("");
    const fontSizeAction = (editor, value2) => {
      editor.formatter.toggle("fontsize", { value: fromFontSizeNumber(editor, value2) });
      editor.nodeChanged();
    };
    const fontSizeQuery = (editor) => mapRange(editor, (elm) => getFontSize(editor.getBody(), elm.dom)).getOr("");
    const lineHeightQuery = (editor) => mapRange(editor, (elm) => {
      const root2 = SugarElement.fromDom(editor.getBody());
      const specifiedStyle = closest$1(elm, (elm2) => getRaw(elm2, "line-height"), curry(eq, root2));
      const computedStyle = () => {
        const lineHeight = parseFloat(get$7(elm, "line-height"));
        const fontSize = parseFloat(get$7(elm, "font-size"));
        return String(lineHeight / fontSize);
      };
      return specifiedStyle.getOrThunk(computedStyle);
    }).getOr("");
    const lineHeightAction = (editor, lineHeight) => {
      editor.formatter.toggle("lineheight", { value: String(lineHeight) });
      editor.nodeChanged();
    };
    const registerExecCommands$2 = (editor) => {
      const toggleFormat2 = (name3, value2) => {
        editor.formatter.toggle(name3, value2);
        editor.nodeChanged();
      };
      editor.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => {
          toggleFormat2(command);
        },
        "ForeColor,HiliteColor": (command, _ui, value2) => {
          toggleFormat2(command, { value: value2 });
        },
        "BackColor": (_command, _ui, value2) => {
          toggleFormat2("hilitecolor", { value: value2 });
        },
        "FontName": (_command, _ui, value2) => {
          fontNameAction(editor, value2);
        },
        "FontSize": (_command, _ui, value2) => {
          fontSizeAction(editor, value2);
        },
        "LineHeight": (_command, _ui, value2) => {
          lineHeightAction(editor, value2);
        },
        "Lang": (command, _ui, lang) => {
          var _a;
          toggleFormat2(command, {
            value: lang.code,
            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null
          });
        },
        "RemoveFormat": (command) => {
          editor.formatter.remove(command);
        },
        "mceBlockQuote": () => {
          toggleFormat2("blockquote");
        },
        "FormatBlock": (_command, _ui, value2) => {
          toggleFormat2(isString2(value2) ? value2 : "p");
        },
        "mceToggleFormat": (_command, _ui, value2) => {
          toggleFormat2(value2);
        }
      });
    };
    const registerQueryValueCommands = (editor) => {
      const isFormatMatch = (name3) => editor.formatter.match(name3);
      editor.editorCommands.addCommands({
        "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (command) => isFormatMatch(command),
        "mceBlockQuote": () => isFormatMatch("blockquote")
      }, "state");
      editor.editorCommands.addQueryValueHandler("FontName", () => fontNameQuery(editor));
      editor.editorCommands.addQueryValueHandler("FontSize", () => fontSizeQuery(editor));
      editor.editorCommands.addQueryValueHandler("LineHeight", () => lineHeightQuery(editor));
    };
    const registerCommands$7 = (editor) => {
      registerExecCommands$2(editor);
      registerQueryValueCommands(editor);
    };
    const registerCommands$6 = (editor) => {
      editor.editorCommands.addCommands({
        mceAddUndoLevel: () => {
          editor.undoManager.add();
        },
        mceEndUndoLevel: () => {
          editor.undoManager.add();
        },
        Undo: () => {
          editor.undoManager.undo();
        },
        Redo: () => {
          editor.undoManager.redo();
        }
      });
    };
    const registerCommands$5 = (editor) => {
      editor.editorCommands.addCommands({
        Indent: () => {
          indent(editor);
        },
        Outdent: () => {
          outdent(editor);
        }
      });
      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, "state");
    };
    const registerCommands$4 = (editor) => {
      const applyLinkToSelection = (_command, _ui, value2) => {
        const linkDetails = isString2(value2) ? { href: value2 } : value2;
        const anchor = editor.dom.getParent(editor.selection.getNode(), "a");
        if (isObject2(linkDetails) && isString2(linkDetails.href)) {
          linkDetails.href = linkDetails.href.replace(/ /g, "%20");
          if (!anchor || !linkDetails.href) {
            editor.formatter.remove("link");
          }
          if (linkDetails.href) {
            editor.formatter.apply("link", linkDetails, anchor);
          }
        }
      };
      editor.editorCommands.addCommands({
        unlink: () => {
          if (editor.selection.isCollapsed()) {
            const elm = editor.dom.getParent(editor.selection.getStart(), "a");
            if (elm) {
              editor.dom.remove(elm, true);
            }
            return;
          }
          editor.formatter.remove("link");
        },
        mceInsertLink: applyLinkToSelection,
        createLink: applyLinkToSelection
      });
    };
    const registerExecCommands$1 = (editor) => {
      editor.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (command) => {
          editor.getDoc().execCommand(command);
          const listElm = editor.dom.getParent(editor.selection.getNode(), "ol,ul");
          if (listElm) {
            const listParent = listElm.parentNode;
            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {
              const bm = editor.selection.getBookmark();
              editor.dom.split(listParent, listElm);
              editor.selection.moveToBookmark(bm);
            }
          }
        }
      });
    };
    const registerQueryStateCommands = (editor) => {
      editor.editorCommands.addCommands({
        "InsertUnorderedList,InsertOrderedList": (command) => {
          const list2 = editor.dom.getParent(editor.selection.getNode(), "ul,ol");
          return list2 && (command === "insertunorderedlist" && list2.tagName === "UL" || command === "insertorderedlist" && list2.tagName === "OL");
        }
      }, "state");
    };
    const registerCommands$3 = (editor) => {
      registerExecCommands$1(editor);
      registerQueryStateCommands(editor);
    };
    const registerCommands$2 = (editor) => {
      editor.editorCommands.addCommands({
        insertParagraph: () => {
          insertBreak(blockbreak, editor);
        },
        mceInsertNewLine: (_command, _ui, value2) => {
          insert(editor, value2);
        },
        InsertLineBreak: (_command, _ui, _value) => {
          insertBreak(linebreak, editor);
        }
      });
    };
    const registerCommands$1 = (editor) => {
      editor.editorCommands.addCommands({
        mceSelectNodeDepth: (_command, _ui, value2) => {
          let counter = 0;
          editor.dom.getParent(editor.selection.getNode(), (node) => {
            if (isElement$6(node) && counter++ === value2) {
              editor.selection.select(node);
              return false;
            } else {
              return true;
            }
          }, editor.getBody());
        },
        mceSelectNode: (_command, _ui, value2) => {
          editor.selection.select(value2);
        },
        selectAll: () => {
          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);
          if (editingHost) {
            const rng = editor.dom.createRng();
            rng.selectNodeContents(editingHost);
            editor.selection.setRng(rng);
          }
        }
      });
    };
    const registerExecCommands = (editor) => {
      editor.editorCommands.addCommands({
        mceRemoveNode: (_command, _ui, value2) => {
          const node = value2 !== null && value2 !== void 0 ? value2 : editor.selection.getNode();
          if (node !== editor.getBody()) {
            const bm = editor.selection.getBookmark();
            editor.dom.remove(node, true);
            editor.selection.moveToBookmark(bm);
          }
        },
        mcePrint: () => {
          editor.getWin().print();
        },
        mceFocus: (_command, _ui, value2) => {
          focus(editor, value2 === true);
        },
        mceToggleVisualAid: () => {
          editor.hasVisual = !editor.hasVisual;
          editor.addVisual();
        }
      });
    };
    const registerCommands = (editor) => {
      registerCommands$a(editor);
      registerCommands$9(editor);
      registerCommands$6(editor);
      registerCommands$1(editor);
      registerCommands$8(editor);
      registerCommands$4(editor);
      registerCommands$5(editor);
      registerCommands$2(editor);
      registerCommands$3(editor);
      registerCommands$7(editor);
      registerExecCommands(editor);
    };
    const selectionSafeCommands = ["toggleview"];
    const isSelectionSafeCommand = (command) => contains$2(selectionSafeCommands, command.toLowerCase());
    class EditorCommands {
      constructor(editor) {
        this.commands = {
          state: {},
          exec: {},
          value: {}
        };
        this.editor = editor;
      }
      execCommand(command, ui = false, value2, args) {
        const editor = this.editor;
        const lowerCaseCommand = command.toLowerCase();
        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;
        if (editor.removed) {
          return false;
        }
        if (lowerCaseCommand !== "mcefocus") {
          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {
            editor.focus();
          } else {
            restore(editor);
          }
        }
        const eventArgs = editor.dispatch("BeforeExecCommand", {
          command,
          ui,
          value: value2
        });
        if (eventArgs.isDefaultPrevented()) {
          return false;
        }
        const func = this.commands.exec[lowerCaseCommand];
        if (isFunction2(func)) {
          func(lowerCaseCommand, ui, value2);
          editor.dispatch("ExecCommand", {
            command,
            ui,
            value: value2
          });
          return true;
        }
        return false;
      }
      queryCommandState(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return false;
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.state[lowerCaseCommand];
        if (isFunction2(func)) {
          return func(lowerCaseCommand);
        }
        return false;
      }
      queryCommandValue(command) {
        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {
          return "";
        }
        const lowerCaseCommand = command.toLowerCase();
        const func = this.commands.value[lowerCaseCommand];
        if (isFunction2(func)) {
          return func(lowerCaseCommand);
        }
        return "";
      }
      addCommands(commandList, type2 = "exec") {
        const commands = this.commands;
        each$d(commandList, (callback, command) => {
          each$e(command.toLowerCase().split(","), (command2) => {
            commands[type2][command2] = callback;
          });
        });
      }
      addCommand(command, callback, scope) {
        const lowerCaseCommand = command.toLowerCase();
        this.commands.exec[lowerCaseCommand] = (_command, ui, value2) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value2);
      }
      queryCommandSupported(command) {
        const lowerCaseCommand = command.toLowerCase();
        if (this.commands.exec[lowerCaseCommand]) {
          return true;
        } else {
          return false;
        }
      }
      addQueryStateHandler(command, callback, scope) {
        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
      addQueryValueHandler(command, callback, scope) {
        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);
      }
    }
    const internalContentEditableAttr = "data-mce-contenteditable";
    const toggleClass = (elm, cls, state2) => {
      if (has(elm, cls) && !state2) {
        remove$8(elm, cls);
      } else if (state2) {
        add$2(elm, cls);
      }
    };
    const setEditorCommandState = (editor, cmd, state2) => {
      try {
        editor.getDoc().execCommand(cmd, false, String(state2));
      } catch (ex) {
      }
    };
    const setContentEditable = (elm, state2) => {
      elm.dom.contentEditable = state2 ? "true" : "false";
    };
    const switchOffContentEditableTrue = (elm) => {
      each$e(descendants(elm, '*[contenteditable="true"]'), (elm2) => {
        set$3(elm2, internalContentEditableAttr, "true");
        setContentEditable(elm2, false);
      });
    };
    const switchOnContentEditableTrue = (elm) => {
      each$e(descendants(elm, `*[${internalContentEditableAttr}="true"]`), (elm2) => {
        remove$b(elm2, internalContentEditableAttr);
        setContentEditable(elm2, true);
      });
    };
    const removeFakeSelection = (editor) => {
      Optional.from(editor.selection.getNode()).each((elm) => {
        elm.removeAttribute("data-mce-selected");
      });
    };
    const restoreFakeSelection = (editor) => {
      editor.selection.setRng(editor.selection.getRng());
    };
    const toggleReadOnly = (editor, state2) => {
      const body = SugarElement.fromDom(editor.getBody());
      toggleClass(body, "mce-content-readonly", state2);
      if (state2) {
        editor.selection.controlSelection.hideResizeRect();
        editor._selectionOverrides.hideFakeCaret();
        removeFakeSelection(editor);
        editor.readonly = true;
        setContentEditable(body, false);
        switchOffContentEditableTrue(body);
      } else {
        editor.readonly = false;
        setContentEditable(body, true);
        switchOnContentEditableTrue(body);
        setEditorCommandState(editor, "StyleWithCSS", false);
        setEditorCommandState(editor, "enableInlineTableEditing", false);
        setEditorCommandState(editor, "enableObjectResizing", false);
        if (hasEditorOrUiFocus(editor)) {
          editor.focus();
        }
        restoreFakeSelection(editor);
        editor.nodeChanged();
      }
    };
    const isReadOnly = (editor) => editor.readonly;
    const registerFilters = (editor) => {
      editor.parser.addAttributeFilter("contenteditable", (nodes) => {
        if (isReadOnly(editor)) {
          each$e(nodes, (node) => {
            node.attr(internalContentEditableAttr, node.attr("contenteditable"));
            node.attr("contenteditable", "false");
          });
        }
      });
      editor.serializer.addAttributeFilter(internalContentEditableAttr, (nodes) => {
        if (isReadOnly(editor)) {
          each$e(nodes, (node) => {
            node.attr("contenteditable", node.attr(internalContentEditableAttr));
          });
        }
      });
      editor.serializer.addTempAttr(internalContentEditableAttr);
    };
    const registerReadOnlyContentFilters = (editor) => {
      if (editor.serializer) {
        registerFilters(editor);
      } else {
        editor.on("PreInit", () => {
          registerFilters(editor);
        });
      }
    };
    const isClickEvent = (e) => e.type === "click";
    const allowedEvents = ["copy"];
    const isReadOnlyAllowedEvent = (e) => contains$2(allowedEvents, e.type);
    const getAnchorHrefOpt = (editor, elm) => {
      const isRoot2 = (elm2) => eq(elm2, SugarElement.fromDom(editor.getBody()));
      return closest$3(elm, "a", isRoot2).bind((a) => getOpt(a, "href"));
    };
    const processReadonlyEvents = (editor, e) => {
      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {
        const elm = SugarElement.fromDom(e.target);
        getAnchorHrefOpt(editor, elm).each((href) => {
          e.preventDefault();
          if (/^#/.test(href)) {
            const targetEl = editor.dom.select(`${href},[name="${removeLeading(href, "#")}"]`);
            if (targetEl.length) {
              editor.selection.scrollIntoView(targetEl[0], true);
            }
          } else {
            window.open(href, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
          }
        });
      } else if (isReadOnlyAllowedEvent(e)) {
        editor.dispatch(e.type, e);
      }
    };
    const registerReadOnlySelectionBlockers = (editor) => {
      editor.on("ShowCaret", (e) => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
      editor.on("ObjectSelected", (e) => {
        if (isReadOnly(editor)) {
          e.preventDefault();
        }
      });
    };
    const nativeEvents2 = Tools.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
    class EventDispatcher {
      constructor(settings) {
        this.bindings = {};
        this.settings = settings || {};
        this.scope = this.settings.scope || this;
        this.toggleEvent = this.settings.toggleEvent || never;
      }
      static isNative(name3) {
        return !!nativeEvents2[name3.toLowerCase()];
      }
      fire(name3, args) {
        return this.dispatch(name3, args);
      }
      dispatch(name3, args) {
        const lcName = name3.toLowerCase();
        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);
        if (this.settings.beforeFire) {
          this.settings.beforeFire(event);
        }
        const handlers = this.bindings[lcName];
        if (handlers) {
          for (let i = 0, l = handlers.length; i < l; i++) {
            const callback = handlers[i];
            if (callback.removed) {
              continue;
            }
            if (callback.once) {
              this.off(lcName, callback.func);
            }
            if (event.isImmediatePropagationStopped()) {
              return event;
            }
            if (callback.func.call(this.scope, event) === false) {
              event.preventDefault();
              return event;
            }
          }
        }
        return event;
      }
      on(name3, callback, prepend2, extra2) {
        if (callback === false) {
          callback = never;
        }
        if (callback) {
          const wrappedCallback = {
            func: callback,
            removed: false
          };
          if (extra2) {
            Tools.extend(wrappedCallback, extra2);
          }
          const names = name3.toLowerCase().split(" ");
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!handlers) {
              handlers = [];
              this.toggleEvent(currentName, true);
            }
            if (prepend2) {
              handlers = [
                wrappedCallback,
                ...handlers
              ];
            } else {
              handlers = [
                ...handlers,
                wrappedCallback
              ];
            }
            this.bindings[currentName] = handlers;
          }
        }
        return this;
      }
      off(name3, callback) {
        if (name3) {
          const names = name3.toLowerCase().split(" ");
          let i = names.length;
          while (i--) {
            const currentName = names[i];
            let handlers = this.bindings[currentName];
            if (!currentName) {
              each$d(this.bindings, (_value, bindingName) => {
                this.toggleEvent(bindingName, false);
                delete this.bindings[bindingName];
              });
              return this;
            }
            if (handlers) {
              if (!callback) {
                handlers.length = 0;
              } else {
                const filteredHandlers = partition$2(handlers, (handler) => handler.func === callback);
                handlers = filteredHandlers.fail;
                this.bindings[currentName] = handlers;
                each$e(filteredHandlers.pass, (handler) => {
                  handler.removed = true;
                });
              }
              if (!handlers.length) {
                this.toggleEvent(name3, false);
                delete this.bindings[currentName];
              }
            }
          }
        } else {
          each$d(this.bindings, (_value, name4) => {
            this.toggleEvent(name4, false);
          });
          this.bindings = {};
        }
        return this;
      }
      once(name3, callback, prepend2) {
        return this.on(name3, callback, prepend2, { once: true });
      }
      has(name3) {
        name3 = name3.toLowerCase();
        const binding = this.bindings[name3];
        return !(!binding || binding.length === 0);
      }
    }
    const getEventDispatcher = (obj) => {
      if (!obj._eventDispatcher) {
        obj._eventDispatcher = new EventDispatcher({
          scope: obj,
          toggleEvent: (name3, state2) => {
            if (EventDispatcher.isNative(name3) && obj.toggleNativeEvent) {
              obj.toggleNativeEvent(name3, state2);
            }
          }
        });
      }
      return obj._eventDispatcher;
    };
    const Observable = {
      fire(name3, args, bubble) {
        return this.dispatch(name3, args, bubble);
      },
      dispatch(name3, args, bubble) {
        const self2 = this;
        if (self2.removed && name3 !== "remove" && name3 !== "detach") {
          return normalize$3(name3.toLowerCase(), args !== null && args !== void 0 ? args : {}, self2);
        }
        const dispatcherArgs = getEventDispatcher(self2).dispatch(name3, args);
        if (bubble !== false && self2.parent) {
          let parent2 = self2.parent();
          while (parent2 && !dispatcherArgs.isPropagationStopped()) {
            parent2.dispatch(name3, dispatcherArgs, false);
            parent2 = parent2.parent ? parent2.parent() : void 0;
          }
        }
        return dispatcherArgs;
      },
      on(name3, callback, prepend2) {
        return getEventDispatcher(this).on(name3, callback, prepend2);
      },
      off(name3, callback) {
        return getEventDispatcher(this).off(name3, callback);
      },
      once(name3, callback) {
        return getEventDispatcher(this).once(name3, callback);
      },
      hasEventListeners(name3) {
        return getEventDispatcher(this).has(name3);
      }
    };
    const DOM$2 = DOMUtils.DOM;
    let customEventRootDelegates;
    const getEventTarget = (editor, eventName) => {
      if (eventName === "selectionchange") {
        return editor.getDoc();
      }
      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {
        return editor.getDoc().documentElement;
      }
      const eventRoot = getEventRoot(editor);
      if (eventRoot) {
        if (!editor.eventRoot) {
          editor.eventRoot = DOM$2.select(eventRoot)[0];
        }
        return editor.eventRoot;
      }
      return editor.getBody();
    };
    const isListening = (editor) => !editor.hidden && !isReadOnly(editor);
    const fireEvent = (editor, eventName, e) => {
      if (isListening(editor)) {
        editor.dispatch(eventName, e);
      } else if (isReadOnly(editor)) {
        processReadonlyEvents(editor, e);
      }
    };
    const bindEventDelegate = (editor, eventName) => {
      if (!editor.delegates) {
        editor.delegates = {};
      }
      if (editor.delegates[eventName] || editor.removed) {
        return;
      }
      const eventRootElm = getEventTarget(editor, eventName);
      if (getEventRoot(editor)) {
        if (!customEventRootDelegates) {
          customEventRootDelegates = {};
          editor.editorManager.on("removeEditor", () => {
            if (!editor.editorManager.activeEditor) {
              if (customEventRootDelegates) {
                each$d(customEventRootDelegates, (_value, name3) => {
                  editor.dom.unbind(getEventTarget(editor, name3));
                });
                customEventRootDelegates = null;
              }
            }
          });
        }
        if (customEventRootDelegates[eventName]) {
          return;
        }
        const delegate = (e) => {
          const target = e.target;
          const editors2 = editor.editorManager.get();
          let i = editors2.length;
          while (i--) {
            const body = editors2[i].getBody();
            if (body === target || DOM$2.isChildOf(target, body)) {
              fireEvent(editors2[i], eventName, e);
            }
          }
        };
        customEventRootDelegates[eventName] = delegate;
        DOM$2.bind(eventRootElm, eventName, delegate);
      } else {
        const delegate = (e) => {
          fireEvent(editor, eventName, e);
        };
        DOM$2.bind(eventRootElm, eventName, delegate);
        editor.delegates[eventName] = delegate;
      }
    };
    const EditorObservable = {
      ...Observable,
      bindPendingEventDelegates() {
        const self2 = this;
        Tools.each(self2._pendingNativeEvents, (name3) => {
          bindEventDelegate(self2, name3);
        });
      },
      toggleNativeEvent(name3, state2) {
        const self2 = this;
        if (name3 === "focus" || name3 === "blur") {
          return;
        }
        if (self2.removed) {
          return;
        }
        if (state2) {
          if (self2.initialized) {
            bindEventDelegate(self2, name3);
          } else {
            if (!self2._pendingNativeEvents) {
              self2._pendingNativeEvents = [name3];
            } else {
              self2._pendingNativeEvents.push(name3);
            }
          }
        } else if (self2.initialized && self2.delegates) {
          self2.dom.unbind(getEventTarget(self2, name3), name3, self2.delegates[name3]);
          delete self2.delegates[name3];
        }
      },
      unbindAllNativeEvents() {
        const self2 = this;
        const body = self2.getBody();
        const dom2 = self2.dom;
        if (self2.delegates) {
          each$d(self2.delegates, (value2, name3) => {
            self2.dom.unbind(getEventTarget(self2, name3), name3, value2);
          });
          delete self2.delegates;
        }
        if (!self2.inline && body && dom2) {
          body.onload = null;
          dom2.unbind(self2.getWin());
          dom2.unbind(self2.getDoc());
        }
        if (dom2) {
          dom2.unbind(body);
          dom2.unbind(self2.getContainer());
        }
      }
    };
    const stringListProcessor = (value2) => {
      if (isString2(value2)) {
        return {
          value: value2.split(/[ ,]/),
          valid: true
        };
      } else if (isArrayOf(value2, isString2)) {
        return {
          value: value2,
          valid: true
        };
      } else {
        return {
          valid: false,
          message: `The value must be a string[] or a comma/space separated string.`
        };
      }
    };
    const getBuiltInProcessor = (type2) => {
      const validator2 = (() => {
        switch (type2) {
          case "array":
            return isArray$12;
          case "boolean":
            return isBoolean2;
          case "function":
            return isFunction2;
          case "number":
            return isNumber2;
          case "object":
            return isObject2;
          case "string":
            return isString2;
          case "string[]":
            return stringListProcessor;
          case "object[]":
            return (val) => isArrayOf(val, isObject2);
          case "regexp":
            return (val) => is$4(val, RegExp);
          default:
            return always;
        }
      })();
      return (value2) => processValue(value2, validator2, `The value must be a ${type2}.`);
    };
    const isBuiltInSpec = (spec) => isString2(spec.processor);
    const getErrorMessage = (message, result) => {
      const additionalText = isEmpty$3(result.message) ? "" : `. ${result.message}`;
      return message + additionalText;
    };
    const isValidResult = (result) => result.valid;
    const processValue = (value2, processor, message = "") => {
      const result = processor(value2);
      if (isBoolean2(result)) {
        return result ? {
          value: value2,
          valid: true
        } : {
          valid: false,
          message
        };
      } else {
        return result;
      }
    };
    const processDefaultValue = (name3, defaultValue, processor) => {
      if (!isUndefined2(defaultValue)) {
        const result = processValue(defaultValue, processor);
        if (isValidResult(result)) {
          return result.value;
        } else {
          console.error(getErrorMessage(`Invalid default value passed for the "${name3}" option`, result));
        }
      }
      return void 0;
    };
    const create$52 = (editor, initialOptions) => {
      const registry2 = {};
      const values2 = {};
      const setValue = (name3, value2, processor) => {
        const result = processValue(value2, processor);
        if (isValidResult(result)) {
          values2[name3] = result.value;
          return true;
        } else {
          console.warn(getErrorMessage(`Invalid value passed for the ${name3} option`, result));
          return false;
        }
      };
      const register2 = (name3, spec) => {
        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;
        const defaultValue = processDefaultValue(name3, spec.default, processor);
        registry2[name3] = {
          ...spec,
          default: defaultValue,
          processor
        };
        const initValue = get$a(values2, name3).orThunk(() => get$a(initialOptions, name3));
        initValue.each((value2) => setValue(name3, value2, processor));
      };
      const isRegistered = (name3) => has$2(registry2, name3);
      const get2 = (name3) => get$a(values2, name3).orThunk(() => get$a(registry2, name3).map((spec) => spec.default)).getOrUndefined();
      const set2 = (name3, value2) => {
        if (!isRegistered(name3)) {
          console.warn(`"${name3}" is not a registered option. Ensure the option has been registered before setting a value.`);
          return false;
        } else {
          const spec = registry2[name3];
          if (spec.immutable) {
            console.error(`"${name3}" is an immutable option and cannot be updated`);
            return false;
          } else {
            return setValue(name3, value2, spec.processor);
          }
        }
      };
      const unset = (name3) => {
        const registered = isRegistered(name3);
        if (registered) {
          delete values2[name3];
        }
        return registered;
      };
      const isSet = (name3) => has$2(values2, name3);
      return {
        register: register2,
        isRegistered,
        get: get2,
        set: set2,
        unset,
        isSet
      };
    };
    const defaultModes = [
      "design",
      "readonly"
    ];
    const switchToMode = (editor, activeMode, availableModes, mode) => {
      const oldMode = availableModes[activeMode.get()];
      const newMode = availableModes[mode];
      try {
        newMode.activate();
      } catch (e) {
        console.error(`problem while activating editor mode ${mode}:`, e);
        return;
      }
      oldMode.deactivate();
      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {
        toggleReadOnly(editor, newMode.editorReadOnly);
      }
      activeMode.set(mode);
      fireSwitchMode(editor, mode);
    };
    const setMode = (editor, availableModes, activeMode, mode) => {
      if (mode === activeMode.get()) {
        return;
      } else if (!has$2(availableModes, mode)) {
        throw new Error(`Editor mode '${mode}' is invalid`);
      }
      if (editor.initialized) {
        switchToMode(editor, activeMode, availableModes, mode);
      } else {
        editor.on("init", () => switchToMode(editor, activeMode, availableModes, mode));
      }
    };
    const registerMode = (availableModes, mode, api2) => {
      if (contains$2(defaultModes, mode)) {
        throw new Error(`Cannot override default mode ${mode}`);
      }
      return {
        ...availableModes,
        [mode]: {
          ...api2,
          deactivate: () => {
            try {
              api2.deactivate();
            } catch (e) {
              console.error(`problem while deactivating editor mode ${mode}:`, e);
            }
          }
        }
      };
    };
    const create$42 = (editor) => {
      const activeMode = Cell("design");
      const availableModes = Cell({
        design: {
          activate: noop2,
          deactivate: noop2,
          editorReadOnly: false
        },
        readonly: {
          activate: noop2,
          deactivate: noop2,
          editorReadOnly: true
        }
      });
      registerReadOnlyContentFilters(editor);
      registerReadOnlySelectionBlockers(editor);
      return {
        isReadOnly: () => isReadOnly(editor),
        set: (mode) => setMode(editor, availableModes.get(), activeMode, mode),
        get: () => activeMode.get(),
        register: (mode, api2) => {
          availableModes.set(registerMode(availableModes.get(), mode, api2));
        }
      };
    };
    const each$2 = Tools.each, explode = Tools.explode;
    const keyCodeLookup = {
      f1: 112,
      f2: 113,
      f3: 114,
      f4: 115,
      f5: 116,
      f6: 117,
      f7: 118,
      f8: 119,
      f9: 120,
      f10: 121,
      f11: 122,
      f12: 123
    };
    const modifierNames = Tools.makeMap("alt,ctrl,shift,meta,access");
    const isModifier = (key) => key in modifierNames;
    const parseShortcut = (pattern) => {
      const shortcut = {};
      const isMac = Env.os.isMacOS() || Env.os.isiOS();
      each$2(explode(pattern.toLowerCase(), "+"), (value2) => {
        if (isModifier(value2)) {
          shortcut[value2] = true;
        } else {
          if (/^[0-9]{2,}$/.test(value2)) {
            shortcut.keyCode = parseInt(value2, 10);
          } else {
            shortcut.charCode = value2.charCodeAt(0);
            shortcut.keyCode = keyCodeLookup[value2] || value2.toUpperCase().charCodeAt(0);
          }
        }
      });
      const id = [shortcut.keyCode];
      let key;
      for (key in modifierNames) {
        if (shortcut[key]) {
          id.push(key);
        } else {
          shortcut[key] = false;
        }
      }
      shortcut.id = id.join(",");
      if (shortcut.access) {
        shortcut.alt = true;
        if (isMac) {
          shortcut.ctrl = true;
        } else {
          shortcut.shift = true;
        }
      }
      if (shortcut.meta) {
        if (isMac) {
          shortcut.meta = true;
        } else {
          shortcut.ctrl = true;
          shortcut.meta = false;
        }
      }
      return shortcut;
    };
    class Shortcuts {
      constructor(editor) {
        this.shortcuts = {};
        this.pendingPatterns = [];
        this.editor = editor;
        const self2 = this;
        editor.on("keyup keypress keydown", (e) => {
          if ((self2.hasModifier(e) || self2.isFunctionKey(e)) && !e.isDefaultPrevented()) {
            each$2(self2.shortcuts, (shortcut) => {
              if (self2.matchShortcut(e, shortcut)) {
                self2.pendingPatterns = shortcut.subpatterns.slice(0);
                if (e.type === "keydown") {
                  self2.executeShortcutAction(shortcut);
                }
              }
            });
            if (self2.matchShortcut(e, self2.pendingPatterns[0])) {
              if (self2.pendingPatterns.length === 1) {
                if (e.type === "keydown") {
                  self2.executeShortcutAction(self2.pendingPatterns[0]);
                }
              }
              self2.pendingPatterns.shift();
            }
          }
        });
      }
      add(pattern, desc, cmdFunc, scope) {
        const self2 = this;
        const func = self2.normalizeCommandFunc(cmdFunc);
        each$2(explode(Tools.trim(pattern)), (pattern2) => {
          const shortcut = self2.createShortcut(pattern2, desc, func, scope);
          self2.shortcuts[shortcut.id] = shortcut;
        });
        return true;
      }
      remove(pattern) {
        const shortcut = this.createShortcut(pattern);
        if (this.shortcuts[shortcut.id]) {
          delete this.shortcuts[shortcut.id];
          return true;
        }
        return false;
      }
      normalizeCommandFunc(cmdFunc) {
        const self2 = this;
        const cmd = cmdFunc;
        if (typeof cmd === "string") {
          return () => {
            self2.editor.execCommand(cmd, false, null);
          };
        } else if (Tools.isArray(cmd)) {
          return () => {
            self2.editor.execCommand(cmd[0], cmd[1], cmd[2]);
          };
        } else {
          return cmd;
        }
      }
      createShortcut(pattern, desc, cmdFunc, scope) {
        const shortcuts = Tools.map(explode(pattern, ">"), parseShortcut);
        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {
          func: cmdFunc,
          scope: scope || this.editor
        });
        return Tools.extend(shortcuts[0], {
          desc: this.editor.translate(desc),
          subpatterns: shortcuts.slice(1)
        });
      }
      hasModifier(e) {
        return e.altKey || e.ctrlKey || e.metaKey;
      }
      isFunctionKey(e) {
        return e.type === "keydown" && e.keyCode >= 112 && e.keyCode <= 123;
      }
      matchShortcut(e, shortcut) {
        if (!shortcut) {
          return false;
        }
        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {
          return false;
        }
        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {
          return false;
        }
        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {
          e.preventDefault();
          return true;
        }
        return false;
      }
      executeShortcutAction(shortcut) {
        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;
      }
    }
    const create$32 = () => {
      const buttons = {};
      const menuItems = {};
      const popups = {};
      const icons = {};
      const contextMenus = {};
      const contextToolbars = {};
      const sidebars = {};
      const views = {};
      const add2 = (collection, type2) => (name3, spec) => {
        collection[name3.toLowerCase()] = {
          ...spec,
          type: type2
        };
      };
      const addIcon = (name3, svgData) => icons[name3.toLowerCase()] = svgData;
      return {
        addButton: add2(buttons, "button"),
        addGroupToolbarButton: add2(buttons, "grouptoolbarbutton"),
        addToggleButton: add2(buttons, "togglebutton"),
        addMenuButton: add2(buttons, "menubutton"),
        addSplitButton: add2(buttons, "splitbutton"),
        addMenuItem: add2(menuItems, "menuitem"),
        addNestedMenuItem: add2(menuItems, "nestedmenuitem"),
        addToggleMenuItem: add2(menuItems, "togglemenuitem"),
        addAutocompleter: add2(popups, "autocompleter"),
        addContextMenu: add2(contextMenus, "contextmenu"),
        addContextToolbar: add2(contextToolbars, "contexttoolbar"),
        addContextForm: add2(contextToolbars, "contextform"),
        addSidebar: add2(sidebars, "sidebar"),
        addView: add2(views, "views"),
        addIcon,
        getAll: () => ({
          buttons,
          menuItems,
          icons,
          popups,
          contextMenus,
          contextToolbars,
          sidebars,
          views
        })
      };
    };
    const registry = () => {
      const bridge = create$32();
      return {
        addAutocompleter: bridge.addAutocompleter,
        addButton: bridge.addButton,
        addContextForm: bridge.addContextForm,
        addContextMenu: bridge.addContextMenu,
        addContextToolbar: bridge.addContextToolbar,
        addIcon: bridge.addIcon,
        addMenuButton: bridge.addMenuButton,
        addMenuItem: bridge.addMenuItem,
        addNestedMenuItem: bridge.addNestedMenuItem,
        addSidebar: bridge.addSidebar,
        addSplitButton: bridge.addSplitButton,
        addToggleButton: bridge.addToggleButton,
        addGroupToolbarButton: bridge.addGroupToolbarButton,
        addToggleMenuItem: bridge.addToggleMenuItem,
        addView: bridge.addView,
        getAll: bridge.getAll
      };
    };
    const DOM$1 = DOMUtils.DOM;
    const extend2 = Tools.extend, each$1 = Tools.each;
    class Editor {
      constructor(id, options, editorManager) {
        this.plugins = {};
        this.contentCSS = [];
        this.contentStyles = [];
        this.loadedCSS = {};
        this.isNotDirty = false;
        this.composing = false;
        this.destroyed = false;
        this.hasHiddenInput = false;
        this.iframeElement = null;
        this.initialized = false;
        this.readonly = false;
        this.removed = false;
        this.startContent = "";
        this._pendingNativeEvents = [];
        this._skinLoaded = false;
        this.editorManager = editorManager;
        this.documentBaseUrl = editorManager.documentBaseURL;
        extend2(this, EditorObservable);
        const self2 = this;
        this.id = id;
        this.hidden = false;
        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);
        this.options = create$52(self2, normalizedOptions);
        register$7(self2);
        const getOption2 = this.options.get;
        if (getOption2("deprecation_warnings")) {
          logWarnings(options, normalizedOptions);
        }
        const suffix = getOption2("suffix");
        if (suffix) {
          editorManager.suffix = suffix;
        }
        this.suffix = editorManager.suffix;
        const baseUrl = getOption2("base_url");
        if (baseUrl) {
          editorManager._setBaseUrl(baseUrl);
        }
        this.baseUri = editorManager.baseURI;
        const referrerPolicy = getReferrerPolicy(self2);
        if (referrerPolicy) {
          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);
          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);
        }
        const contentCssCors = hasContentCssCors(self2);
        if (isNonNullable(contentCssCors)) {
          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);
        }
        AddOnManager.languageLoad = getOption2("language_load");
        AddOnManager.baseURL = editorManager.baseURL;
        this.setDirty(false);
        this.documentBaseURI = new URI(getDocumentBaseUrl(self2), { base_uri: this.baseUri });
        this.baseURI = this.baseUri;
        this.inline = isInline(self2);
        this.hasVisual = isVisualAidsEnabled(self2);
        this.shortcuts = new Shortcuts(this);
        this.editorCommands = new EditorCommands(this);
        registerCommands(this);
        const cacheSuffix = getOption2("cache_suffix");
        if (cacheSuffix) {
          Env.cacheSuffix = cacheSuffix.replace(/^[\?\&]+/, "");
        }
        this.ui = {
          registry: registry(),
          styleSheetLoader: void 0,
          show: noop2,
          hide: noop2,
          setEnabled: noop2,
          isEnabled: always
        };
        this.mode = create$42(self2);
        editorManager.dispatch("SetupEditor", { editor: this });
        const setupCallback = getSetupCallback(self2);
        if (isFunction2(setupCallback)) {
          setupCallback.call(self2, self2);
        }
      }
      render() {
        render(this);
      }
      focus(skipFocus) {
        this.execCommand("mceFocus", false, skipFocus);
      }
      hasFocus() {
        return hasFocus(this);
      }
      translate(text3) {
        return I18n.translate(text3);
      }
      getParam(name3, defaultVal, type2) {
        const options = this.options;
        if (!options.isRegistered(name3)) {
          if (isNonNullable(type2)) {
            options.register(name3, {
              processor: type2,
              default: defaultVal
            });
          } else {
            options.register(name3, {
              processor: always,
              default: defaultVal
            });
          }
        }
        return !options.isSet(name3) && !isUndefined2(defaultVal) ? defaultVal : options.get(name3);
      }
      hasPlugin(name3, loaded) {
        const hasPlugin = contains$2(getPlugins(this), name3);
        if (hasPlugin) {
          return loaded ? PluginManager.get(name3) !== void 0 : true;
        } else {
          return false;
        }
      }
      nodeChanged(args) {
        this._nodeChangeDispatcher.nodeChanged(args);
      }
      addCommand(name3, callback, scope) {
        this.editorCommands.addCommand(name3, callback, scope);
      }
      addQueryStateHandler(name3, callback, scope) {
        this.editorCommands.addQueryStateHandler(name3, callback, scope);
      }
      addQueryValueHandler(name3, callback, scope) {
        this.editorCommands.addQueryValueHandler(name3, callback, scope);
      }
      addShortcut(pattern, desc, cmdFunc, scope) {
        this.shortcuts.add(pattern, desc, cmdFunc, scope);
      }
      execCommand(cmd, ui, value2, args) {
        return this.editorCommands.execCommand(cmd, ui, value2, args);
      }
      queryCommandState(cmd) {
        return this.editorCommands.queryCommandState(cmd);
      }
      queryCommandValue(cmd) {
        return this.editorCommands.queryCommandValue(cmd);
      }
      queryCommandSupported(cmd) {
        return this.editorCommands.queryCommandSupported(cmd);
      }
      show() {
        const self2 = this;
        if (self2.hidden) {
          self2.hidden = false;
          if (self2.inline) {
            self2.getBody().contentEditable = "true";
          } else {
            DOM$1.show(self2.getContainer());
            DOM$1.hide(self2.id);
          }
          self2.load();
          self2.dispatch("show");
        }
      }
      hide() {
        const self2 = this;
        if (!self2.hidden) {
          self2.save();
          if (self2.inline) {
            self2.getBody().contentEditable = "false";
            if (self2 === self2.editorManager.focusedEditor) {
              self2.editorManager.focusedEditor = null;
            }
          } else {
            DOM$1.hide(self2.getContainer());
            DOM$1.setStyle(self2.id, "display", self2.orgDisplay);
          }
          self2.hidden = true;
          self2.dispatch("hide");
        }
      }
      isHidden() {
        return this.hidden;
      }
      setProgressState(state2, time) {
        this.dispatch("ProgressState", {
          state: state2,
          time
        });
      }
      load(args = {}) {
        const self2 = this;
        const elm = self2.getElement();
        if (self2.removed) {
          return "";
        }
        if (elm) {
          const loadArgs = {
            ...args,
            load: true
          };
          const value2 = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;
          const html2 = self2.setContent(value2, loadArgs);
          if (!loadArgs.no_events) {
            self2.dispatch("LoadContent", {
              ...loadArgs,
              element: elm
            });
          }
          return html2;
        } else {
          return "";
        }
      }
      save(args = {}) {
        const self2 = this;
        let elm = self2.getElement();
        if (!elm || !self2.initialized || self2.removed) {
          return "";
        }
        const getArgs = {
          ...args,
          save: true,
          element: elm
        };
        let html2 = self2.getContent(getArgs);
        const saveArgs = {
          ...getArgs,
          content: html2
        };
        if (!saveArgs.no_events) {
          self2.dispatch("SaveContent", saveArgs);
        }
        if (saveArgs.format === "raw") {
          self2.dispatch("RawSaveContent", saveArgs);
        }
        html2 = saveArgs.content;
        if (!isTextareaOrInput(elm)) {
          if (args.is_removing || !self2.inline) {
            elm.innerHTML = html2;
          }
          const form = DOM$1.getParent(self2.id, "form");
          if (form) {
            each$1(form.elements, (elm2) => {
              if (elm2.name === self2.id) {
                elm2.value = html2;
                return false;
              } else {
                return true;
              }
            });
          }
        } else {
          elm.value = html2;
        }
        saveArgs.element = getArgs.element = elm = null;
        if (saveArgs.set_dirty !== false) {
          self2.setDirty(false);
        }
        return html2;
      }
      setContent(content, args) {
        return setContent(this, content, args);
      }
      getContent(args) {
        return getContent(this, args);
      }
      insertContent(content, args) {
        if (args) {
          content = extend2({ content }, args);
        }
        this.execCommand("mceInsertContent", false, content);
      }
      resetContent(initialContent) {
        if (initialContent === void 0) {
          setContent(this, this.startContent, { format: "raw" });
        } else {
          setContent(this, initialContent);
        }
        this.undoManager.reset();
        this.setDirty(false);
        this.nodeChanged();
      }
      isDirty() {
        return !this.isNotDirty;
      }
      setDirty(state2) {
        const oldState = !this.isNotDirty;
        this.isNotDirty = !state2;
        if (state2 && state2 !== oldState) {
          this.dispatch("dirty");
        }
      }
      getContainer() {
        const self2 = this;
        if (!self2.container) {
          self2.container = self2.editorContainer || DOM$1.get(self2.id + "_parent");
        }
        return self2.container;
      }
      getContentAreaContainer() {
        return this.contentAreaContainer;
      }
      getElement() {
        if (!this.targetElm) {
          this.targetElm = DOM$1.get(this.id);
        }
        return this.targetElm;
      }
      getWin() {
        const self2 = this;
        if (!self2.contentWindow) {
          const elm = self2.iframeElement;
          if (elm) {
            self2.contentWindow = elm.contentWindow;
          }
        }
        return self2.contentWindow;
      }
      getDoc() {
        const self2 = this;
        if (!self2.contentDocument) {
          const win = self2.getWin();
          if (win) {
            self2.contentDocument = win.document;
          }
        }
        return self2.contentDocument;
      }
      getBody() {
        var _a, _b;
        const doc = this.getDoc();
        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;
      }
      convertURL(url, name3, elm) {
        const self2 = this, getOption2 = self2.options.get;
        const urlConverterCallback = getUrlConverterCallback(self2);
        if (isFunction2(urlConverterCallback)) {
          return urlConverterCallback.call(self2, url, elm, true, name3);
        }
        if (!getOption2("convert_urls") || elm === "link" || isObject2(elm) && elm.nodeName === "LINK" || url.indexOf("file:") === 0 || url.length === 0) {
          return url;
        }
        if (getOption2("relative_urls")) {
          return self2.documentBaseURI.toRelative(url);
        }
        url = self2.documentBaseURI.toAbsolute(url, getOption2("remove_script_host"));
        return url;
      }
      addVisual(elm) {
        addVisual(this, elm);
      }
      remove() {
        remove$1(this);
      }
      destroy(automatic) {
        destroy2(this, automatic);
      }
      uploadImages() {
        return this.editorUpload.uploadImages();
      }
      _scanForImages() {
        return this.editorUpload.scanForImages();
      }
    }
    const DOM = DOMUtils.DOM;
    const each = Tools.each;
    let boundGlobalEvents = false;
    let beforeUnloadDelegate;
    let editors = [];
    const globalEventDelegate = (e) => {
      const type2 = e.type;
      each(EditorManager.get(), (editor) => {
        switch (type2) {
          case "scroll":
            editor.dispatch("ScrollWindow", e);
            break;
          case "resize":
            editor.dispatch("ResizeWindow", e);
            break;
        }
      });
    };
    const toggleGlobalEvents = (state2) => {
      if (state2 !== boundGlobalEvents) {
        const DOM2 = DOMUtils.DOM;
        if (state2) {
          DOM2.bind(window, "resize", globalEventDelegate);
          DOM2.bind(window, "scroll", globalEventDelegate);
        } else {
          DOM2.unbind(window, "resize", globalEventDelegate);
          DOM2.unbind(window, "scroll", globalEventDelegate);
        }
        boundGlobalEvents = state2;
      }
    };
    const removeEditorFromList = (targetEditor) => {
      const oldEditors = editors;
      editors = filter$5(editors, (editor) => {
        return targetEditor !== editor;
      });
      if (EditorManager.activeEditor === targetEditor) {
        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;
      }
      if (EditorManager.focusedEditor === targetEditor) {
        EditorManager.focusedEditor = null;
      }
      return oldEditors.length !== editors.length;
    };
    const purgeDestroyedEditor = (editor) => {
      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {
        removeEditorFromList(editor);
        editor.unbindAllNativeEvents();
        editor.destroy(true);
        editor.removed = true;
      }
    };
    const isQuirksMode = document.compatMode !== "CSS1Compat";
    const EditorManager = {
      ...Observable,
      baseURI: null,
      baseURL: null,
      defaultOptions: {},
      documentBaseURL: null,
      suffix: null,
      majorVersion: "6",
      minorVersion: "4.1",
      releaseDate: "2023-03-29",
      i18n: I18n,
      activeEditor: null,
      focusedEditor: null,
      setup() {
        const self2 = this;
        let baseURL = "";
        let suffix = "";
        let documentBaseURL = URI.getDocumentBaseUrl(document.location);
        if (/^[^:]+:\/\/\/?[^\/]+\//.test(documentBaseURL)) {
          documentBaseURL = documentBaseURL.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, "");
          if (!/[\/\\]$/.test(documentBaseURL)) {
            documentBaseURL += "/";
          }
        }
        const preInit2 = window.tinymce || window.tinyMCEPreInit;
        if (preInit2) {
          baseURL = preInit2.base || preInit2.baseURL;
          suffix = preInit2.suffix;
        } else {
          const scripts = document.getElementsByTagName("script");
          for (let i = 0; i < scripts.length; i++) {
            const src = scripts[i].src || "";
            if (src === "") {
              continue;
            }
            const srcScript = src.substring(src.lastIndexOf("/"));
            if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(src)) {
              if (srcScript.indexOf(".min") !== -1) {
                suffix = ".min";
              }
              baseURL = src.substring(0, src.lastIndexOf("/"));
              break;
            }
          }
          if (!baseURL && document.currentScript) {
            const src = document.currentScript.src;
            if (src.indexOf(".min") !== -1) {
              suffix = ".min";
            }
            baseURL = src.substring(0, src.lastIndexOf("/"));
          }
        }
        self2.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);
        self2.documentBaseURL = documentBaseURL;
        self2.baseURI = new URI(self2.baseURL);
        self2.suffix = suffix;
        setup$v(self2);
      },
      overrideDefaults(defaultOptions2) {
        const baseUrl = defaultOptions2.base_url;
        if (baseUrl) {
          this._setBaseUrl(baseUrl);
        }
        const suffix = defaultOptions2.suffix;
        if (suffix) {
          this.suffix = suffix;
        }
        this.defaultOptions = defaultOptions2;
        const pluginBaseUrls = defaultOptions2.plugin_base_urls;
        if (pluginBaseUrls !== void 0) {
          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {
            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;
          });
        }
      },
      init(options) {
        const self2 = this;
        let result;
        const invalidInlineTargets = Tools.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " ");
        const isInvalidInlineTarget = (options2, elm) => options2.inline && elm.tagName.toLowerCase() in invalidInlineTargets;
        const createId = (elm) => {
          let id = elm.id;
          if (!id) {
            id = get$a(elm, "name").filter((name3) => !DOM.get(name3)).getOrThunk(DOM.uniqueId);
            elm.setAttribute("id", id);
          }
          return id;
        };
        const execCallback = (name3) => {
          const callback = options[name3];
          if (!callback) {
            return;
          }
          return callback.apply(self2, []);
        };
        const findTargets = (options2) => {
          if (Env.browser.isIE() || Env.browser.isEdge()) {
            initError("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers");
            return [];
          } else if (isQuirksMode) {
            initError("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode.");
            return [];
          } else if (isString2(options2.selector)) {
            return DOM.select(options2.selector);
          } else if (isNonNullable(options2.target)) {
            return [options2.target];
          } else {
            return [];
          }
        };
        let provideResults = (editors2) => {
          result = editors2;
        };
        const initEditors = () => {
          let initCount = 0;
          const editors2 = [];
          let targets;
          const createEditor = (id, options2, targetElm) => {
            const editor = new Editor(id, options2, self2);
            editors2.push(editor);
            editor.on("init", () => {
              if (++initCount === targets.length) {
                provideResults(editors2);
              }
            });
            editor.targetElm = editor.targetElm || targetElm;
            editor.render();
          };
          DOM.unbind(window, "ready", initEditors);
          execCallback("onpageload");
          targets = unique$1(findTargets(options));
          Tools.each(targets, (elm) => {
            purgeDestroyedEditor(self2.get(elm.id));
          });
          targets = Tools.grep(targets, (elm) => {
            return !self2.get(elm.id);
          });
          if (targets.length === 0) {
            provideResults([]);
          } else {
            each(targets, (elm) => {
              if (isInvalidInlineTarget(options, elm)) {
                initError("Could not initialize inline editor on invalid inline target element", elm);
              } else {
                createEditor(createId(elm), options, elm);
              }
            });
          }
        };
        DOM.bind(window, "ready", initEditors);
        return new Promise((resolve2) => {
          if (result) {
            resolve2(result);
          } else {
            provideResults = (editors2) => {
              resolve2(editors2);
            };
          }
        });
      },
      get(id) {
        if (arguments.length === 0) {
          return editors.slice(0);
        } else if (isString2(id)) {
          return find$2(editors, (editor) => {
            return editor.id === id;
          }).getOr(null);
        } else if (isNumber2(id)) {
          return editors[id] ? editors[id] : null;
        } else {
          return null;
        }
      },
      add(editor) {
        const self2 = this;
        const existingEditor = self2.get(editor.id);
        if (existingEditor === editor) {
          return editor;
        }
        if (existingEditor === null) {
          editors.push(editor);
        }
        toggleGlobalEvents(true);
        self2.activeEditor = editor;
        self2.dispatch("AddEditor", { editor });
        if (!beforeUnloadDelegate) {
          beforeUnloadDelegate = (e) => {
            const event = self2.dispatch("BeforeUnload");
            if (event.returnValue) {
              e.preventDefault();
              e.returnValue = event.returnValue;
              return event.returnValue;
            }
          };
          window.addEventListener("beforeunload", beforeUnloadDelegate);
        }
        return editor;
      },
      createEditor(id, options) {
        return this.add(new Editor(id, options, this));
      },
      remove(selector) {
        const self2 = this;
        let editor;
        if (!selector) {
          for (let i = editors.length - 1; i >= 0; i--) {
            self2.remove(editors[i]);
          }
          return;
        }
        if (isString2(selector)) {
          each(DOM.select(selector), (elm) => {
            editor = self2.get(elm.id);
            if (editor) {
              self2.remove(editor);
            }
          });
          return;
        }
        editor = selector;
        if (isNull2(self2.get(editor.id))) {
          return null;
        }
        if (removeEditorFromList(editor)) {
          self2.dispatch("RemoveEditor", { editor });
        }
        if (editors.length === 0) {
          window.removeEventListener("beforeunload", beforeUnloadDelegate);
        }
        editor.remove();
        toggleGlobalEvents(editors.length > 0);
        return editor;
      },
      execCommand(cmd, ui, value2) {
        var _a;
        const self2 = this;
        const editorId = isObject2(value2) ? (_a = value2.id) !== null && _a !== void 0 ? _a : value2.index : value2;
        switch (cmd) {
          case "mceAddEditor": {
            if (!self2.get(editorId)) {
              const editorOptions = value2.options;
              new Editor(editorId, editorOptions, self2).render();
            }
            return true;
          }
          case "mceRemoveEditor": {
            const editor = self2.get(editorId);
            if (editor) {
              editor.remove();
            }
            return true;
          }
          case "mceToggleEditor": {
            const editor = self2.get(editorId);
            if (!editor) {
              self2.execCommand("mceAddEditor", false, value2);
              return true;
            }
            if (editor.isHidden()) {
              editor.show();
            } else {
              editor.hide();
            }
            return true;
          }
        }
        if (self2.activeEditor) {
          return self2.activeEditor.execCommand(cmd, ui, value2);
        }
        return false;
      },
      triggerSave: () => {
        each(editors, (editor) => {
          editor.save();
        });
      },
      addI18n: (code, items) => {
        I18n.add(code, items);
      },
      translate: (text3) => {
        return I18n.translate(text3);
      },
      setActive(editor) {
        const activeEditor = this.activeEditor;
        if (this.activeEditor !== editor) {
          if (activeEditor) {
            activeEditor.dispatch("deactivate", { relatedTarget: editor });
          }
          editor.dispatch("activate", { relatedTarget: activeEditor });
        }
        this.activeEditor = editor;
      },
      _setBaseUrl(baseUrl) {
        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\/+$/, ""));
        this.baseURI = new URI(this.baseURL);
      }
    };
    EditorManager.setup();
    const setup = () => {
      const dataValue = value$2();
      const FakeClipboardItem = (items) => ({
        items,
        types: keys(items),
        getType: (type2) => get$a(items, type2).getOrUndefined()
      });
      const write3 = (data3) => {
        dataValue.set(data3);
      };
      const read3 = () => dataValue.get().getOrUndefined();
      const clear3 = dataValue.clear;
      return {
        FakeClipboardItem,
        write: write3,
        read: read3,
        clear: clear3
      };
    };
    const FakeClipboard = setup();
    const min2 = Math.min, max2 = Math.max, round2 = Math.round;
    const relativePosition = (rect, targetRect, rel) => {
      let x = targetRect.x;
      let y = targetRect.y;
      const w = rect.w;
      const h = rect.h;
      const targetW = targetRect.w;
      const targetH = targetRect.h;
      const relChars = (rel || "").split("");
      if (relChars[0] === "b") {
        y += targetH;
      }
      if (relChars[1] === "r") {
        x += targetW;
      }
      if (relChars[0] === "c") {
        y += round2(targetH / 2);
      }
      if (relChars[1] === "c") {
        x += round2(targetW / 2);
      }
      if (relChars[3] === "b") {
        y -= h;
      }
      if (relChars[4] === "r") {
        x -= w;
      }
      if (relChars[3] === "c") {
        y -= round2(h / 2);
      }
      if (relChars[4] === "c") {
        x -= round2(w / 2);
      }
      return create$22(x, y, w, h);
    };
    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {
      for (let i = 0; i < rels.length; i++) {
        const pos = relativePosition(rect, targetRect, rels[i]);
        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {
          return rels[i];
        }
      }
      return null;
    };
    const inflate = (rect, w, h) => {
      return create$22(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);
    };
    const intersect = (rect, cropRect) => {
      const x1 = max2(rect.x, cropRect.x);
      const y1 = max2(rect.y, cropRect.y);
      const x2 = min2(rect.x + rect.w, cropRect.x + cropRect.w);
      const y2 = min2(rect.y + rect.h, cropRect.y + cropRect.h);
      if (x2 - x1 < 0 || y2 - y1 < 0) {
        return null;
      }
      return create$22(x1, y1, x2 - x1, y2 - y1);
    };
    const clamp = (rect, clampRect, fixedSize) => {
      let x1 = rect.x;
      let y1 = rect.y;
      let x2 = rect.x + rect.w;
      let y2 = rect.y + rect.h;
      const cx2 = clampRect.x + clampRect.w;
      const cy2 = clampRect.y + clampRect.h;
      const underflowX1 = max2(0, clampRect.x - x1);
      const underflowY1 = max2(0, clampRect.y - y1);
      const overflowX2 = max2(0, x2 - cx2);
      const overflowY2 = max2(0, y2 - cy2);
      x1 += underflowX1;
      y1 += underflowY1;
      if (fixedSize) {
        x2 += underflowX1;
        y2 += underflowY1;
        x1 -= overflowX2;
        y1 -= overflowY2;
      }
      x2 -= overflowX2;
      y2 -= overflowY2;
      return create$22(x1, y1, x2 - x1, y2 - y1);
    };
    const create$22 = (x, y, w, h) => {
      return {
        x,
        y,
        w,
        h
      };
    };
    const fromClientRect = (clientRect) => {
      return create$22(clientRect.left, clientRect.top, clientRect.width, clientRect.height);
    };
    const Rect = {
      inflate,
      relativePosition,
      findBestRelativePosition,
      intersect,
      clamp,
      create: create$22,
      fromClientRect
    };
    const awaiter = (resolveCb, rejectCb, timeout = 1e3) => {
      let done = false;
      let timer = null;
      const complete = (completer) => (...args) => {
        if (!done) {
          done = true;
          if (timer !== null) {
            clearTimeout(timer);
            timer = null;
          }
          completer.apply(null, args);
        }
      };
      const resolve2 = complete(resolveCb);
      const reject = complete(rejectCb);
      const start3 = (...args) => {
        if (!done && timer === null) {
          timer = setTimeout(() => reject.apply(null, args), timeout);
        }
      };
      return {
        start: start3,
        resolve: resolve2,
        reject
      };
    };
    const create$12 = () => {
      const tasks = {};
      const resultFns = {};
      const load = (id, url) => {
        const loadErrMsg = `Script at URL "${url}" failed to load`;
        const runErrMsg = `Script at URL "${url}" did not call \`tinymce.Resource.add('${id}', data)\` within 1 second`;
        if (tasks[id] !== void 0) {
          return tasks[id];
        } else {
          const task = new Promise((resolve2, reject) => {
            const waiter = awaiter(resolve2, reject);
            resultFns[id] = waiter.resolve;
            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));
          });
          tasks[id] = task;
          return task;
        }
      };
      const add2 = (id, data3) => {
        if (resultFns[id] !== void 0) {
          resultFns[id](data3);
          delete resultFns[id];
        }
        tasks[id] = Promise.resolve(data3);
      };
      const unload = (id) => {
        delete tasks[id];
      };
      return {
        load,
        add: add2,
        unload
      };
    };
    const Resource = create$12();
    const create2 = () => (() => {
      let data3 = {};
      let keys2 = [];
      const storage = {
        getItem: (key) => {
          const item2 = data3[key];
          return item2 ? item2 : null;
        },
        setItem: (key, value2) => {
          keys2.push(key);
          data3[key] = String(value2);
        },
        key: (index) => {
          return keys2[index];
        },
        removeItem: (key) => {
          keys2 = keys2.filter((k) => k === key);
          delete data3[key];
        },
        clear: () => {
          keys2 = [];
          data3 = {};
        },
        length: 0
      };
      Object.defineProperty(storage, "length", {
        get: () => keys2.length,
        configurable: false,
        enumerable: false
      });
      return storage;
    })();
    let localStorage;
    try {
      const test = "__storage_test__";
      localStorage = window.localStorage;
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
    } catch (e) {
      localStorage = create2();
    }
    var LocalStorage = localStorage;
    const publicApi = {
      geom: { Rect },
      util: {
        Delay,
        Tools,
        VK,
        URI,
        EventDispatcher,
        Observable,
        I18n,
        LocalStorage,
        ImageUploader
      },
      dom: {
        EventUtils,
        TreeWalker: DomTreeWalker,
        TextSeeker,
        DOMUtils,
        ScriptLoader,
        RangeUtils,
        Serializer: DomSerializer,
        StyleSheetLoader,
        ControlSelection,
        BookmarkManager,
        Selection: EditorSelection,
        Event: EventUtils.Event
      },
      html: {
        Styles,
        Entities,
        Node: AstNode,
        Schema,
        DomParser,
        Writer,
        Serializer: HtmlSerializer
      },
      Env,
      AddOnManager,
      Annotator,
      Formatter,
      UndoManager,
      EditorCommands,
      WindowManager,
      NotificationManager,
      EditorObservable,
      Shortcuts,
      Editor,
      FocusManager,
      EditorManager,
      DOM: DOMUtils.DOM,
      ScriptLoader: ScriptLoader.ScriptLoader,
      PluginManager,
      ThemeManager,
      ModelManager,
      IconManager,
      Resource,
      FakeClipboard,
      trim: Tools.trim,
      isArray: Tools.isArray,
      is: Tools.is,
      toArray: Tools.toArray,
      makeMap: Tools.makeMap,
      each: Tools.each,
      map: Tools.map,
      grep: Tools.grep,
      inArray: Tools.inArray,
      extend: Tools.extend,
      walk: Tools.walk,
      resolve: Tools.resolve,
      explode: Tools.explode,
      _addCacheSuffix: Tools._addCacheSuffix
    };
    const tinymce2 = Tools.extend(EditorManager, publicApi);
    const exportToModuleLoaders = (tinymce3) => {
      {
        try {
          module.exports = tinymce3;
        } catch (_2) {
        }
      }
    };
    const exportToWindowGlobal = (tinymce3) => {
      window.tinymce = tinymce3;
      window.tinyMCE = tinymce3;
    };
    exportToWindowGlobal(tinymce2);
    exportToModuleLoaders(tinymce2);
  })();
})(tinymce$2);
const tinymce$1 = tinymceExports;
var bootstrap_bundleExports = {};
var bootstrap_bundle = {
  get exports() {
    return bootstrap_bundleExports;
  },
  set exports(v) {
    bootstrap_bundleExports = v;
  }
};
/*!
  * Bootstrap v5.3.0-alpha3 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    const elementMap2 = /* @__PURE__ */ new Map();
    const Data2 = {
      set(element, key, instance) {
        if (!elementMap2.has(element)) {
          elementMap2.set(element, /* @__PURE__ */ new Map());
        }
        const instanceMap = elementMap2.get(element);
        if (!instanceMap.has(key) && instanceMap.size !== 0) {
          console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
          return;
        }
        instanceMap.set(key, instance);
      },
      get(element, key) {
        if (elementMap2.has(element)) {
          return elementMap2.get(element).get(key) || null;
        }
        return null;
      },
      remove(element, key) {
        if (!elementMap2.has(element)) {
          return;
        }
        const instanceMap = elementMap2.get(element);
        instanceMap.delete(key);
        if (instanceMap.size === 0) {
          elementMap2.delete(element);
        }
      }
    };
    const MAX_UID2 = 1e6;
    const MILLISECONDS_MULTIPLIER2 = 1e3;
    const TRANSITION_END2 = "transitionend";
    const parseSelector2 = (selector) => {
      if (selector && window.CSS && window.CSS.escape) {
        selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
      }
      return selector;
    };
    const toType2 = (object) => {
      if (object === null || object === void 0) {
        return `${object}`;
      }
      return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
    };
    const getUID2 = (prefix) => {
      do {
        prefix += Math.floor(Math.random() * MAX_UID2);
      } while (document.getElementById(prefix));
      return prefix;
    };
    const getTransitionDurationFromElement2 = (element) => {
      if (!element) {
        return 0;
      }
      let {
        transitionDuration,
        transitionDelay
      } = window.getComputedStyle(element);
      const floatTransitionDuration = Number.parseFloat(transitionDuration);
      const floatTransitionDelay = Number.parseFloat(transitionDelay);
      if (!floatTransitionDuration && !floatTransitionDelay) {
        return 0;
      }
      transitionDuration = transitionDuration.split(",")[0];
      transitionDelay = transitionDelay.split(",")[0];
      return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER2;
    };
    const triggerTransitionEnd2 = (element) => {
      element.dispatchEvent(new Event(TRANSITION_END2));
    };
    const isElement$12 = (object) => {
      if (!object || typeof object !== "object") {
        return false;
      }
      if (typeof object.jquery !== "undefined") {
        object = object[0];
      }
      return typeof object.nodeType !== "undefined";
    };
    const getElement2 = (object) => {
      if (isElement$12(object)) {
        return object.jquery ? object[0] : object;
      }
      if (typeof object === "string" && object.length > 0) {
        return document.querySelector(parseSelector2(object));
      }
      return null;
    };
    const isVisible2 = (element) => {
      if (!isElement$12(element) || element.getClientRects().length === 0) {
        return false;
      }
      const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
      const closedDetails = element.closest("details:not([open])");
      if (!closedDetails) {
        return elementIsVisible;
      }
      if (closedDetails !== element) {
        const summary = element.closest("summary");
        if (summary && summary.parentNode !== closedDetails) {
          return false;
        }
        if (summary === null) {
          return false;
        }
      }
      return elementIsVisible;
    };
    const isDisabled2 = (element) => {
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        return true;
      }
      if (element.classList.contains("disabled")) {
        return true;
      }
      if (typeof element.disabled !== "undefined") {
        return element.disabled;
      }
      return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
    };
    const findShadowRoot2 = (element) => {
      if (!document.documentElement.attachShadow) {
        return null;
      }
      if (typeof element.getRootNode === "function") {
        const root2 = element.getRootNode();
        return root2 instanceof ShadowRoot ? root2 : null;
      }
      if (element instanceof ShadowRoot) {
        return element;
      }
      if (!element.parentNode) {
        return null;
      }
      return findShadowRoot2(element.parentNode);
    };
    const noop2 = () => {
    };
    const reflow2 = (element) => {
      element.offsetHeight;
    };
    const getjQuery2 = () => {
      if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
        return window.jQuery;
      }
      return null;
    };
    const DOMContentLoadedCallbacks2 = [];
    const onDOMContentLoaded2 = (callback) => {
      if (document.readyState === "loading") {
        if (!DOMContentLoadedCallbacks2.length) {
          document.addEventListener("DOMContentLoaded", () => {
            for (const callback2 of DOMContentLoadedCallbacks2) {
              callback2();
            }
          });
        }
        DOMContentLoadedCallbacks2.push(callback);
      } else {
        callback();
      }
    };
    const isRTL2 = () => document.documentElement.dir === "rtl";
    const defineJQueryPlugin2 = (plugin2) => {
      onDOMContentLoaded2(() => {
        const $2 = getjQuery2();
        if ($2) {
          const name2 = plugin2.NAME;
          const JQUERY_NO_CONFLICT = $2.fn[name2];
          $2.fn[name2] = plugin2.jQueryInterface;
          $2.fn[name2].Constructor = plugin2;
          $2.fn[name2].noConflict = () => {
            $2.fn[name2] = JQUERY_NO_CONFLICT;
            return plugin2.jQueryInterface;
          };
        }
      });
    };
    const execute2 = (possibleCallback, args = [], defaultValue = possibleCallback) => {
      return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
    };
    const executeAfterTransition2 = (callback, transitionElement, waitForTransition = true) => {
      if (!waitForTransition) {
        execute2(callback);
        return;
      }
      const durationPadding = 5;
      const emulatedDuration = getTransitionDurationFromElement2(transitionElement) + durationPadding;
      let called = false;
      const handler = ({
        target
      }) => {
        if (target !== transitionElement) {
          return;
        }
        called = true;
        transitionElement.removeEventListener(TRANSITION_END2, handler);
        execute2(callback);
      };
      transitionElement.addEventListener(TRANSITION_END2, handler);
      setTimeout(() => {
        if (!called) {
          triggerTransitionEnd2(transitionElement);
        }
      }, emulatedDuration);
    };
    const getNextActiveElement2 = (list2, activeElement, shouldGetNext, isCycleAllowed) => {
      const listLength = list2.length;
      let index = list2.indexOf(activeElement);
      if (index === -1) {
        return !shouldGetNext && isCycleAllowed ? list2[listLength - 1] : list2[0];
      }
      index += shouldGetNext ? 1 : -1;
      if (isCycleAllowed) {
        index = (index + listLength) % listLength;
      }
      return list2[Math.max(0, Math.min(index, listLength - 1))];
    };
    const namespaceRegex2 = /[^.]*(?=\..*)\.|.*/;
    const stripNameRegex2 = /\..*/;
    const stripUidRegex2 = /::\d+$/;
    const eventRegistry2 = {};
    let uidEvent2 = 1;
    const customEvents2 = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
    const nativeEvents2 = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function makeEventUid2(element, uid) {
      return uid && `${uid}::${uidEvent2++}` || element.uidEvent || uidEvent2++;
    }
    function getElementEvents2(element) {
      const uid = makeEventUid2(element);
      element.uidEvent = uid;
      eventRegistry2[uid] = eventRegistry2[uid] || {};
      return eventRegistry2[uid];
    }
    function bootstrapHandler2(element, fn3) {
      return function handler(event) {
        hydrateObj2(event, {
          delegateTarget: element
        });
        if (handler.oneOff) {
          EventHandler2.off(element, event.type, fn3);
        }
        return fn3.apply(element, [event]);
      };
    }
    function bootstrapDelegationHandler2(element, selector, fn3) {
      return function handler(event) {
        const domElements = element.querySelectorAll(selector);
        for (let {
          target
        } = event; target && target !== this; target = target.parentNode) {
          for (const domElement of domElements) {
            if (domElement !== target) {
              continue;
            }
            hydrateObj2(event, {
              delegateTarget: target
            });
            if (handler.oneOff) {
              EventHandler2.off(element, event.type, selector, fn3);
            }
            return fn3.apply(target, [event]);
          }
        }
      };
    }
    function findHandler2(events, callable, delegationSelector = null) {
      return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
    }
    function normalizeParameters2(originalTypeEvent, handler, delegationFunction) {
      const isDelegated = typeof handler === "string";
      const callable = isDelegated ? delegationFunction : handler || delegationFunction;
      let typeEvent = getTypeEvent2(originalTypeEvent);
      if (!nativeEvents2.has(typeEvent)) {
        typeEvent = originalTypeEvent;
      }
      return [isDelegated, callable, typeEvent];
    }
    function addHandler2(element, originalTypeEvent, handler, delegationFunction, oneOff) {
      if (typeof originalTypeEvent !== "string" || !element) {
        return;
      }
      let [isDelegated, callable, typeEvent] = normalizeParameters2(originalTypeEvent, handler, delegationFunction);
      if (originalTypeEvent in customEvents2) {
        const wrapFunction = (fn4) => {
          return function(event) {
            if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
              return fn4.call(this, event);
            }
          };
        };
        callable = wrapFunction(callable);
      }
      const events = getElementEvents2(element);
      const handlers = events[typeEvent] || (events[typeEvent] = {});
      const previousFunction = findHandler2(handlers, callable, isDelegated ? handler : null);
      if (previousFunction) {
        previousFunction.oneOff = previousFunction.oneOff && oneOff;
        return;
      }
      const uid = makeEventUid2(callable, originalTypeEvent.replace(namespaceRegex2, ""));
      const fn3 = isDelegated ? bootstrapDelegationHandler2(element, handler, callable) : bootstrapHandler2(element, callable);
      fn3.delegationSelector = isDelegated ? handler : null;
      fn3.callable = callable;
      fn3.oneOff = oneOff;
      fn3.uidEvent = uid;
      handlers[uid] = fn3;
      element.addEventListener(typeEvent, fn3, isDelegated);
    }
    function removeHandler2(element, events, typeEvent, handler, delegationSelector) {
      const fn3 = findHandler2(events[typeEvent], handler, delegationSelector);
      if (!fn3) {
        return;
      }
      element.removeEventListener(typeEvent, fn3, Boolean(delegationSelector));
      delete events[typeEvent][fn3.uidEvent];
    }
    function removeNamespacedHandlers2(element, events, typeEvent, namespace) {
      const storeElementEvent = events[typeEvent] || {};
      for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
        if (handlerKey.includes(namespace)) {
          removeHandler2(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    }
    function getTypeEvent2(event) {
      event = event.replace(stripNameRegex2, "");
      return customEvents2[event] || event;
    }
    const EventHandler2 = {
      on(element, event, handler, delegationFunction) {
        addHandler2(element, event, handler, delegationFunction, false);
      },
      one(element, event, handler, delegationFunction) {
        addHandler2(element, event, handler, delegationFunction, true);
      },
      off(element, originalTypeEvent, handler, delegationFunction) {
        if (typeof originalTypeEvent !== "string" || !element) {
          return;
        }
        const [isDelegated, callable, typeEvent] = normalizeParameters2(originalTypeEvent, handler, delegationFunction);
        const inNamespace = typeEvent !== originalTypeEvent;
        const events = getElementEvents2(element);
        const storeElementEvent = events[typeEvent] || {};
        const isNamespace = originalTypeEvent.startsWith(".");
        if (typeof callable !== "undefined") {
          if (!Object.keys(storeElementEvent).length) {
            return;
          }
          removeHandler2(element, events, typeEvent, callable, isDelegated ? handler : null);
          return;
        }
        if (isNamespace) {
          for (const elementEvent of Object.keys(events)) {
            removeNamespacedHandlers2(element, events, elementEvent, originalTypeEvent.slice(1));
          }
        }
        for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
          const handlerKey = keyHandlers.replace(stripUidRegex2, "");
          if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
            removeHandler2(element, events, typeEvent, event.callable, event.delegationSelector);
          }
        }
      },
      trigger(element, event, args) {
        if (typeof event !== "string" || !element) {
          return null;
        }
        const $2 = getjQuery2();
        const typeEvent = getTypeEvent2(event);
        const inNamespace = event !== typeEvent;
        let jQueryEvent = null;
        let bubbles = true;
        let nativeDispatch = true;
        let defaultPrevented = false;
        if (inNamespace && $2) {
          jQueryEvent = $2.Event(event, args);
          $2(element).trigger(jQueryEvent);
          bubbles = !jQueryEvent.isPropagationStopped();
          nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
          defaultPrevented = jQueryEvent.isDefaultPrevented();
        }
        const evt = hydrateObj2(new Event(event, {
          bubbles,
          cancelable: true
        }), args);
        if (defaultPrevented) {
          evt.preventDefault();
        }
        if (nativeDispatch) {
          element.dispatchEvent(evt);
        }
        if (evt.defaultPrevented && jQueryEvent) {
          jQueryEvent.preventDefault();
        }
        return evt;
      }
    };
    function hydrateObj2(obj, meta = {}) {
      for (const [key, value] of Object.entries(meta)) {
        try {
          obj[key] = value;
        } catch (_unused) {
          Object.defineProperty(obj, key, {
            configurable: true,
            get() {
              return value;
            }
          });
        }
      }
      return obj;
    }
    function normalizeData2(value) {
      if (value === "true") {
        return true;
      }
      if (value === "false") {
        return false;
      }
      if (value === Number(value).toString()) {
        return Number(value);
      }
      if (value === "" || value === "null") {
        return null;
      }
      if (typeof value !== "string") {
        return value;
      }
      try {
        return JSON.parse(decodeURIComponent(value));
      } catch (_unused) {
        return value;
      }
    }
    function normalizeDataKey2(key) {
      return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
    }
    const Manipulator2 = {
      setDataAttribute(element, key, value) {
        element.setAttribute(`data-bs-${normalizeDataKey2(key)}`, value);
      },
      removeDataAttribute(element, key) {
        element.removeAttribute(`data-bs-${normalizeDataKey2(key)}`);
      },
      getDataAttributes(element) {
        if (!element) {
          return {};
        }
        const attributes = {};
        const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
        for (const key of bsKeys) {
          let pureKey = key.replace(/^bs/, "");
          pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
          attributes[pureKey] = normalizeData2(element.dataset[key]);
        }
        return attributes;
      },
      getDataAttribute(element, key) {
        return normalizeData2(element.getAttribute(`data-bs-${normalizeDataKey2(key)}`));
      }
    };
    class Config2 {
      // Getters
      static get Default() {
        return {};
      }
      static get DefaultType() {
        return {};
      }
      static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!');
      }
      _getConfig(config) {
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
      }
      _configAfterMerge(config) {
        return config;
      }
      _mergeConfigObj(config, element) {
        const jsonConfig = isElement$12(element) ? Manipulator2.getDataAttribute(element, "config") : {};
        return {
          ...this.constructor.Default,
          ...typeof jsonConfig === "object" ? jsonConfig : {},
          ...isElement$12(element) ? Manipulator2.getDataAttributes(element) : {},
          ...typeof config === "object" ? config : {}
        };
      }
      _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
        for (const [property, expectedTypes] of Object.entries(configTypes)) {
          const value = config[property];
          const valueType = isElement$12(value) ? "element" : toType2(value);
          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
          }
        }
      }
    }
    const VERSION2 = "5.3.0-alpha2";
    class BaseComponent2 extends Config2 {
      constructor(element, config) {
        super();
        element = getElement2(element);
        if (!element) {
          return;
        }
        this._element = element;
        this._config = this._getConfig(config);
        Data2.set(this._element, this.constructor.DATA_KEY, this);
      }
      // Public
      dispose() {
        Data2.remove(this._element, this.constructor.DATA_KEY);
        EventHandler2.off(this._element, this.constructor.EVENT_KEY);
        for (const propertyName of Object.getOwnPropertyNames(this)) {
          this[propertyName] = null;
        }
      }
      _queueCallback(callback, element, isAnimated = true) {
        executeAfterTransition2(callback, element, isAnimated);
      }
      _getConfig(config) {
        config = this._mergeConfigObj(config, this._element);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
      }
      // Static
      static getInstance(element) {
        return Data2.get(getElement2(element), this.DATA_KEY);
      }
      static getOrCreateInstance(element, config = {}) {
        return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
      }
      static get VERSION() {
        return VERSION2;
      }
      static get DATA_KEY() {
        return `bs.${this.NAME}`;
      }
      static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
      }
      static eventName(name2) {
        return `${name2}${this.EVENT_KEY}`;
      }
    }
    const getSelector2 = (element) => {
      let selector = element.getAttribute("data-bs-target");
      if (!selector || selector === "#") {
        let hrefAttribute = element.getAttribute("href");
        if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
          return null;
        }
        if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
          hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
        }
        selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
      }
      return parseSelector2(selector);
    };
    const SelectorEngine2 = {
      find(selector, element = document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
      },
      findOne(selector, element = document.documentElement) {
        return Element.prototype.querySelector.call(element, selector);
      },
      children(element, selector) {
        return [].concat(...element.children).filter((child) => child.matches(selector));
      },
      parents(element, selector) {
        const parents = [];
        let ancestor = element.parentNode.closest(selector);
        while (ancestor) {
          parents.push(ancestor);
          ancestor = ancestor.parentNode.closest(selector);
        }
        return parents;
      },
      prev(element, selector) {
        let previous = element.previousElementSibling;
        while (previous) {
          if (previous.matches(selector)) {
            return [previous];
          }
          previous = previous.previousElementSibling;
        }
        return [];
      },
      // TODO: this is now unused; remove later along with prev()
      next(element, selector) {
        let next = element.nextElementSibling;
        while (next) {
          if (next.matches(selector)) {
            return [next];
          }
          next = next.nextElementSibling;
        }
        return [];
      },
      focusableChildren(element) {
        const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
        return this.find(focusables, element).filter((el) => !isDisabled2(el) && isVisible2(el));
      },
      getSelectorFromElement(element) {
        const selector = getSelector2(element);
        if (selector) {
          return SelectorEngine2.findOne(selector) ? selector : null;
        }
        return null;
      },
      getElementFromSelector(element) {
        const selector = getSelector2(element);
        return selector ? SelectorEngine2.findOne(selector) : null;
      },
      getMultipleElementsFromSelector(element) {
        const selector = getSelector2(element);
        return selector ? SelectorEngine2.find(selector) : [];
      }
    };
    const enableDismissTrigger2 = (component, method = "hide") => {
      const clickEvent = `click.dismiss${component.EVENT_KEY}`;
      const name2 = component.NAME;
      EventHandler2.on(document, clickEvent, `[data-bs-dismiss="${name2}"]`, function(event) {
        if (["A", "AREA"].includes(this.tagName)) {
          event.preventDefault();
        }
        if (isDisabled2(this)) {
          return;
        }
        const target = SelectorEngine2.getElementFromSelector(this) || this.closest(`.${name2}`);
        const instance = component.getOrCreateInstance(target);
        instance[method]();
      });
    };
    const NAME$f2 = "alert";
    const DATA_KEY$a2 = "bs.alert";
    const EVENT_KEY$b2 = `.${DATA_KEY$a2}`;
    const EVENT_CLOSE2 = `close${EVENT_KEY$b2}`;
    const EVENT_CLOSED2 = `closed${EVENT_KEY$b2}`;
    const CLASS_NAME_FADE$52 = "fade";
    const CLASS_NAME_SHOW$82 = "show";
    class Alert2 extends BaseComponent2 {
      // Getters
      static get NAME() {
        return NAME$f2;
      }
      // Public
      close() {
        const closeEvent = EventHandler2.trigger(this._element, EVENT_CLOSE2);
        if (closeEvent.defaultPrevented) {
          return;
        }
        this._element.classList.remove(CLASS_NAME_SHOW$82);
        const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$52);
        this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
      }
      // Private
      _destroyElement() {
        this._element.remove();
        EventHandler2.trigger(this._element, EVENT_CLOSED2);
        this.dispose();
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Alert2.getOrCreateInstance(this);
          if (typeof config !== "string") {
            return;
          }
          if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config](this);
        });
      }
    }
    enableDismissTrigger2(Alert2, "close");
    defineJQueryPlugin2(Alert2);
    const NAME$e2 = "button";
    const DATA_KEY$92 = "bs.button";
    const EVENT_KEY$a2 = `.${DATA_KEY$92}`;
    const DATA_API_KEY$62 = ".data-api";
    const CLASS_NAME_ACTIVE$32 = "active";
    const SELECTOR_DATA_TOGGLE$52 = '[data-bs-toggle="button"]';
    const EVENT_CLICK_DATA_API$62 = `click${EVENT_KEY$a2}${DATA_API_KEY$62}`;
    class Button2 extends BaseComponent2 {
      // Getters
      static get NAME() {
        return NAME$e2;
      }
      // Public
      toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$32));
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Button2.getOrCreateInstance(this);
          if (config === "toggle") {
            data2[config]();
          }
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API$62, SELECTOR_DATA_TOGGLE$52, (event) => {
      event.preventDefault();
      const button = event.target.closest(SELECTOR_DATA_TOGGLE$52);
      const data2 = Button2.getOrCreateInstance(button);
      data2.toggle();
    });
    defineJQueryPlugin2(Button2);
    const NAME$d2 = "swipe";
    const EVENT_KEY$92 = ".bs.swipe";
    const EVENT_TOUCHSTART2 = `touchstart${EVENT_KEY$92}`;
    const EVENT_TOUCHMOVE2 = `touchmove${EVENT_KEY$92}`;
    const EVENT_TOUCHEND2 = `touchend${EVENT_KEY$92}`;
    const EVENT_POINTERDOWN2 = `pointerdown${EVENT_KEY$92}`;
    const EVENT_POINTERUP2 = `pointerup${EVENT_KEY$92}`;
    const POINTER_TYPE_TOUCH2 = "touch";
    const POINTER_TYPE_PEN2 = "pen";
    const CLASS_NAME_POINTER_EVENT2 = "pointer-event";
    const SWIPE_THRESHOLD2 = 40;
    const Default$c2 = {
      endCallback: null,
      leftCallback: null,
      rightCallback: null
    };
    const DefaultType$c2 = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)"
    };
    class Swipe2 extends Config2 {
      constructor(element, config) {
        super();
        this._element = element;
        if (!element || !Swipe2.isSupported()) {
          return;
        }
        this._config = this._getConfig(config);
        this._deltaX = 0;
        this._supportPointerEvents = Boolean(window.PointerEvent);
        this._initEvents();
      }
      // Getters
      static get Default() {
        return Default$c2;
      }
      static get DefaultType() {
        return DefaultType$c2;
      }
      static get NAME() {
        return NAME$d2;
      }
      // Public
      dispose() {
        EventHandler2.off(this._element, EVENT_KEY$92);
      }
      // Private
      _start(event) {
        if (!this._supportPointerEvents) {
          this._deltaX = event.touches[0].clientX;
          return;
        }
        if (this._eventIsPointerPenTouch(event)) {
          this._deltaX = event.clientX;
        }
      }
      _end(event) {
        if (this._eventIsPointerPenTouch(event)) {
          this._deltaX = event.clientX - this._deltaX;
        }
        this._handleSwipe();
        execute2(this._config.endCallback);
      }
      _move(event) {
        this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
      }
      _handleSwipe() {
        const absDeltaX = Math.abs(this._deltaX);
        if (absDeltaX <= SWIPE_THRESHOLD2) {
          return;
        }
        const direction = absDeltaX / this._deltaX;
        this._deltaX = 0;
        if (!direction) {
          return;
        }
        execute2(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
      }
      _initEvents() {
        if (this._supportPointerEvents) {
          EventHandler2.on(this._element, EVENT_POINTERDOWN2, (event) => this._start(event));
          EventHandler2.on(this._element, EVENT_POINTERUP2, (event) => this._end(event));
          this._element.classList.add(CLASS_NAME_POINTER_EVENT2);
        } else {
          EventHandler2.on(this._element, EVENT_TOUCHSTART2, (event) => this._start(event));
          EventHandler2.on(this._element, EVENT_TOUCHMOVE2, (event) => this._move(event));
          EventHandler2.on(this._element, EVENT_TOUCHEND2, (event) => this._end(event));
        }
      }
      _eventIsPointerPenTouch(event) {
        return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN2 || event.pointerType === POINTER_TYPE_TOUCH2);
      }
      // Static
      static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
      }
    }
    const NAME$c2 = "carousel";
    const DATA_KEY$82 = "bs.carousel";
    const EVENT_KEY$82 = `.${DATA_KEY$82}`;
    const DATA_API_KEY$52 = ".data-api";
    const ARROW_LEFT_KEY$12 = "ArrowLeft";
    const ARROW_RIGHT_KEY$12 = "ArrowRight";
    const TOUCHEVENT_COMPAT_WAIT2 = 500;
    const ORDER_NEXT2 = "next";
    const ORDER_PREV2 = "prev";
    const DIRECTION_LEFT2 = "left";
    const DIRECTION_RIGHT2 = "right";
    const EVENT_SLIDE2 = `slide${EVENT_KEY$82}`;
    const EVENT_SLID2 = `slid${EVENT_KEY$82}`;
    const EVENT_KEYDOWN$12 = `keydown${EVENT_KEY$82}`;
    const EVENT_MOUSEENTER$12 = `mouseenter${EVENT_KEY$82}`;
    const EVENT_MOUSELEAVE$12 = `mouseleave${EVENT_KEY$82}`;
    const EVENT_DRAG_START2 = `dragstart${EVENT_KEY$82}`;
    const EVENT_LOAD_DATA_API$32 = `load${EVENT_KEY$82}${DATA_API_KEY$52}`;
    const EVENT_CLICK_DATA_API$52 = `click${EVENT_KEY$82}${DATA_API_KEY$52}`;
    const CLASS_NAME_CAROUSEL2 = "carousel";
    const CLASS_NAME_ACTIVE$22 = "active";
    const CLASS_NAME_SLIDE2 = "slide";
    const CLASS_NAME_END2 = "carousel-item-end";
    const CLASS_NAME_START2 = "carousel-item-start";
    const CLASS_NAME_NEXT2 = "carousel-item-next";
    const CLASS_NAME_PREV2 = "carousel-item-prev";
    const SELECTOR_ACTIVE2 = ".active";
    const SELECTOR_ITEM2 = ".carousel-item";
    const SELECTOR_ACTIVE_ITEM2 = SELECTOR_ACTIVE2 + SELECTOR_ITEM2;
    const SELECTOR_ITEM_IMG2 = ".carousel-item img";
    const SELECTOR_INDICATORS2 = ".carousel-indicators";
    const SELECTOR_DATA_SLIDE2 = "[data-bs-slide], [data-bs-slide-to]";
    const SELECTOR_DATA_RIDE2 = '[data-bs-ride="carousel"]';
    const KEY_TO_DIRECTION2 = {
      [ARROW_LEFT_KEY$12]: DIRECTION_RIGHT2,
      [ARROW_RIGHT_KEY$12]: DIRECTION_LEFT2
    };
    const Default$b2 = {
      interval: 5e3,
      keyboard: true,
      pause: "hover",
      ride: false,
      touch: true,
      wrap: true
    };
    const DefaultType$b2 = {
      interval: "(number|boolean)",
      // TODO:v6 remove boolean support
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean"
    };
    class Carousel2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._interval = null;
        this._activeElement = null;
        this._isSliding = false;
        this.touchTimeout = null;
        this._swipeHelper = null;
        this._indicatorsElement = SelectorEngine2.findOne(SELECTOR_INDICATORS2, this._element);
        this._addEventListeners();
        if (this._config.ride === CLASS_NAME_CAROUSEL2) {
          this.cycle();
        }
      }
      // Getters
      static get Default() {
        return Default$b2;
      }
      static get DefaultType() {
        return DefaultType$b2;
      }
      static get NAME() {
        return NAME$c2;
      }
      // Public
      next() {
        this._slide(ORDER_NEXT2);
      }
      nextWhenVisible() {
        if (!document.hidden && isVisible2(this._element)) {
          this.next();
        }
      }
      prev() {
        this._slide(ORDER_PREV2);
      }
      pause() {
        if (this._isSliding) {
          triggerTransitionEnd2(this._element);
        }
        this._clearInterval();
      }
      cycle() {
        this._clearInterval();
        this._updateInterval();
        this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
      }
      _maybeEnableCycle() {
        if (!this._config.ride) {
          return;
        }
        if (this._isSliding) {
          EventHandler2.one(this._element, EVENT_SLID2, () => this.cycle());
          return;
        }
        this.cycle();
      }
      to(index) {
        const items = this._getItems();
        if (index > items.length - 1 || index < 0) {
          return;
        }
        if (this._isSliding) {
          EventHandler2.one(this._element, EVENT_SLID2, () => this.to(index));
          return;
        }
        const activeIndex = this._getItemIndex(this._getActive());
        if (activeIndex === index) {
          return;
        }
        const order3 = index > activeIndex ? ORDER_NEXT2 : ORDER_PREV2;
        this._slide(order3, items[index]);
      }
      dispose() {
        if (this._swipeHelper) {
          this._swipeHelper.dispose();
        }
        super.dispose();
      }
      // Private
      _configAfterMerge(config) {
        config.defaultInterval = config.interval;
        return config;
      }
      _addEventListeners() {
        if (this._config.keyboard) {
          EventHandler2.on(this._element, EVENT_KEYDOWN$12, (event) => this._keydown(event));
        }
        if (this._config.pause === "hover") {
          EventHandler2.on(this._element, EVENT_MOUSEENTER$12, () => this.pause());
          EventHandler2.on(this._element, EVENT_MOUSELEAVE$12, () => this._maybeEnableCycle());
        }
        if (this._config.touch && Swipe2.isSupported()) {
          this._addTouchEventListeners();
        }
      }
      _addTouchEventListeners() {
        for (const img of SelectorEngine2.find(SELECTOR_ITEM_IMG2, this._element)) {
          EventHandler2.on(img, EVENT_DRAG_START2, (event) => event.preventDefault());
        }
        const endCallBack = () => {
          if (this._config.pause !== "hover") {
            return;
          }
          this.pause();
          if (this.touchTimeout) {
            clearTimeout(this.touchTimeout);
          }
          this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT2 + this._config.interval);
        };
        const swipeConfig = {
          leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT2)),
          rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT2)),
          endCallback: endCallBack
        };
        this._swipeHelper = new Swipe2(this._element, swipeConfig);
      }
      _keydown(event) {
        if (/input|textarea/i.test(event.target.tagName)) {
          return;
        }
        const direction = KEY_TO_DIRECTION2[event.key];
        if (direction) {
          event.preventDefault();
          this._slide(this._directionToOrder(direction));
        }
      }
      _getItemIndex(element) {
        return this._getItems().indexOf(element);
      }
      _setActiveIndicatorElement(index) {
        if (!this._indicatorsElement) {
          return;
        }
        const activeIndicator = SelectorEngine2.findOne(SELECTOR_ACTIVE2, this._indicatorsElement);
        activeIndicator.classList.remove(CLASS_NAME_ACTIVE$22);
        activeIndicator.removeAttribute("aria-current");
        const newActiveIndicator = SelectorEngine2.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
        if (newActiveIndicator) {
          newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$22);
          newActiveIndicator.setAttribute("aria-current", "true");
        }
      }
      _updateInterval() {
        const element = this._activeElement || this._getActive();
        if (!element) {
          return;
        }
        const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
        this._config.interval = elementInterval || this._config.defaultInterval;
      }
      _slide(order3, element = null) {
        if (this._isSliding) {
          return;
        }
        const activeElement = this._getActive();
        const isNext = order3 === ORDER_NEXT2;
        const nextElement = element || getNextActiveElement2(this._getItems(), activeElement, isNext, this._config.wrap);
        if (nextElement === activeElement) {
          return;
        }
        const nextElementIndex = this._getItemIndex(nextElement);
        const triggerEvent = (eventName) => {
          return EventHandler2.trigger(this._element, eventName, {
            relatedTarget: nextElement,
            direction: this._orderToDirection(order3),
            from: this._getItemIndex(activeElement),
            to: nextElementIndex
          });
        };
        const slideEvent = triggerEvent(EVENT_SLIDE2);
        if (slideEvent.defaultPrevented) {
          return;
        }
        if (!activeElement || !nextElement) {
          return;
        }
        const isCycling = Boolean(this._interval);
        this.pause();
        this._isSliding = true;
        this._setActiveIndicatorElement(nextElementIndex);
        this._activeElement = nextElement;
        const directionalClassName = isNext ? CLASS_NAME_START2 : CLASS_NAME_END2;
        const orderClassName = isNext ? CLASS_NAME_NEXT2 : CLASS_NAME_PREV2;
        nextElement.classList.add(orderClassName);
        reflow2(nextElement);
        activeElement.classList.add(directionalClassName);
        nextElement.classList.add(directionalClassName);
        const completeCallBack = () => {
          nextElement.classList.remove(directionalClassName, orderClassName);
          nextElement.classList.add(CLASS_NAME_ACTIVE$22);
          activeElement.classList.remove(CLASS_NAME_ACTIVE$22, orderClassName, directionalClassName);
          this._isSliding = false;
          triggerEvent(EVENT_SLID2);
        };
        this._queueCallback(completeCallBack, activeElement, this._isAnimated());
        if (isCycling) {
          this.cycle();
        }
      }
      _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_SLIDE2);
      }
      _getActive() {
        return SelectorEngine2.findOne(SELECTOR_ACTIVE_ITEM2, this._element);
      }
      _getItems() {
        return SelectorEngine2.find(SELECTOR_ITEM2, this._element);
      }
      _clearInterval() {
        if (this._interval) {
          clearInterval(this._interval);
          this._interval = null;
        }
      }
      _directionToOrder(direction) {
        if (isRTL2()) {
          return direction === DIRECTION_LEFT2 ? ORDER_PREV2 : ORDER_NEXT2;
        }
        return direction === DIRECTION_LEFT2 ? ORDER_NEXT2 : ORDER_PREV2;
      }
      _orderToDirection(order3) {
        if (isRTL2()) {
          return order3 === ORDER_PREV2 ? DIRECTION_LEFT2 : DIRECTION_RIGHT2;
        }
        return order3 === ORDER_PREV2 ? DIRECTION_RIGHT2 : DIRECTION_LEFT2;
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Carousel2.getOrCreateInstance(this, config);
          if (typeof config === "number") {
            data2.to(config);
            return;
          }
          if (typeof config === "string") {
            if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
              throw new TypeError(`No method named "${config}"`);
            }
            data2[config]();
          }
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API$52, SELECTOR_DATA_SLIDE2, function(event) {
      const target = SelectorEngine2.getElementFromSelector(this);
      if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL2)) {
        return;
      }
      event.preventDefault();
      const carousel = Carousel2.getOrCreateInstance(target);
      const slideIndex = this.getAttribute("data-bs-slide-to");
      if (slideIndex) {
        carousel.to(slideIndex);
        carousel._maybeEnableCycle();
        return;
      }
      if (Manipulator2.getDataAttribute(this, "slide") === "next") {
        carousel.next();
        carousel._maybeEnableCycle();
        return;
      }
      carousel.prev();
      carousel._maybeEnableCycle();
    });
    EventHandler2.on(window, EVENT_LOAD_DATA_API$32, () => {
      const carousels = SelectorEngine2.find(SELECTOR_DATA_RIDE2);
      for (const carousel of carousels) {
        Carousel2.getOrCreateInstance(carousel);
      }
    });
    defineJQueryPlugin2(Carousel2);
    const NAME$b2 = "collapse";
    const DATA_KEY$72 = "bs.collapse";
    const EVENT_KEY$72 = `.${DATA_KEY$72}`;
    const DATA_API_KEY$42 = ".data-api";
    const EVENT_SHOW$62 = `show${EVENT_KEY$72}`;
    const EVENT_SHOWN$62 = `shown${EVENT_KEY$72}`;
    const EVENT_HIDE$62 = `hide${EVENT_KEY$72}`;
    const EVENT_HIDDEN$62 = `hidden${EVENT_KEY$72}`;
    const EVENT_CLICK_DATA_API$42 = `click${EVENT_KEY$72}${DATA_API_KEY$42}`;
    const CLASS_NAME_SHOW$72 = "show";
    const CLASS_NAME_COLLAPSE2 = "collapse";
    const CLASS_NAME_COLLAPSING2 = "collapsing";
    const CLASS_NAME_COLLAPSED2 = "collapsed";
    const CLASS_NAME_DEEPER_CHILDREN2 = `:scope .${CLASS_NAME_COLLAPSE2} .${CLASS_NAME_COLLAPSE2}`;
    const CLASS_NAME_HORIZONTAL2 = "collapse-horizontal";
    const WIDTH2 = "width";
    const HEIGHT2 = "height";
    const SELECTOR_ACTIVES2 = ".collapse.show, .collapse.collapsing";
    const SELECTOR_DATA_TOGGLE$42 = '[data-bs-toggle="collapse"]';
    const Default$a2 = {
      parent: null,
      toggle: true
    };
    const DefaultType$a2 = {
      parent: "(null|element)",
      toggle: "boolean"
    };
    class Collapse2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._isTransitioning = false;
        this._triggerArray = [];
        const toggleList = SelectorEngine2.find(SELECTOR_DATA_TOGGLE$42);
        for (const elem of toggleList) {
          const selector = SelectorEngine2.getSelectorFromElement(elem);
          const filterElement = SelectorEngine2.find(selector).filter((foundElement) => foundElement === this._element);
          if (selector !== null && filterElement.length) {
            this._triggerArray.push(elem);
          }
        }
        this._initializeChildren();
        if (!this._config.parent) {
          this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
        }
        if (this._config.toggle) {
          this.toggle();
        }
      }
      // Getters
      static get Default() {
        return Default$a2;
      }
      static get DefaultType() {
        return DefaultType$a2;
      }
      static get NAME() {
        return NAME$b2;
      }
      // Public
      toggle() {
        if (this._isShown()) {
          this.hide();
        } else {
          this.show();
        }
      }
      show() {
        if (this._isTransitioning || this._isShown()) {
          return;
        }
        let activeChildren = [];
        if (this._config.parent) {
          activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES2).filter((element) => element !== this._element).map((element) => Collapse2.getOrCreateInstance(element, {
            toggle: false
          }));
        }
        if (activeChildren.length && activeChildren[0]._isTransitioning) {
          return;
        }
        const startEvent = EventHandler2.trigger(this._element, EVENT_SHOW$62);
        if (startEvent.defaultPrevented) {
          return;
        }
        for (const activeInstance of activeChildren) {
          activeInstance.hide();
        }
        const dimension = this._getDimension();
        this._element.classList.remove(CLASS_NAME_COLLAPSE2);
        this._element.classList.add(CLASS_NAME_COLLAPSING2);
        this._element.style[dimension] = 0;
        this._addAriaAndCollapsedClass(this._triggerArray, true);
        this._isTransitioning = true;
        const complete = () => {
          this._isTransitioning = false;
          this._element.classList.remove(CLASS_NAME_COLLAPSING2);
          this._element.classList.add(CLASS_NAME_COLLAPSE2, CLASS_NAME_SHOW$72);
          this._element.style[dimension] = "";
          EventHandler2.trigger(this._element, EVENT_SHOWN$62);
        };
        const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
        const scrollSize = `scroll${capitalizedDimension}`;
        this._queueCallback(complete, this._element, true);
        this._element.style[dimension] = `${this._element[scrollSize]}px`;
      }
      hide() {
        if (this._isTransitioning || !this._isShown()) {
          return;
        }
        const startEvent = EventHandler2.trigger(this._element, EVENT_HIDE$62);
        if (startEvent.defaultPrevented) {
          return;
        }
        const dimension = this._getDimension();
        this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
        reflow2(this._element);
        this._element.classList.add(CLASS_NAME_COLLAPSING2);
        this._element.classList.remove(CLASS_NAME_COLLAPSE2, CLASS_NAME_SHOW$72);
        for (const trigger of this._triggerArray) {
          const element = SelectorEngine2.getElementFromSelector(trigger);
          if (element && !this._isShown(element)) {
            this._addAriaAndCollapsedClass([trigger], false);
          }
        }
        this._isTransitioning = true;
        const complete = () => {
          this._isTransitioning = false;
          this._element.classList.remove(CLASS_NAME_COLLAPSING2);
          this._element.classList.add(CLASS_NAME_COLLAPSE2);
          EventHandler2.trigger(this._element, EVENT_HIDDEN$62);
        };
        this._element.style[dimension] = "";
        this._queueCallback(complete, this._element, true);
      }
      _isShown(element = this._element) {
        return element.classList.contains(CLASS_NAME_SHOW$72);
      }
      // Private
      _configAfterMerge(config) {
        config.toggle = Boolean(config.toggle);
        config.parent = getElement2(config.parent);
        return config;
      }
      _getDimension() {
        return this._element.classList.contains(CLASS_NAME_HORIZONTAL2) ? WIDTH2 : HEIGHT2;
      }
      _initializeChildren() {
        if (!this._config.parent) {
          return;
        }
        const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$42);
        for (const element of children) {
          const selected = SelectorEngine2.getElementFromSelector(element);
          if (selected) {
            this._addAriaAndCollapsedClass([element], this._isShown(selected));
          }
        }
      }
      _getFirstLevelChildren(selector) {
        const children = SelectorEngine2.find(CLASS_NAME_DEEPER_CHILDREN2, this._config.parent);
        return SelectorEngine2.find(selector, this._config.parent).filter((element) => !children.includes(element));
      }
      _addAriaAndCollapsedClass(triggerArray, isOpen) {
        if (!triggerArray.length) {
          return;
        }
        for (const element of triggerArray) {
          element.classList.toggle(CLASS_NAME_COLLAPSED2, !isOpen);
          element.setAttribute("aria-expanded", isOpen);
        }
      }
      // Static
      static jQueryInterface(config) {
        const _config = {};
        if (typeof config === "string" && /show|hide/.test(config)) {
          _config.toggle = false;
        }
        return this.each(function() {
          const data2 = Collapse2.getOrCreateInstance(this, _config);
          if (typeof config === "string") {
            if (typeof data2[config] === "undefined") {
              throw new TypeError(`No method named "${config}"`);
            }
            data2[config]();
          }
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API$42, SELECTOR_DATA_TOGGLE$42, function(event) {
      if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
        event.preventDefault();
      }
      for (const element of SelectorEngine2.getMultipleElementsFromSelector(this)) {
        Collapse2.getOrCreateInstance(element, {
          toggle: false
        }).toggle();
      }
    });
    defineJQueryPlugin2(Collapse2);
    var top2 = "top";
    var bottom2 = "bottom";
    var right2 = "right";
    var left2 = "left";
    var auto2 = "auto";
    var basePlacements2 = [top2, bottom2, right2, left2];
    var start2 = "start";
    var end2 = "end";
    var clippingParents2 = "clippingParents";
    var viewport2 = "viewport";
    var popper2 = "popper";
    var reference2 = "reference";
    var variationPlacements2 = /* @__PURE__ */ basePlacements2.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start2, placement + "-" + end2]);
    }, []);
    var placements2 = /* @__PURE__ */ [].concat(basePlacements2, [auto2]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start2, placement + "-" + end2]);
    }, []);
    var beforeRead2 = "beforeRead";
    var read2 = "read";
    var afterRead2 = "afterRead";
    var beforeMain2 = "beforeMain";
    var main2 = "main";
    var afterMain2 = "afterMain";
    var beforeWrite2 = "beforeWrite";
    var write2 = "write";
    var afterWrite2 = "afterWrite";
    var modifierPhases2 = [beforeRead2, read2, afterRead2, beforeMain2, main2, afterMain2, beforeWrite2, write2, afterWrite2];
    function getNodeName2(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow2(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement2(node) {
      var OwnElement = getWindow2(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement2(node) {
      var OwnElement = getWindow2(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot2(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow2(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles2(_ref) {
      var state2 = _ref.state;
      Object.keys(state2.elements).forEach(function(name2) {
        var style = state2.styles[name2] || {};
        var attributes = state2.attributes[name2] || {};
        var element = state2.elements[name2];
        if (!isHTMLElement2(element) || !getNodeName2(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name3) {
          var value = attributes[name3];
          if (value === false) {
            element.removeAttribute(name3);
          } else {
            element.setAttribute(name3, value === true ? "" : value);
          }
        });
      });
    }
    function effect$22(_ref2) {
      var state2 = _ref2.state;
      var initialStyles = {
        popper: {
          position: state2.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state2.elements.popper.style, initialStyles.popper);
      state2.styles = initialStyles;
      if (state2.elements.arrow) {
        Object.assign(state2.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state2.elements).forEach(function(name2) {
          var element = state2.elements[name2];
          var attributes = state2.attributes[name2] || {};
          var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement2(element) || !getNodeName2(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$12 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles2,
      effect: effect$22,
      requires: ["computeStyles"]
    };
    function getBasePlacement2(placement) {
      return placement.split("-")[0];
    }
    var max2 = Math.max;
    var min2 = Math.min;
    var round2 = Math.round;
    function getUAString2() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item2) {
          return item2.brand + "/" + item2.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport2() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString2());
    }
    function getBoundingClientRect2(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement2(element)) {
        scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement2(element) ? getWindow2(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport2() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width2 = clientRect.width / scaleX;
      var height2 = clientRect.height / scaleY;
      return {
        width: width2,
        height: height2,
        top: y,
        right: x + width2,
        bottom: y + height2,
        left: x,
        x,
        y
      };
    }
    function getLayoutRect2(element) {
      var clientRect = getBoundingClientRect2(element);
      var width2 = element.offsetWidth;
      var height2 = element.offsetHeight;
      if (Math.abs(clientRect.width - width2) <= 1) {
        width2 = clientRect.width;
      }
      if (Math.abs(clientRect.height - height2) <= 1) {
        height2 = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width: width2,
        height: height2
      };
    }
    function contains2(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot2(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$12(element) {
      return getWindow2(element).getComputedStyle(element);
    }
    function isTableElement2(element) {
      return ["table", "td", "th"].indexOf(getNodeName2(element)) >= 0;
    }
    function getDocumentElement2(element) {
      return ((isElement2(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode2(element) {
      if (getNodeName2(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot2(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement2(element)
      );
    }
    function getTrueOffsetParent2(element) {
      if (!isHTMLElement2(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$12(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock2(element) {
      var isFirefox = /firefox/i.test(getUAString2());
      var isIE = /Trident/i.test(getUAString2());
      if (isIE && isHTMLElement2(element)) {
        var elementCss = getComputedStyle$12(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode2(element);
      if (isShadowRoot2(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement2(currentNode) && ["html", "body"].indexOf(getNodeName2(currentNode)) < 0) {
        var css = getComputedStyle$12(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent2(element) {
      var window2 = getWindow2(element);
      var offsetParent = getTrueOffsetParent2(element);
      while (offsetParent && isTableElement2(offsetParent) && getComputedStyle$12(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent2(offsetParent);
      }
      if (offsetParent && (getNodeName2(offsetParent) === "html" || getNodeName2(offsetParent) === "body" && getComputedStyle$12(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock2(element) || window2;
    }
    function getMainAxisFromPlacement2(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within2(min$1, value, max$1) {
      return max2(min$1, min2(value, max$1));
    }
    function withinMaxClamp2(min3, value, max3) {
      var v = within2(min3, value, max3);
      return v > max3 ? max3 : v;
    }
    function getFreshSideObject2() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject2(paddingObject) {
      return Object.assign({}, getFreshSideObject2(), paddingObject);
    }
    function expandToHashMap2(value, keys) {
      return keys.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject3 = function toPaddingObject4(padding, state2) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
        placement: state2.placement
      })) : padding;
      return mergePaddingObject2(typeof padding !== "number" ? padding : expandToHashMap2(padding, basePlacements2));
    };
    function arrow2(_ref) {
      var _state$modifiersData$;
      var state2 = _ref.state, name2 = _ref.name, options = _ref.options;
      var arrowElement = state2.elements.arrow;
      var popperOffsets3 = state2.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement2(state2.placement);
      var axis = getMainAxisFromPlacement2(basePlacement);
      var isVertical = [left2, right2].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets3) {
        return;
      }
      var paddingObject = toPaddingObject3(options.padding, state2);
      var arrowRect = getLayoutRect2(arrowElement);
      var minProp = axis === "y" ? top2 : left2;
      var maxProp = axis === "y" ? bottom2 : right2;
      var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets3[axis] - state2.rects.popper[len];
      var startDiff = popperOffsets3[axis] - state2.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent2(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min3 = paddingObject[minProp];
      var max3 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset3 = within2(min3, center2, max3);
      var axisProp = axis;
      state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset3, _state$modifiersData$.centerOffset = offset3 - center2, _state$modifiersData$);
    }
    function effect$12(_ref2) {
      var state2 = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state2.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains2(state2.elements.popper, arrowElement)) {
        return;
      }
      state2.elements.arrow = arrowElement;
    }
    const arrow$12 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow2,
      effect: effect$12,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation2(placement) {
      return placement.split("-")[1];
    }
    var unsetSides2 = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR2(_ref, win) {
      var x = _ref.x, y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round2(x * dpr) / dpr || 0,
        y: round2(y * dpr) / dpr || 0
      };
    }
    function mapToStyles2(_ref2) {
      var _Object$assign2;
      var popper3 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
      }) : {
        x,
        y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left2;
      var sideY = top2;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent2(popper3);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow2(popper3)) {
          offsetParent = getDocumentElement2(popper3);
          if (getComputedStyle$12(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top2 || (placement === left2 || placement === right2) && variation === end2) {
          sideY = bottom2;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left2 || (placement === top2 || placement === bottom2) && variation === end2) {
          sideX = right2;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides2);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR2({
        x,
        y
      }, getWindow2(popper3)) : {
        x,
        y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles2(_ref5) {
      var state2 = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement2(state2.placement),
        variation: getVariation2(state2.placement),
        popper: state2.elements.popper,
        popperRect: state2.rects.popper,
        gpuAcceleration,
        isFixed: state2.options.strategy === "fixed"
      };
      if (state2.modifiersData.popperOffsets != null) {
        state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles2(Object.assign({}, commonStyles, {
          offsets: state2.modifiersData.popperOffsets,
          position: state2.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state2.modifiersData.arrow != null) {
        state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles2(Object.assign({}, commonStyles, {
          offsets: state2.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
        "data-popper-placement": state2.placement
      });
    }
    const computeStyles$12 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles2,
      data: {}
    };
    var passive2 = {
      passive: true
    };
    function effect2(_ref) {
      var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow2(state2.elements.popper);
      var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive2);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive2);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive2);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive2);
        }
      };
    }
    const eventListeners2 = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn3() {
      },
      effect: effect2,
      data: {}
    };
    var hash$12 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement2(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$12[matched];
      });
    }
    var hash2 = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement2(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash2[matched];
      });
    }
    function getWindowScroll2(node) {
      var win = getWindow2(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX2(element) {
      return getBoundingClientRect2(getDocumentElement2(element)).left + getWindowScroll2(element).scrollLeft;
    }
    function getViewportRect2(element, strategy) {
      var win = getWindow2(element);
      var html = getDocumentElement2(element);
      var visualViewport = win.visualViewport;
      var width2 = html.clientWidth;
      var height2 = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width2 = visualViewport.width;
        height2 = visualViewport.height;
        var layoutViewport = isLayoutViewport2();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width: width2,
        height: height2,
        x: x + getWindowScrollBarX2(element),
        y
      };
    }
    function getDocumentRect2(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement2(element);
      var winScroll = getWindowScroll2(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width2 = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height2 = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX2(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$12(body || html).direction === "rtl") {
        x += max2(html.clientWidth, body ? body.clientWidth : 0) - width2;
      }
      return {
        width: width2,
        height: height2,
        x,
        y
      };
    }
    function isScrollParent2(element) {
      var _getComputedStyle = getComputedStyle$12(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent2(node) {
      if (["html", "body", "#document"].indexOf(getNodeName2(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement2(node) && isScrollParent2(node)) {
        return node;
      }
      return getScrollParent2(getParentNode2(node));
    }
    function listScrollParents2(element, list2) {
      var _element$ownerDocumen;
      if (list2 === void 0) {
        list2 = [];
      }
      var scrollParent = getScrollParent2(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow2(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent2(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list2.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents2(getParentNode2(target)))
      );
    }
    function rectToClientRect2(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect2(element, strategy) {
      var rect = getBoundingClientRect2(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType2(element, clippingParent, strategy) {
      return clippingParent === viewport2 ? rectToClientRect2(getViewportRect2(element, strategy)) : isElement2(clippingParent) ? getInnerBoundingClientRect2(clippingParent, strategy) : rectToClientRect2(getDocumentRect2(getDocumentElement2(element)));
    }
    function getClippingParents2(element) {
      var clippingParents3 = listScrollParents2(getParentNode2(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$12(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement2(element) ? getOffsetParent2(element) : element;
      if (!isElement2(clipperElement)) {
        return [];
      }
      return clippingParents3.filter(function(clippingParent) {
        return isElement2(clippingParent) && contains2(clippingParent, clipperElement) && getNodeName2(clippingParent) !== "body";
      });
    }
    function getClippingRect2(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents2(element) : [].concat(boundary);
      var clippingParents3 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents3[0];
      var clippingRect = clippingParents3.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType2(element, clippingParent, strategy);
        accRect.top = max2(rect.top, accRect.top);
        accRect.right = min2(rect.right, accRect.right);
        accRect.bottom = min2(rect.bottom, accRect.bottom);
        accRect.left = max2(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType2(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets2(_ref) {
      var reference3 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement2(placement) : null;
      var variation = placement ? getVariation2(placement) : null;
      var commonX = reference3.x + reference3.width / 2 - element.width / 2;
      var commonY = reference3.y + reference3.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top2:
          offsets = {
            x: commonX,
            y: reference3.y - element.height
          };
          break;
        case bottom2:
          offsets = {
            x: commonX,
            y: reference3.y + reference3.height
          };
          break;
        case right2:
          offsets = {
            x: reference3.x + reference3.width,
            y: commonY
          };
          break;
        case left2:
          offsets = {
            x: reference3.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference3.x,
            y: reference3.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement2(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start2:
            offsets[mainAxis] = offsets[mainAxis] - (reference3[len] / 2 - element[len] / 2);
            break;
          case end2:
            offsets[mainAxis] = offsets[mainAxis] + (reference3[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow2(state2, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents2 : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport2 : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper2 : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject2(typeof padding !== "number" ? padding : expandToHashMap2(padding, basePlacements2));
      var altContext = elementContext === popper2 ? reference2 : popper2;
      var popperRect = state2.rects.popper;
      var element = state2.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect2(isElement2(element) ? element : element.contextElement || getDocumentElement2(state2.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect2(state2.elements.reference);
      var popperOffsets3 = computeOffsets2({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect2(Object.assign({}, popperRect, popperOffsets3));
      var elementClientRect = elementContext === popper2 ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state2.modifiersData.offset;
      if (elementContext === popper2 && offsetData) {
        var offset3 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right2, bottom2].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top2, bottom2].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset3[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement2(state2, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements2 : _options$allowedAutoP;
      var variation = getVariation2(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements2 : variationPlacements2.filter(function(placement2) {
        return getVariation2(placement2) === variation;
      }) : basePlacements2;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow2(state2, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement2(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements2(placement) {
      if (getBasePlacement2(placement) === auto2) {
        return [];
      }
      var oppositePlacement = getOppositePlacement2(placement);
      return [getOppositeVariationPlacement2(placement), oppositePlacement, getOppositeVariationPlacement2(oppositePlacement)];
    }
    function flip2(_ref) {
      var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
      if (state2.modifiersData[name2]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state2.options.placement;
      var basePlacement = getBasePlacement2(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement2(preferredPlacement)] : getExpandedFallbackPlacements2(preferredPlacement));
      var placements3 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement2(placement2) === auto2 ? computeAutoPlacement2(state2, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements3[0];
      for (var i = 0; i < placements3.length; i++) {
        var placement = placements3[i];
        var _basePlacement = getBasePlacement2(placement);
        var isStartVariation = getVariation2(placement) === start2;
        var isVertical = [top2, bottom2].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow2(state2, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right2 : left2 : isStartVariation ? bottom2 : top2;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement2(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement2(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements3.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state2.placement !== firstFittingPlacement) {
        state2.modifiersData[name2]._skip = true;
        state2.placement = firstFittingPlacement;
        state2.reset = true;
      }
    }
    const flip$12 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip2,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets2(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped2(overflow) {
      return [top2, right2, bottom2, left2].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide2(_ref) {
      var state2 = _ref.state, name2 = _ref.name;
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var preventedOffsets = state2.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow2(state2, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow2(state2, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets2(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets2(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped2(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped2(popperEscapeOffsets);
      state2.modifiersData[name2] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$12 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide2
    };
    function distanceAndSkiddingToXY2(placement, rects, offset3) {
      var basePlacement = getBasePlacement2(placement);
      var invertDistance = [left2, top2].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset3 === "function" ? offset3(Object.assign({}, rects, {
        placement
      })) : offset3, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left2, right2].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset2(_ref2) {
      var state2 = _ref2.state, options = _ref2.options, name2 = _ref2.name;
      var _options$offset = options.offset, offset3 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data2 = placements2.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY2(placement, state2.rects, offset3);
        return acc;
      }, {});
      var _data$state$placement = data2[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
      if (state2.modifiersData.popperOffsets != null) {
        state2.modifiersData.popperOffsets.x += x;
        state2.modifiersData.popperOffsets.y += y;
      }
      state2.modifiersData[name2] = data2;
    }
    const offset$12 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset2
    };
    function popperOffsets2(_ref) {
      var state2 = _ref.state, name2 = _ref.name;
      state2.modifiersData[name2] = computeOffsets2({
        reference: state2.rects.reference,
        element: state2.rects.popper,
        strategy: "absolute",
        placement: state2.placement
      });
    }
    const popperOffsets$12 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets2,
      data: {}
    };
    function getAltAxis2(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow2(_ref) {
      var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow2(state2, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement2(state2.placement);
      var variation = getVariation2(state2.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement2(basePlacement);
      var altAxis = getAltAxis2(mainAxis);
      var popperOffsets3 = state2.modifiersData.popperOffsets;
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
        placement: state2.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
      var data2 = {
        x: 0,
        y: 0
      };
      if (!popperOffsets3) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top2 : left2;
        var altSide = mainAxis === "y" ? bottom2 : right2;
        var len = mainAxis === "y" ? "height" : "width";
        var offset3 = popperOffsets3[mainAxis];
        var min$1 = offset3 + overflow[mainSide];
        var max$1 = offset3 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start2 ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start2 ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state2.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect2(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject2();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within2(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state2.elements.arrow && getOffsetParent2(state2.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset3 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset3 + maxOffset - offsetModifierValue;
        var preventedOffset = within2(tether ? min2(min$1, tetherMin) : min$1, offset3, tether ? max2(max$1, tetherMax) : max$1);
        popperOffsets3[mainAxis] = preventedOffset;
        data2[mainAxis] = preventedOffset - offset3;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top2 : left2;
        var _altSide = mainAxis === "x" ? bottom2 : right2;
        var _offset = popperOffsets3[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top2, left2].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp2(_tetherMin, _offset, _tetherMax) : within2(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets3[altAxis] = _preventedOffset;
        data2[altAxis] = _preventedOffset - _offset;
      }
      state2.modifiersData[name2] = data2;
    }
    const preventOverflow$12 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow2,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll2(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll2(node) {
      if (node === getWindow2(node) || !isHTMLElement2(node)) {
        return getWindowScroll2(node);
      } else {
        return getHTMLElementScroll2(node);
      }
    }
    function isElementScaled2(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round2(rect.width) / element.offsetWidth || 1;
      var scaleY = round2(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect2(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement2(offsetParent);
      var offsetParentIsScaled = isHTMLElement2(offsetParent) && isElementScaled2(offsetParent);
      var documentElement = getDocumentElement2(offsetParent);
      var rect = getBoundingClientRect2(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName2(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent2(documentElement)) {
          scroll = getNodeScroll2(offsetParent);
        }
        if (isHTMLElement2(offsetParent)) {
          offsets = getBoundingClientRect2(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX2(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order2(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers2(modifiers) {
      var orderedModifiers = order2(modifiers);
      return modifierPhases2.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce2(fn3) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve(fn3());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName2(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS2 = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator2(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers3 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS2 : _generatorOptions$def2;
      return function createPopper3(reference3, popper3, options) {
        if (options === void 0) {
          options = defaultOptions2;
        }
        var state2 = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS2, defaultOptions2),
          modifiersData: {},
          elements: {
            reference: reference3,
            popper: popper3
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state2,
          setOptions: function setOptions2(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
            cleanupModifierEffects();
            state2.options = Object.assign({}, defaultOptions2, state2.options, options2);
            state2.scrollParents = {
              reference: isElement2(reference3) ? listScrollParents2(reference3) : reference3.contextElement ? listScrollParents2(reference3.contextElement) : [],
              popper: listScrollParents2(popper3)
            };
            var orderedModifiers = orderModifiers2(mergeByName2([].concat(defaultModifiers3, state2.options.modifiers)));
            state2.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state2.elements, reference4 = _state$elements.reference, popper4 = _state$elements.popper;
            if (!areValidElements2(reference4, popper4)) {
              return;
            }
            state2.rects = {
              reference: getCompositeRect2(reference4, getOffsetParent2(popper4), state2.options.strategy === "fixed"),
              popper: getLayoutRect2(popper4)
            };
            state2.reset = false;
            state2.placement = state2.options.placement;
            state2.orderedModifiers.forEach(function(modifier) {
              return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state2.orderedModifiers.length; index++) {
              if (state2.reset === true) {
                state2.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state2.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
              if (typeof fn3 === "function") {
                state2 = fn3({
                  state: state2,
                  options: _options,
                  name: name2,
                  instance
                }) || state2;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce2(function() {
            return new Promise(function(resolve) {
              instance.forceUpdate();
              resolve(state2);
            });
          }),
          destroy: function destroy2() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements2(reference3, popper3)) {
          return instance;
        }
        instance.setOptions(options).then(function(state3) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state3);
          }
        });
        function runModifierEffects() {
          state2.orderedModifiers.forEach(function(_ref3) {
            var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
            if (typeof effect3 === "function") {
              var cleanupFn = effect3({
                state: state2,
                name: name2,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn3) {
            return fn3();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var createPopper$22 = /* @__PURE__ */ popperGenerator2();
    var defaultModifiers$12 = [eventListeners2, popperOffsets$12, computeStyles$12, applyStyles$12];
    var createPopper$12 = /* @__PURE__ */ popperGenerator2({
      defaultModifiers: defaultModifiers$12
    });
    var defaultModifiers2 = [eventListeners2, popperOffsets$12, computeStyles$12, applyStyles$12, offset$12, flip$12, preventOverflow$12, arrow$12, hide$12];
    var createPopper2 = /* @__PURE__ */ popperGenerator2({
      defaultModifiers: defaultModifiers2
    });
    const Popper2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      afterMain: afterMain2,
      afterRead: afterRead2,
      afterWrite: afterWrite2,
      applyStyles: applyStyles$12,
      arrow: arrow$12,
      auto: auto2,
      basePlacements: basePlacements2,
      beforeMain: beforeMain2,
      beforeRead: beforeRead2,
      beforeWrite: beforeWrite2,
      bottom: bottom2,
      clippingParents: clippingParents2,
      computeStyles: computeStyles$12,
      createPopper: createPopper2,
      createPopperBase: createPopper$22,
      createPopperLite: createPopper$12,
      detectOverflow: detectOverflow2,
      end: end2,
      eventListeners: eventListeners2,
      flip: flip$12,
      hide: hide$12,
      left: left2,
      main: main2,
      modifierPhases: modifierPhases2,
      offset: offset$12,
      placements: placements2,
      popper: popper2,
      popperGenerator: popperGenerator2,
      popperOffsets: popperOffsets$12,
      preventOverflow: preventOverflow$12,
      read: read2,
      reference: reference2,
      right: right2,
      start: start2,
      top: top2,
      variationPlacements: variationPlacements2,
      viewport: viewport2,
      write: write2
    }, Symbol.toStringTag, { value: "Module" }));
    const NAME$a2 = "dropdown";
    const DATA_KEY$62 = "bs.dropdown";
    const EVENT_KEY$62 = `.${DATA_KEY$62}`;
    const DATA_API_KEY$32 = ".data-api";
    const ESCAPE_KEY$22 = "Escape";
    const TAB_KEY$12 = "Tab";
    const ARROW_UP_KEY$12 = "ArrowUp";
    const ARROW_DOWN_KEY$12 = "ArrowDown";
    const RIGHT_MOUSE_BUTTON2 = 2;
    const EVENT_HIDE$52 = `hide${EVENT_KEY$62}`;
    const EVENT_HIDDEN$52 = `hidden${EVENT_KEY$62}`;
    const EVENT_SHOW$52 = `show${EVENT_KEY$62}`;
    const EVENT_SHOWN$52 = `shown${EVENT_KEY$62}`;
    const EVENT_CLICK_DATA_API$32 = `click${EVENT_KEY$62}${DATA_API_KEY$32}`;
    const EVENT_KEYDOWN_DATA_API2 = `keydown${EVENT_KEY$62}${DATA_API_KEY$32}`;
    const EVENT_KEYUP_DATA_API2 = `keyup${EVENT_KEY$62}${DATA_API_KEY$32}`;
    const CLASS_NAME_SHOW$62 = "show";
    const CLASS_NAME_DROPUP2 = "dropup";
    const CLASS_NAME_DROPEND2 = "dropend";
    const CLASS_NAME_DROPSTART2 = "dropstart";
    const CLASS_NAME_DROPUP_CENTER2 = "dropup-center";
    const CLASS_NAME_DROPDOWN_CENTER2 = "dropdown-center";
    const SELECTOR_DATA_TOGGLE$32 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
    const SELECTOR_DATA_TOGGLE_SHOWN2 = `${SELECTOR_DATA_TOGGLE$32}.${CLASS_NAME_SHOW$62}`;
    const SELECTOR_MENU2 = ".dropdown-menu";
    const SELECTOR_NAVBAR2 = ".navbar";
    const SELECTOR_NAVBAR_NAV2 = ".navbar-nav";
    const SELECTOR_VISIBLE_ITEMS2 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
    const PLACEMENT_TOP2 = isRTL2() ? "top-end" : "top-start";
    const PLACEMENT_TOPEND2 = isRTL2() ? "top-start" : "top-end";
    const PLACEMENT_BOTTOM2 = isRTL2() ? "bottom-end" : "bottom-start";
    const PLACEMENT_BOTTOMEND2 = isRTL2() ? "bottom-start" : "bottom-end";
    const PLACEMENT_RIGHT2 = isRTL2() ? "left-start" : "right-start";
    const PLACEMENT_LEFT2 = isRTL2() ? "right-start" : "left-start";
    const PLACEMENT_TOPCENTER2 = "top";
    const PLACEMENT_BOTTOMCENTER2 = "bottom";
    const Default$92 = {
      autoClose: true,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle"
    };
    const DefaultType$92 = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)"
    };
    class Dropdown2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._popper = null;
        this._parent = this._element.parentNode;
        this._menu = SelectorEngine2.next(this._element, SELECTOR_MENU2)[0] || SelectorEngine2.prev(this._element, SELECTOR_MENU2)[0] || SelectorEngine2.findOne(SELECTOR_MENU2, this._parent);
        this._inNavbar = this._detectNavbar();
      }
      // Getters
      static get Default() {
        return Default$92;
      }
      static get DefaultType() {
        return DefaultType$92;
      }
      static get NAME() {
        return NAME$a2;
      }
      // Public
      toggle() {
        return this._isShown() ? this.hide() : this.show();
      }
      show() {
        if (isDisabled2(this._element) || this._isShown()) {
          return;
        }
        const relatedTarget = {
          relatedTarget: this._element
        };
        const showEvent = EventHandler2.trigger(this._element, EVENT_SHOW$52, relatedTarget);
        if (showEvent.defaultPrevented) {
          return;
        }
        this._createPopper();
        if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV2)) {
          for (const element of [].concat(...document.body.children)) {
            EventHandler2.on(element, "mouseover", noop2);
          }
        }
        this._element.focus();
        this._element.setAttribute("aria-expanded", true);
        this._menu.classList.add(CLASS_NAME_SHOW$62);
        this._element.classList.add(CLASS_NAME_SHOW$62);
        EventHandler2.trigger(this._element, EVENT_SHOWN$52, relatedTarget);
      }
      hide() {
        if (isDisabled2(this._element) || !this._isShown()) {
          return;
        }
        const relatedTarget = {
          relatedTarget: this._element
        };
        this._completeHide(relatedTarget);
      }
      dispose() {
        if (this._popper) {
          this._popper.destroy();
        }
        super.dispose();
      }
      update() {
        this._inNavbar = this._detectNavbar();
        if (this._popper) {
          this._popper.update();
        }
      }
      // Private
      _completeHide(relatedTarget) {
        const hideEvent = EventHandler2.trigger(this._element, EVENT_HIDE$52, relatedTarget);
        if (hideEvent.defaultPrevented) {
          return;
        }
        if ("ontouchstart" in document.documentElement) {
          for (const element of [].concat(...document.body.children)) {
            EventHandler2.off(element, "mouseover", noop2);
          }
        }
        if (this._popper) {
          this._popper.destroy();
        }
        this._menu.classList.remove(CLASS_NAME_SHOW$62);
        this._element.classList.remove(CLASS_NAME_SHOW$62);
        this._element.setAttribute("aria-expanded", "false");
        Manipulator2.removeDataAttribute(this._menu, "popper");
        EventHandler2.trigger(this._element, EVENT_HIDDEN$52, relatedTarget);
      }
      _getConfig(config) {
        config = super._getConfig(config);
        if (typeof config.reference === "object" && !isElement$12(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
          throw new TypeError(`${NAME$a2.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        }
        return config;
      }
      _createPopper() {
        if (typeof Popper2 === "undefined") {
          throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        }
        let referenceElement = this._element;
        if (this._config.reference === "parent") {
          referenceElement = this._parent;
        } else if (isElement$12(this._config.reference)) {
          referenceElement = getElement2(this._config.reference);
        } else if (typeof this._config.reference === "object") {
          referenceElement = this._config.reference;
        }
        const popperConfig = this._getPopperConfig();
        this._popper = createPopper2(referenceElement, this._menu, popperConfig);
      }
      _isShown() {
        return this._menu.classList.contains(CLASS_NAME_SHOW$62);
      }
      _getPlacement() {
        const parentDropdown = this._parent;
        if (parentDropdown.classList.contains(CLASS_NAME_DROPEND2)) {
          return PLACEMENT_RIGHT2;
        }
        if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART2)) {
          return PLACEMENT_LEFT2;
        }
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER2)) {
          return PLACEMENT_TOPCENTER2;
        }
        if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER2)) {
          return PLACEMENT_BOTTOMCENTER2;
        }
        const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
        if (parentDropdown.classList.contains(CLASS_NAME_DROPUP2)) {
          return isEnd ? PLACEMENT_TOPEND2 : PLACEMENT_TOP2;
        }
        return isEnd ? PLACEMENT_BOTTOMEND2 : PLACEMENT_BOTTOM2;
      }
      _detectNavbar() {
        return this._element.closest(SELECTOR_NAVBAR2) !== null;
      }
      _getOffset() {
        const {
          offset: offset3
        } = this._config;
        if (typeof offset3 === "string") {
          return offset3.split(",").map((value) => Number.parseInt(value, 10));
        }
        if (typeof offset3 === "function") {
          return (popperData) => offset3(popperData, this._element);
        }
        return offset3;
      }
      _getPopperConfig() {
        const defaultBsPopperConfig = {
          placement: this._getPlacement(),
          modifiers: [{
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: "offset",
            options: {
              offset: this._getOffset()
            }
          }]
        };
        if (this._inNavbar || this._config.display === "static") {
          Manipulator2.setDataAttribute(this._menu, "popper", "static");
          defaultBsPopperConfig.modifiers = [{
            name: "applyStyles",
            enabled: false
          }];
        }
        return {
          ...defaultBsPopperConfig,
          ...execute2(this._config.popperConfig, [defaultBsPopperConfig])
        };
      }
      _selectMenuItem({
        key,
        target
      }) {
        const items = SelectorEngine2.find(SELECTOR_VISIBLE_ITEMS2, this._menu).filter((element) => isVisible2(element));
        if (!items.length) {
          return;
        }
        getNextActiveElement2(items, target, key === ARROW_DOWN_KEY$12, !items.includes(target)).focus();
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Dropdown2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (typeof data2[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config]();
        });
      }
      static clearMenus(event) {
        if (event.button === RIGHT_MOUSE_BUTTON2 || event.type === "keyup" && event.key !== TAB_KEY$12) {
          return;
        }
        const openToggles = SelectorEngine2.find(SELECTOR_DATA_TOGGLE_SHOWN2);
        for (const toggle of openToggles) {
          const context = Dropdown2.getInstance(toggle);
          if (!context || context._config.autoClose === false) {
            continue;
          }
          const composedPath = event.composedPath();
          const isMenuTarget = composedPath.includes(context._menu);
          if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
            continue;
          }
          if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$12 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
            continue;
          }
          const relatedTarget = {
            relatedTarget: context._element
          };
          if (event.type === "click") {
            relatedTarget.clickEvent = event;
          }
          context._completeHide(relatedTarget);
        }
      }
      static dataApiKeydownHandler(event) {
        const isInput = /input|textarea/i.test(event.target.tagName);
        const isEscapeEvent = event.key === ESCAPE_KEY$22;
        const isUpOrDownEvent = [ARROW_UP_KEY$12, ARROW_DOWN_KEY$12].includes(event.key);
        if (!isUpOrDownEvent && !isEscapeEvent) {
          return;
        }
        if (isInput && !isEscapeEvent) {
          return;
        }
        event.preventDefault();
        const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$32) ? this : SelectorEngine2.prev(this, SELECTOR_DATA_TOGGLE$32)[0] || SelectorEngine2.next(this, SELECTOR_DATA_TOGGLE$32)[0] || SelectorEngine2.findOne(SELECTOR_DATA_TOGGLE$32, event.delegateTarget.parentNode);
        const instance = Dropdown2.getOrCreateInstance(getToggleButton);
        if (isUpOrDownEvent) {
          event.stopPropagation();
          instance.show();
          instance._selectMenuItem(event);
          return;
        }
        if (instance._isShown()) {
          event.stopPropagation();
          instance.hide();
          getToggleButton.focus();
        }
      }
    }
    EventHandler2.on(document, EVENT_KEYDOWN_DATA_API2, SELECTOR_DATA_TOGGLE$32, Dropdown2.dataApiKeydownHandler);
    EventHandler2.on(document, EVENT_KEYDOWN_DATA_API2, SELECTOR_MENU2, Dropdown2.dataApiKeydownHandler);
    EventHandler2.on(document, EVENT_CLICK_DATA_API$32, Dropdown2.clearMenus);
    EventHandler2.on(document, EVENT_KEYUP_DATA_API2, Dropdown2.clearMenus);
    EventHandler2.on(document, EVENT_CLICK_DATA_API$32, SELECTOR_DATA_TOGGLE$32, function(event) {
      event.preventDefault();
      Dropdown2.getOrCreateInstance(this).toggle();
    });
    defineJQueryPlugin2(Dropdown2);
    const NAME$92 = "backdrop";
    const CLASS_NAME_FADE$42 = "fade";
    const CLASS_NAME_SHOW$52 = "show";
    const EVENT_MOUSEDOWN2 = `mousedown.bs.${NAME$92}`;
    const Default$82 = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: false,
      isVisible: true,
      // if false, we use the backdrop helper without adding any element to the dom
      rootElement: "body"
      // give the choice to place backdrop under different elements
    };
    const DefaultType$82 = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)"
    };
    class Backdrop2 extends Config2 {
      constructor(config) {
        super();
        this._config = this._getConfig(config);
        this._isAppended = false;
        this._element = null;
      }
      // Getters
      static get Default() {
        return Default$82;
      }
      static get DefaultType() {
        return DefaultType$82;
      }
      static get NAME() {
        return NAME$92;
      }
      // Public
      show(callback) {
        if (!this._config.isVisible) {
          execute2(callback);
          return;
        }
        this._append();
        const element = this._getElement();
        if (this._config.isAnimated) {
          reflow2(element);
        }
        element.classList.add(CLASS_NAME_SHOW$52);
        this._emulateAnimation(() => {
          execute2(callback);
        });
      }
      hide(callback) {
        if (!this._config.isVisible) {
          execute2(callback);
          return;
        }
        this._getElement().classList.remove(CLASS_NAME_SHOW$52);
        this._emulateAnimation(() => {
          this.dispose();
          execute2(callback);
        });
      }
      dispose() {
        if (!this._isAppended) {
          return;
        }
        EventHandler2.off(this._element, EVENT_MOUSEDOWN2);
        this._element.remove();
        this._isAppended = false;
      }
      // Private
      _getElement() {
        if (!this._element) {
          const backdrop = document.createElement("div");
          backdrop.className = this._config.className;
          if (this._config.isAnimated) {
            backdrop.classList.add(CLASS_NAME_FADE$42);
          }
          this._element = backdrop;
        }
        return this._element;
      }
      _configAfterMerge(config) {
        config.rootElement = getElement2(config.rootElement);
        return config;
      }
      _append() {
        if (this._isAppended) {
          return;
        }
        const element = this._getElement();
        this._config.rootElement.append(element);
        EventHandler2.on(element, EVENT_MOUSEDOWN2, () => {
          execute2(this._config.clickCallback);
        });
        this._isAppended = true;
      }
      _emulateAnimation(callback) {
        executeAfterTransition2(callback, this._getElement(), this._config.isAnimated);
      }
    }
    const NAME$82 = "focustrap";
    const DATA_KEY$52 = "bs.focustrap";
    const EVENT_KEY$52 = `.${DATA_KEY$52}`;
    const EVENT_FOCUSIN$22 = `focusin${EVENT_KEY$52}`;
    const EVENT_KEYDOWN_TAB2 = `keydown.tab${EVENT_KEY$52}`;
    const TAB_KEY2 = "Tab";
    const TAB_NAV_FORWARD2 = "forward";
    const TAB_NAV_BACKWARD2 = "backward";
    const Default$72 = {
      autofocus: true,
      trapElement: null
      // The element to trap focus inside of
    };
    const DefaultType$72 = {
      autofocus: "boolean",
      trapElement: "element"
    };
    class FocusTrap2 extends Config2 {
      constructor(config) {
        super();
        this._config = this._getConfig(config);
        this._isActive = false;
        this._lastTabNavDirection = null;
      }
      // Getters
      static get Default() {
        return Default$72;
      }
      static get DefaultType() {
        return DefaultType$72;
      }
      static get NAME() {
        return NAME$82;
      }
      // Public
      activate() {
        if (this._isActive) {
          return;
        }
        if (this._config.autofocus) {
          this._config.trapElement.focus();
        }
        EventHandler2.off(document, EVENT_KEY$52);
        EventHandler2.on(document, EVENT_FOCUSIN$22, (event) => this._handleFocusin(event));
        EventHandler2.on(document, EVENT_KEYDOWN_TAB2, (event) => this._handleKeydown(event));
        this._isActive = true;
      }
      deactivate() {
        if (!this._isActive) {
          return;
        }
        this._isActive = false;
        EventHandler2.off(document, EVENT_KEY$52);
      }
      // Private
      _handleFocusin(event) {
        const {
          trapElement
        } = this._config;
        if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
          return;
        }
        const elements = SelectorEngine2.focusableChildren(trapElement);
        if (elements.length === 0) {
          trapElement.focus();
        } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD2) {
          elements[elements.length - 1].focus();
        } else {
          elements[0].focus();
        }
      }
      _handleKeydown(event) {
        if (event.key !== TAB_KEY2) {
          return;
        }
        this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD2 : TAB_NAV_FORWARD2;
      }
    }
    const SELECTOR_FIXED_CONTENT2 = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
    const SELECTOR_STICKY_CONTENT2 = ".sticky-top";
    const PROPERTY_PADDING2 = "padding-right";
    const PROPERTY_MARGIN2 = "margin-right";
    class ScrollBarHelper2 {
      constructor() {
        this._element = document.body;
      }
      // Public
      getWidth() {
        const documentWidth = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - documentWidth);
      }
      hide() {
        const width2 = this.getWidth();
        this._disableOverFlow();
        this._setElementAttributes(this._element, PROPERTY_PADDING2, (calculatedValue) => calculatedValue + width2);
        this._setElementAttributes(SELECTOR_FIXED_CONTENT2, PROPERTY_PADDING2, (calculatedValue) => calculatedValue + width2);
        this._setElementAttributes(SELECTOR_STICKY_CONTENT2, PROPERTY_MARGIN2, (calculatedValue) => calculatedValue - width2);
      }
      reset() {
        this._resetElementAttributes(this._element, "overflow");
        this._resetElementAttributes(this._element, PROPERTY_PADDING2);
        this._resetElementAttributes(SELECTOR_FIXED_CONTENT2, PROPERTY_PADDING2);
        this._resetElementAttributes(SELECTOR_STICKY_CONTENT2, PROPERTY_MARGIN2);
      }
      isOverflowing() {
        return this.getWidth() > 0;
      }
      // Private
      _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow");
        this._element.style.overflow = "hidden";
      }
      _setElementAttributes(selector, styleProperty, callback) {
        const scrollbarWidth = this.getWidth();
        const manipulationCallBack = (element) => {
          if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
            return;
          }
          this._saveInitialAttribute(element, styleProperty);
          const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
          element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
      }
      _saveInitialAttribute(element, styleProperty) {
        const actualValue = element.style.getPropertyValue(styleProperty);
        if (actualValue) {
          Manipulator2.setDataAttribute(element, styleProperty, actualValue);
        }
      }
      _resetElementAttributes(selector, styleProperty) {
        const manipulationCallBack = (element) => {
          const value = Manipulator2.getDataAttribute(element, styleProperty);
          if (value === null) {
            element.style.removeProperty(styleProperty);
            return;
          }
          Manipulator2.removeDataAttribute(element, styleProperty);
          element.style.setProperty(styleProperty, value);
        };
        this._applyManipulationCallback(selector, manipulationCallBack);
      }
      _applyManipulationCallback(selector, callBack) {
        if (isElement$12(selector)) {
          callBack(selector);
          return;
        }
        for (const sel of SelectorEngine2.find(selector, this._element)) {
          callBack(sel);
        }
      }
    }
    const NAME$72 = "modal";
    const DATA_KEY$42 = "bs.modal";
    const EVENT_KEY$42 = `.${DATA_KEY$42}`;
    const DATA_API_KEY$22 = ".data-api";
    const ESCAPE_KEY$12 = "Escape";
    const EVENT_HIDE$42 = `hide${EVENT_KEY$42}`;
    const EVENT_HIDE_PREVENTED$12 = `hidePrevented${EVENT_KEY$42}`;
    const EVENT_HIDDEN$42 = `hidden${EVENT_KEY$42}`;
    const EVENT_SHOW$42 = `show${EVENT_KEY$42}`;
    const EVENT_SHOWN$42 = `shown${EVENT_KEY$42}`;
    const EVENT_RESIZE$12 = `resize${EVENT_KEY$42}`;
    const EVENT_CLICK_DISMISS2 = `click.dismiss${EVENT_KEY$42}`;
    const EVENT_MOUSEDOWN_DISMISS2 = `mousedown.dismiss${EVENT_KEY$42}`;
    const EVENT_KEYDOWN_DISMISS$12 = `keydown.dismiss${EVENT_KEY$42}`;
    const EVENT_CLICK_DATA_API$22 = `click${EVENT_KEY$42}${DATA_API_KEY$22}`;
    const CLASS_NAME_OPEN2 = "modal-open";
    const CLASS_NAME_FADE$32 = "fade";
    const CLASS_NAME_SHOW$42 = "show";
    const CLASS_NAME_STATIC2 = "modal-static";
    const OPEN_SELECTOR$12 = ".modal.show";
    const SELECTOR_DIALOG2 = ".modal-dialog";
    const SELECTOR_MODAL_BODY2 = ".modal-body";
    const SELECTOR_DATA_TOGGLE$22 = '[data-bs-toggle="modal"]';
    const Default$62 = {
      backdrop: true,
      focus: true,
      keyboard: true
    };
    const DefaultType$62 = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean"
    };
    class Modal2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._dialog = SelectorEngine2.findOne(SELECTOR_DIALOG2, this._element);
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._isShown = false;
        this._isTransitioning = false;
        this._scrollBar = new ScrollBarHelper2();
        this._addEventListeners();
      }
      // Getters
      static get Default() {
        return Default$62;
      }
      static get DefaultType() {
        return DefaultType$62;
      }
      static get NAME() {
        return NAME$72;
      }
      // Public
      toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
      show(relatedTarget) {
        if (this._isShown || this._isTransitioning) {
          return;
        }
        const showEvent = EventHandler2.trigger(this._element, EVENT_SHOW$42, {
          relatedTarget
        });
        if (showEvent.defaultPrevented) {
          return;
        }
        this._isShown = true;
        this._isTransitioning = true;
        this._scrollBar.hide();
        document.body.classList.add(CLASS_NAME_OPEN2);
        this._adjustDialog();
        this._backdrop.show(() => this._showElement(relatedTarget));
      }
      hide() {
        if (!this._isShown || this._isTransitioning) {
          return;
        }
        const hideEvent = EventHandler2.trigger(this._element, EVENT_HIDE$42);
        if (hideEvent.defaultPrevented) {
          return;
        }
        this._isShown = false;
        this._isTransitioning = true;
        this._focustrap.deactivate();
        this._element.classList.remove(CLASS_NAME_SHOW$42);
        this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
      }
      dispose() {
        EventHandler2.off(window, EVENT_KEY$42);
        EventHandler2.off(this._dialog, EVENT_KEY$42);
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
      }
      handleUpdate() {
        this._adjustDialog();
      }
      // Private
      _initializeBackDrop() {
        return new Backdrop2({
          isVisible: Boolean(this._config.backdrop),
          // 'static' option will be translated to true, and booleans will keep their value,
          isAnimated: this._isAnimated()
        });
      }
      _initializeFocusTrap() {
        return new FocusTrap2({
          trapElement: this._element
        });
      }
      _showElement(relatedTarget) {
        if (!document.body.contains(this._element)) {
          document.body.append(this._element);
        }
        this._element.style.display = "block";
        this._element.removeAttribute("aria-hidden");
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        this._element.scrollTop = 0;
        const modalBody = SelectorEngine2.findOne(SELECTOR_MODAL_BODY2, this._dialog);
        if (modalBody) {
          modalBody.scrollTop = 0;
        }
        reflow2(this._element);
        this._element.classList.add(CLASS_NAME_SHOW$42);
        const transitionComplete = () => {
          if (this._config.focus) {
            this._focustrap.activate();
          }
          this._isTransitioning = false;
          EventHandler2.trigger(this._element, EVENT_SHOWN$42, {
            relatedTarget
          });
        };
        this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
      }
      _addEventListeners() {
        EventHandler2.on(this._element, EVENT_KEYDOWN_DISMISS$12, (event) => {
          if (event.key !== ESCAPE_KEY$12) {
            return;
          }
          if (this._config.keyboard) {
            this.hide();
            return;
          }
          this._triggerBackdropTransition();
        });
        EventHandler2.on(window, EVENT_RESIZE$12, () => {
          if (this._isShown && !this._isTransitioning) {
            this._adjustDialog();
          }
        });
        EventHandler2.on(this._element, EVENT_MOUSEDOWN_DISMISS2, (event) => {
          EventHandler2.one(this._element, EVENT_CLICK_DISMISS2, (event2) => {
            if (this._element !== event.target || this._element !== event2.target) {
              return;
            }
            if (this._config.backdrop === "static") {
              this._triggerBackdropTransition();
              return;
            }
            if (this._config.backdrop) {
              this.hide();
            }
          });
        });
      }
      _hideModal() {
        this._element.style.display = "none";
        this._element.setAttribute("aria-hidden", true);
        this._element.removeAttribute("aria-modal");
        this._element.removeAttribute("role");
        this._isTransitioning = false;
        this._backdrop.hide(() => {
          document.body.classList.remove(CLASS_NAME_OPEN2);
          this._resetAdjustments();
          this._scrollBar.reset();
          EventHandler2.trigger(this._element, EVENT_HIDDEN$42);
        });
      }
      _isAnimated() {
        return this._element.classList.contains(CLASS_NAME_FADE$32);
      }
      _triggerBackdropTransition() {
        const hideEvent = EventHandler2.trigger(this._element, EVENT_HIDE_PREVENTED$12);
        if (hideEvent.defaultPrevented) {
          return;
        }
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const initialOverflowY = this._element.style.overflowY;
        if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC2)) {
          return;
        }
        if (!isModalOverflowing) {
          this._element.style.overflowY = "hidden";
        }
        this._element.classList.add(CLASS_NAME_STATIC2);
        this._queueCallback(() => {
          this._element.classList.remove(CLASS_NAME_STATIC2);
          this._queueCallback(() => {
            this._element.style.overflowY = initialOverflowY;
          }, this._dialog);
        }, this._dialog);
        this._element.focus();
      }
      /**
       * The following methods are used to handle overflowing modals
       */
      _adjustDialog() {
        const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
        const scrollbarWidth = this._scrollBar.getWidth();
        const isBodyOverflowing = scrollbarWidth > 0;
        if (isBodyOverflowing && !isModalOverflowing) {
          const property = isRTL2() ? "paddingLeft" : "paddingRight";
          this._element.style[property] = `${scrollbarWidth}px`;
        }
        if (!isBodyOverflowing && isModalOverflowing) {
          const property = isRTL2() ? "paddingRight" : "paddingLeft";
          this._element.style[property] = `${scrollbarWidth}px`;
        }
      }
      _resetAdjustments() {
        this._element.style.paddingLeft = "";
        this._element.style.paddingRight = "";
      }
      // Static
      static jQueryInterface(config, relatedTarget) {
        return this.each(function() {
          const data2 = Modal2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (typeof data2[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config](relatedTarget);
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API$22, SELECTOR_DATA_TOGGLE$22, function(event) {
      const target = SelectorEngine2.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      EventHandler2.one(target, EVENT_SHOW$42, (showEvent) => {
        if (showEvent.defaultPrevented) {
          return;
        }
        EventHandler2.one(target, EVENT_HIDDEN$42, () => {
          if (isVisible2(this)) {
            this.focus();
          }
        });
      });
      const alreadyOpen = SelectorEngine2.findOne(OPEN_SELECTOR$12);
      if (alreadyOpen) {
        Modal2.getInstance(alreadyOpen).hide();
      }
      const data2 = Modal2.getOrCreateInstance(target);
      data2.toggle(this);
    });
    enableDismissTrigger2(Modal2);
    defineJQueryPlugin2(Modal2);
    const NAME$62 = "offcanvas";
    const DATA_KEY$32 = "bs.offcanvas";
    const EVENT_KEY$32 = `.${DATA_KEY$32}`;
    const DATA_API_KEY$12 = ".data-api";
    const EVENT_LOAD_DATA_API$22 = `load${EVENT_KEY$32}${DATA_API_KEY$12}`;
    const ESCAPE_KEY2 = "Escape";
    const CLASS_NAME_SHOW$32 = "show";
    const CLASS_NAME_SHOWING$12 = "showing";
    const CLASS_NAME_HIDING2 = "hiding";
    const CLASS_NAME_BACKDROP2 = "offcanvas-backdrop";
    const OPEN_SELECTOR2 = ".offcanvas.show";
    const EVENT_SHOW$32 = `show${EVENT_KEY$32}`;
    const EVENT_SHOWN$32 = `shown${EVENT_KEY$32}`;
    const EVENT_HIDE$32 = `hide${EVENT_KEY$32}`;
    const EVENT_HIDE_PREVENTED2 = `hidePrevented${EVENT_KEY$32}`;
    const EVENT_HIDDEN$32 = `hidden${EVENT_KEY$32}`;
    const EVENT_RESIZE2 = `resize${EVENT_KEY$32}`;
    const EVENT_CLICK_DATA_API$12 = `click${EVENT_KEY$32}${DATA_API_KEY$12}`;
    const EVENT_KEYDOWN_DISMISS2 = `keydown.dismiss${EVENT_KEY$32}`;
    const SELECTOR_DATA_TOGGLE$12 = '[data-bs-toggle="offcanvas"]';
    const Default$52 = {
      backdrop: true,
      keyboard: true,
      scroll: false
    };
    const DefaultType$52 = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean"
    };
    class Offcanvas2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._isShown = false;
        this._backdrop = this._initializeBackDrop();
        this._focustrap = this._initializeFocusTrap();
        this._addEventListeners();
      }
      // Getters
      static get Default() {
        return Default$52;
      }
      static get DefaultType() {
        return DefaultType$52;
      }
      static get NAME() {
        return NAME$62;
      }
      // Public
      toggle(relatedTarget) {
        return this._isShown ? this.hide() : this.show(relatedTarget);
      }
      show(relatedTarget) {
        if (this._isShown) {
          return;
        }
        const showEvent = EventHandler2.trigger(this._element, EVENT_SHOW$32, {
          relatedTarget
        });
        if (showEvent.defaultPrevented) {
          return;
        }
        this._isShown = true;
        this._backdrop.show();
        if (!this._config.scroll) {
          new ScrollBarHelper2().hide();
        }
        this._element.setAttribute("aria-modal", true);
        this._element.setAttribute("role", "dialog");
        this._element.classList.add(CLASS_NAME_SHOWING$12);
        const completeCallBack = () => {
          if (!this._config.scroll || this._config.backdrop) {
            this._focustrap.activate();
          }
          this._element.classList.add(CLASS_NAME_SHOW$32);
          this._element.classList.remove(CLASS_NAME_SHOWING$12);
          EventHandler2.trigger(this._element, EVENT_SHOWN$32, {
            relatedTarget
          });
        };
        this._queueCallback(completeCallBack, this._element, true);
      }
      hide() {
        if (!this._isShown) {
          return;
        }
        const hideEvent = EventHandler2.trigger(this._element, EVENT_HIDE$32);
        if (hideEvent.defaultPrevented) {
          return;
        }
        this._focustrap.deactivate();
        this._element.blur();
        this._isShown = false;
        this._element.classList.add(CLASS_NAME_HIDING2);
        this._backdrop.hide();
        const completeCallback = () => {
          this._element.classList.remove(CLASS_NAME_SHOW$32, CLASS_NAME_HIDING2);
          this._element.removeAttribute("aria-modal");
          this._element.removeAttribute("role");
          if (!this._config.scroll) {
            new ScrollBarHelper2().reset();
          }
          EventHandler2.trigger(this._element, EVENT_HIDDEN$32);
        };
        this._queueCallback(completeCallback, this._element, true);
      }
      dispose() {
        this._backdrop.dispose();
        this._focustrap.deactivate();
        super.dispose();
      }
      // Private
      _initializeBackDrop() {
        const clickCallback = () => {
          if (this._config.backdrop === "static") {
            EventHandler2.trigger(this._element, EVENT_HIDE_PREVENTED2);
            return;
          }
          this.hide();
        };
        const isVisible3 = Boolean(this._config.backdrop);
        return new Backdrop2({
          className: CLASS_NAME_BACKDROP2,
          isVisible: isVisible3,
          isAnimated: true,
          rootElement: this._element.parentNode,
          clickCallback: isVisible3 ? clickCallback : null
        });
      }
      _initializeFocusTrap() {
        return new FocusTrap2({
          trapElement: this._element
        });
      }
      _addEventListeners() {
        EventHandler2.on(this._element, EVENT_KEYDOWN_DISMISS2, (event) => {
          if (event.key !== ESCAPE_KEY2) {
            return;
          }
          if (this._config.keyboard) {
            this.hide();
            return;
          }
          EventHandler2.trigger(this._element, EVENT_HIDE_PREVENTED2);
        });
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Offcanvas2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config](this);
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API$12, SELECTOR_DATA_TOGGLE$12, function(event) {
      const target = SelectorEngine2.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled2(this)) {
        return;
      }
      EventHandler2.one(target, EVENT_HIDDEN$32, () => {
        if (isVisible2(this)) {
          this.focus();
        }
      });
      const alreadyOpen = SelectorEngine2.findOne(OPEN_SELECTOR2);
      if (alreadyOpen && alreadyOpen !== target) {
        Offcanvas2.getInstance(alreadyOpen).hide();
      }
      const data2 = Offcanvas2.getOrCreateInstance(target);
      data2.toggle(this);
    });
    EventHandler2.on(window, EVENT_LOAD_DATA_API$22, () => {
      for (const selector of SelectorEngine2.find(OPEN_SELECTOR2)) {
        Offcanvas2.getOrCreateInstance(selector).show();
      }
    });
    EventHandler2.on(window, EVENT_RESIZE2, () => {
      for (const element of SelectorEngine2.find("[aria-modal][class*=show][class*=offcanvas-]")) {
        if (getComputedStyle(element).position !== "fixed") {
          Offcanvas2.getOrCreateInstance(element).hide();
        }
      }
    });
    enableDismissTrigger2(Offcanvas2);
    defineJQueryPlugin2(Offcanvas2);
    const uriAttributes2 = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
    const SAFE_URL_PATTERN2 = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
    const DATA_URL_PATTERN2 = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
    const allowedAttribute2 = (attribute, allowedAttributeList) => {
      const attributeName = attribute.nodeName.toLowerCase();
      if (allowedAttributeList.includes(attributeName)) {
        if (uriAttributes2.has(attributeName)) {
          return Boolean(SAFE_URL_PATTERN2.test(attribute.nodeValue) || DATA_URL_PATTERN2.test(attribute.nodeValue));
        }
        return true;
      }
      return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
    };
    const ARIA_ATTRIBUTE_PATTERN2 = /^aria-[\w-]*$/i;
    const DefaultAllowlist2 = {
      // Global attributes allowed on any supplied element below.
      "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN2],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: []
    };
    function sanitizeHtml2(unsafeHtml, allowList, sanitizeFunction) {
      if (!unsafeHtml.length) {
        return unsafeHtml;
      }
      if (sanitizeFunction && typeof sanitizeFunction === "function") {
        return sanitizeFunction(unsafeHtml);
      }
      const domParser = new window.DOMParser();
      const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
      const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
      for (const element of elements) {
        const elementName = element.nodeName.toLowerCase();
        if (!Object.keys(allowList).includes(elementName)) {
          element.remove();
          continue;
        }
        const attributeList = [].concat(...element.attributes);
        const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
        for (const attribute of attributeList) {
          if (!allowedAttribute2(attribute, allowedAttributes)) {
            element.removeAttribute(attribute.nodeName);
          }
        }
      }
      return createdDocument.body.innerHTML;
    }
    const NAME$52 = "TemplateFactory";
    const Default$42 = {
      allowList: DefaultAllowlist2,
      content: {},
      // { selector : text ,  selector2 : text2 , }
      extraClass: "",
      html: false,
      sanitize: true,
      sanitizeFn: null,
      template: "<div></div>"
    };
    const DefaultType$42 = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string"
    };
    const DefaultContentType2 = {
      entry: "(string|element|function|null)",
      selector: "(string|element)"
    };
    class TemplateFactory2 extends Config2 {
      constructor(config) {
        super();
        this._config = this._getConfig(config);
      }
      // Getters
      static get Default() {
        return Default$42;
      }
      static get DefaultType() {
        return DefaultType$42;
      }
      static get NAME() {
        return NAME$52;
      }
      // Public
      getContent() {
        return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
      }
      hasContent() {
        return this.getContent().length > 0;
      }
      changeContent(content) {
        this._checkContent(content);
        this._config.content = {
          ...this._config.content,
          ...content
        };
        return this;
      }
      toHtml() {
        const templateWrapper = document.createElement("div");
        templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
        for (const [selector, text2] of Object.entries(this._config.content)) {
          this._setContent(templateWrapper, text2, selector);
        }
        const template = templateWrapper.children[0];
        const extraClass = this._resolvePossibleFunction(this._config.extraClass);
        if (extraClass) {
          template.classList.add(...extraClass.split(" "));
        }
        return template;
      }
      // Private
      _typeCheckConfig(config) {
        super._typeCheckConfig(config);
        this._checkContent(config.content);
      }
      _checkContent(arg) {
        for (const [selector, content] of Object.entries(arg)) {
          super._typeCheckConfig({
            selector,
            entry: content
          }, DefaultContentType2);
        }
      }
      _setContent(template, content, selector) {
        const templateElement = SelectorEngine2.findOne(selector, template);
        if (!templateElement) {
          return;
        }
        content = this._resolvePossibleFunction(content);
        if (!content) {
          templateElement.remove();
          return;
        }
        if (isElement$12(content)) {
          this._putElementInTemplate(getElement2(content), templateElement);
          return;
        }
        if (this._config.html) {
          templateElement.innerHTML = this._maybeSanitize(content);
          return;
        }
        templateElement.textContent = content;
      }
      _maybeSanitize(arg) {
        return this._config.sanitize ? sanitizeHtml2(arg, this._config.allowList, this._config.sanitizeFn) : arg;
      }
      _resolvePossibleFunction(arg) {
        return execute2(arg, [this]);
      }
      _putElementInTemplate(element, templateElement) {
        if (this._config.html) {
          templateElement.innerHTML = "";
          templateElement.append(element);
          return;
        }
        templateElement.textContent = element.textContent;
      }
    }
    const NAME$42 = "tooltip";
    const DISALLOWED_ATTRIBUTES2 = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
    const CLASS_NAME_FADE$22 = "fade";
    const CLASS_NAME_MODAL2 = "modal";
    const CLASS_NAME_SHOW$22 = "show";
    const SELECTOR_TOOLTIP_INNER2 = ".tooltip-inner";
    const SELECTOR_MODAL2 = `.${CLASS_NAME_MODAL2}`;
    const EVENT_MODAL_HIDE2 = "hide.bs.modal";
    const TRIGGER_HOVER2 = "hover";
    const TRIGGER_FOCUS2 = "focus";
    const TRIGGER_CLICK2 = "click";
    const TRIGGER_MANUAL2 = "manual";
    const EVENT_HIDE$22 = "hide";
    const EVENT_HIDDEN$22 = "hidden";
    const EVENT_SHOW$22 = "show";
    const EVENT_SHOWN$22 = "shown";
    const EVENT_INSERTED2 = "inserted";
    const EVENT_CLICK$12 = "click";
    const EVENT_FOCUSIN$12 = "focusin";
    const EVENT_FOCUSOUT$12 = "focusout";
    const EVENT_MOUSEENTER2 = "mouseenter";
    const EVENT_MOUSELEAVE2 = "mouseleave";
    const AttachmentMap2 = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: isRTL2() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: isRTL2() ? "right" : "left"
    };
    const Default$32 = {
      allowList: DefaultAllowlist2,
      animation: true,
      boundary: "clippingParents",
      container: false,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: false,
      offset: [0, 6],
      placement: "top",
      popperConfig: null,
      sanitize: true,
      sanitizeFn: null,
      selector: false,
      template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus"
    };
    const DefaultType$32 = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string"
    };
    class Tooltip2 extends BaseComponent2 {
      constructor(element, config) {
        if (typeof Popper2 === "undefined") {
          throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        }
        super(element, config);
        this._isEnabled = true;
        this._timeout = 0;
        this._isHovered = null;
        this._activeTrigger = {};
        this._popper = null;
        this._templateFactory = null;
        this._newContent = null;
        this.tip = null;
        this._setListeners();
        if (!this._config.selector) {
          this._fixTitle();
        }
      }
      // Getters
      static get Default() {
        return Default$32;
      }
      static get DefaultType() {
        return DefaultType$32;
      }
      static get NAME() {
        return NAME$42;
      }
      // Public
      enable() {
        this._isEnabled = true;
      }
      disable() {
        this._isEnabled = false;
      }
      toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
      toggle() {
        if (!this._isEnabled) {
          return;
        }
        this._activeTrigger.click = !this._activeTrigger.click;
        if (this._isShown()) {
          this._leave();
          return;
        }
        this._enter();
      }
      dispose() {
        clearTimeout(this._timeout);
        EventHandler2.off(this._element.closest(SELECTOR_MODAL2), EVENT_MODAL_HIDE2, this._hideModalHandler);
        if (this._element.getAttribute("data-bs-original-title")) {
          this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
        }
        this._disposePopper();
        super.dispose();
      }
      show() {
        if (this._element.style.display === "none") {
          throw new Error("Please use show on visible elements");
        }
        if (!(this._isWithContent() && this._isEnabled)) {
          return;
        }
        const showEvent = EventHandler2.trigger(this._element, this.constructor.eventName(EVENT_SHOW$22));
        const shadowRoot = findShadowRoot2(this._element);
        const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
        if (showEvent.defaultPrevented || !isInTheDom) {
          return;
        }
        this._disposePopper();
        const tip = this._getTipElement();
        this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
        const {
          container
        } = this._config;
        if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
          container.append(tip);
          EventHandler2.trigger(this._element, this.constructor.eventName(EVENT_INSERTED2));
        }
        this._popper = this._createPopper(tip);
        tip.classList.add(CLASS_NAME_SHOW$22);
        if ("ontouchstart" in document.documentElement) {
          for (const element of [].concat(...document.body.children)) {
            EventHandler2.on(element, "mouseover", noop2);
          }
        }
        const complete = () => {
          EventHandler2.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$22));
          if (this._isHovered === false) {
            this._leave();
          }
          this._isHovered = false;
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
      }
      hide() {
        if (!this._isShown()) {
          return;
        }
        const hideEvent = EventHandler2.trigger(this._element, this.constructor.eventName(EVENT_HIDE$22));
        if (hideEvent.defaultPrevented) {
          return;
        }
        const tip = this._getTipElement();
        tip.classList.remove(CLASS_NAME_SHOW$22);
        if ("ontouchstart" in document.documentElement) {
          for (const element of [].concat(...document.body.children)) {
            EventHandler2.off(element, "mouseover", noop2);
          }
        }
        this._activeTrigger[TRIGGER_CLICK2] = false;
        this._activeTrigger[TRIGGER_FOCUS2] = false;
        this._activeTrigger[TRIGGER_HOVER2] = false;
        this._isHovered = null;
        const complete = () => {
          if (this._isWithActiveTrigger()) {
            return;
          }
          if (!this._isHovered) {
            this._disposePopper();
          }
          this._element.removeAttribute("aria-describedby");
          EventHandler2.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$22));
        };
        this._queueCallback(complete, this.tip, this._isAnimated());
      }
      update() {
        if (this._popper) {
          this._popper.update();
        }
      }
      // Protected
      _isWithContent() {
        return Boolean(this._getTitle());
      }
      _getTipElement() {
        if (!this.tip) {
          this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
        }
        return this.tip;
      }
      _createTipElement(content) {
        const tip = this._getTemplateFactory(content).toHtml();
        if (!tip) {
          return null;
        }
        tip.classList.remove(CLASS_NAME_FADE$22, CLASS_NAME_SHOW$22);
        tip.classList.add(`bs-${this.constructor.NAME}-auto`);
        const tipId = getUID2(this.constructor.NAME).toString();
        tip.setAttribute("id", tipId);
        if (this._isAnimated()) {
          tip.classList.add(CLASS_NAME_FADE$22);
        }
        return tip;
      }
      setContent(content) {
        this._newContent = content;
        if (this._isShown()) {
          this._disposePopper();
          this.show();
        }
      }
      _getTemplateFactory(content) {
        if (this._templateFactory) {
          this._templateFactory.changeContent(content);
        } else {
          this._templateFactory = new TemplateFactory2({
            ...this._config,
            // the `content` var has to be after `this._config`
            // to override config.content in case of popover
            content,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
          });
        }
        return this._templateFactory;
      }
      _getContentForTemplate() {
        return {
          [SELECTOR_TOOLTIP_INNER2]: this._getTitle()
        };
      }
      _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
      }
      // Private
      _initializeOnDelegatedTarget(event) {
        return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
      }
      _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$22);
      }
      _isShown() {
        return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$22);
      }
      _createPopper(tip) {
        const placement = execute2(this._config.placement, [this, tip, this._element]);
        const attachment = AttachmentMap2[placement.toUpperCase()];
        return createPopper2(this._element, tip, this._getPopperConfig(attachment));
      }
      _getOffset() {
        const {
          offset: offset3
        } = this._config;
        if (typeof offset3 === "string") {
          return offset3.split(",").map((value) => Number.parseInt(value, 10));
        }
        if (typeof offset3 === "function") {
          return (popperData) => offset3(popperData, this._element);
        }
        return offset3;
      }
      _resolvePossibleFunction(arg) {
        return execute2(arg, [this._element]);
      }
      _getPopperConfig(attachment) {
        const defaultBsPopperConfig = {
          placement: attachment,
          modifiers: [{
            name: "flip",
            options: {
              fallbackPlacements: this._config.fallbackPlacements
            }
          }, {
            name: "offset",
            options: {
              offset: this._getOffset()
            }
          }, {
            name: "preventOverflow",
            options: {
              boundary: this._config.boundary
            }
          }, {
            name: "arrow",
            options: {
              element: `.${this.constructor.NAME}-arrow`
            }
          }, {
            name: "preSetPlacement",
            enabled: true,
            phase: "beforeMain",
            fn: (data2) => {
              this._getTipElement().setAttribute("data-popper-placement", data2.state.placement);
            }
          }]
        };
        return {
          ...defaultBsPopperConfig,
          ...execute2(this._config.popperConfig, [defaultBsPopperConfig])
        };
      }
      _setListeners() {
        const triggers = this._config.trigger.split(" ");
        for (const trigger of triggers) {
          if (trigger === "click") {
            EventHandler2.on(this._element, this.constructor.eventName(EVENT_CLICK$12), this._config.selector, (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context.toggle();
            });
          } else if (trigger !== TRIGGER_MANUAL2) {
            const eventIn = trigger === TRIGGER_HOVER2 ? this.constructor.eventName(EVENT_MOUSEENTER2) : this.constructor.eventName(EVENT_FOCUSIN$12);
            const eventOut = trigger === TRIGGER_HOVER2 ? this.constructor.eventName(EVENT_MOUSELEAVE2) : this.constructor.eventName(EVENT_FOCUSOUT$12);
            EventHandler2.on(this._element, eventIn, this._config.selector, (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS2 : TRIGGER_HOVER2] = true;
              context._enter();
            });
            EventHandler2.on(this._element, eventOut, this._config.selector, (event) => {
              const context = this._initializeOnDelegatedTarget(event);
              context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS2 : TRIGGER_HOVER2] = context._element.contains(event.relatedTarget);
              context._leave();
            });
          }
        }
        this._hideModalHandler = () => {
          if (this._element) {
            this.hide();
          }
        };
        EventHandler2.on(this._element.closest(SELECTOR_MODAL2), EVENT_MODAL_HIDE2, this._hideModalHandler);
      }
      _fixTitle() {
        const title = this._element.getAttribute("title");
        if (!title) {
          return;
        }
        if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
          this._element.setAttribute("aria-label", title);
        }
        this._element.setAttribute("data-bs-original-title", title);
        this._element.removeAttribute("title");
      }
      _enter() {
        if (this._isShown() || this._isHovered) {
          this._isHovered = true;
          return;
        }
        this._isHovered = true;
        this._setTimeout(() => {
          if (this._isHovered) {
            this.show();
          }
        }, this._config.delay.show);
      }
      _leave() {
        if (this._isWithActiveTrigger()) {
          return;
        }
        this._isHovered = false;
        this._setTimeout(() => {
          if (!this._isHovered) {
            this.hide();
          }
        }, this._config.delay.hide);
      }
      _setTimeout(handler, timeout) {
        clearTimeout(this._timeout);
        this._timeout = setTimeout(handler, timeout);
      }
      _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(true);
      }
      _getConfig(config) {
        const dataAttributes = Manipulator2.getDataAttributes(this._element);
        for (const dataAttribute of Object.keys(dataAttributes)) {
          if (DISALLOWED_ATTRIBUTES2.has(dataAttribute)) {
            delete dataAttributes[dataAttribute];
          }
        }
        config = {
          ...dataAttributes,
          ...typeof config === "object" && config ? config : {}
        };
        config = this._mergeConfigObj(config);
        config = this._configAfterMerge(config);
        this._typeCheckConfig(config);
        return config;
      }
      _configAfterMerge(config) {
        config.container = config.container === false ? document.body : getElement2(config.container);
        if (typeof config.delay === "number") {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }
        if (typeof config.title === "number") {
          config.title = config.title.toString();
        }
        if (typeof config.content === "number") {
          config.content = config.content.toString();
        }
        return config;
      }
      _getDelegateConfig() {
        const config = {};
        for (const [key, value] of Object.entries(this._config)) {
          if (this.constructor.Default[key] !== value) {
            config[key] = value;
          }
        }
        config.selector = false;
        config.trigger = "manual";
        return config;
      }
      _disposePopper() {
        if (this._popper) {
          this._popper.destroy();
          this._popper = null;
        }
        if (this.tip) {
          this.tip.remove();
          this.tip = null;
        }
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Tooltip2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (typeof data2[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config]();
        });
      }
    }
    defineJQueryPlugin2(Tooltip2);
    const NAME$32 = "popover";
    const SELECTOR_TITLE2 = ".popover-header";
    const SELECTOR_CONTENT2 = ".popover-body";
    const Default$22 = {
      ...Tooltip2.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click"
    };
    const DefaultType$22 = {
      ...Tooltip2.DefaultType,
      content: "(null|string|element|function)"
    };
    class Popover2 extends Tooltip2 {
      // Getters
      static get Default() {
        return Default$22;
      }
      static get DefaultType() {
        return DefaultType$22;
      }
      static get NAME() {
        return NAME$32;
      }
      // Overrides
      _isWithContent() {
        return this._getTitle() || this._getContent();
      }
      // Private
      _getContentForTemplate() {
        return {
          [SELECTOR_TITLE2]: this._getTitle(),
          [SELECTOR_CONTENT2]: this._getContent()
        };
      }
      _getContent() {
        return this._resolvePossibleFunction(this._config.content);
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Popover2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (typeof data2[config] === "undefined") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config]();
        });
      }
    }
    defineJQueryPlugin2(Popover2);
    const NAME$22 = "scrollspy";
    const DATA_KEY$22 = "bs.scrollspy";
    const EVENT_KEY$22 = `.${DATA_KEY$22}`;
    const DATA_API_KEY2 = ".data-api";
    const EVENT_ACTIVATE2 = `activate${EVENT_KEY$22}`;
    const EVENT_CLICK2 = `click${EVENT_KEY$22}`;
    const EVENT_LOAD_DATA_API$12 = `load${EVENT_KEY$22}${DATA_API_KEY2}`;
    const CLASS_NAME_DROPDOWN_ITEM2 = "dropdown-item";
    const CLASS_NAME_ACTIVE$12 = "active";
    const SELECTOR_DATA_SPY2 = '[data-bs-spy="scroll"]';
    const SELECTOR_TARGET_LINKS2 = "[href]";
    const SELECTOR_NAV_LIST_GROUP2 = ".nav, .list-group";
    const SELECTOR_NAV_LINKS2 = ".nav-link";
    const SELECTOR_NAV_ITEMS2 = ".nav-item";
    const SELECTOR_LIST_ITEMS2 = ".list-group-item";
    const SELECTOR_LINK_ITEMS2 = `${SELECTOR_NAV_LINKS2}, ${SELECTOR_NAV_ITEMS2} > ${SELECTOR_NAV_LINKS2}, ${SELECTOR_LIST_ITEMS2}`;
    const SELECTOR_DROPDOWN2 = ".dropdown";
    const SELECTOR_DROPDOWN_TOGGLE$12 = ".dropdown-toggle";
    const Default$12 = {
      offset: null,
      // TODO: v6 @deprecated, keep it for backwards compatibility reasons
      rootMargin: "0px 0px -25%",
      smoothScroll: false,
      target: null,
      threshold: [0.1, 0.5, 1]
    };
    const DefaultType$12 = {
      offset: "(number|null)",
      // TODO v6 @deprecated, keep it for backwards compatibility reasons
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array"
    };
    class ScrollSpy2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._targetLinks = /* @__PURE__ */ new Map();
        this._observableSections = /* @__PURE__ */ new Map();
        this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
        this._activeTarget = null;
        this._observer = null;
        this._previousScrollData = {
          visibleEntryTop: 0,
          parentScrollTop: 0
        };
        this.refresh();
      }
      // Getters
      static get Default() {
        return Default$12;
      }
      static get DefaultType() {
        return DefaultType$12;
      }
      static get NAME() {
        return NAME$22;
      }
      // Public
      refresh() {
        this._initializeTargetsAndObservables();
        this._maybeEnableSmoothScroll();
        if (this._observer) {
          this._observer.disconnect();
        } else {
          this._observer = this._getNewObserver();
        }
        for (const section of this._observableSections.values()) {
          this._observer.observe(section);
        }
      }
      dispose() {
        this._observer.disconnect();
        super.dispose();
      }
      // Private
      _configAfterMerge(config) {
        config.target = getElement2(config.target) || document.body;
        config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
        if (typeof config.threshold === "string") {
          config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
        }
        return config;
      }
      _maybeEnableSmoothScroll() {
        if (!this._config.smoothScroll) {
          return;
        }
        EventHandler2.off(this._config.target, EVENT_CLICK2);
        EventHandler2.on(this._config.target, EVENT_CLICK2, SELECTOR_TARGET_LINKS2, (event) => {
          const observableSection = this._observableSections.get(event.target.hash);
          if (observableSection) {
            event.preventDefault();
            const root2 = this._rootElement || window;
            const height2 = observableSection.offsetTop - this._element.offsetTop;
            if (root2.scrollTo) {
              root2.scrollTo({
                top: height2,
                behavior: "smooth"
              });
              return;
            }
            root2.scrollTop = height2;
          }
        });
      }
      _getNewObserver() {
        const options = {
          root: this._rootElement,
          threshold: this._config.threshold,
          rootMargin: this._config.rootMargin
        };
        return new IntersectionObserver((entries) => this._observerCallback(entries), options);
      }
      // The logic of selection
      _observerCallback(entries) {
        const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
        const activate = (entry) => {
          this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
          this._process(targetElement(entry));
        };
        const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
        const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = parentScrollTop;
        for (const entry of entries) {
          if (!entry.isIntersecting) {
            this._activeTarget = null;
            this._clearActiveClass(targetElement(entry));
            continue;
          }
          const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
          if (userScrollsDown && entryIsLowerThanPrevious) {
            activate(entry);
            if (!parentScrollTop) {
              return;
            }
            continue;
          }
          if (!userScrollsDown && !entryIsLowerThanPrevious) {
            activate(entry);
          }
        }
      }
      _initializeTargetsAndObservables() {
        this._targetLinks = /* @__PURE__ */ new Map();
        this._observableSections = /* @__PURE__ */ new Map();
        const targetLinks = SelectorEngine2.find(SELECTOR_TARGET_LINKS2, this._config.target);
        for (const anchor of targetLinks) {
          if (!anchor.hash || isDisabled2(anchor)) {
            continue;
          }
          const observableSection = SelectorEngine2.findOne(anchor.hash, this._element);
          if (isVisible2(observableSection)) {
            this._targetLinks.set(anchor.hash, anchor);
            this._observableSections.set(anchor.hash, observableSection);
          }
        }
      }
      _process(target) {
        if (this._activeTarget === target) {
          return;
        }
        this._clearActiveClass(this._config.target);
        this._activeTarget = target;
        target.classList.add(CLASS_NAME_ACTIVE$12);
        this._activateParents(target);
        EventHandler2.trigger(this._element, EVENT_ACTIVATE2, {
          relatedTarget: target
        });
      }
      _activateParents(target) {
        if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM2)) {
          SelectorEngine2.findOne(SELECTOR_DROPDOWN_TOGGLE$12, target.closest(SELECTOR_DROPDOWN2)).classList.add(CLASS_NAME_ACTIVE$12);
          return;
        }
        for (const listGroup of SelectorEngine2.parents(target, SELECTOR_NAV_LIST_GROUP2)) {
          for (const item2 of SelectorEngine2.prev(listGroup, SELECTOR_LINK_ITEMS2)) {
            item2.classList.add(CLASS_NAME_ACTIVE$12);
          }
        }
      }
      _clearActiveClass(parent) {
        parent.classList.remove(CLASS_NAME_ACTIVE$12);
        const activeNodes = SelectorEngine2.find(`${SELECTOR_TARGET_LINKS2}.${CLASS_NAME_ACTIVE$12}`, parent);
        for (const node of activeNodes) {
          node.classList.remove(CLASS_NAME_ACTIVE$12);
        }
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = ScrollSpy2.getOrCreateInstance(this, config);
          if (typeof config !== "string") {
            return;
          }
          if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config]();
        });
      }
    }
    EventHandler2.on(window, EVENT_LOAD_DATA_API$12, () => {
      for (const spy of SelectorEngine2.find(SELECTOR_DATA_SPY2)) {
        ScrollSpy2.getOrCreateInstance(spy);
      }
    });
    defineJQueryPlugin2(ScrollSpy2);
    const NAME$12 = "tab";
    const DATA_KEY$12 = "bs.tab";
    const EVENT_KEY$12 = `.${DATA_KEY$12}`;
    const EVENT_HIDE$12 = `hide${EVENT_KEY$12}`;
    const EVENT_HIDDEN$12 = `hidden${EVENT_KEY$12}`;
    const EVENT_SHOW$12 = `show${EVENT_KEY$12}`;
    const EVENT_SHOWN$12 = `shown${EVENT_KEY$12}`;
    const EVENT_CLICK_DATA_API2 = `click${EVENT_KEY$12}`;
    const EVENT_KEYDOWN2 = `keydown${EVENT_KEY$12}`;
    const EVENT_LOAD_DATA_API2 = `load${EVENT_KEY$12}`;
    const ARROW_LEFT_KEY2 = "ArrowLeft";
    const ARROW_RIGHT_KEY2 = "ArrowRight";
    const ARROW_UP_KEY2 = "ArrowUp";
    const ARROW_DOWN_KEY2 = "ArrowDown";
    const CLASS_NAME_ACTIVE2 = "active";
    const CLASS_NAME_FADE$12 = "fade";
    const CLASS_NAME_SHOW$12 = "show";
    const CLASS_DROPDOWN2 = "dropdown";
    const SELECTOR_DROPDOWN_TOGGLE2 = ".dropdown-toggle";
    const SELECTOR_DROPDOWN_MENU2 = ".dropdown-menu";
    const NOT_SELECTOR_DROPDOWN_TOGGLE2 = ":not(.dropdown-toggle)";
    const SELECTOR_TAB_PANEL2 = '.list-group, .nav, [role="tablist"]';
    const SELECTOR_OUTER2 = ".nav-item, .list-group-item";
    const SELECTOR_INNER2 = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE2}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE2}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE2}`;
    const SELECTOR_DATA_TOGGLE2 = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
    const SELECTOR_INNER_ELEM2 = `${SELECTOR_INNER2}, ${SELECTOR_DATA_TOGGLE2}`;
    const SELECTOR_DATA_TOGGLE_ACTIVE2 = `.${CLASS_NAME_ACTIVE2}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE2}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE2}[data-bs-toggle="list"]`;
    class Tab2 extends BaseComponent2 {
      constructor(element) {
        super(element);
        this._parent = this._element.closest(SELECTOR_TAB_PANEL2);
        if (!this._parent) {
          return;
        }
        this._setInitialAttributes(this._parent, this._getChildren());
        EventHandler2.on(this._element, EVENT_KEYDOWN2, (event) => this._keydown(event));
      }
      // Getters
      static get NAME() {
        return NAME$12;
      }
      // Public
      show() {
        const innerElem = this._element;
        if (this._elemIsActive(innerElem)) {
          return;
        }
        const active = this._getActiveElem();
        const hideEvent = active ? EventHandler2.trigger(active, EVENT_HIDE$12, {
          relatedTarget: innerElem
        }) : null;
        const showEvent = EventHandler2.trigger(innerElem, EVENT_SHOW$12, {
          relatedTarget: active
        });
        if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
          return;
        }
        this._deactivate(active, innerElem);
        this._activate(innerElem, active);
      }
      // Private
      _activate(element, relatedElem) {
        if (!element) {
          return;
        }
        element.classList.add(CLASS_NAME_ACTIVE2);
        this._activate(SelectorEngine2.getElementFromSelector(element));
        const complete = () => {
          if (element.getAttribute("role") !== "tab") {
            element.classList.add(CLASS_NAME_SHOW$12);
            return;
          }
          element.removeAttribute("tabindex");
          element.setAttribute("aria-selected", true);
          this._toggleDropDown(element, true);
          EventHandler2.trigger(element, EVENT_SHOWN$12, {
            relatedTarget: relatedElem
          });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$12));
      }
      _deactivate(element, relatedElem) {
        if (!element) {
          return;
        }
        element.classList.remove(CLASS_NAME_ACTIVE2);
        element.blur();
        this._deactivate(SelectorEngine2.getElementFromSelector(element));
        const complete = () => {
          if (element.getAttribute("role") !== "tab") {
            element.classList.remove(CLASS_NAME_SHOW$12);
            return;
          }
          element.setAttribute("aria-selected", false);
          element.setAttribute("tabindex", "-1");
          this._toggleDropDown(element, false);
          EventHandler2.trigger(element, EVENT_HIDDEN$12, {
            relatedTarget: relatedElem
          });
        };
        this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$12));
      }
      _keydown(event) {
        if (![ARROW_LEFT_KEY2, ARROW_RIGHT_KEY2, ARROW_UP_KEY2, ARROW_DOWN_KEY2].includes(event.key)) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        const isNext = [ARROW_RIGHT_KEY2, ARROW_DOWN_KEY2].includes(event.key);
        const nextActiveElement = getNextActiveElement2(this._getChildren().filter((element) => !isDisabled2(element)), event.target, isNext, true);
        if (nextActiveElement) {
          nextActiveElement.focus({
            preventScroll: true
          });
          Tab2.getOrCreateInstance(nextActiveElement).show();
        }
      }
      _getChildren() {
        return SelectorEngine2.find(SELECTOR_INNER_ELEM2, this._parent);
      }
      _getActiveElem() {
        return this._getChildren().find((child) => this._elemIsActive(child)) || null;
      }
      _setInitialAttributes(parent, children) {
        this._setAttributeIfNotExists(parent, "role", "tablist");
        for (const child of children) {
          this._setInitialAttributesOnChild(child);
        }
      }
      _setInitialAttributesOnChild(child) {
        child = this._getInnerElement(child);
        const isActive = this._elemIsActive(child);
        const outerElem = this._getOuterElement(child);
        child.setAttribute("aria-selected", isActive);
        if (outerElem !== child) {
          this._setAttributeIfNotExists(outerElem, "role", "presentation");
        }
        if (!isActive) {
          child.setAttribute("tabindex", "-1");
        }
        this._setAttributeIfNotExists(child, "role", "tab");
        this._setInitialAttributesOnTargetPanel(child);
      }
      _setInitialAttributesOnTargetPanel(child) {
        const target = SelectorEngine2.getElementFromSelector(child);
        if (!target) {
          return;
        }
        this._setAttributeIfNotExists(target, "role", "tabpanel");
        if (child.id) {
          this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
        }
      }
      _toggleDropDown(element, open) {
        const outerElem = this._getOuterElement(element);
        if (!outerElem.classList.contains(CLASS_DROPDOWN2)) {
          return;
        }
        const toggle = (selector, className) => {
          const element2 = SelectorEngine2.findOne(selector, outerElem);
          if (element2) {
            element2.classList.toggle(className, open);
          }
        };
        toggle(SELECTOR_DROPDOWN_TOGGLE2, CLASS_NAME_ACTIVE2);
        toggle(SELECTOR_DROPDOWN_MENU2, CLASS_NAME_SHOW$12);
        outerElem.setAttribute("aria-expanded", open);
      }
      _setAttributeIfNotExists(element, attribute, value) {
        if (!element.hasAttribute(attribute)) {
          element.setAttribute(attribute, value);
        }
      }
      _elemIsActive(elem) {
        return elem.classList.contains(CLASS_NAME_ACTIVE2);
      }
      // Try to get the inner element (usually the .nav-link)
      _getInnerElement(elem) {
        return elem.matches(SELECTOR_INNER_ELEM2) ? elem : SelectorEngine2.findOne(SELECTOR_INNER_ELEM2, elem);
      }
      // Try to get the outer element (usually the .nav-item)
      _getOuterElement(elem) {
        return elem.closest(SELECTOR_OUTER2) || elem;
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Tab2.getOrCreateInstance(this);
          if (typeof config !== "string") {
            return;
          }
          if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
            throw new TypeError(`No method named "${config}"`);
          }
          data2[config]();
        });
      }
    }
    EventHandler2.on(document, EVENT_CLICK_DATA_API2, SELECTOR_DATA_TOGGLE2, function(event) {
      if (["A", "AREA"].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled2(this)) {
        return;
      }
      Tab2.getOrCreateInstance(this).show();
    });
    EventHandler2.on(window, EVENT_LOAD_DATA_API2, () => {
      for (const element of SelectorEngine2.find(SELECTOR_DATA_TOGGLE_ACTIVE2)) {
        Tab2.getOrCreateInstance(element);
      }
    });
    defineJQueryPlugin2(Tab2);
    const NAME2 = "toast";
    const DATA_KEY2 = "bs.toast";
    const EVENT_KEY2 = `.${DATA_KEY2}`;
    const EVENT_MOUSEOVER2 = `mouseover${EVENT_KEY2}`;
    const EVENT_MOUSEOUT2 = `mouseout${EVENT_KEY2}`;
    const EVENT_FOCUSIN2 = `focusin${EVENT_KEY2}`;
    const EVENT_FOCUSOUT2 = `focusout${EVENT_KEY2}`;
    const EVENT_HIDE2 = `hide${EVENT_KEY2}`;
    const EVENT_HIDDEN2 = `hidden${EVENT_KEY2}`;
    const EVENT_SHOW2 = `show${EVENT_KEY2}`;
    const EVENT_SHOWN2 = `shown${EVENT_KEY2}`;
    const CLASS_NAME_FADE2 = "fade";
    const CLASS_NAME_HIDE2 = "hide";
    const CLASS_NAME_SHOW2 = "show";
    const CLASS_NAME_SHOWING2 = "showing";
    const DefaultType2 = {
      animation: "boolean",
      autohide: "boolean",
      delay: "number"
    };
    const Default2 = {
      animation: true,
      autohide: true,
      delay: 5e3
    };
    class Toast2 extends BaseComponent2 {
      constructor(element, config) {
        super(element, config);
        this._timeout = null;
        this._hasMouseInteraction = false;
        this._hasKeyboardInteraction = false;
        this._setListeners();
      }
      // Getters
      static get Default() {
        return Default2;
      }
      static get DefaultType() {
        return DefaultType2;
      }
      static get NAME() {
        return NAME2;
      }
      // Public
      show() {
        const showEvent = EventHandler2.trigger(this._element, EVENT_SHOW2);
        if (showEvent.defaultPrevented) {
          return;
        }
        this._clearTimeout();
        if (this._config.animation) {
          this._element.classList.add(CLASS_NAME_FADE2);
        }
        const complete = () => {
          this._element.classList.remove(CLASS_NAME_SHOWING2);
          EventHandler2.trigger(this._element, EVENT_SHOWN2);
          this._maybeScheduleHide();
        };
        this._element.classList.remove(CLASS_NAME_HIDE2);
        reflow2(this._element);
        this._element.classList.add(CLASS_NAME_SHOW2, CLASS_NAME_SHOWING2);
        this._queueCallback(complete, this._element, this._config.animation);
      }
      hide() {
        if (!this.isShown()) {
          return;
        }
        const hideEvent = EventHandler2.trigger(this._element, EVENT_HIDE2);
        if (hideEvent.defaultPrevented) {
          return;
        }
        const complete = () => {
          this._element.classList.add(CLASS_NAME_HIDE2);
          this._element.classList.remove(CLASS_NAME_SHOWING2, CLASS_NAME_SHOW2);
          EventHandler2.trigger(this._element, EVENT_HIDDEN2);
        };
        this._element.classList.add(CLASS_NAME_SHOWING2);
        this._queueCallback(complete, this._element, this._config.animation);
      }
      dispose() {
        this._clearTimeout();
        if (this.isShown()) {
          this._element.classList.remove(CLASS_NAME_SHOW2);
        }
        super.dispose();
      }
      isShown() {
        return this._element.classList.contains(CLASS_NAME_SHOW2);
      }
      // Private
      _maybeScheduleHide() {
        if (!this._config.autohide) {
          return;
        }
        if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
          return;
        }
        this._timeout = setTimeout(() => {
          this.hide();
        }, this._config.delay);
      }
      _onInteraction(event, isInteracting) {
        switch (event.type) {
          case "mouseover":
          case "mouseout": {
            this._hasMouseInteraction = isInteracting;
            break;
          }
          case "focusin":
          case "focusout": {
            this._hasKeyboardInteraction = isInteracting;
            break;
          }
        }
        if (isInteracting) {
          this._clearTimeout();
          return;
        }
        const nextElement = event.relatedTarget;
        if (this._element === nextElement || this._element.contains(nextElement)) {
          return;
        }
        this._maybeScheduleHide();
      }
      _setListeners() {
        EventHandler2.on(this._element, EVENT_MOUSEOVER2, (event) => this._onInteraction(event, true));
        EventHandler2.on(this._element, EVENT_MOUSEOUT2, (event) => this._onInteraction(event, false));
        EventHandler2.on(this._element, EVENT_FOCUSIN2, (event) => this._onInteraction(event, true));
        EventHandler2.on(this._element, EVENT_FOCUSOUT2, (event) => this._onInteraction(event, false));
      }
      _clearTimeout() {
        clearTimeout(this._timeout);
        this._timeout = null;
      }
      // Static
      static jQueryInterface(config) {
        return this.each(function() {
          const data2 = Toast2.getOrCreateInstance(this, config);
          if (typeof config === "string") {
            if (typeof data2[config] === "undefined") {
              throw new TypeError(`No method named "${config}"`);
            }
            data2[config](this);
          }
        });
      }
    }
    enableDismissTrigger2(Toast2);
    defineJQueryPlugin2(Toast2);
    const index_umd = {
      Alert: Alert2,
      Button: Button2,
      Carousel: Carousel2,
      Collapse: Collapse2,
      Dropdown: Dropdown2,
      Modal: Modal2,
      Offcanvas: Offcanvas2,
      Popover: Popover2,
      ScrollSpy: ScrollSpy2,
      Tab: Tab2,
      Toast: Toast2,
      Tooltip: Tooltip2
    };
    return index_umd;
  });
})(bootstrap_bundle);
const bootstrap = bootstrap_bundleExports;
tinymce.IconManager.add("default", {
  icons: {
    "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
    "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
    "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
    "addtag": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
    "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
    "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
    "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
    "bold": '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
    "bookmark": '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
    "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
    "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
    "brightness": '<svg width="24" height="24"><path d="M12 17c.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7v-1c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3Zm0-10a1 1 0 0 1-.7-.3A1 1 0 0 1 11 6V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v1c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3Zm7 4c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-1a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1ZM7 12c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H5a1 1 0 0 1-.7-.3A1 1 0 0 1 4 12c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h1c.3 0 .5.1.7.3.2.2.3.4.3.7Zm10 3.5.7.8c.2.1.3.4.3.6 0 .3-.1.6-.3.8a1 1 0 0 1-.8.3 1 1 0 0 1-.6-.3l-.8-.7a1 1 0 0 1-.3-.8c0-.2.1-.5.3-.7a1 1 0 0 1 1.4 0Zm-10-7-.7-.8a1 1 0 0 1-.3-.6c0-.3.1-.6.3-.8.2-.2.5-.3.8-.3.2 0 .5.1.7.3l.7.7c.2.2.3.5.3.8 0 .2-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.8-.3Zm10 0a1 1 0 0 1-.8.3 1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.6.3-.8l.8-.7c.1-.2.4-.3.6-.3.3 0 .6.1.8.3.2.2.3.5.3.8 0 .2-.1.5-.3.7l-.7.7Zm-10 7c.2-.2.5-.3.8-.3.2 0 .5.1.7.3a1 1 0 0 1 0 1.4l-.8.8a1 1 0 0 1-.6.3 1 1 0 0 1-.8-.3 1 1 0 0 1-.3-.8c0-.2.1-.5.3-.6l.7-.8ZM12 8a4 4 0 0 1 3.7 2.4 4 4 0 0 1 0 3.2A4 4 0 0 1 12 16a4 4 0 0 1-3.7-2.4 4 4 0 0 1 0-3.2A4 4 0 0 1 12 8Zm0 6.5c.7 0 1.3-.2 1.8-.7.5-.5.7-1.1.7-1.8s-.2-1.3-.7-1.8c-.5-.5-1.1-.7-1.8-.7s-1.3.2-1.8.7c-.5.5-.7 1.1-.7 1.8s.2 1.3.7 1.8c.5.5 1.1.7 1.8.7Z" fill-rule="evenodd"/></svg>',
    "browse": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
    "cancel": '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
    "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
    "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
    "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
    "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
    "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
    "checklist": '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
    "checkmark": '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
    "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
    "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
    "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
    "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
    "close": '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
    "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
    "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
    "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
    "color-swatch-remove-color": '<svg width="24" height="24"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
    "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
    "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
    "comment": '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
    "contrast": '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-6 8a6 6 0 0 0 6 6V6a6 6 0 0 0-6 6Z" fill-rule="evenodd"/></svg>',
    "copy": '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
    "crop": '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
    "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
    "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
    "cut": '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
    "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "drag": '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
    "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
    "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
    "duplicate": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
    "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
    "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
    "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
    "embed": '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
    "emoji": '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
    "export": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
    "fill": '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
    "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
    "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
    "footnote": '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
    "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
    "format": '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
    "fullscreen": '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
    "gallery": '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
    "gamma": '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm6.5 11.8V14L9.2 8.7a5.1 5.1 0 0 0-.4-.8l-.1-.2H8v-1l.3-.1.3-.1h.7a1 1 0 0 1 .6.5l.1.3a8.5 8.5 0 0 1 .3.6l1.9 4.6 2-5.2a1 1 0 0 1 1-.6.5.5 0 0 1 .5.6L13 14v2.8a.7.7 0 0 1-1.4 0Z" fill-rule="nonzero"/></svg>',
    "help": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
    "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
    "home": '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
    "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
    "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "image": '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
    "indent": '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    "info": '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
    "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
    "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
    "invert": '<svg width="24" height="24"><path d="M18 19.3 16.5 18a5.8 5.8 0 0 1-3.1 1.9 6.1 6.1 0 0 1-5.5-1.6A5.8 5.8 0 0 1 6 14v-.3l.1-1.2A13.9 13.9 0 0 1 7.7 9l-3-3 .7-.8 2.8 2.9 9 8.9 1.5 1.6-.7.6Zm0-5.5v.3l-.1 1.1-.4 1-1.2-1.2a4.3 4.3 0 0 0 .2-1v-.2c0-.4 0-.8-.2-1.3l-.5-1.4a14.8 14.8 0 0 0-3-4.2L12 6a26.1 26.1 0 0 0-2.2 2.5l-1-1a20.9 20.9 0 0 1 2.9-3.3L12 4l1 .8a22.2 22.2 0 0 1 4 5.4c.6 1.2 1 2.4 1 3.6Z" fill-rule="evenodd"/></svg>',
    "italic": '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
    "language": '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
    "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
    "line": '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
    "link": '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
    "list-bull-circle": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M11 16a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 26a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6ZM11 36a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 1a3 3 0 1 1 0-6 3 3 0 0 1 0 6Z" fill-rule="nonzero"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-default": '<svg width="48" height="48"><g fill-rule="evenodd"><circle cx="11" cy="14" r="3"/><circle cx="11" cy="24" r="3"/><circle cx="11" cy="34" r="3"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-bull-square": '<svg width="48" height="48"><g fill-rule="evenodd"><path d="M8 11h6v6H8zM8 21h6v6H8zM8 31h6v6H8z"/><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/></g></svg>',
    "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
    "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
    "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
    "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
    "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
    "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
    "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
    "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
    "lock": '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
    "ltr": '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
    "minus": '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
    "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
    "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
    "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
    "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "notice": '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
    "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
    "orientation": '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
    "outdent": '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
    "paragraph": '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
    "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
    "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
    "paste": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
    "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
    "plus": '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
    "preferences": '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
    "preview": '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
    "print": '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
    "quote": '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
    "redo": '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
    "reload": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
    "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
    "remove": '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
    "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
    "resize": '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
    "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
    "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
    "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
    "rtl": '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
    "save": '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
    "search": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
    "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
    "selected": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
    "settings": '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
    "sharpen": '<svg width="24" height="24"><path d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z" fill-rule="evenodd"/></svg>',
    "sourcecode": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
    "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
    "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
    "subscript": '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
    "superscript": '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
    "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
    "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
    "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
    "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
    "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
    "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
    "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
    "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
    "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
    "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
    "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
    "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
    "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
    "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
    "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
    "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
    "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
    "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
    "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
    "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
    "table": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
    "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
    "template": '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
    "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
    "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path id="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
    "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
    "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
    "toc": '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "translate": '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
    "typography": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
    "underline": '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
    "undo": '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
    "unlink": '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
    "unlock": '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
    "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
    "unselected": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
    "upload": '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
    "user": '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
    "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
    "visualblocks": '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
    "visualchars": '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
    "warning": '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
    "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
    "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
  }
});
(function() {
  const getPrototypeOf$2 = Object.getPrototypeOf;
  const hasProto = (v, constructor, predicate) => {
    var _a;
    if (predicate(v, constructor.prototype)) {
      return true;
    } else {
      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    }
  };
  const typeOf = (x) => {
    const t2 = typeof x;
    if (x === null) {
      return "null";
    } else if (t2 === "object" && Array.isArray(x)) {
      return "array";
    } else if (t2 === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
      return "string";
    } else {
      return t2;
    }
  };
  const isType$1 = (type2) => (value2) => typeOf(value2) === type2;
  const isSimpleType = (type2) => (value2) => typeof value2 === type2;
  const eq$1 = (t2) => (a) => t2 === a;
  const is$2 = (value2, constructor) => isObject2(value2) && hasProto(value2, constructor, (o, proto) => getPrototypeOf$2(o) === proto);
  const isString2 = isType$1("string");
  const isObject2 = isType$1("object");
  const isPlainObject2 = (value2) => is$2(value2, Object);
  const isArray2 = isType$1("array");
  const isNull2 = eq$1(null);
  const isBoolean2 = isSimpleType("boolean");
  const isUndefined2 = eq$1(void 0);
  const isNullable = (a) => a === null || a === void 0;
  const isNonNullable = (a) => !isNullable(a);
  const isFunction2 = isSimpleType("function");
  const isNumber2 = isSimpleType("number");
  const isArrayOf = (value2, pred) => {
    if (isArray2(value2)) {
      for (let i = 0, len = value2.length; i < len; ++i) {
        if (!pred(value2[i])) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  const noop2 = () => {
  };
  const noarg = (f2) => () => f2();
  const compose = (fa, fb) => {
    return (...args) => {
      return fa(fb.apply(null, args));
    };
  };
  const compose1 = (fbc, fab) => (a) => fbc(fab(a));
  const constant$1 = (value2) => {
    return () => {
      return value2;
    };
  };
  const identity = (x) => {
    return x;
  };
  const tripleEquals = (a, b2) => {
    return a === b2;
  };
  function curry(fn3, ...initialArgs) {
    return (...restArgs) => {
      const all3 = initialArgs.concat(restArgs);
      return fn3.apply(null, all3);
    };
  }
  const not = (f2) => (t2) => !f2(t2);
  const die = (msg) => {
    return () => {
      throw new Error(msg);
    };
  };
  const apply$1 = (f2) => {
    return f2();
  };
  const never = constant$1(false);
  const always = constant$1(true);
  class Optional {
    constructor(tag, value2) {
      this.tag = tag;
      this.value = value2;
    }
    static some(value2) {
      return new Optional(true, value2);
    }
    static none() {
      return Optional.singletonNone;
    }
    fold(onNone, onSome) {
      if (this.tag) {
        return onSome(this.value);
      } else {
        return onNone();
      }
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(mapper) {
      if (this.tag) {
        return Optional.some(mapper(this.value));
      } else {
        return Optional.none();
      }
    }
    bind(binder2) {
      if (this.tag) {
        return binder2(this.value);
      } else {
        return Optional.none();
      }
    }
    exists(predicate) {
      return this.tag && predicate(this.value);
    }
    forall(predicate) {
      return !this.tag || predicate(this.value);
    }
    filter(predicate) {
      if (!this.tag || predicate(this.value)) {
        return this;
      } else {
        return Optional.none();
      }
    }
    getOr(replacement) {
      return this.tag ? this.value : replacement;
    }
    or(replacement) {
      return this.tag ? this : replacement;
    }
    getOrThunk(thunk2) {
      return this.tag ? this.value : thunk2();
    }
    orThunk(thunk2) {
      return this.tag ? this : thunk2();
    }
    getOrDie(message) {
      if (!this.tag) {
        throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
      } else {
        return this.value;
      }
    }
    static from(value2) {
      return isNonNullable(value2) ? Optional.some(value2) : Optional.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(worker) {
      if (this.tag) {
        worker(this.value);
      }
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Optional.singletonNone = new Optional(false);
  const nativeSlice = Array.prototype.slice;
  const nativeIndexOf = Array.prototype.indexOf;
  const nativePush = Array.prototype.push;
  const rawIndexOf = (ts, t2) => nativeIndexOf.call(ts, t2);
  const indexOf = (xs, x) => {
    const r2 = rawIndexOf(xs, x);
    return r2 === -1 ? Optional.none() : Optional.some(r2);
  };
  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
  const exists = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return true;
      }
    }
    return false;
  };
  const range$2 = (num, f2) => {
    const r2 = [];
    for (let i = 0; i < num; i++) {
      r2.push(f2(i));
    }
    return r2;
  };
  const chunk$1 = (array, size) => {
    const r2 = [];
    for (let i = 0; i < array.length; i += size) {
      const s = nativeSlice.call(array, i, i + size);
      r2.push(s);
    }
    return r2;
  };
  const map$2 = (xs, f2) => {
    const len = xs.length;
    const r2 = new Array(len);
    for (let i = 0; i < len; i++) {
      const x = xs[i];
      r2[i] = f2(x, i);
    }
    return r2;
  };
  const each$1 = (xs, f2) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      f2(x, i);
    }
  };
  const eachr = (xs, f2) => {
    for (let i = xs.length - 1; i >= 0; i--) {
      const x = xs[i];
      f2(x, i);
    }
  };
  const partition$3 = (xs, pred) => {
    const pass = [];
    const fail = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      const arr = pred(x, i) ? pass : fail;
      arr.push(x);
    }
    return {
      pass,
      fail
    };
  };
  const filter$2 = (xs, pred) => {
    const r2 = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        r2.push(x);
      }
    }
    return r2;
  };
  const foldr = (xs, f2, acc) => {
    eachr(xs, (x, i) => {
      acc = f2(acc, x, i);
    });
    return acc;
  };
  const foldl = (xs, f2, acc) => {
    each$1(xs, (x, i) => {
      acc = f2(acc, x, i);
    });
    return acc;
  };
  const findUntil = (xs, pred, until) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(x);
      } else if (until(x, i)) {
        break;
      }
    }
    return Optional.none();
  };
  const find$5 = (xs, pred) => {
    return findUntil(xs, pred, never);
  };
  const findIndex$1 = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(i);
      }
    }
    return Optional.none();
  };
  const flatten = (xs) => {
    const r2 = [];
    for (let i = 0, len = xs.length; i < len; ++i) {
      if (!isArray2(xs[i])) {
        throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
      }
      nativePush.apply(r2, xs[i]);
    }
    return r2;
  };
  const bind$3 = (xs, f2) => flatten(map$2(xs, f2));
  const forall = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; ++i) {
      const x = xs[i];
      if (pred(x, i) !== true) {
        return false;
      }
    }
    return true;
  };
  const reverse = (xs) => {
    const r2 = nativeSlice.call(xs, 0);
    r2.reverse();
    return r2;
  };
  const difference = (a1, a2) => filter$2(a1, (x) => !contains$2(a2, x));
  const mapToObject = (xs, f2) => {
    const r2 = {};
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      r2[String(x)] = f2(x, i);
    }
    return r2;
  };
  const pure$2 = (x) => [x];
  const sort = (xs, comparator) => {
    const copy = nativeSlice.call(xs, 0);
    copy.sort(comparator);
    return copy;
  };
  const get$h = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
  const head = (xs) => get$h(xs, 0);
  const last$1 = (xs) => get$h(xs, xs.length - 1);
  const from = isFunction2(Array.from) ? Array.from : (x) => nativeSlice.call(x);
  const findMap = (arr, f2) => {
    for (let i = 0; i < arr.length; i++) {
      const r2 = f2(arr[i], i);
      if (r2.isSome()) {
        return r2;
      }
    }
    return Optional.none();
  };
  const keys = Object.keys;
  const hasOwnProperty$1 = Object.hasOwnProperty;
  const each = (obj, f2) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
      const i = props[k];
      const x = obj[i];
      f2(x, i);
    }
  };
  const map$1 = (obj, f2) => {
    return tupleMap(obj, (x, i) => ({
      k: i,
      v: f2(x, i)
    }));
  };
  const tupleMap = (obj, f2) => {
    const r2 = {};
    each(obj, (x, i) => {
      const tuple = f2(x, i);
      r2[tuple.k] = tuple.v;
    });
    return r2;
  };
  const objAcc = (r2) => (x, i) => {
    r2[i] = x;
  };
  const internalFilter = (obj, pred, onTrue, onFalse) => {
    each(obj, (x, i) => {
      (pred(x, i) ? onTrue : onFalse)(x, i);
    });
  };
  const bifilter = (obj, pred) => {
    const t2 = {};
    const f2 = {};
    internalFilter(obj, pred, objAcc(t2), objAcc(f2));
    return {
      t: t2,
      f: f2
    };
  };
  const filter$1 = (obj, pred) => {
    const t2 = {};
    internalFilter(obj, pred, objAcc(t2), noop2);
    return t2;
  };
  const mapToArray = (obj, f2) => {
    const r2 = [];
    each(obj, (value2, name3) => {
      r2.push(f2(value2, name3));
    });
    return r2;
  };
  const find$4 = (obj, pred) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
      const i = props[k];
      const x = obj[i];
      if (pred(x, i, obj)) {
        return Optional.some(x);
      }
    }
    return Optional.none();
  };
  const values = (obj) => {
    return mapToArray(obj, identity);
  };
  const get$g = (obj, key) => {
    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
  };
  const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);
  const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== void 0 && obj[key] !== null;
  const is$1 = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left3) => comparator(left3, rhs));
  const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());
  const cat = (arr) => {
    const r2 = [];
    const push = (x) => {
      r2.push(x);
    };
    for (let i = 0; i < arr.length; i++) {
      arr[i].each(push);
    }
    return r2;
  };
  const sequence = (arr) => {
    const r2 = [];
    for (let i = 0; i < arr.length; i++) {
      const x = arr[i];
      if (x.isSome()) {
        r2.push(x.getOrDie());
      } else {
        return Optional.none();
      }
    }
    return Optional.some(r2);
  };
  const lift2 = (oa, ob, f2) => oa.isSome() && ob.isSome() ? Optional.some(f2(oa.getOrDie(), ob.getOrDie())) : Optional.none();
  const lift3 = (oa, ob, oc, f2) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f2(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();
  const mapFrom = (a, f2) => a !== void 0 && a !== null ? Optional.some(f2(a)) : Optional.none();
  const someIf = (b2, a) => b2 ? Optional.some(a) : Optional.none();
  const addToEnd = (str, suffix2) => {
    return str + suffix2;
  };
  const removeFromStart = (str, numChars) => {
    return str.substring(numChars);
  };
  const checkRange = (str, substr, start2) => substr === "" || str.length >= substr.length && str.substr(start2, start2 + substr.length) === substr;
  const removeLeading = (str, prefix2) => {
    return startsWith(str, prefix2) ? removeFromStart(str, prefix2.length) : str;
  };
  const ensureTrailing = (str, suffix2) => {
    return endsWith2(str, suffix2) ? str : addToEnd(str, suffix2);
  };
  const contains$1 = (str, substr, start2 = 0, end2) => {
    const idx = str.indexOf(substr, start2);
    if (idx !== -1) {
      return isUndefined2(end2) ? true : idx + substr.length <= end2;
    } else {
      return false;
    }
  };
  const startsWith = (str, prefix2) => {
    return checkRange(str, prefix2, 0);
  };
  const endsWith2 = (str, suffix2) => {
    return checkRange(str, suffix2, str.length - suffix2.length);
  };
  const blank = (r2) => (s) => s.replace(r2, "");
  const trim$12 = blank(/^\s+|\s+$/g);
  const isNotEmpty = (s) => s.length > 0;
  const isEmpty2 = (s) => !isNotEmpty(s);
  const isSupported$1 = (dom2) => dom2.style !== void 0 && isFunction2(dom2.style.getPropertyValue);
  const fromHtml$2 = (html2, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html2;
    if (!div.hasChildNodes() || div.childNodes.length > 1) {
      const message = "HTML does not have a single root node";
      console.error(message, html2);
      throw new Error(message);
    }
    return fromDom(div.childNodes[0]);
  };
  const fromTag = (tag, scope) => {
    const doc = scope || document;
    const node = doc.createElement(tag);
    return fromDom(node);
  };
  const fromText = (text3, scope) => {
    const doc = scope || document;
    const node = doc.createTextNode(text3);
    return fromDom(node);
  };
  const fromDom = (node) => {
    if (node === null || node === void 0) {
      throw new Error("Node cannot be null or undefined");
    }
    return { dom: node };
  };
  const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);
  const SugarElement = {
    fromHtml: fromHtml$2,
    fromTag,
    fromText,
    fromDom,
    fromPoint
  };
  const Global = typeof window !== "undefined" ? window : Function("return this;")();
  const path$1 = (parts2, scope) => {
    let o = scope !== void 0 && scope !== null ? scope : Global;
    for (let i = 0; i < parts2.length && o !== void 0 && o !== null; ++i) {
      o = o[parts2[i]];
    }
    return o;
  };
  const resolve = (p, scope) => {
    const parts2 = p.split(".");
    return path$1(parts2, scope);
  };
  const unsafe = (name3, scope) => {
    return resolve(name3, scope);
  };
  const getOrDie$1 = (name3, scope) => {
    const actual = unsafe(name3, scope);
    if (actual === void 0 || actual === null) {
      throw new Error(name3 + " not available on this browser");
    }
    return actual;
  };
  const getPrototypeOf$1 = Object.getPrototypeOf;
  const sandHTMLElement = (scope) => {
    return getOrDie$1("HTMLElement", scope);
  };
  const isPrototypeOf = (x) => {
    const scope = resolve("ownerDocument.defaultView", x);
    return isObject2(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf$1(x).constructor.name));
  };
  const DOCUMENT = 9;
  const DOCUMENT_FRAGMENT = 11;
  const ELEMENT = 1;
  const TEXT = 3;
  const name$3 = (element2) => {
    const r2 = element2.dom.nodeName;
    return r2.toLowerCase();
  };
  const type$1 = (element2) => element2.dom.nodeType;
  const isType = (t2) => (element2) => type$1(element2) === t2;
  const isHTMLElement2 = (element2) => isElement$12(element2) && isPrototypeOf(element2.dom);
  const isElement$12 = isType(ELEMENT);
  const isText = isType(TEXT);
  const isDocument = isType(DOCUMENT);
  const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
  const isTag = (tag) => (e) => isElement$12(e) && name$3(e) === tag;
  const is = (element2, selector) => {
    const dom2 = element2.dom;
    if (dom2.nodeType !== ELEMENT) {
      return false;
    } else {
      const elem = dom2;
      if (elem.matches !== void 0) {
        return elem.matches(selector);
      } else if (elem.msMatchesSelector !== void 0) {
        return elem.msMatchesSelector(selector);
      } else if (elem.webkitMatchesSelector !== void 0) {
        return elem.webkitMatchesSelector(selector);
      } else if (elem.mozMatchesSelector !== void 0) {
        return elem.mozMatchesSelector(selector);
      } else {
        throw new Error("Browser lacks native selectors");
      }
    }
  };
  const bypassSelector = (dom2) => dom2.nodeType !== ELEMENT && dom2.nodeType !== DOCUMENT && dom2.nodeType !== DOCUMENT_FRAGMENT || dom2.childElementCount === 0;
  const all$3 = (selector, scope) => {
    const base2 = scope === void 0 ? document : scope.dom;
    return bypassSelector(base2) ? [] : map$2(base2.querySelectorAll(selector), SugarElement.fromDom);
  };
  const one = (selector, scope) => {
    const base2 = scope === void 0 ? document : scope.dom;
    return bypassSelector(base2) ? Optional.none() : Optional.from(base2.querySelector(selector)).map(SugarElement.fromDom);
  };
  const eq = (e1, e2) => e1.dom === e2.dom;
  const contains2 = (e1, e2) => {
    const d1 = e1.dom;
    const d2 = e2.dom;
    return d1 === d2 ? false : d1.contains(d2);
  };
  const owner$4 = (element2) => SugarElement.fromDom(element2.dom.ownerDocument);
  const documentOrOwner = (dos) => isDocument(dos) ? dos : owner$4(dos);
  const documentElement = (element2) => SugarElement.fromDom(documentOrOwner(element2).dom.documentElement);
  const defaultView = (element2) => SugarElement.fromDom(documentOrOwner(element2).dom.defaultView);
  const parent = (element2) => Optional.from(element2.dom.parentNode).map(SugarElement.fromDom);
  const parentElement = (element2) => Optional.from(element2.dom.parentElement).map(SugarElement.fromDom);
  const parents = (element2, isRoot) => {
    const stop2 = isFunction2(isRoot) ? isRoot : never;
    let dom2 = element2.dom;
    const ret = [];
    while (dom2.parentNode !== null && dom2.parentNode !== void 0) {
      const rawParent = dom2.parentNode;
      const p = SugarElement.fromDom(rawParent);
      ret.push(p);
      if (stop2(p) === true) {
        break;
      } else {
        dom2 = rawParent;
      }
    }
    return ret;
  };
  const offsetParent = (element2) => Optional.from(element2.dom.offsetParent).map(SugarElement.fromDom);
  const nextSibling = (element2) => Optional.from(element2.dom.nextSibling).map(SugarElement.fromDom);
  const children = (element2) => map$2(element2.dom.childNodes, SugarElement.fromDom);
  const child$2 = (element2, index) => {
    const cs = element2.dom.childNodes;
    return Optional.from(cs[index]).map(SugarElement.fromDom);
  };
  const firstChild = (element2) => child$2(element2, 0);
  const spot = (element2, offset3) => ({
    element: element2,
    offset: offset3
  });
  const leaf = (element2, offset3) => {
    const cs = children(element2);
    return cs.length > 0 && offset3 < cs.length ? spot(cs[offset3], 0) : spot(element2, offset3);
  };
  const isShadowRoot2 = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
  const supported2 = isFunction2(Element.prototype.attachShadow) && isFunction2(Node.prototype.getRootNode);
  const isSupported = constant$1(supported2);
  const getRootNode2 = supported2 ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
  const getContentContainer = (dos) => isShadowRoot2(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);
  const isInShadowRoot = (e) => getShadowRoot(e).isSome();
  const getShadowRoot = (e) => {
    const r2 = getRootNode2(e);
    return isShadowRoot2(r2) ? Optional.some(r2) : Optional.none();
  };
  const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
  const getOriginalEventTarget = (event) => {
    if (isSupported() && isNonNullable(event.target)) {
      const el = SugarElement.fromDom(event.target);
      if (isElement$12(el) && isOpenShadowHost(el)) {
        if (event.composed && event.composedPath) {
          const composedPath = event.composedPath();
          if (composedPath) {
            return head(composedPath);
          }
        }
      }
    }
    return Optional.from(event.target);
  };
  const isOpenShadowHost = (element2) => isNonNullable(element2.dom.shadowRoot);
  const inBody = (element2) => {
    const dom2 = isText(element2) ? element2.dom.parentNode : element2.dom;
    if (dom2 === void 0 || dom2 === null || dom2.ownerDocument === null) {
      return false;
    }
    const doc = dom2.ownerDocument;
    return getShadowRoot(SugarElement.fromDom(dom2)).fold(() => doc.body.contains(dom2), compose1(inBody, getShadowHost));
  };
  const body = () => getBody(SugarElement.fromDom(document));
  const getBody = (doc) => {
    const b2 = doc.dom.body;
    if (b2 === null || b2 === void 0) {
      throw new Error("Body is not available yet");
    }
    return SugarElement.fromDom(b2);
  };
  const rawSet = (dom2, key, value2) => {
    if (isString2(value2) || isBoolean2(value2) || isNumber2(value2)) {
      dom2.setAttribute(key, value2 + "");
    } else {
      console.error("Invalid call to Attribute.set. Key ", key, ":: Value ", value2, ":: Element ", dom2);
      throw new Error("Attribute value was not simple");
    }
  };
  const set$9 = (element2, key, value2) => {
    rawSet(element2.dom, key, value2);
  };
  const setAll$1 = (element2, attrs) => {
    const dom2 = element2.dom;
    each(attrs, (v, k) => {
      rawSet(dom2, k, v);
    });
  };
  const get$f = (element2, key) => {
    const v = element2.dom.getAttribute(key);
    return v === null ? void 0 : v;
  };
  const getOpt = (element2, key) => Optional.from(get$f(element2, key));
  const has$1 = (element2, key) => {
    const dom2 = element2.dom;
    return dom2 && dom2.hasAttribute ? dom2.hasAttribute(key) : false;
  };
  const remove$7 = (element2, key) => {
    element2.dom.removeAttribute(key);
  };
  const clone$2 = (element2) => foldl(element2.dom.attributes, (acc, attr2) => {
    acc[attr2.name] = attr2.value;
    return acc;
  }, {});
  const internalSet = (dom2, property, value2) => {
    if (!isString2(value2)) {
      console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom2);
      throw new Error("CSS value must be a string: " + value2);
    }
    if (isSupported$1(dom2)) {
      dom2.style.setProperty(property, value2);
    }
  };
  const internalRemove = (dom2, property) => {
    if (isSupported$1(dom2)) {
      dom2.style.removeProperty(property);
    }
  };
  const set$8 = (element2, property, value2) => {
    const dom2 = element2.dom;
    internalSet(dom2, property, value2);
  };
  const setAll = (element2, css) => {
    const dom2 = element2.dom;
    each(css, (v, k) => {
      internalSet(dom2, k, v);
    });
  };
  const setOptions2 = (element2, css) => {
    const dom2 = element2.dom;
    each(css, (v, k) => {
      v.fold(() => {
        internalRemove(dom2, k);
      }, (value2) => {
        internalSet(dom2, k, value2);
      });
    });
  };
  const get$e = (element2, property) => {
    const dom2 = element2.dom;
    const styles2 = window.getComputedStyle(dom2);
    const r2 = styles2.getPropertyValue(property);
    return r2 === "" && !inBody(element2) ? getUnsafeProperty(dom2, property) : r2;
  };
  const getUnsafeProperty = (dom2, property) => isSupported$1(dom2) ? dom2.style.getPropertyValue(property) : "";
  const getRaw = (element2, property) => {
    const dom2 = element2.dom;
    const raw = getUnsafeProperty(dom2, property);
    return Optional.from(raw).filter((r2) => r2.length > 0);
  };
  const getAllRaw = (element2) => {
    const css = {};
    const dom2 = element2.dom;
    if (isSupported$1(dom2)) {
      for (let i = 0; i < dom2.style.length; i++) {
        const ruleName = dom2.style.item(i);
        css[ruleName] = dom2.style[ruleName];
      }
    }
    return css;
  };
  const isValidValue = (tag, property, value2) => {
    const element2 = SugarElement.fromTag(tag);
    set$8(element2, property, value2);
    const style = getRaw(element2, property);
    return style.isSome();
  };
  const remove$6 = (element2, property) => {
    const dom2 = element2.dom;
    internalRemove(dom2, property);
    if (is$1(getOpt(element2, "style").map(trim$12), "")) {
      remove$7(element2, "style");
    }
  };
  const reflow2 = (e) => e.dom.offsetWidth;
  const Dimension = (name3, getOffset2) => {
    const set2 = (element2, h) => {
      if (!isNumber2(h) && !h.match(/^[0-9]+$/)) {
        throw new Error(name3 + ".set accepts only positive integer values. Value was " + h);
      }
      const dom2 = element2.dom;
      if (isSupported$1(dom2)) {
        dom2.style[name3] = h + "px";
      }
    };
    const get2 = (element2) => {
      const r2 = getOffset2(element2);
      if (r2 <= 0 || r2 === null) {
        const css = get$e(element2, name3);
        return parseFloat(css) || 0;
      }
      return r2;
    };
    const getOuter2 = get2;
    const aggregate = (element2, properties2) => foldl(properties2, (acc, property) => {
      const val = get$e(element2, property);
      const value2 = val === void 0 ? 0 : parseInt(val, 10);
      return isNaN(value2) ? acc : acc + value2;
    }, 0);
    const max3 = (element2, value2, properties2) => {
      const cumulativeInclusions = aggregate(element2, properties2);
      const absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
      return absoluteMax;
    };
    return {
      set: set2,
      get: get2,
      getOuter: getOuter2,
      aggregate,
      max: max3
    };
  };
  const api$2 = Dimension("height", (element2) => {
    const dom2 = element2.dom;
    return inBody(element2) ? dom2.getBoundingClientRect().height : dom2.offsetHeight;
  });
  const get$d = (element2) => api$2.get(element2);
  const getOuter$2 = (element2) => api$2.getOuter(element2);
  const setMax$1 = (element2, value2) => {
    const inclusions = [
      "margin-top",
      "border-top-width",
      "padding-top",
      "padding-bottom",
      "border-bottom-width",
      "margin-bottom"
    ];
    const absMax = api$2.max(element2, value2, inclusions);
    set$8(element2, "max-height", absMax + "px");
  };
  const r$1 = (left3, top3) => {
    const translate2 = (x, y) => r$1(left3 + x, top3 + y);
    return {
      left: left3,
      top: top3,
      translate: translate2
    };
  };
  const SugarPosition = r$1;
  const boxPosition = (dom2) => {
    const box2 = dom2.getBoundingClientRect();
    return SugarPosition(box2.left, box2.top);
  };
  const firstDefinedOrZero = (a, b2) => {
    if (a !== void 0) {
      return a;
    } else {
      return b2 !== void 0 ? b2 : 0;
    }
  };
  const absolute$3 = (element2) => {
    const doc = element2.dom.ownerDocument;
    const body2 = doc.body;
    const win2 = doc.defaultView;
    const html2 = doc.documentElement;
    if (body2 === element2.dom) {
      return SugarPosition(body2.offsetLeft, body2.offsetTop);
    }
    const scrollTop = firstDefinedOrZero(win2 === null || win2 === void 0 ? void 0 : win2.pageYOffset, html2.scrollTop);
    const scrollLeft = firstDefinedOrZero(win2 === null || win2 === void 0 ? void 0 : win2.pageXOffset, html2.scrollLeft);
    const clientTop = firstDefinedOrZero(html2.clientTop, body2.clientTop);
    const clientLeft = firstDefinedOrZero(html2.clientLeft, body2.clientLeft);
    return viewport$1(element2).translate(scrollLeft - clientLeft, scrollTop - clientTop);
  };
  const viewport$1 = (element2) => {
    const dom2 = element2.dom;
    const doc = dom2.ownerDocument;
    const body2 = doc.body;
    if (body2 === dom2) {
      return SugarPosition(body2.offsetLeft, body2.offsetTop);
    }
    if (!inBody(element2)) {
      return SugarPosition(0, 0);
    }
    return boxPosition(dom2);
  };
  const api$1 = Dimension("width", (element2) => element2.dom.offsetWidth);
  const set$7 = (element2, h) => api$1.set(element2, h);
  const get$c = (element2) => api$1.get(element2);
  const getOuter$1 = (element2) => api$1.getOuter(element2);
  const setMax = (element2, value2) => {
    const inclusions = [
      "margin-left",
      "border-left-width",
      "padding-left",
      "padding-right",
      "border-right-width",
      "margin-right"
    ];
    const absMax = api$1.max(element2, value2, inclusions);
    set$8(element2, "max-width", absMax + "px");
  };
  const cached = (f2) => {
    let called = false;
    let r2;
    return (...args) => {
      if (!called) {
        called = true;
        r2 = f2.apply(null, args);
      }
      return r2;
    };
  };
  const DeviceType = (os, browser2, userAgent, mediaMatch2) => {
    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
    const isiPhone = os.isiOS() && !isiPad;
    const isMobile = os.isiOS() || os.isAndroid();
    const isTouch2 = isMobile || mediaMatch2("(pointer:coarse)");
    const isTablet2 = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
    const isPhone2 = isiPhone || isMobile && !isTablet2;
    const iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
    const isDesktop = !isPhone2 && !isTablet2 && !iOSwebview;
    return {
      isiPad: constant$1(isiPad),
      isiPhone: constant$1(isiPhone),
      isTablet: constant$1(isTablet2),
      isPhone: constant$1(isPhone2),
      isTouch: constant$1(isTouch2),
      isAndroid: os.isAndroid,
      isiOS: os.isiOS,
      isWebView: constant$1(iOSwebview),
      isDesktop: constant$1(isDesktop)
    };
  };
  const firstMatch = (regexes, s) => {
    for (let i = 0; i < regexes.length; i++) {
      const x = regexes[i];
      if (x.test(s)) {
        return x;
      }
    }
    return void 0;
  };
  const find$3 = (regexes, agent) => {
    const r2 = firstMatch(regexes, agent);
    if (!r2) {
      return {
        major: 0,
        minor: 0
      };
    }
    const group2 = (i) => {
      return Number(agent.replace(r2, "$" + i));
    };
    return nu$d(group2(1), group2(2));
  };
  const detect$5 = (versionRegexes, agent) => {
    const cleanedAgent = String(agent).toLowerCase();
    if (versionRegexes.length === 0) {
      return unknown$3();
    }
    return find$3(versionRegexes, cleanedAgent);
  };
  const unknown$3 = () => {
    return nu$d(0, 0);
  };
  const nu$d = (major, minor) => {
    return {
      major,
      minor
    };
  };
  const Version = {
    nu: nu$d,
    detect: detect$5,
    unknown: unknown$3
  };
  const detectBrowser$1 = (browsers2, userAgentData) => {
    return findMap(userAgentData.brands, (uaBrand) => {
      const lcBrand = uaBrand.brand.toLowerCase();
      return find$5(browsers2, (browser2) => {
        var _a;
        return lcBrand === ((_a = browser2.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
      }).map((info) => ({
        current: info.name,
        version: Version.nu(parseInt(uaBrand.version, 10), 0)
      }));
    });
  };
  const detect$4 = (candidates, userAgent) => {
    const agent = String(userAgent).toLowerCase();
    return find$5(candidates, (candidate) => {
      return candidate.search(agent);
    });
  };
  const detectBrowser = (browsers2, userAgent) => {
    return detect$4(browsers2, userAgent).map((browser2) => {
      const version = Version.detect(browser2.versionRegexes, userAgent);
      return {
        current: browser2.name,
        version
      };
    });
  };
  const detectOs = (oses2, userAgent) => {
    return detect$4(oses2, userAgent).map((os) => {
      const version = Version.detect(os.versionRegexes, userAgent);
      return {
        current: os.name,
        version
      };
    });
  };
  const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
  const checkContains = (target) => {
    return (uastring) => {
      return contains$1(uastring, target);
    };
  };
  const browsers = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (uastring) => {
        return contains$1(uastring, "edge/") && contains$1(uastring, "chrome") && contains$1(uastring, "safari") && contains$1(uastring, "applewebkit");
      }
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        normalVersionRegex
      ],
      search: (uastring) => {
        return contains$1(uastring, "chrome") && !contains$1(uastring, "chromeframe");
      }
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (uastring) => {
        return contains$1(uastring, "msie") || contains$1(uastring, "trident");
      }
    },
    {
      name: "Opera",
      versionRegexes: [
        normalVersionRegex,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: checkContains("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: checkContains("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        normalVersionRegex,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (uastring) => {
        return (contains$1(uastring, "safari") || contains$1(uastring, "mobile/")) && contains$1(uastring, "applewebkit");
      }
    }
  ];
  const oses = [
    {
      name: "Windows",
      search: checkContains("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (uastring) => {
        return contains$1(uastring, "iphone") || contains$1(uastring, "ipad");
      },
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: checkContains("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: checkContains("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: checkContains("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: checkContains("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: checkContains("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: checkContains("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ];
  const PlatformInfo = {
    browsers: constant$1(browsers),
    oses: constant$1(oses)
  };
  const edge = "Edge";
  const chromium = "Chromium";
  const ie = "IE";
  const opera = "Opera";
  const firefox = "Firefox";
  const safari = "Safari";
  const unknown$2 = () => {
    return nu$c({
      current: void 0,
      version: Version.unknown()
    });
  };
  const nu$c = (info) => {
    const current = info.current;
    const version = info.version;
    const isBrowser2 = (name3) => () => current === name3;
    return {
      current,
      version,
      isEdge: isBrowser2(edge),
      isChromium: isBrowser2(chromium),
      isIE: isBrowser2(ie),
      isOpera: isBrowser2(opera),
      isFirefox: isBrowser2(firefox),
      isSafari: isBrowser2(safari)
    };
  };
  const Browser = {
    unknown: unknown$2,
    nu: nu$c,
    edge: constant$1(edge),
    chromium: constant$1(chromium),
    ie: constant$1(ie),
    opera: constant$1(opera),
    firefox: constant$1(firefox),
    safari: constant$1(safari)
  };
  const windows = "Windows";
  const ios = "iOS";
  const android = "Android";
  const linux = "Linux";
  const macos = "macOS";
  const solaris = "Solaris";
  const freebsd = "FreeBSD";
  const chromeos = "ChromeOS";
  const unknown$1 = () => {
    return nu$b({
      current: void 0,
      version: Version.unknown()
    });
  };
  const nu$b = (info) => {
    const current = info.current;
    const version = info.version;
    const isOS = (name3) => () => current === name3;
    return {
      current,
      version,
      isWindows: isOS(windows),
      isiOS: isOS(ios),
      isAndroid: isOS(android),
      isMacOS: isOS(macos),
      isLinux: isOS(linux),
      isSolaris: isOS(solaris),
      isFreeBSD: isOS(freebsd),
      isChromeOS: isOS(chromeos)
    };
  };
  const OperatingSystem = {
    unknown: unknown$1,
    nu: nu$b,
    windows: constant$1(windows),
    ios: constant$1(ios),
    android: constant$1(android),
    linux: constant$1(linux),
    macos: constant$1(macos),
    solaris: constant$1(solaris),
    freebsd: constant$1(freebsd),
    chromeos: constant$1(chromeos)
  };
  const detect$3 = (userAgent, userAgentDataOpt, mediaMatch2) => {
    const browsers2 = PlatformInfo.browsers();
    const oses2 = PlatformInfo.oses();
    const browser2 = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers2, userAgentData)).orThunk(() => detectBrowser(browsers2, userAgent)).fold(Browser.unknown, Browser.nu);
    const os = detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
    const deviceType = DeviceType(os, browser2, userAgent, mediaMatch2);
    return {
      browser: browser2,
      os,
      deviceType
    };
  };
  const PlatformDetection = { detect: detect$3 };
  const mediaMatch = (query2) => window.matchMedia(query2).matches;
  let platform2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
  const detect$2 = () => platform2();
  const mkEvent = (target, x, y, stop2, prevent2, kill, raw) => ({
    target,
    x,
    y,
    stop: stop2,
    prevent: prevent2,
    kill,
    raw
  });
  const fromRawEvent$1 = (rawEvent) => {
    const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
    const stop2 = () => rawEvent.stopPropagation();
    const prevent2 = () => rawEvent.preventDefault();
    const kill = compose(prevent2, stop2);
    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop2, prevent2, kill, rawEvent);
  };
  const handle = (filter3, handler) => (rawEvent) => {
    if (filter3(rawEvent)) {
      handler(fromRawEvent$1(rawEvent));
    }
  };
  const binder = (element2, event, filter3, handler, useCapture) => {
    const wrapped = handle(filter3, handler);
    element2.dom.addEventListener(event, wrapped, useCapture);
    return { unbind: curry(unbind, element2, event, wrapped, useCapture) };
  };
  const bind$2 = (element2, event, filter3, handler) => binder(element2, event, filter3, handler, false);
  const capture$1 = (element2, event, filter3, handler) => binder(element2, event, filter3, handler, true);
  const unbind = (element2, event, handler, useCapture) => {
    element2.dom.removeEventListener(event, handler, useCapture);
  };
  const before$1 = (marker, element2) => {
    const parent$1 = parent(marker);
    parent$1.each((v) => {
      v.dom.insertBefore(element2.dom, marker.dom);
    });
  };
  const after$2 = (marker, element2) => {
    const sibling = nextSibling(marker);
    sibling.fold(() => {
      const parent$1 = parent(marker);
      parent$1.each((v) => {
        append$2(v, element2);
      });
    }, (v) => {
      before$1(v, element2);
    });
  };
  const prepend$1 = (parent2, element2) => {
    const firstChild$1 = firstChild(parent2);
    firstChild$1.fold(() => {
      append$2(parent2, element2);
    }, (v) => {
      parent2.dom.insertBefore(element2.dom, v.dom);
    });
  };
  const append$2 = (parent2, element2) => {
    parent2.dom.appendChild(element2.dom);
  };
  const appendAt = (parent2, element2, index) => {
    child$2(parent2, index).fold(() => {
      append$2(parent2, element2);
    }, (v) => {
      before$1(v, element2);
    });
  };
  const append$1 = (parent2, elements) => {
    each$1(elements, (x) => {
      append$2(parent2, x);
    });
  };
  const empty = (element2) => {
    element2.dom.textContent = "";
    each$1(children(element2), (rogue) => {
      remove$5(rogue);
    });
  };
  const remove$5 = (element2) => {
    const dom2 = element2.dom;
    if (dom2.parentNode !== null) {
      dom2.parentNode.removeChild(dom2);
    }
  };
  const get$b = (_DOC) => {
    const doc = _DOC !== void 0 ? _DOC.dom : document;
    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
    const y = doc.body.scrollTop || doc.documentElement.scrollTop;
    return SugarPosition(x, y);
  };
  const to = (x, y, _DOC) => {
    const doc = _DOC !== void 0 ? _DOC.dom : document;
    const win2 = doc.defaultView;
    if (win2) {
      win2.scrollTo(x, y);
    }
  };
  const get$a = (_win) => {
    const win2 = _win === void 0 ? window : _win;
    if (detect$2().browser.isFirefox()) {
      return Optional.none();
    } else {
      return Optional.from(win2.visualViewport);
    }
  };
  const bounds$1 = (x, y, width3, height3) => ({
    x,
    y,
    width: width3,
    height: height3,
    right: x + width3,
    bottom: y + height3
  });
  const getBounds$3 = (_win) => {
    const win2 = _win === void 0 ? window : _win;
    const doc = win2.document;
    const scroll = get$b(SugarElement.fromDom(doc));
    return get$a(win2).fold(() => {
      const html2 = win2.document.documentElement;
      const width3 = html2.clientWidth;
      const height3 = html2.clientHeight;
      return bounds$1(scroll.left, scroll.top, width3, height3);
    }, (visualViewport) => bounds$1(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));
  };
  const getDocument = () => SugarElement.fromDom(document);
  const walkUp = (navigation, doc) => {
    const frame = navigation.view(doc);
    return frame.fold(constant$1([]), (f2) => {
      const parent2 = navigation.owner(f2);
      const rest = walkUp(navigation, parent2);
      return [f2].concat(rest);
    });
  };
  const pathTo = (element2, navigation) => {
    const d = navigation.owner(element2);
    const paths = walkUp(navigation, d);
    return Optional.some(paths);
  };
  const view = (doc) => {
    var _a;
    const element2 = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);
    return element2.map(SugarElement.fromDom);
  };
  const owner$3 = (element2) => owner$4(element2);
  var Navigation = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    view,
    owner: owner$3
  });
  const find$2 = (element2) => {
    const doc = getDocument();
    const scroll = get$b(doc);
    const path2 = pathTo(element2, Navigation);
    return path2.fold(curry(absolute$3, element2), (frames) => {
      const offset3 = viewport$1(element2);
      const r2 = foldr(frames, (b2, a) => {
        const loc = viewport$1(a);
        return {
          left: b2.left + loc.left,
          top: b2.top + loc.top
        };
      }, {
        left: 0,
        top: 0
      });
      return SugarPosition(r2.left + offset3.left + scroll.left, r2.top + offset3.top + scroll.top);
    });
  };
  const pointed = (point2, width3, height3) => ({
    point: point2,
    width: width3,
    height: height3
  });
  const rect = (x, y, width3, height3) => ({
    x,
    y,
    width: width3,
    height: height3
  });
  const bounds = (x, y, width3, height3) => ({
    x,
    y,
    width: width3,
    height: height3,
    right: x + width3,
    bottom: y + height3
  });
  const box$1 = (element2) => {
    const xy = absolute$3(element2);
    const w = getOuter$1(element2);
    const h = getOuter$2(element2);
    return bounds(xy.left, xy.top, w, h);
  };
  const absolute$2 = (element2) => {
    const position2 = find$2(element2);
    const width3 = getOuter$1(element2);
    const height3 = getOuter$2(element2);
    return bounds(position2.left, position2.top, width3, height3);
  };
  const constrain = (original2, constraint) => {
    const left3 = Math.max(original2.x, constraint.x);
    const top3 = Math.max(original2.y, constraint.y);
    const right3 = Math.min(original2.right, constraint.right);
    const bottom3 = Math.min(original2.bottom, constraint.bottom);
    const width3 = right3 - left3;
    const height3 = bottom3 - top3;
    return bounds(left3, top3, width3, height3);
  };
  const constrainByMany = (original2, constraints) => {
    return foldl(constraints, (acc, c) => constrain(acc, c), original2);
  };
  const win = () => getBounds$3(window);
  var global$a = tinymce.util.Tools.resolve("tinymce.ThemeManager");
  const value$4 = (value2) => {
    const applyHelper = (fn3) => fn3(value2);
    const constHelper = constant$1(value2);
    const outputHelper = () => output2;
    const output2 = {
      tag: true,
      inner: value2,
      fold: (_onError, onValue) => onValue(value2),
      isValue: always,
      isError: never,
      map: (mapper) => Result.value(mapper(value2)),
      mapError: outputHelper,
      bind: applyHelper,
      exists: applyHelper,
      forall: applyHelper,
      getOr: constHelper,
      or: outputHelper,
      getOrThunk: constHelper,
      orThunk: outputHelper,
      getOrDie: constHelper,
      each: (fn3) => {
        fn3(value2);
      },
      toOptional: () => Optional.some(value2)
    };
    return output2;
  };
  const error$1 = (error3) => {
    const outputHelper = () => output2;
    const output2 = {
      tag: false,
      inner: error3,
      fold: (onError, _onValue) => onError(error3),
      isValue: never,
      isError: always,
      map: outputHelper,
      mapError: (mapper) => Result.error(mapper(error3)),
      bind: outputHelper,
      exists: never,
      forall: always,
      getOr: identity,
      or: identity,
      getOrThunk: apply$1,
      orThunk: apply$1,
      getOrDie: die(String(error3)),
      each: noop2,
      toOptional: Optional.none
    };
    return output2;
  };
  const fromOption = (optional2, err) => optional2.fold(() => error$1(err), value$4);
  const Result = {
    value: value$4,
    error: error$1,
    fromOption
  };
  var SimpleResultType;
  (function(SimpleResultType2) {
    SimpleResultType2[SimpleResultType2["Error"] = 0] = "Error";
    SimpleResultType2[SimpleResultType2["Value"] = 1] = "Value";
  })(SimpleResultType || (SimpleResultType = {}));
  const fold$1 = (res2, onError, onValue) => res2.stype === SimpleResultType.Error ? onError(res2.serror) : onValue(res2.svalue);
  const partition$2 = (results) => {
    const values2 = [];
    const errors = [];
    each$1(results, (obj) => {
      fold$1(obj, (err) => errors.push(err), (val) => values2.push(val));
    });
    return {
      values: values2,
      errors
    };
  };
  const mapError = (res2, f2) => {
    if (res2.stype === SimpleResultType.Error) {
      return {
        stype: SimpleResultType.Error,
        serror: f2(res2.serror)
      };
    } else {
      return res2;
    }
  };
  const map2 = (res2, f2) => {
    if (res2.stype === SimpleResultType.Value) {
      return {
        stype: SimpleResultType.Value,
        svalue: f2(res2.svalue)
      };
    } else {
      return res2;
    }
  };
  const bind$1 = (res2, f2) => {
    if (res2.stype === SimpleResultType.Value) {
      return f2(res2.svalue);
    } else {
      return res2;
    }
  };
  const bindError = (res2, f2) => {
    if (res2.stype === SimpleResultType.Error) {
      return f2(res2.serror);
    } else {
      return res2;
    }
  };
  const svalue = (v) => ({
    stype: SimpleResultType.Value,
    svalue: v
  });
  const serror = (e) => ({
    stype: SimpleResultType.Error,
    serror: e
  });
  const toResult$1 = (res2) => fold$1(res2, Result.error, Result.value);
  const fromResult$1 = (res2) => res2.fold(serror, svalue);
  const SimpleResult = {
    fromResult: fromResult$1,
    toResult: toResult$1,
    svalue,
    partition: partition$2,
    serror,
    bind: bind$1,
    bindError,
    map: map2,
    mapError,
    fold: fold$1
  };
  const field$2 = (key, newKey, presence, prop) => ({
    tag: "field",
    key,
    newKey,
    presence,
    prop
  });
  const customField$1 = (newKey, instantiator) => ({
    tag: "custom",
    newKey,
    instantiator
  });
  const fold = (value2, ifField, ifCustom) => {
    switch (value2.tag) {
      case "field":
        return ifField(value2.key, value2.newKey, value2.presence, value2.prop);
      case "custom":
        return ifCustom(value2.newKey, value2.instantiator);
    }
  };
  const shallow$1 = (old, nu2) => {
    return nu2;
  };
  const deep = (old, nu2) => {
    const bothObjects = isPlainObject2(old) && isPlainObject2(nu2);
    return bothObjects ? deepMerge(old, nu2) : nu2;
  };
  const baseMerge = (merger) => {
    return (...objects) => {
      if (objects.length === 0) {
        throw new Error(`Can't merge zero objects`);
      }
      const ret = {};
      for (let j = 0; j < objects.length; j++) {
        const curObject = objects[j];
        for (const key in curObject) {
          if (has$2(curObject, key)) {
            ret[key] = merger(ret[key], curObject[key]);
          }
        }
      }
      return ret;
    };
  };
  const deepMerge = baseMerge(deep);
  const merge$1 = baseMerge(shallow$1);
  const required$2 = () => ({
    tag: "required",
    process: {}
  });
  const defaultedThunk = (fallbackThunk) => ({
    tag: "defaultedThunk",
    process: fallbackThunk
  });
  const defaulted$1 = (fallback2) => defaultedThunk(constant$1(fallback2));
  const asOption = () => ({
    tag: "option",
    process: {}
  });
  const mergeWithThunk = (baseThunk) => ({
    tag: "mergeWithThunk",
    process: baseThunk
  });
  const mergeWith = (base2) => mergeWithThunk(constant$1(base2));
  const mergeValues$1 = (values2, base2) => values2.length > 0 ? SimpleResult.svalue(deepMerge(base2, merge$1.apply(void 0, values2))) : SimpleResult.svalue(base2);
  const mergeErrors$1 = (errors) => compose(SimpleResult.serror, flatten)(errors);
  const consolidateObj = (objects, base2) => {
    const partition2 = SimpleResult.partition(objects);
    return partition2.errors.length > 0 ? mergeErrors$1(partition2.errors) : mergeValues$1(partition2.values, base2);
  };
  const consolidateArr = (objects) => {
    const partitions = SimpleResult.partition(objects);
    return partitions.errors.length > 0 ? mergeErrors$1(partitions.errors) : SimpleResult.svalue(partitions.values);
  };
  const ResultCombine = {
    consolidateObj,
    consolidateArr
  };
  const formatObj = (input2) => {
    return isObject2(input2) && keys(input2).length > 100 ? " removed due to size" : JSON.stringify(input2, null, 2);
  };
  const formatErrors = (errors) => {
    const es = errors.length > 10 ? errors.slice(0, 10).concat([{
      path: [],
      getErrorInfo: constant$1("... (only showing first ten failures)")
    }]) : errors;
    return map$2(es, (e) => {
      return "Failed path: (" + e.path.join(" > ") + ")\n" + e.getErrorInfo();
    });
  };
  const nu$a = (path2, getErrorInfo) => {
    return SimpleResult.serror([{
      path: path2,
      getErrorInfo
    }]);
  };
  const missingRequired = (path2, key, obj) => nu$a(path2, () => 'Could not find valid *required* value for "' + key + '" in ' + formatObj(obj));
  const missingKey = (path2, key) => nu$a(path2, () => 'Choice schema did not contain choice key: "' + key + '"');
  const missingBranch = (path2, branches, branch) => nu$a(path2, () => 'The chosen schema: "' + branch + '" did not exist in branches: ' + formatObj(branches));
  const unsupportedFields = (path2, unsupported) => nu$a(path2, () => "There are unsupported fields: [" + unsupported.join(", ") + "] specified");
  const custom = (path2, err) => nu$a(path2, constant$1(err));
  const value$3 = (validator2) => {
    const extract2 = (path2, val) => {
      return SimpleResult.bindError(validator2(val), (err) => custom(path2, err));
    };
    const toString4 = constant$1("val");
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const anyValue$1 = value$3(SimpleResult.svalue);
  const requiredAccess = (path2, obj, key, bundle) => get$g(obj, key).fold(() => missingRequired(path2, key, obj), bundle);
  const fallbackAccess = (obj, key, fallback2, bundle) => {
    const v = get$g(obj, key).getOrThunk(() => fallback2(obj));
    return bundle(v);
  };
  const optionAccess = (obj, key, bundle) => bundle(get$g(obj, key));
  const optionDefaultedAccess = (obj, key, fallback2, bundle) => {
    const opt = get$g(obj, key).map((val) => val === true ? fallback2(obj) : val);
    return bundle(opt);
  };
  const extractField = (field2, path2, obj, key, prop) => {
    const bundle = (av) => prop.extract(path2.concat([key]), av);
    const bundleAsOption = (optValue) => optValue.fold(() => SimpleResult.svalue(Optional.none()), (ov) => {
      const result = prop.extract(path2.concat([key]), ov);
      return SimpleResult.map(result, Optional.some);
    });
    switch (field2.tag) {
      case "required":
        return requiredAccess(path2, obj, key, bundle);
      case "defaultedThunk":
        return fallbackAccess(obj, key, field2.process, bundle);
      case "option":
        return optionAccess(obj, key, bundleAsOption);
      case "defaultedOptionThunk":
        return optionDefaultedAccess(obj, key, field2.process, bundleAsOption);
      case "mergeWithThunk": {
        return fallbackAccess(obj, key, constant$1({}), (v) => {
          const result = deepMerge(field2.process(obj), v);
          return bundle(result);
        });
      }
    }
  };
  const extractFields = (path2, obj, fields) => {
    const success = {};
    const errors = [];
    for (const field2 of fields) {
      fold(field2, (key, newKey, presence, prop) => {
        const result = extractField(presence, path2, obj, key, prop);
        SimpleResult.fold(result, (err) => {
          errors.push(...err);
        }, (res2) => {
          success[newKey] = res2;
        });
      }, (newKey, instantiator) => {
        success[newKey] = instantiator(obj);
      });
    }
    return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);
  };
  const valueThunk = (getDelegate) => {
    const extract2 = (path2, val) => getDelegate().extract(path2, val);
    const toString4 = () => getDelegate().toString();
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const getSetKeys = (obj) => keys(filter$1(obj, isNonNullable));
  const objOfOnly = (fields) => {
    const delegate = objOf(fields);
    const fieldNames = foldr(fields, (acc, value2) => {
      return fold(value2, (key) => deepMerge(acc, { [key]: true }), constant$1(acc));
    }, {});
    const extract2 = (path2, o) => {
      const keys2 = isBoolean2(o) ? [] : getSetKeys(o);
      const extra = filter$2(keys2, (k) => !hasNonNullableKey(fieldNames, k));
      return extra.length === 0 ? delegate.extract(path2, o) : unsupportedFields(path2, extra);
    };
    return {
      extract: extract2,
      toString: delegate.toString
    };
  };
  const objOf = (values2) => {
    const extract2 = (path2, o) => extractFields(path2, o, values2);
    const toString4 = () => {
      const fieldStrings = map$2(values2, (value2) => fold(value2, (key, _okey, _presence, prop) => key + " -> " + prop.toString(), (newKey, _instantiator) => "state(" + newKey + ")"));
      return "obj{\n" + fieldStrings.join("\n") + "}";
    };
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const arrOf = (prop) => {
    const extract2 = (path2, array) => {
      const results = map$2(array, (a, i) => prop.extract(path2.concat(["[" + i + "]"]), a));
      return ResultCombine.consolidateArr(results);
    };
    const toString4 = () => "array(" + prop.toString() + ")";
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const oneOf = (props, rawF) => {
    const f2 = rawF !== void 0 ? rawF : identity;
    const extract2 = (path2, val) => {
      const errors = [];
      for (const prop of props) {
        const res2 = prop.extract(path2, val);
        if (res2.stype === SimpleResultType.Value) {
          return {
            stype: SimpleResultType.Value,
            svalue: f2(res2.svalue)
          };
        }
        errors.push(res2);
      }
      return ResultCombine.consolidateArr(errors);
    };
    const toString4 = () => "oneOf(" + map$2(props, (prop) => prop.toString()).join(", ") + ")";
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const setOf$1 = (validator2, prop) => {
    const validateKeys = (path2, keys2) => arrOf(value$3(validator2)).extract(path2, keys2);
    const extract2 = (path2, o) => {
      const keys$1 = keys(o);
      const validatedKeys = validateKeys(path2, keys$1);
      return SimpleResult.bind(validatedKeys, (validKeys) => {
        const schema2 = map$2(validKeys, (vk) => {
          return field$2(vk, vk, required$2(), prop);
        });
        return objOf(schema2).extract(path2, o);
      });
    };
    const toString4 = () => "setOf(" + prop.toString() + ")";
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const thunk = (_desc, processor) => {
    const getP = cached(processor);
    const extract2 = (path2, val) => getP().extract(path2, val);
    const toString4 = () => getP().toString();
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const arrOfObj = compose(arrOf, objOf);
  const anyValue = constant$1(anyValue$1);
  const typedValue = (validator2, expectedType) => value$3((a) => {
    const actualType = typeof a;
    return validator2(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);
  });
  const number = typedValue(isNumber2, "number");
  const string = typedValue(isString2, "string");
  const boolean = typedValue(isBoolean2, "boolean");
  const functionProcessor = typedValue(isFunction2, "function");
  const isPostMessageable = (val) => {
    if (Object(val) !== val) {
      return true;
    }
    switch ({}.toString.call(val).slice(8, -1)) {
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "RegExp":
      case "Blob":
      case "FileList":
      case "ImageData":
      case "ImageBitmap":
      case "ArrayBuffer":
        return true;
      case "Array":
      case "Object":
        return Object.keys(val).every((prop) => isPostMessageable(val[prop]));
      default:
        return false;
    }
  };
  const postMessageable = value$3((a) => {
    if (isPostMessageable(a)) {
      return SimpleResult.svalue(a);
    } else {
      return SimpleResult.serror("Expected value to be acceptable for sending via postMessage");
    }
  });
  const chooseFrom = (path2, input2, branches, ch) => {
    const fields = get$g(branches, ch);
    return fields.fold(() => missingBranch(path2, branches, ch), (vp) => vp.extract(path2.concat(["branch: " + ch]), input2));
  };
  const choose$2 = (key, branches) => {
    const extract2 = (path2, input2) => {
      const choice = get$g(input2, key);
      return choice.fold(() => missingKey(path2, key), (chosen) => chooseFrom(path2, input2, branches, chosen));
    };
    const toString4 = () => "chooseOn(" + key + "). Possible values: " + keys(branches);
    return {
      extract: extract2,
      toString: toString4
    };
  };
  const arrOfVal = () => arrOf(anyValue$1);
  const valueOf = (validator2) => value$3((v) => validator2(v).fold(SimpleResult.serror, SimpleResult.svalue));
  const setOf = (validator2, prop) => setOf$1((v) => SimpleResult.fromResult(validator2(v)), prop);
  const extractValue = (label2, prop, obj) => {
    const res2 = prop.extract([label2], obj);
    return SimpleResult.mapError(res2, (errs) => ({
      input: obj,
      errors: errs
    }));
  };
  const asRaw = (label2, prop, obj) => SimpleResult.toResult(extractValue(label2, prop, obj));
  const getOrDie = (extraction) => {
    return extraction.fold((errInfo) => {
      throw new Error(formatError(errInfo));
    }, identity);
  };
  const asRawOrDie$1 = (label2, prop, obj) => getOrDie(asRaw(label2, prop, obj));
  const formatError = (errInfo) => {
    return "Errors: \n" + formatErrors(errInfo.errors).join("\n") + "\n\nInput object: " + formatObj(errInfo.input);
  };
  const choose$1 = (key, branches) => choose$2(key, map$1(branches, objOf));
  const thunkOf = (desc, schema2) => thunk(desc, schema2);
  const field$1 = field$2;
  const customField = customField$1;
  const validateEnum = (values2) => valueOf((value2) => contains$2(values2, value2) ? Result.value(value2) : Result.error(`Unsupported value: "${value2}", choose one of "${values2.join(", ")}".`));
  const required$1 = (key) => field$1(key, key, required$2(), anyValue());
  const requiredOf = (key, schema2) => field$1(key, key, required$2(), schema2);
  const requiredNumber = (key) => requiredOf(key, number);
  const requiredString = (key) => requiredOf(key, string);
  const requiredStringEnum = (key, values2) => field$1(key, key, required$2(), validateEnum(values2));
  const requiredBoolean = (key) => requiredOf(key, boolean);
  const requiredFunction = (key) => requiredOf(key, functionProcessor);
  const forbid = (key, message) => field$1(key, key, asOption(), value$3((_v) => SimpleResult.serror("The field: " + key + " is forbidden. " + message)));
  const requiredObjOf = (key, objSchema) => field$1(key, key, required$2(), objOf(objSchema));
  const requiredArrayOfObj = (key, objFields) => field$1(key, key, required$2(), arrOfObj(objFields));
  const requiredArrayOf = (key, schema2) => field$1(key, key, required$2(), arrOf(schema2));
  const option$3 = (key) => field$1(key, key, asOption(), anyValue());
  const optionOf = (key, schema2) => field$1(key, key, asOption(), schema2);
  const optionNumber = (key) => optionOf(key, number);
  const optionString = (key) => optionOf(key, string);
  const optionStringEnum = (key, values2) => optionOf(key, validateEnum(values2));
  const optionFunction = (key) => optionOf(key, functionProcessor);
  const optionArrayOf = (key, schema2) => optionOf(key, arrOf(schema2));
  const optionObjOf = (key, objSchema) => optionOf(key, objOf(objSchema));
  const optionObjOfOnly = (key, objSchema) => optionOf(key, objOfOnly(objSchema));
  const defaulted = (key, fallback2) => field$1(key, key, defaulted$1(fallback2), anyValue());
  const defaultedOf = (key, fallback2, schema2) => field$1(key, key, defaulted$1(fallback2), schema2);
  const defaultedNumber = (key, fallback2) => defaultedOf(key, fallback2, number);
  const defaultedString = (key, fallback2) => defaultedOf(key, fallback2, string);
  const defaultedStringEnum = (key, fallback2, values2) => defaultedOf(key, fallback2, validateEnum(values2));
  const defaultedBoolean = (key, fallback2) => defaultedOf(key, fallback2, boolean);
  const defaultedFunction = (key, fallback2) => defaultedOf(key, fallback2, functionProcessor);
  const defaultedPostMsg = (key, fallback2) => defaultedOf(key, fallback2, postMessageable);
  const defaultedArrayOf = (key, fallback2, schema2) => defaultedOf(key, fallback2, arrOf(schema2));
  const defaultedObjOf = (key, fallback2, objSchema) => defaultedOf(key, fallback2, objOf(objSchema));
  const Cell = (initial) => {
    let value2 = initial;
    const get2 = () => {
      return value2;
    };
    const set2 = (v) => {
      value2 = v;
    };
    return {
      get: get2,
      set: set2
    };
  };
  const generate$7 = (cases) => {
    if (!isArray2(cases)) {
      throw new Error("cases must be an array");
    }
    if (cases.length === 0) {
      throw new Error("there must be at least one case");
    }
    const constructors = [];
    const adt2 = {};
    each$1(cases, (acase, count) => {
      const keys$1 = keys(acase);
      if (keys$1.length !== 1) {
        throw new Error("one and only one name per case");
      }
      const key = keys$1[0];
      const value2 = acase[key];
      if (adt2[key] !== void 0) {
        throw new Error("duplicate key detected:" + key);
      } else if (key === "cata") {
        throw new Error("cannot have a case named cata (sorry)");
      } else if (!isArray2(value2)) {
        throw new Error("case arguments must be an array");
      }
      constructors.push(key);
      adt2[key] = (...args) => {
        const argLength = args.length;
        if (argLength !== value2.length) {
          throw new Error("Wrong number of arguments to case " + key + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
        }
        const match = (branches) => {
          const branchKeys = keys(branches);
          if (constructors.length !== branchKeys.length) {
            throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
          }
          const allReqd = forall(constructors, (reqKey) => {
            return contains$2(branchKeys, reqKey);
          });
          if (!allReqd) {
            throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
          }
          return branches[key].apply(null, args);
        };
        return {
          fold: (...foldArgs) => {
            if (foldArgs.length !== cases.length) {
              throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
            }
            const target = foldArgs[count];
            return target.apply(null, args);
          },
          match,
          log: (label2) => {
            console.log(label2, {
              constructors,
              constructor: key,
              params: args
            });
          }
        };
      };
    });
    return adt2;
  };
  const Adt = { generate: generate$7 };
  Adt.generate([
    {
      bothErrors: [
        "error1",
        "error2"
      ]
    },
    {
      firstError: [
        "error1",
        "value2"
      ]
    },
    {
      secondError: [
        "value1",
        "error2"
      ]
    },
    {
      bothValues: [
        "value1",
        "value2"
      ]
    }
  ]);
  const partition$1 = (results) => {
    const errors = [];
    const values2 = [];
    each$1(results, (result) => {
      result.fold((err) => {
        errors.push(err);
      }, (value2) => {
        values2.push(value2);
      });
    });
    return {
      errors,
      values: values2
    };
  };
  const exclude$1 = (obj, fields) => {
    const r2 = {};
    each(obj, (v, k) => {
      if (!contains$2(fields, k)) {
        r2[k] = v;
      }
    });
    return r2;
  };
  const wrap$2 = (key, value2) => ({ [key]: value2 });
  const wrapAll$1 = (keyvalues) => {
    const r2 = {};
    each$1(keyvalues, (kv) => {
      r2[kv.key] = kv.value;
    });
    return r2;
  };
  const exclude = (obj, fields) => exclude$1(obj, fields);
  const wrap$1 = (key, value2) => wrap$2(key, value2);
  const wrapAll = (keyvalues) => wrapAll$1(keyvalues);
  const mergeValues = (values2, base2) => {
    return values2.length === 0 ? Result.value(base2) : Result.value(deepMerge(base2, merge$1.apply(void 0, values2)));
  };
  const mergeErrors = (errors) => Result.error(flatten(errors));
  const consolidate = (objs, base2) => {
    const partitions = partition$1(objs);
    return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : mergeValues(partitions.values, base2);
  };
  const ensureIsRoot = (isRoot) => isFunction2(isRoot) ? isRoot : never;
  const ancestor$2 = (scope, transform2, isRoot) => {
    let element2 = scope.dom;
    const stop2 = ensureIsRoot(isRoot);
    while (element2.parentNode) {
      element2 = element2.parentNode;
      const el = SugarElement.fromDom(element2);
      const transformed = transform2(el);
      if (transformed.isSome()) {
        return transformed;
      } else if (stop2(el)) {
        break;
      }
    }
    return Optional.none();
  };
  const closest$4 = (scope, transform2, isRoot) => {
    const current = transform2(scope);
    const stop2 = ensureIsRoot(isRoot);
    return current.orThunk(() => stop2(scope) ? Optional.none() : ancestor$2(scope, transform2, stop2));
  };
  const isSource = (component, simulatedEvent) => eq(component.element, simulatedEvent.event.target);
  const defaultEventHandler = {
    can: always,
    abort: never,
    run: noop2
  };
  const nu$9 = (parts2) => {
    if (!hasNonNullableKey(parts2, "can") && !hasNonNullableKey(parts2, "abort") && !hasNonNullableKey(parts2, "run")) {
      throw new Error("EventHandler defined by: " + JSON.stringify(parts2, null, 2) + " does not have can, abort, or run!");
    }
    return {
      ...defaultEventHandler,
      ...parts2
    };
  };
  const all$2 = (handlers2, f2) => (...args) => foldl(handlers2, (acc, handler) => acc && f2(handler).apply(void 0, args), true);
  const any = (handlers2, f2) => (...args) => foldl(handlers2, (acc, handler) => acc || f2(handler).apply(void 0, args), false);
  const read$2 = (handler) => isFunction2(handler) ? {
    can: always,
    abort: never,
    run: handler
  } : handler;
  const fuse$1 = (handlers2) => {
    const can2 = all$2(handlers2, (handler) => handler.can);
    const abort2 = any(handlers2, (handler) => handler.abort);
    const run3 = (...args) => {
      each$1(handlers2, (handler) => {
        handler.run.apply(void 0, args);
      });
    };
    return {
      can: can2,
      abort: abort2,
      run: run3
    };
  };
  const constant = constant$1;
  const touchstart = constant("touchstart");
  const touchmove = constant("touchmove");
  const touchend = constant("touchend");
  const touchcancel = constant("touchcancel");
  const mousedown = constant("mousedown");
  const mousemove = constant("mousemove");
  const mouseout = constant("mouseout");
  const mouseup = constant("mouseup");
  const mouseover = constant("mouseover");
  const focusin = constant("focusin");
  const focusout = constant("focusout");
  const keydown = constant("keydown");
  const keyup = constant("keyup");
  const input = constant("input");
  const change = constant("change");
  const click = constant("click");
  const transitioncancel = constant("transitioncancel");
  const transitionend = constant("transitionend");
  const transitionstart = constant("transitionstart");
  const selectstart = constant("selectstart");
  const prefixName = (name3) => constant$1("alloy." + name3);
  const alloy = { tap: prefixName("tap") };
  const focus$4 = prefixName("focus");
  const postBlur = prefixName("blur.post");
  const postPaste = prefixName("paste.post");
  const receive = prefixName("receive");
  const execute$5 = prefixName("execute");
  const focusItem = prefixName("focus.item");
  const tap = alloy.tap;
  const longpress = prefixName("longpress");
  const sandboxClose = prefixName("sandbox.close");
  const typeaheadCancel = prefixName("typeahead.cancel");
  const systemInit = prefixName("system.init");
  const documentTouchmove = prefixName("system.touchmove");
  const documentTouchend = prefixName("system.touchend");
  const windowScroll = prefixName("system.scroll");
  const windowResize = prefixName("system.resize");
  const attachedToDom = prefixName("system.attached");
  const detachedFromDom = prefixName("system.detached");
  const dismissRequested = prefixName("system.dismissRequested");
  const repositionRequested = prefixName("system.repositionRequested");
  const focusShifted = prefixName("focusmanager.shifted");
  const slotVisibility = prefixName("slotcontainer.visibility");
  const externalElementScroll = prefixName("system.external.element.scroll");
  const changeTab = prefixName("change.tab");
  const dismissTab = prefixName("dismiss.tab");
  const highlight$1 = prefixName("highlight");
  const dehighlight$1 = prefixName("dehighlight");
  const emit = (component, event) => {
    dispatchWith(component, component.element, event, {});
  };
  const emitWith = (component, event, properties2) => {
    dispatchWith(component, component.element, event, properties2);
  };
  const emitExecute = (component) => {
    emit(component, execute$5());
  };
  const dispatch = (component, target, event) => {
    dispatchWith(component, target, event, {});
  };
  const dispatchWith = (component, target, event, properties2) => {
    const data2 = {
      target,
      ...properties2
    };
    component.getSystem().triggerEvent(event, target, data2);
  };
  const retargetAndDispatchWith = (component, target, eventName, properties2) => {
    const data2 = {
      ...properties2,
      target
    };
    component.getSystem().triggerEvent(eventName, target, data2);
  };
  const dispatchEvent = (component, target, event, simulatedEvent) => {
    component.getSystem().triggerEvent(event, target, simulatedEvent.event);
  };
  const derive$2 = (configs) => wrapAll(configs);
  const abort = (name3, predicate) => {
    return {
      key: name3,
      value: nu$9({ abort: predicate })
    };
  };
  const can = (name3, predicate) => {
    return {
      key: name3,
      value: nu$9({ can: predicate })
    };
  };
  const preventDefault = (name3) => {
    return {
      key: name3,
      value: nu$9({
        run: (component, simulatedEvent) => {
          simulatedEvent.event.prevent();
        }
      })
    };
  };
  const run$1 = (name3, handler) => {
    return {
      key: name3,
      value: nu$9({ run: handler })
    };
  };
  const runActionExtra = (name3, action, extra) => {
    return {
      key: name3,
      value: nu$9({
        run: (component, simulatedEvent) => {
          action.apply(void 0, [
            component,
            simulatedEvent
          ].concat(extra));
        }
      })
    };
  };
  const runOnName = (name3) => {
    return (handler) => run$1(name3, handler);
  };
  const runOnSourceName = (name3) => {
    return (handler) => ({
      key: name3,
      value: nu$9({
        run: (component, simulatedEvent) => {
          if (isSource(component, simulatedEvent)) {
            handler(component, simulatedEvent);
          }
        }
      })
    });
  };
  const redirectToUid = (name3, uid) => {
    return run$1(name3, (component, simulatedEvent) => {
      component.getSystem().getByUid(uid).each((redirectee) => {
        dispatchEvent(redirectee, redirectee.element, name3, simulatedEvent);
      });
    });
  };
  const redirectToPart = (name3, detail, partName) => {
    const uid = detail.partUids[partName];
    return redirectToUid(name3, uid);
  };
  const runWithTarget = (name3, f2) => {
    return run$1(name3, (component, simulatedEvent) => {
      const ev = simulatedEvent.event;
      const target = component.getSystem().getByDom(ev.target).getOrThunk(() => {
        const closest2 = closest$4(ev.target, (el) => component.getSystem().getByDom(el).toOptional(), never);
        return closest2.getOr(component);
      });
      f2(component, target, simulatedEvent);
    });
  };
  const cutter = (name3) => {
    return run$1(name3, (component, simulatedEvent) => {
      simulatedEvent.cut();
    });
  };
  const stopper = (name3) => {
    return run$1(name3, (component, simulatedEvent) => {
      simulatedEvent.stop();
    });
  };
  const runOnSource = (name3, f2) => {
    return runOnSourceName(name3)(f2);
  };
  const runOnAttached = runOnSourceName(attachedToDom());
  const runOnDetached = runOnSourceName(detachedFromDom());
  const runOnInit = runOnSourceName(systemInit());
  const runOnExecute$1 = runOnName(execute$5());
  const fromHtml$1 = (html2, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html2;
    return children(SugarElement.fromDom(div));
  };
  const get$9 = (element2) => element2.dom.innerHTML;
  const set$6 = (element2, content) => {
    const owner2 = owner$4(element2);
    const docDom = owner2.dom;
    const fragment = SugarElement.fromDom(docDom.createDocumentFragment());
    const contentElements = fromHtml$1(content, docDom);
    append$1(fragment, contentElements);
    empty(element2);
    append$2(element2, fragment);
  };
  const getOuter = (element2) => {
    const container = SugarElement.fromTag("div");
    const clone2 = SugarElement.fromDom(element2.dom.cloneNode(true));
    append$2(container, clone2);
    return get$9(container);
  };
  const clone$1 = (original2, isDeep) => SugarElement.fromDom(original2.dom.cloneNode(isDeep));
  const shallow = (original2) => clone$1(original2, false);
  const getHtml = (element2) => {
    if (isShadowRoot2(element2)) {
      return "#shadow-root";
    } else {
      const clone2 = shallow(element2);
      return getOuter(clone2);
    }
  };
  const element = (elem) => getHtml(elem);
  const isRecursive = (component, originator, target) => eq(originator, component.element) && !eq(originator, target);
  const events$i = derive$2([can(focus$4(), (component, simulatedEvent) => {
    const event = simulatedEvent.event;
    const originator = event.originator;
    const target = event.target;
    if (isRecursive(component, originator, target)) {
      console.warn(focus$4() + " did not get interpreted by the desired target. \nOriginator: " + element(originator) + "\nTarget: " + element(target) + "\nCheck the " + focus$4() + " event handlers");
      return false;
    } else {
      return true;
    }
  })]);
  var DefaultEvents = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$i
  });
  let unique = 0;
  const generate$6 = (prefix2) => {
    const date = /* @__PURE__ */ new Date();
    const time = date.getTime();
    const random = Math.floor(Math.random() * 1e9);
    unique++;
    return prefix2 + "_" + random + unique + String(time);
  };
  const prefix$1 = constant$1("alloy-id-");
  const idAttr$1 = constant$1("data-alloy-id");
  const prefix = prefix$1();
  const idAttr = idAttr$1();
  const write2 = (label2, elem) => {
    const id = generate$6(prefix + label2);
    writeOnly(elem, id);
    return id;
  };
  const writeOnly = (elem, uid) => {
    Object.defineProperty(elem.dom, idAttr, {
      value: uid,
      writable: true
    });
  };
  const read$1 = (elem) => {
    const id = isElement$12(elem) ? elem.dom[idAttr] : null;
    return Optional.from(id);
  };
  const generate$5 = (prefix2) => generate$6(prefix2);
  const make$8 = identity;
  const NoContextApi = (getComp) => {
    const getMessage = (event) => `The component must be in a context to execute: ${event}` + (getComp ? "\n" + element(getComp().element) + " is not in context." : "");
    const fail = (event) => () => {
      throw new Error(getMessage(event));
    };
    const warn = (event) => () => {
      console.warn(getMessage(event));
    };
    return {
      debugInfo: constant$1("fake"),
      triggerEvent: warn("triggerEvent"),
      triggerFocus: warn("triggerFocus"),
      triggerEscape: warn("triggerEscape"),
      broadcast: warn("broadcast"),
      broadcastOn: warn("broadcastOn"),
      broadcastEvent: warn("broadcastEvent"),
      build: fail("build"),
      buildOrPatch: fail("buildOrPatch"),
      addToWorld: fail("addToWorld"),
      removeFromWorld: fail("removeFromWorld"),
      addToGui: fail("addToGui"),
      removeFromGui: fail("removeFromGui"),
      getByUid: fail("getByUid"),
      getByDom: fail("getByDom"),
      isConnected: never
    };
  };
  const singleton$1 = NoContextApi();
  const markAsBehaviourApi = (f2, apiName, apiFunction) => {
    const delegate = apiFunction.toString();
    const endIndex = delegate.indexOf(")") + 1;
    const openBracketIndex = delegate.indexOf("(");
    const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
    f2.toFunctionAnnotation = () => ({
      name: apiName,
      parameters: cleanParameters(parameters.slice(0, 1).concat(parameters.slice(3)))
    });
    return f2;
  };
  const cleanParameters = (parameters) => map$2(parameters, (p) => endsWith2(p, "/*") ? p.substring(0, p.length - "/*".length) : p);
  const markAsExtraApi = (f2, extraName) => {
    const delegate = f2.toString();
    const endIndex = delegate.indexOf(")") + 1;
    const openBracketIndex = delegate.indexOf("(");
    const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
    f2.toFunctionAnnotation = () => ({
      name: extraName,
      parameters: cleanParameters(parameters)
    });
    return f2;
  };
  const markAsSketchApi = (f2, apiFunction) => {
    const delegate = apiFunction.toString();
    const endIndex = delegate.indexOf(")") + 1;
    const openBracketIndex = delegate.indexOf("(");
    const parameters = delegate.substring(openBracketIndex + 1, endIndex - 1).split(/,\s*/);
    f2.toFunctionAnnotation = () => ({
      name: "OVERRIDE",
      parameters: cleanParameters(parameters.slice(1))
    });
    return f2;
  };
  const premadeTag = generate$6("alloy-premade");
  const premade$1 = (comp) => {
    Object.defineProperty(comp.element.dom, premadeTag, {
      value: comp.uid,
      writable: true
    });
    return wrap$1(premadeTag, comp);
  };
  const isPremade = (element2) => has$2(element2.dom, premadeTag);
  const getPremade = (spec) => get$g(spec, premadeTag);
  const makeApi = (f2) => markAsSketchApi((component, ...rest) => f2(component.getApis(), component, ...rest), f2);
  const NoState = { init: () => nu$8({ readState: constant$1("No State required") }) };
  const nu$8 = (spec) => spec;
  const generateFrom$1 = (spec, all3) => {
    const schema2 = map$2(all3, (a) => optionObjOf(a.name(), [
      required$1("config"),
      defaulted("state", NoState)
    ]));
    const validated = asRaw("component.behaviours", objOf(schema2), spec.behaviours).fold((errInfo) => {
      throw new Error(formatError(errInfo) + "\nComplete spec:\n" + JSON.stringify(spec, null, 2));
    }, identity);
    return {
      list: all3,
      data: map$1(validated, (optBlobThunk) => {
        const output2 = optBlobThunk.map((blob2) => ({
          config: blob2.config,
          state: blob2.state.init(blob2.config)
        }));
        return constant$1(output2);
      })
    };
  };
  const getBehaviours$3 = (bData) => bData.list;
  const getData$2 = (bData) => bData.data;
  const byInnerKey = (data2, tuple) => {
    const r2 = {};
    each(data2, (detail, key) => {
      each(detail, (value2, indexKey) => {
        const chain2 = get$g(r2, indexKey).getOr([]);
        r2[indexKey] = chain2.concat([tuple(key, value2)]);
      });
    });
    return r2;
  };
  const nu$7 = (s) => ({
    classes: isUndefined2(s.classes) ? [] : s.classes,
    attributes: isUndefined2(s.attributes) ? {} : s.attributes,
    styles: isUndefined2(s.styles) ? {} : s.styles
  });
  const merge2 = (defnA, mod) => ({
    ...defnA,
    attributes: {
      ...defnA.attributes,
      ...mod.attributes
    },
    styles: {
      ...defnA.styles,
      ...mod.styles
    },
    classes: defnA.classes.concat(mod.classes)
  });
  const combine$2 = (info, baseMod, behaviours2, base2) => {
    const modsByBehaviour = { ...baseMod };
    each$1(behaviours2, (behaviour) => {
      modsByBehaviour[behaviour.name()] = behaviour.exhibit(info, base2);
    });
    const byAspect = byInnerKey(modsByBehaviour, (name3, modification) => ({
      name: name3,
      modification
    }));
    const combineObjects = (objects) => foldr(objects, (b2, a) => ({
      ...a.modification,
      ...b2
    }), {});
    const combinedClasses = foldr(byAspect.classes, (b2, a) => a.modification.concat(b2), []);
    const combinedAttributes = combineObjects(byAspect.attributes);
    const combinedStyles = combineObjects(byAspect.styles);
    return nu$7({
      classes: combinedClasses,
      attributes: combinedAttributes,
      styles: combinedStyles
    });
  };
  const sortKeys = (label2, keyName, array, order2) => {
    try {
      const sorted = sort(array, (a, b2) => {
        const aKey = a[keyName];
        const bKey = b2[keyName];
        const aIndex = order2.indexOf(aKey);
        const bIndex = order2.indexOf(bKey);
        if (aIndex === -1) {
          throw new Error("The ordering for " + label2 + " does not have an entry for " + aKey + ".\nOrder specified: " + JSON.stringify(order2, null, 2));
        }
        if (bIndex === -1) {
          throw new Error("The ordering for " + label2 + " does not have an entry for " + bKey + ".\nOrder specified: " + JSON.stringify(order2, null, 2));
        }
        if (aIndex < bIndex) {
          return -1;
        } else if (bIndex < aIndex) {
          return 1;
        } else {
          return 0;
        }
      });
      return Result.value(sorted);
    } catch (err) {
      return Result.error([err]);
    }
  };
  const uncurried = (handler, purpose) => ({
    handler,
    purpose
  });
  const curried = (handler, purpose) => ({
    cHandler: handler,
    purpose
  });
  const curryArgs = (descHandler, extraArgs) => curried(curry.apply(void 0, [descHandler.handler].concat(extraArgs)), descHandler.purpose);
  const getCurried = (descHandler) => descHandler.cHandler;
  const behaviourTuple = (name3, handler) => ({
    name: name3,
    handler
  });
  const nameToHandlers = (behaviours2, info) => {
    const r2 = {};
    each$1(behaviours2, (behaviour) => {
      r2[behaviour.name()] = behaviour.handlers(info);
    });
    return r2;
  };
  const groupByEvents = (info, behaviours2, base2) => {
    const behaviourEvents = {
      ...base2,
      ...nameToHandlers(behaviours2, info)
    };
    return byInnerKey(behaviourEvents, behaviourTuple);
  };
  const combine$1 = (info, eventOrder, behaviours2, base2) => {
    const byEventName = groupByEvents(info, behaviours2, base2);
    return combineGroups(byEventName, eventOrder);
  };
  const assemble = (rawHandler) => {
    const handler = read$2(rawHandler);
    return (component, simulatedEvent, ...rest) => {
      const args = [
        component,
        simulatedEvent
      ].concat(rest);
      if (handler.abort.apply(void 0, args)) {
        simulatedEvent.stop();
      } else if (handler.can.apply(void 0, args)) {
        handler.run.apply(void 0, args);
      }
    };
  };
  const missingOrderError = (eventName, tuples) => Result.error(["The event (" + eventName + ') has more than one behaviour that listens to it.\nWhen this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).\nThe behaviours that can trigger it are: ' + JSON.stringify(map$2(tuples, (c) => c.name), null, 2)]);
  const fuse = (tuples, eventOrder, eventName) => {
    const order2 = eventOrder[eventName];
    if (!order2) {
      return missingOrderError(eventName, tuples);
    } else {
      return sortKeys("Event: " + eventName, "name", tuples, order2).map((sortedTuples) => {
        const handlers2 = map$2(sortedTuples, (tuple) => tuple.handler);
        return fuse$1(handlers2);
      });
    }
  };
  const combineGroups = (byEventName, eventOrder) => {
    const r2 = mapToArray(byEventName, (tuples, eventName) => {
      const combined = tuples.length === 1 ? Result.value(tuples[0].handler) : fuse(tuples, eventOrder, eventName);
      return combined.map((handler) => {
        const assembled = assemble(handler);
        const purpose = tuples.length > 1 ? filter$2(eventOrder[eventName], (o) => exists(tuples, (t2) => t2.name === o)).join(" > ") : tuples[0].name;
        return wrap$1(eventName, uncurried(assembled, purpose));
      });
    });
    return consolidate(r2, {});
  };
  const baseBehaviour = "alloy.base.behaviour";
  const schema$z = objOf([
    field$1("dom", "dom", required$2(), objOf([
      required$1("tag"),
      defaulted("styles", {}),
      defaulted("classes", []),
      defaulted("attributes", {}),
      option$3("value"),
      option$3("innerHtml")
    ])),
    required$1("components"),
    required$1("uid"),
    defaulted("events", {}),
    defaulted("apis", {}),
    field$1("eventOrder", "eventOrder", mergeWith({
      [execute$5()]: [
        "disabling",
        baseBehaviour,
        "toggling",
        "typeaheadevents"
      ],
      [focus$4()]: [
        baseBehaviour,
        "focusing",
        "keying"
      ],
      [systemInit()]: [
        baseBehaviour,
        "disabling",
        "toggling",
        "representing"
      ],
      [input()]: [
        baseBehaviour,
        "representing",
        "streaming",
        "invalidating"
      ],
      [detachedFromDom()]: [
        baseBehaviour,
        "representing",
        "item-events",
        "tooltipping"
      ],
      [mousedown()]: [
        "focusing",
        baseBehaviour,
        "item-type-events"
      ],
      [touchstart()]: [
        "focusing",
        baseBehaviour,
        "item-type-events"
      ],
      [mouseover()]: [
        "item-type-events",
        "tooltipping"
      ],
      [receive()]: [
        "receiving",
        "reflecting",
        "tooltipping"
      ]
    }), anyValue()),
    option$3("domModification")
  ]);
  const toInfo = (spec) => asRaw("custom.definition", schema$z, spec);
  const toDefinition = (detail) => ({
    ...detail.dom,
    uid: detail.uid,
    domChildren: map$2(detail.components, (comp) => comp.element)
  });
  const toModification = (detail) => detail.domModification.fold(() => nu$7({}), nu$7);
  const toEvents = (info) => info.events;
  const read2 = (element2, attr2) => {
    const value2 = get$f(element2, attr2);
    return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
  };
  const add$4 = (element2, attr2, id) => {
    const old = read2(element2, attr2);
    const nu2 = old.concat([id]);
    set$9(element2, attr2, nu2.join(" "));
    return true;
  };
  const remove$4 = (element2, attr2, id) => {
    const nu2 = filter$2(read2(element2, attr2), (v) => v !== id);
    if (nu2.length > 0) {
      set$9(element2, attr2, nu2.join(" "));
    } else {
      remove$7(element2, attr2);
    }
    return false;
  };
  const supports = (element2) => element2.dom.classList !== void 0;
  const get$8 = (element2) => read2(element2, "class");
  const add$3 = (element2, clazz) => add$4(element2, "class", clazz);
  const remove$3 = (element2, clazz) => remove$4(element2, "class", clazz);
  const add$2 = (element2, clazz) => {
    if (supports(element2)) {
      element2.dom.classList.add(clazz);
    } else {
      add$3(element2, clazz);
    }
  };
  const cleanClass = (element2) => {
    const classList = supports(element2) ? element2.dom.classList : get$8(element2);
    if (classList.length === 0) {
      remove$7(element2, "class");
    }
  };
  const remove$2 = (element2, clazz) => {
    if (supports(element2)) {
      const classList = element2.dom.classList;
      classList.remove(clazz);
    } else {
      remove$3(element2, clazz);
    }
    cleanClass(element2);
  };
  const has = (element2, clazz) => supports(element2) && element2.dom.classList.contains(clazz);
  const add$1 = (element2, classes2) => {
    each$1(classes2, (x) => {
      add$2(element2, x);
    });
  };
  const remove$1 = (element2, classes2) => {
    each$1(classes2, (x) => {
      remove$2(element2, x);
    });
  };
  const hasAll = (element2, classes2) => forall(classes2, (clazz) => has(element2, clazz));
  const getNative = (element2) => {
    const classList = element2.dom.classList;
    const r2 = new Array(classList.length);
    for (let i = 0; i < classList.length; i++) {
      const item3 = classList.item(i);
      if (item3 !== null) {
        r2[i] = item3;
      }
    }
    return r2;
  };
  const get$7 = (element2) => supports(element2) ? getNative(element2) : get$8(element2);
  const get$6 = (element2) => element2.dom.value;
  const set$5 = (element2, value2) => {
    if (value2 === void 0) {
      throw new Error("Value.set was undefined");
    }
    element2.dom.value = value2;
  };
  const determineObsoleted = (parent2, index, oldObsoleted) => {
    const newObsoleted = child$2(parent2, index);
    return newObsoleted.map((newObs) => {
      const elemChanged = oldObsoleted.exists((o) => !eq(o, newObs));
      if (elemChanged) {
        const oldTag = oldObsoleted.map(name$3).getOr("span");
        const marker = SugarElement.fromTag(oldTag);
        before$1(newObs, marker);
        return marker;
      } else {
        return newObs;
      }
    });
  };
  const ensureInDom = (parent2, child2, obsoleted) => {
    obsoleted.fold(() => append$2(parent2, child2), (obs) => {
      if (!eq(obs, child2)) {
        before$1(obs, child2);
        remove$5(obs);
      }
    });
  };
  const patchChildrenWith = (parent2, nu2, f2) => {
    const builtChildren = map$2(nu2, f2);
    const currentChildren = children(parent2);
    each$1(currentChildren.slice(builtChildren.length), remove$5);
    return builtChildren;
  };
  const patchSpecChild = (parent2, index, spec, build2) => {
    const oldObsoleted = child$2(parent2, index);
    const childComp = build2(spec, oldObsoleted);
    const obsoleted = determineObsoleted(parent2, index, oldObsoleted);
    ensureInDom(parent2, childComp.element, obsoleted);
    return childComp;
  };
  const patchSpecChildren = (parent2, specs, build2) => patchChildrenWith(parent2, specs, (spec, index) => patchSpecChild(parent2, index, spec, build2));
  const patchDomChildren = (parent2, nodes) => patchChildrenWith(parent2, nodes, (node, index) => {
    const optObsoleted = child$2(parent2, index);
    ensureInDom(parent2, node, optObsoleted);
    return node;
  });
  const diffKeyValueSet = (newObj, oldObj) => {
    const newKeys = keys(newObj);
    const oldKeys = keys(oldObj);
    const toRemove = difference(oldKeys, newKeys);
    const toSet = bifilter(newObj, (v, k) => {
      return !has$2(oldObj, k) || v !== oldObj[k];
    }).t;
    return {
      toRemove,
      toSet
    };
  };
  const reconcileToDom = (definition, obsoleted) => {
    const {
      class: clazz,
      style,
      ...existingAttributes
    } = clone$2(obsoleted);
    const {
      toSet: attrsToSet,
      toRemove: attrsToRemove
    } = diffKeyValueSet(definition.attributes, existingAttributes);
    const updateAttrs = () => {
      each$1(attrsToRemove, (a) => remove$7(obsoleted, a));
      setAll$1(obsoleted, attrsToSet);
    };
    const existingStyles = getAllRaw(obsoleted);
    const {
      toSet: stylesToSet,
      toRemove: stylesToRemove
    } = diffKeyValueSet(definition.styles, existingStyles);
    const updateStyles = () => {
      each$1(stylesToRemove, (s) => remove$6(obsoleted, s));
      setAll(obsoleted, stylesToSet);
    };
    const existingClasses = get$7(obsoleted);
    const classesToRemove = difference(existingClasses, definition.classes);
    const classesToAdd = difference(definition.classes, existingClasses);
    const updateClasses = () => {
      add$1(obsoleted, classesToAdd);
      remove$1(obsoleted, classesToRemove);
    };
    const updateHtml = (html2) => {
      set$6(obsoleted, html2);
    };
    const updateChildren = () => {
      const children2 = definition.domChildren;
      patchDomChildren(obsoleted, children2);
    };
    const updateValue = () => {
      const valueElement = obsoleted;
      const value2 = definition.value.getOrUndefined();
      if (value2 !== get$6(valueElement)) {
        set$5(valueElement, value2 !== null && value2 !== void 0 ? value2 : "");
      }
    };
    updateAttrs();
    updateClasses();
    updateStyles();
    definition.innerHtml.fold(updateChildren, updateHtml);
    updateValue();
    return obsoleted;
  };
  const introduceToDom = (definition) => {
    const subject = SugarElement.fromTag(definition.tag);
    setAll$1(subject, definition.attributes);
    add$1(subject, definition.classes);
    setAll(subject, definition.styles);
    definition.innerHtml.each((html2) => set$6(subject, html2));
    const children2 = definition.domChildren;
    append$1(subject, children2);
    definition.value.each((value2) => {
      set$5(subject, value2);
    });
    return subject;
  };
  const attemptPatch = (definition, obsoleted) => {
    try {
      const e = reconcileToDom(definition, obsoleted);
      return Optional.some(e);
    } catch (err) {
      return Optional.none();
    }
  };
  const hasMixedChildren = (definition) => definition.innerHtml.isSome() && definition.domChildren.length > 0;
  const renderToDom = (definition, optObsoleted) => {
    const canBePatched = (candidate) => name$3(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);
    const elem = optObsoleted.filter(canBePatched).bind((obsoleted) => attemptPatch(definition, obsoleted)).getOrThunk(() => introduceToDom(definition));
    writeOnly(elem, definition.uid);
    return elem;
  };
  const getBehaviours$2 = (spec) => {
    const behaviours2 = get$g(spec, "behaviours").getOr({});
    return bind$3(keys(behaviours2), (name3) => {
      const behaviour = behaviours2[name3];
      return isNonNullable(behaviour) ? [behaviour.me] : [];
    });
  };
  const generateFrom = (spec, all3) => generateFrom$1(spec, all3);
  const generate$4 = (spec) => {
    const all3 = getBehaviours$2(spec);
    return generateFrom(spec, all3);
  };
  const getDomDefinition = (info, bList, bData) => {
    const definition = toDefinition(info);
    const infoModification = toModification(info);
    const baseModification = { "alloy.base.modification": infoModification };
    const modification = bList.length > 0 ? combine$2(bData, baseModification, bList, definition) : infoModification;
    return merge2(definition, modification);
  };
  const getEvents = (info, bList, bData) => {
    const baseEvents = { "alloy.base.behaviour": toEvents(info) };
    return combine$1(bData, info.eventOrder, bList, baseEvents).getOrDie();
  };
  const build$2 = (spec, obsoleted) => {
    const getMe = () => me;
    const systemApi = Cell(singleton$1);
    const info = getOrDie(toInfo(spec));
    const bBlob = generate$4(spec);
    const bList = getBehaviours$3(bBlob);
    const bData = getData$2(bBlob);
    const modDefinition = getDomDefinition(info, bList, bData);
    const item3 = renderToDom(modDefinition, obsoleted);
    const events2 = getEvents(info, bList, bData);
    const subcomponents = Cell(info.components);
    const connect = (newApi) => {
      systemApi.set(newApi);
    };
    const disconnect = () => {
      systemApi.set(NoContextApi(getMe));
    };
    const syncComponents = () => {
      const children$1 = children(item3);
      const subs2 = bind$3(children$1, (child2) => systemApi.get().getByDom(child2).fold(() => [], pure$2));
      subcomponents.set(subs2);
    };
    const config2 = (behaviour) => {
      const b2 = bData;
      const f2 = isFunction2(b2[behaviour.name()]) ? b2[behaviour.name()] : () => {
        throw new Error("Could not find " + behaviour.name() + " in " + JSON.stringify(spec, null, 2));
      };
      return f2();
    };
    const hasConfigured = (behaviour) => isFunction2(bData[behaviour.name()]);
    const getApis = () => info.apis;
    const readState = (behaviourName) => bData[behaviourName]().map((b2) => b2.state.readState()).getOr("not enabled");
    const me = {
      uid: spec.uid,
      getSystem: systemApi.get,
      config: config2,
      hasConfigured,
      spec,
      readState,
      getApis,
      connect,
      disconnect,
      element: item3,
      syncComponents,
      components: subcomponents.get,
      events: events2
    };
    return me;
  };
  const buildSubcomponents = (spec, obsoleted) => {
    const components2 = get$g(spec, "components").getOr([]);
    return obsoleted.fold(() => map$2(components2, build$1), (obs) => map$2(components2, (c, i) => {
      return buildOrPatch(c, child$2(obs, i));
    }));
  };
  const buildFromSpec = (userSpec, obsoleted) => {
    const {
      events: specEvents,
      ...spec
    } = make$8(userSpec);
    const components2 = buildSubcomponents(spec, obsoleted);
    const completeSpec = {
      ...spec,
      events: {
        ...DefaultEvents,
        ...specEvents
      },
      components: components2
    };
    return Result.value(build$2(completeSpec, obsoleted));
  };
  const text$2 = (textContent) => {
    const element2 = SugarElement.fromText(textContent);
    return external$1({ element: element2 });
  };
  const external$1 = (spec) => {
    const extSpec = asRawOrDie$1("external.component", objOfOnly([
      required$1("element"),
      option$3("uid")
    ]), spec);
    const systemApi = Cell(NoContextApi());
    const connect = (newApi) => {
      systemApi.set(newApi);
    };
    const disconnect = () => {
      systemApi.set(NoContextApi(() => me));
    };
    const uid = extSpec.uid.getOrThunk(() => generate$5("external"));
    writeOnly(extSpec.element, uid);
    const me = {
      uid,
      getSystem: systemApi.get,
      config: Optional.none,
      hasConfigured: never,
      connect,
      disconnect,
      getApis: () => ({}),
      element: extSpec.element,
      spec,
      readState: constant$1("No state"),
      syncComponents: noop2,
      components: constant$1([]),
      events: {}
    };
    return premade$1(me);
  };
  const uids = generate$5;
  const isSketchSpec$1 = (spec) => has$2(spec, "uid");
  const buildOrPatch = (spec, obsoleted) => getPremade(spec).getOrThunk(() => {
    const userSpecWithUid = isSketchSpec$1(spec) ? spec : {
      uid: uids(""),
      ...spec
    };
    return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();
  });
  const build$1 = (spec) => buildOrPatch(spec, Optional.none());
  const premade = premade$1;
  var ClosestOrAncestor = (is2, ancestor2, scope, a, isRoot) => {
    if (is2(scope, a)) {
      return Optional.some(scope);
    } else if (isFunction2(isRoot) && isRoot(scope)) {
      return Optional.none();
    } else {
      return ancestor2(scope, a, isRoot);
    }
  };
  const ancestor$1 = (scope, predicate, isRoot) => {
    let element2 = scope.dom;
    const stop2 = isFunction2(isRoot) ? isRoot : never;
    while (element2.parentNode) {
      element2 = element2.parentNode;
      const el = SugarElement.fromDom(element2);
      if (predicate(el)) {
        return Optional.some(el);
      } else if (stop2(el)) {
        break;
      }
    }
    return Optional.none();
  };
  const closest$3 = (scope, predicate, isRoot) => {
    const is2 = (s, test) => test(s);
    return ClosestOrAncestor(is2, ancestor$1, scope, predicate, isRoot);
  };
  const child$1 = (scope, predicate) => {
    const pred = (node) => predicate(SugarElement.fromDom(node));
    const result = find$5(scope.dom.childNodes, pred);
    return result.map(SugarElement.fromDom);
  };
  const descendant$1 = (scope, predicate) => {
    const descend = (node) => {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child2 = SugarElement.fromDom(node.childNodes[i]);
        if (predicate(child2)) {
          return Optional.some(child2);
        }
        const res2 = descend(node.childNodes[i]);
        if (res2.isSome()) {
          return res2;
        }
      }
      return Optional.none();
    };
    return descend(scope.dom);
  };
  const closest$2 = (scope, predicate, isRoot) => closest$3(scope, predicate, isRoot).isSome();
  const ancestor = (scope, selector, isRoot) => ancestor$1(scope, (e) => is(e, selector), isRoot);
  const child = (scope, selector) => child$1(scope, (e) => is(e, selector));
  const descendant = (scope, selector) => one(selector, scope);
  const closest$1 = (scope, selector, isRoot) => {
    const is$12 = (element2, selector2) => is(element2, selector2);
    return ClosestOrAncestor(is$12, ancestor, scope, selector, isRoot);
  };
  const attribute = "aria-controls";
  const find$1 = (queryElem) => {
    const dependent = closest$3(queryElem, (elem) => {
      if (!isElement$12(elem)) {
        return false;
      }
      const id = get$f(elem, "id");
      return id !== void 0 && id.indexOf(attribute) > -1;
    });
    return dependent.bind((dep) => {
      const id = get$f(dep, "id");
      const dos = getRootNode2(dep);
      return descendant(dos, `[${attribute}="${id}"]`);
    });
  };
  const manager = () => {
    const ariaId = generate$6(attribute);
    const link = (elem) => {
      set$9(elem, attribute, ariaId);
    };
    const unlink = (elem) => {
      remove$7(elem, attribute);
    };
    return {
      id: ariaId,
      link,
      unlink
    };
  };
  const isAriaPartOf = (component, queryElem) => find$1(queryElem).exists((owner2) => isPartOf$1(component, owner2));
  const isPartOf$1 = (component, queryElem) => closest$2(queryElem, (el) => eq(el, component.element), never) || isAriaPartOf(component, queryElem);
  const unknown = "unknown";
  var EventConfiguration;
  (function(EventConfiguration2) {
    EventConfiguration2[EventConfiguration2["STOP"] = 0] = "STOP";
    EventConfiguration2[EventConfiguration2["NORMAL"] = 1] = "NORMAL";
    EventConfiguration2[EventConfiguration2["LOGGING"] = 2] = "LOGGING";
  })(EventConfiguration || (EventConfiguration = {}));
  const eventConfig = Cell({});
  const makeEventLogger = (eventName, initialTarget2) => {
    const sequence2 = [];
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    return {
      logEventCut: (_name, target, purpose) => {
        sequence2.push({
          outcome: "cut",
          target,
          purpose
        });
      },
      logEventStopped: (_name, target, purpose) => {
        sequence2.push({
          outcome: "stopped",
          target,
          purpose
        });
      },
      logNoParent: (_name, target, purpose) => {
        sequence2.push({
          outcome: "no-parent",
          target,
          purpose
        });
      },
      logEventNoHandlers: (_name, target) => {
        sequence2.push({
          outcome: "no-handlers-left",
          target
        });
      },
      logEventResponse: (_name, target, purpose) => {
        sequence2.push({
          outcome: "response",
          purpose,
          target
        });
      },
      write: () => {
        const finishTime = (/* @__PURE__ */ new Date()).getTime();
        if (contains$2([
          "mousemove",
          "mouseover",
          "mouseout",
          systemInit()
        ], eventName)) {
          return;
        }
        console.log(eventName, {
          event: eventName,
          time: finishTime - startTime,
          target: initialTarget2.dom,
          sequence: map$2(sequence2, (s) => {
            if (!contains$2([
              "cut",
              "stopped",
              "response"
            ], s.outcome)) {
              return s.outcome;
            } else {
              return "{" + s.purpose + "} " + s.outcome + " at (" + element(s.target) + ")";
            }
          })
        });
      }
    };
  };
  const processEvent = (eventName, initialTarget2, f2) => {
    const status = get$g(eventConfig.get(), eventName).orThunk(() => {
      const patterns = keys(eventConfig.get());
      return findMap(patterns, (p) => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());
    }).getOr(EventConfiguration.NORMAL);
    switch (status) {
      case EventConfiguration.NORMAL:
        return f2(noLogger());
      case EventConfiguration.LOGGING: {
        const logger = makeEventLogger(eventName, initialTarget2);
        const output2 = f2(logger);
        logger.write();
        return output2;
      }
      case EventConfiguration.STOP:
        return true;
    }
  };
  const path = [
    "alloy/data/Fields",
    "alloy/debugging/Debugging"
  ];
  const getTrace = () => {
    const err = new Error();
    if (err.stack !== void 0) {
      const lines = err.stack.split("\n");
      return find$5(lines, (line) => line.indexOf("alloy") > 0 && !exists(path, (p) => line.indexOf(p) > -1)).getOr(unknown);
    } else {
      return unknown;
    }
  };
  const ignoreEvent = {
    logEventCut: noop2,
    logEventStopped: noop2,
    logNoParent: noop2,
    logEventNoHandlers: noop2,
    logEventResponse: noop2,
    write: noop2
  };
  const monitorEvent = (eventName, initialTarget2, f2) => processEvent(eventName, initialTarget2, f2);
  const noLogger = constant$1(ignoreEvent);
  const menuFields = constant$1([
    required$1("menu"),
    required$1("selectedMenu")
  ]);
  const itemFields = constant$1([
    required$1("item"),
    required$1("selectedItem")
  ]);
  constant$1(objOf(itemFields().concat(menuFields())));
  const itemSchema$3 = constant$1(objOf(itemFields()));
  const _initSize = requiredObjOf("initSize", [
    required$1("numColumns"),
    required$1("numRows")
  ]);
  const itemMarkers = () => requiredOf("markers", itemSchema$3());
  const tieredMenuMarkers = () => requiredObjOf("markers", [required$1("backgroundMenu")].concat(menuFields()).concat(itemFields()));
  const markers$1 = (required2) => requiredObjOf("markers", map$2(required2, required$1));
  const onPresenceHandler = (label2, fieldName, presence) => {
    getTrace();
    return field$1(fieldName, fieldName, presence, valueOf((f2) => Result.value((...args) => {
      return f2.apply(void 0, args);
    })));
  };
  const onHandler = (fieldName) => onPresenceHandler("onHandler", fieldName, defaulted$1(noop2));
  const onKeyboardHandler = (fieldName) => onPresenceHandler("onKeyboardHandler", fieldName, defaulted$1(Optional.none));
  const onStrictHandler = (fieldName) => onPresenceHandler("onHandler", fieldName, required$2());
  const onStrictKeyboardHandler = (fieldName) => onPresenceHandler("onKeyboardHandler", fieldName, required$2());
  const output$1 = (name3, value2) => customField(name3, constant$1(value2));
  const snapshot = (name3) => customField(name3, identity);
  const initSize = constant$1(_initSize);
  const nu$6 = (x, y, bubble, direction, placement2, boundsRestriction2, labelPrefix2, alwaysFit = false) => ({
    x,
    y,
    bubble,
    direction,
    placement: placement2,
    restriction: boundsRestriction2,
    label: `${labelPrefix2}-${placement2}`,
    alwaysFit
  });
  const adt$a = Adt.generate([
    { southeast: [] },
    { southwest: [] },
    { northeast: [] },
    { northwest: [] },
    { south: [] },
    { north: [] },
    { east: [] },
    { west: [] }
  ]);
  const cata$2 = (subject, southeast2, southwest2, northeast2, northwest2, south2, north2, east2, west2) => subject.fold(southeast2, southwest2, northeast2, northwest2, south2, north2, east2, west2);
  const cataVertical = (subject, south2, middle, north2) => subject.fold(south2, south2, north2, north2, south2, north2, middle, middle);
  const cataHorizontal = (subject, east2, middle, west2) => subject.fold(east2, west2, east2, west2, middle, middle, east2, west2);
  const southeast$3 = adt$a.southeast;
  const southwest$3 = adt$a.southwest;
  const northeast$3 = adt$a.northeast;
  const northwest$3 = adt$a.northwest;
  const south$3 = adt$a.south;
  const north$3 = adt$a.north;
  const east$3 = adt$a.east;
  const west$3 = adt$a.west;
  const cycleBy = (value2, delta, min3, max3) => {
    const r2 = value2 + delta;
    if (r2 > max3) {
      return min3;
    } else if (r2 < min3) {
      return max3;
    } else {
      return r2;
    }
  };
  const clamp = (value2, min3, max3) => Math.min(Math.max(value2, min3), max3);
  const getRestriction = (anchor2, restriction) => {
    switch (restriction) {
      case 1:
        return anchor2.x;
      case 0:
        return anchor2.x + anchor2.width;
      case 2:
        return anchor2.y;
      case 3:
        return anchor2.y + anchor2.height;
    }
  };
  const boundsRestriction = (anchor2, restrictions) => mapToObject([
    "left",
    "right",
    "top",
    "bottom"
  ], (dir) => get$g(restrictions, dir).map((restriction) => getRestriction(anchor2, restriction)));
  const adjustBounds = (bounds$12, restriction, bubbleOffset) => {
    const applyRestriction = (dir, current) => restriction[dir].map((pos) => {
      const isVerticalAxis = dir === "top" || dir === "bottom";
      const offset3 = isVerticalAxis ? bubbleOffset.top : bubbleOffset.left;
      const comparator = dir === "left" || dir === "top" ? Math.max : Math.min;
      const newPos = comparator(pos, current) + offset3;
      return isVerticalAxis ? clamp(newPos, bounds$12.y, bounds$12.bottom) : clamp(newPos, bounds$12.x, bounds$12.right);
    }).getOr(current);
    const adjustedLeft = applyRestriction("left", bounds$12.x);
    const adjustedTop = applyRestriction("top", bounds$12.y);
    const adjustedRight = applyRestriction("right", bounds$12.right);
    const adjustedBottom = applyRestriction("bottom", bounds$12.bottom);
    return bounds(adjustedLeft, adjustedTop, adjustedRight - adjustedLeft, adjustedBottom - adjustedTop);
  };
  const labelPrefix$2 = "layout";
  const eastX$1 = (anchor2) => anchor2.x;
  const middleX$1 = (anchor2, element2) => anchor2.x + anchor2.width / 2 - element2.width / 2;
  const westX$1 = (anchor2, element2) => anchor2.x + anchor2.width - element2.width;
  const northY$2 = (anchor2, element2) => anchor2.y - element2.height;
  const southY$2 = (anchor2) => anchor2.y + anchor2.height;
  const centreY$1 = (anchor2, element2) => anchor2.y + anchor2.height / 2 - element2.height / 2;
  const eastEdgeX$1 = (anchor2) => anchor2.x + anchor2.width;
  const westEdgeX$1 = (anchor2, element2) => anchor2.x - element2.width;
  const southeast$2 = (anchor2, element2, bubbles) => nu$6(eastX$1(anchor2), southY$2(anchor2), bubbles.southeast(), southeast$3(), "southeast", boundsRestriction(anchor2, {
    left: 1,
    top: 3
  }), labelPrefix$2);
  const southwest$2 = (anchor2, element2, bubbles) => nu$6(westX$1(anchor2, element2), southY$2(anchor2), bubbles.southwest(), southwest$3(), "southwest", boundsRestriction(anchor2, {
    right: 0,
    top: 3
  }), labelPrefix$2);
  const northeast$2 = (anchor2, element2, bubbles) => nu$6(eastX$1(anchor2), northY$2(anchor2, element2), bubbles.northeast(), northeast$3(), "northeast", boundsRestriction(anchor2, {
    left: 1,
    bottom: 2
  }), labelPrefix$2);
  const northwest$2 = (anchor2, element2, bubbles) => nu$6(westX$1(anchor2, element2), northY$2(anchor2, element2), bubbles.northwest(), northwest$3(), "northwest", boundsRestriction(anchor2, {
    right: 0,
    bottom: 2
  }), labelPrefix$2);
  const north$2 = (anchor2, element2, bubbles) => nu$6(middleX$1(anchor2, element2), northY$2(anchor2, element2), bubbles.north(), north$3(), "north", boundsRestriction(anchor2, { bottom: 2 }), labelPrefix$2);
  const south$2 = (anchor2, element2, bubbles) => nu$6(middleX$1(anchor2, element2), southY$2(anchor2), bubbles.south(), south$3(), "south", boundsRestriction(anchor2, { top: 3 }), labelPrefix$2);
  const east$2 = (anchor2, element2, bubbles) => nu$6(eastEdgeX$1(anchor2), centreY$1(anchor2, element2), bubbles.east(), east$3(), "east", boundsRestriction(anchor2, { left: 0 }), labelPrefix$2);
  const west$2 = (anchor2, element2, bubbles) => nu$6(westEdgeX$1(anchor2, element2), centreY$1(anchor2, element2), bubbles.west(), west$3(), "west", boundsRestriction(anchor2, { right: 1 }), labelPrefix$2);
  const all$1 = () => [
    southeast$2,
    southwest$2,
    northeast$2,
    northwest$2,
    south$2,
    north$2,
    east$2,
    west$2
  ];
  const allRtl$1 = () => [
    southwest$2,
    southeast$2,
    northwest$2,
    northeast$2,
    south$2,
    north$2,
    east$2,
    west$2
  ];
  const aboveOrBelow = () => [
    northeast$2,
    northwest$2,
    southeast$2,
    southwest$2,
    north$2,
    south$2
  ];
  const aboveOrBelowRtl = () => [
    northwest$2,
    northeast$2,
    southwest$2,
    southeast$2,
    north$2,
    south$2
  ];
  const belowOrAbove = () => [
    southeast$2,
    southwest$2,
    northeast$2,
    northwest$2,
    south$2,
    north$2
  ];
  const belowOrAboveRtl = () => [
    southwest$2,
    southeast$2,
    northwest$2,
    northeast$2,
    south$2,
    north$2
  ];
  const chooseChannels = (channels, message) => message.universal ? channels : filter$2(channels, (ch) => contains$2(message.channels, ch));
  const events$h = (receiveConfig) => derive$2([run$1(receive(), (component, message) => {
    const channelMap = receiveConfig.channels;
    const channels = keys(channelMap);
    const receivingData = message;
    const targetChannels = chooseChannels(channels, receivingData);
    each$1(targetChannels, (ch) => {
      const channelInfo = channelMap[ch];
      const channelSchema = channelInfo.schema;
      const data2 = asRawOrDie$1("channel[" + ch + "] data\nReceiver: " + element(component.element), channelSchema, receivingData.data);
      channelInfo.onReceive(component, data2);
    });
  })]);
  var ActiveReceiving = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$h
  });
  var ReceivingSchema = [requiredOf("channels", setOf(Result.value, objOfOnly([
    onStrictHandler("onReceive"),
    defaulted("schema", anyValue())
  ])))];
  const executeEvent = (bConfig, bState, executor) => runOnExecute$1((component) => {
    executor(component, bConfig, bState);
  });
  const loadEvent = (bConfig, bState, f2) => runOnInit((component, _simulatedEvent) => {
    f2(component, bConfig, bState);
  });
  const create$52 = (schema2, name3, active2, apis2, extra, state2) => {
    const configSchema = objOfOnly(schema2);
    const schemaSchema = optionObjOf(name3, [optionObjOfOnly("config", schema2)]);
    return doCreate(configSchema, schemaSchema, name3, active2, apis2, extra, state2);
  };
  const createModes$1 = (modes, name3, active2, apis2, extra, state2) => {
    const configSchema = modes;
    const schemaSchema = optionObjOf(name3, [optionOf("config", modes)]);
    return doCreate(configSchema, schemaSchema, name3, active2, apis2, extra, state2);
  };
  const wrapApi = (bName, apiFunction, apiName) => {
    const f2 = (component, ...rest) => {
      const args = [component].concat(rest);
      return component.config({ name: constant$1(bName) }).fold(() => {
        throw new Error("We could not find any behaviour configuration for: " + bName + ". Using API: " + apiName);
      }, (info) => {
        const rest2 = Array.prototype.slice.call(args, 1);
        return apiFunction.apply(void 0, [
          component,
          info.config,
          info.state
        ].concat(rest2));
      });
    };
    return markAsBehaviourApi(f2, apiName, apiFunction);
  };
  const revokeBehaviour = (name3) => ({
    key: name3,
    value: void 0
  });
  const doCreate = (configSchema, schemaSchema, name3, active2, apis2, extra, state2) => {
    const getConfig = (info) => hasNonNullableKey(info, name3) ? info[name3]() : Optional.none();
    const wrappedApis = map$1(apis2, (apiF, apiName) => wrapApi(name3, apiF, apiName));
    const wrappedExtra = map$1(extra, (extraF, extraName) => markAsExtraApi(extraF, extraName));
    const me = {
      ...wrappedExtra,
      ...wrappedApis,
      revoke: curry(revokeBehaviour, name3),
      config: (spec) => {
        const prepared = asRawOrDie$1(name3 + "-config", configSchema, spec);
        return {
          key: name3,
          value: {
            config: prepared,
            me,
            configAsRaw: cached(() => asRawOrDie$1(name3 + "-config", configSchema, spec)),
            initialConfig: spec,
            state: state2
          }
        };
      },
      schema: constant$1(schemaSchema),
      exhibit: (info, base2) => {
        return lift2(getConfig(info), get$g(active2, "exhibit"), (behaviourInfo, exhibitor) => {
          return exhibitor(base2, behaviourInfo.config, behaviourInfo.state);
        }).getOrThunk(() => nu$7({}));
      },
      name: constant$1(name3),
      handlers: (info) => {
        return getConfig(info).map((behaviourInfo) => {
          const getEvents2 = get$g(active2, "events").getOr(() => ({}));
          return getEvents2(behaviourInfo.config, behaviourInfo.state);
        }).getOr({});
      }
    };
    return me;
  };
  const derive$1 = (capabilities) => wrapAll(capabilities);
  const simpleSchema = objOfOnly([
    required$1("fields"),
    required$1("name"),
    defaulted("active", {}),
    defaulted("apis", {}),
    defaulted("state", NoState),
    defaulted("extra", {})
  ]);
  const create$42 = (data2) => {
    const value2 = asRawOrDie$1("Creating behaviour: " + data2.name, simpleSchema, data2);
    return create$52(value2.fields, value2.name, value2.active, value2.apis, value2.extra, value2.state);
  };
  const modeSchema = objOfOnly([
    required$1("branchKey"),
    required$1("branches"),
    required$1("name"),
    defaulted("active", {}),
    defaulted("apis", {}),
    defaulted("state", NoState),
    defaulted("extra", {})
  ]);
  const createModes = (data2) => {
    const value2 = asRawOrDie$1("Creating behaviour: " + data2.name, modeSchema, data2);
    return createModes$1(choose$1(value2.branchKey, value2.branches), value2.name, value2.active, value2.apis, value2.extra, value2.state);
  };
  const revoke = constant$1(void 0);
  const Receiving = create$42({
    fields: ReceivingSchema,
    name: "receiving",
    active: ActiveReceiving
  });
  const exhibit$6 = (base2, posConfig) => nu$7({
    classes: [],
    styles: posConfig.useFixed() ? {} : { position: "relative" }
  });
  var ActivePosition = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: exhibit$6
  });
  const focus$3 = (element2) => element2.dom.focus();
  const blur$1 = (element2) => element2.dom.blur();
  const hasFocus = (element2) => {
    const root2 = getRootNode2(element2).dom;
    return element2.dom === root2.activeElement;
  };
  const active$1 = (root2 = getDocument()) => Optional.from(root2.dom.activeElement).map(SugarElement.fromDom);
  const search = (element2) => active$1(getRootNode2(element2)).filter((e) => element2.dom.contains(e.dom));
  const preserve$1 = (f2, container) => {
    const dos = getRootNode2(container);
    const refocus = active$1(dos).bind((focused) => {
      const hasFocus2 = (elem) => eq(focused, elem);
      return hasFocus2(container) ? Optional.some(container) : descendant$1(container, hasFocus2);
    });
    const result = f2(container);
    refocus.each((oldFocus) => {
      active$1(dos).filter((newFocus) => eq(newFocus, oldFocus)).fold(() => {
        focus$3(oldFocus);
      }, noop2);
    });
    return result;
  };
  const NuPositionCss = (position2, left3, top3, right3, bottom3) => {
    const toPx = (num) => num + "px";
    return {
      position: position2,
      left: left3.map(toPx),
      top: top3.map(toPx),
      right: right3.map(toPx),
      bottom: bottom3.map(toPx)
    };
  };
  const toOptions = (position2) => ({
    ...position2,
    position: Optional.some(position2.position)
  });
  const applyPositionCss = (element2, position2) => {
    setOptions2(element2, toOptions(position2));
  };
  const adt$9 = Adt.generate([
    { none: [] },
    {
      relative: [
        "x",
        "y",
        "width",
        "height"
      ]
    },
    {
      fixed: [
        "x",
        "y",
        "width",
        "height"
      ]
    }
  ]);
  const positionWithDirection = (posName, decision, x, y, width3, height3) => {
    const decisionRect = decision.rect;
    const decisionX = decisionRect.x - x;
    const decisionY = decisionRect.y - y;
    const decisionWidth = decisionRect.width;
    const decisionHeight = decisionRect.height;
    const decisionRight = width3 - (decisionX + decisionWidth);
    const decisionBottom = height3 - (decisionY + decisionHeight);
    const left3 = Optional.some(decisionX);
    const top3 = Optional.some(decisionY);
    const right3 = Optional.some(decisionRight);
    const bottom3 = Optional.some(decisionBottom);
    const none = Optional.none();
    return cata$2(decision.direction, () => NuPositionCss(posName, left3, top3, none, none), () => NuPositionCss(posName, none, top3, right3, none), () => NuPositionCss(posName, left3, none, none, bottom3), () => NuPositionCss(posName, none, none, right3, bottom3), () => NuPositionCss(posName, left3, top3, none, none), () => NuPositionCss(posName, left3, none, none, bottom3), () => NuPositionCss(posName, left3, top3, none, none), () => NuPositionCss(posName, none, top3, right3, none));
  };
  const reposition = (origin, decision) => origin.fold(() => {
    const decisionRect = decision.rect;
    return NuPositionCss("absolute", Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
  }, (x, y, width3, height3) => {
    return positionWithDirection("absolute", decision, x, y, width3, height3);
  }, (x, y, width3, height3) => {
    return positionWithDirection("fixed", decision, x, y, width3, height3);
  });
  const toBox = (origin, element2) => {
    const rel = curry(find$2, element2);
    const position2 = origin.fold(rel, rel, () => {
      const scroll = get$b();
      return find$2(element2).translate(-scroll.left, -scroll.top);
    });
    const width3 = getOuter$1(element2);
    const height3 = getOuter$2(element2);
    return bounds(position2.left, position2.top, width3, height3);
  };
  const viewport2 = (origin, optBounds) => optBounds.fold(() => origin.fold(win, win, bounds), (bounds$12) => origin.fold(constant$1(bounds$12), constant$1(bounds$12), () => {
    const pos = translate$2(origin, bounds$12.x, bounds$12.y);
    return bounds(pos.left, pos.top, bounds$12.width, bounds$12.height);
  }));
  const translate$2 = (origin, x, y) => {
    const pos = SugarPosition(x, y);
    const removeScroll = () => {
      const outerScroll = get$b();
      return pos.translate(-outerScroll.left, -outerScroll.top);
    };
    return origin.fold(constant$1(pos), constant$1(pos), removeScroll);
  };
  const cata$1 = (subject, onNone, onRelative, onFixed) => subject.fold(onNone, onRelative, onFixed);
  adt$9.none;
  const relative$1 = adt$9.relative;
  const fixed$1 = adt$9.fixed;
  const anchor = (anchorBox, origin) => ({
    anchorBox,
    origin
  });
  const box = (anchorBox, origin) => anchor(anchorBox, origin);
  const placementAttribute = "data-alloy-placement";
  const setPlacement$1 = (element2, placement2) => {
    set$9(element2, placementAttribute, placement2);
  };
  const getPlacement = (element2) => getOpt(element2, placementAttribute);
  const reset$2 = (element2) => remove$7(element2, placementAttribute);
  const adt$8 = Adt.generate([
    { fit: ["reposition"] },
    {
      nofit: [
        "reposition",
        "visibleW",
        "visibleH",
        "isVisible"
      ]
    }
  ]);
  const determinePosition = (box2, bounds2) => {
    const {
      x: boundsX,
      y: boundsY,
      right: boundsRight,
      bottom: boundsBottom
    } = bounds2;
    const { x, y, right: right3, bottom: bottom3, width: width3, height: height3 } = box2;
    const xInBounds = x >= boundsX && x <= boundsRight;
    const yInBounds = y >= boundsY && y <= boundsBottom;
    const originInBounds = xInBounds && yInBounds;
    const rightInBounds = right3 <= boundsRight && right3 >= boundsX;
    const bottomInBounds = bottom3 <= boundsBottom && bottom3 >= boundsY;
    const sizeInBounds = rightInBounds && bottomInBounds;
    const visibleW = Math.min(width3, x >= boundsX ? boundsRight - x : right3 - boundsX);
    const visibleH = Math.min(height3, y >= boundsY ? boundsBottom - y : bottom3 - boundsY);
    return {
      originInBounds,
      sizeInBounds,
      visibleW,
      visibleH
    };
  };
  const calcReposition = (box2, bounds$12) => {
    const {
      x: boundsX,
      y: boundsY,
      right: boundsRight,
      bottom: boundsBottom
    } = bounds$12;
    const { x, y, width: width3, height: height3 } = box2;
    const maxX2 = Math.max(boundsX, boundsRight - width3);
    const maxY2 = Math.max(boundsY, boundsBottom - height3);
    const restrictedX = clamp(x, boundsX, maxX2);
    const restrictedY = clamp(y, boundsY, maxY2);
    const restrictedWidth = Math.min(restrictedX + width3, boundsRight) - restrictedX;
    const restrictedHeight = Math.min(restrictedY + height3, boundsBottom) - restrictedY;
    return bounds(restrictedX, restrictedY, restrictedWidth, restrictedHeight);
  };
  const calcMaxSizes = (direction, box2, bounds2) => {
    const upAvailable = constant$1(box2.bottom - bounds2.y);
    const downAvailable = constant$1(bounds2.bottom - box2.y);
    const maxHeight = cataVertical(direction, downAvailable, downAvailable, upAvailable);
    const westAvailable = constant$1(box2.right - bounds2.x);
    const eastAvailable = constant$1(bounds2.right - box2.x);
    const maxWidth = cataHorizontal(direction, eastAvailable, eastAvailable, westAvailable);
    return {
      maxWidth,
      maxHeight
    };
  };
  const attempt = (candidate, width3, height3, bounds$12) => {
    const bubble = candidate.bubble;
    const bubbleOffset = bubble.offset;
    const adjustedBounds = adjustBounds(bounds$12, candidate.restriction, bubbleOffset);
    const newX = candidate.x + bubbleOffset.left;
    const newY = candidate.y + bubbleOffset.top;
    const box2 = bounds(newX, newY, width3, height3);
    const { originInBounds, sizeInBounds, visibleW, visibleH } = determinePosition(box2, adjustedBounds);
    const fits = originInBounds && sizeInBounds;
    const fittedBox = fits ? box2 : calcReposition(box2, adjustedBounds);
    const isPartlyVisible = fittedBox.width > 0 && fittedBox.height > 0;
    const { maxWidth, maxHeight } = calcMaxSizes(candidate.direction, fittedBox, bounds$12);
    const reposition2 = {
      rect: fittedBox,
      maxHeight,
      maxWidth,
      direction: candidate.direction,
      placement: candidate.placement,
      classes: {
        on: bubble.classesOn,
        off: bubble.classesOff
      },
      layout: candidate.label,
      testY: newY
    };
    return fits || candidate.alwaysFit ? adt$8.fit(reposition2) : adt$8.nofit(reposition2, visibleW, visibleH, isPartlyVisible);
  };
  const attempts = (element2, candidates, anchorBox, elementBox, bubbles, bounds2) => {
    const panelWidth = elementBox.width;
    const panelHeight = elementBox.height;
    const attemptBestFit = (layout2, reposition2, visibleW, visibleH, isVisible3) => {
      const next = layout2(anchorBox, elementBox, bubbles, element2, bounds2);
      const attemptLayout = attempt(next, panelWidth, panelHeight, bounds2);
      return attemptLayout.fold(constant$1(attemptLayout), (newReposition, newVisibleW, newVisibleH, newIsVisible) => {
        const improved = isVisible3 === newIsVisible ? newVisibleH > visibleH || newVisibleW > visibleW : !isVisible3 && newIsVisible;
        return improved ? attemptLayout : adt$8.nofit(reposition2, visibleW, visibleH, isVisible3);
      });
    };
    const abc = foldl(candidates, (b2, a) => {
      const bestNext = curry(attemptBestFit, a);
      return b2.fold(constant$1(b2), bestNext);
    }, adt$8.nofit({
      rect: anchorBox,
      maxHeight: elementBox.height,
      maxWidth: elementBox.width,
      direction: southeast$3(),
      placement: "southeast",
      classes: {
        on: [],
        off: []
      },
      layout: "none",
      testY: anchorBox.y
    }, -1, -1, false));
    return abc.fold(identity, identity);
  };
  const singleton = (doRevoke) => {
    const subject = Cell(Optional.none());
    const revoke2 = () => subject.get().each(doRevoke);
    const clear3 = () => {
      revoke2();
      subject.set(Optional.none());
    };
    const isSet = () => subject.get().isSome();
    const get2 = () => subject.get();
    const set2 = (s) => {
      revoke2();
      subject.set(Optional.some(s));
    };
    return {
      clear: clear3,
      isSet,
      get: get2,
      set: set2
    };
  };
  const destroyable = () => singleton((s) => s.destroy());
  const unbindable = () => singleton((s) => s.unbind());
  const value$2 = () => {
    const subject = singleton(noop2);
    const on3 = (f2) => subject.get().each(f2);
    return {
      ...subject,
      on: on3
    };
  };
  const filter2 = always;
  const bind2 = (element2, event, handler) => bind$2(element2, event, filter2, handler);
  const capture = (element2, event, handler) => capture$1(element2, event, filter2, handler);
  const fromRawEvent = fromRawEvent$1;
  const properties = [
    "top",
    "bottom",
    "right",
    "left"
  ];
  const timerAttr = "data-alloy-transition-timer";
  const isTransitioning$1 = (element2, transition) => hasAll(element2, transition.classes);
  const shouldApplyTransitionCss = (transition, decision, lastPlacement) => {
    return lastPlacement.exists((placer) => {
      const mode = transition.mode;
      return mode === "all" ? true : placer[mode] !== decision[mode];
    });
  };
  const hasChanges = (position2, intermediate) => {
    const round3 = (value2) => parseFloat(value2).toFixed(3);
    return find$4(intermediate, (value2, key) => {
      const newValue = position2[key].map(round3);
      const val = value2.map(round3);
      return !equals(newValue, val);
    }).isSome();
  };
  const getTransitionDuration = (element2) => {
    const get2 = (name3) => {
      const style = get$e(element2, name3);
      const times = style.split(/\s*,\s*/);
      return filter$2(times, isNotEmpty);
    };
    const parse3 = (value2) => {
      if (isString2(value2) && /^[\d.]+/.test(value2)) {
        const num = parseFloat(value2);
        return endsWith2(value2, "ms") ? num : num * 1e3;
      } else {
        return 0;
      }
    };
    const delay = get2("transition-delay");
    const duration = get2("transition-duration");
    return foldl(duration, (acc, dur, i) => {
      const time = parse3(delay[i]) + parse3(dur);
      return Math.max(acc, time);
    }, 0);
  };
  const setupTransitionListeners = (element2, transition) => {
    const transitionEnd = unbindable();
    const transitionCancel = unbindable();
    let timer;
    const isSourceTransition = (e) => {
      var _a;
      const pseudoElement = (_a = e.raw.pseudoElement) !== null && _a !== void 0 ? _a : "";
      return eq(e.target, element2) && isEmpty2(pseudoElement) && contains$2(properties, e.raw.propertyName);
    };
    const transitionDone = (e) => {
      if (isNullable(e) || isSourceTransition(e)) {
        transitionEnd.clear();
        transitionCancel.clear();
        const type2 = e === null || e === void 0 ? void 0 : e.raw.type;
        if (isNullable(type2) || type2 === transitionend()) {
          clearTimeout(timer);
          remove$7(element2, timerAttr);
          remove$1(element2, transition.classes);
        }
      }
    };
    const transitionStart = bind2(element2, transitionstart(), (e) => {
      if (isSourceTransition(e)) {
        transitionStart.unbind();
        transitionEnd.set(bind2(element2, transitionend(), transitionDone));
        transitionCancel.set(bind2(element2, transitioncancel(), transitionDone));
      }
    });
    const duration = getTransitionDuration(element2);
    requestAnimationFrame(() => {
      timer = setTimeout(transitionDone, duration + 17);
      set$9(element2, timerAttr, timer);
    });
  };
  const startTransitioning = (element2, transition) => {
    add$1(element2, transition.classes);
    getOpt(element2, timerAttr).each((timerId) => {
      clearTimeout(parseInt(timerId, 10));
      remove$7(element2, timerAttr);
    });
    setupTransitionListeners(element2, transition);
  };
  const applyTransitionCss = (element2, origin, position2, transition, decision, lastPlacement) => {
    const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
    if (shouldTransition || isTransitioning$1(element2, transition)) {
      set$8(element2, "position", position2.position);
      const rect2 = toBox(origin, element2);
      const intermediatePosition = reposition(origin, {
        ...decision,
        rect: rect2
      });
      const intermediateCssOptions = mapToObject(properties, (prop) => intermediatePosition[prop]);
      if (hasChanges(position2, intermediateCssOptions)) {
        setOptions2(element2, intermediateCssOptions);
        if (shouldTransition) {
          startTransitioning(element2, transition);
        }
        reflow2(element2);
      }
    } else {
      remove$1(element2, transition.classes);
    }
  };
  const elementSize = (p) => ({
    width: getOuter$1(p),
    height: getOuter$2(p)
  });
  const layout = (anchorBox, element2, bubbles, options) => {
    remove$6(element2, "max-height");
    remove$6(element2, "max-width");
    const elementBox = elementSize(element2);
    return attempts(element2, options.preference, anchorBox, elementBox, bubbles, options.bounds);
  };
  const setClasses = (element2, decision) => {
    const classInfo = decision.classes;
    remove$1(element2, classInfo.off);
    add$1(element2, classInfo.on);
  };
  const setHeight = (element2, decision, options) => {
    const maxHeightFunction = options.maxHeightFunction;
    maxHeightFunction(element2, decision.maxHeight);
  };
  const setWidth = (element2, decision, options) => {
    const maxWidthFunction = options.maxWidthFunction;
    maxWidthFunction(element2, decision.maxWidth);
  };
  const position$2 = (element2, decision, options) => {
    const positionCss = reposition(options.origin, decision);
    options.transition.each((transition) => {
      applyTransitionCss(element2, options.origin, positionCss, transition, decision, options.lastPlacement);
    });
    applyPositionCss(element2, positionCss);
  };
  const setPlacement = (element2, decision) => {
    setPlacement$1(element2, decision.placement);
  };
  const setMaxHeight = (element2, maxHeight) => {
    setMax$1(element2, Math.floor(maxHeight));
  };
  const anchored = constant$1((element2, available) => {
    setMaxHeight(element2, available);
    setAll(element2, {
      "overflow-x": "hidden",
      "overflow-y": "auto"
    });
  });
  const expandable$1 = constant$1((element2, available) => {
    setMaxHeight(element2, available);
  });
  const defaultOr = (options, key, dephault) => options[key] === void 0 ? dephault : options[key];
  const simple = (anchor2, element2, bubble, layouts2, lastPlacement, optBounds, overrideOptions, transition) => {
    const maxHeightFunction = defaultOr(overrideOptions, "maxHeightFunction", anchored());
    const maxWidthFunction = defaultOr(overrideOptions, "maxWidthFunction", noop2);
    const anchorBox = anchor2.anchorBox;
    const origin = anchor2.origin;
    const options = {
      bounds: viewport2(origin, optBounds),
      origin,
      preference: layouts2,
      maxHeightFunction,
      maxWidthFunction,
      lastPlacement,
      transition
    };
    return go(anchorBox, element2, bubble, options);
  };
  const go = (anchorBox, element2, bubble, options) => {
    const decision = layout(anchorBox, element2, bubble, options);
    position$2(element2, decision, options);
    setPlacement(element2, decision);
    setClasses(element2, decision);
    setHeight(element2, decision, options);
    setWidth(element2, decision, options);
    return {
      layout: decision.layout,
      placement: decision.placement
    };
  };
  const allAlignments = [
    "valignCentre",
    "alignLeft",
    "alignRight",
    "alignCentre",
    "top",
    "bottom",
    "left",
    "right",
    "inset"
  ];
  const nu$5 = (xOffset, yOffset, classes2, insetModifier = 1) => {
    const insetXOffset = xOffset * insetModifier;
    const insetYOffset = yOffset * insetModifier;
    const getClasses2 = (prop) => get$g(classes2, prop).getOr([]);
    const make2 = (xDelta, yDelta, alignmentsOn) => {
      const alignmentsOff = difference(allAlignments, alignmentsOn);
      return {
        offset: SugarPosition(xDelta, yDelta),
        classesOn: bind$3(alignmentsOn, getClasses2),
        classesOff: bind$3(alignmentsOff, getClasses2)
      };
    };
    return {
      southeast: () => make2(-xOffset, yOffset, [
        "top",
        "alignLeft"
      ]),
      southwest: () => make2(xOffset, yOffset, [
        "top",
        "alignRight"
      ]),
      south: () => make2(-xOffset / 2, yOffset, [
        "top",
        "alignCentre"
      ]),
      northeast: () => make2(-xOffset, -yOffset, [
        "bottom",
        "alignLeft"
      ]),
      northwest: () => make2(xOffset, -yOffset, [
        "bottom",
        "alignRight"
      ]),
      north: () => make2(-xOffset / 2, -yOffset, [
        "bottom",
        "alignCentre"
      ]),
      east: () => make2(xOffset, -yOffset / 2, [
        "valignCentre",
        "left"
      ]),
      west: () => make2(-xOffset, -yOffset / 2, [
        "valignCentre",
        "right"
      ]),
      insetNortheast: () => make2(insetXOffset, insetYOffset, [
        "top",
        "alignLeft",
        "inset"
      ]),
      insetNorthwest: () => make2(-insetXOffset, insetYOffset, [
        "top",
        "alignRight",
        "inset"
      ]),
      insetNorth: () => make2(-insetXOffset / 2, insetYOffset, [
        "top",
        "alignCentre",
        "inset"
      ]),
      insetSoutheast: () => make2(insetXOffset, -insetYOffset, [
        "bottom",
        "alignLeft",
        "inset"
      ]),
      insetSouthwest: () => make2(-insetXOffset, -insetYOffset, [
        "bottom",
        "alignRight",
        "inset"
      ]),
      insetSouth: () => make2(-insetXOffset / 2, -insetYOffset, [
        "bottom",
        "alignCentre",
        "inset"
      ]),
      insetEast: () => make2(-insetXOffset, -insetYOffset / 2, [
        "valignCentre",
        "right",
        "inset"
      ]),
      insetWest: () => make2(insetXOffset, -insetYOffset / 2, [
        "valignCentre",
        "left",
        "inset"
      ])
    };
  };
  const fallback = () => nu$5(0, 0, {});
  const nu$4 = identity;
  const onDirection = (isLtr, isRtl) => (element2) => getDirection(element2) === "rtl" ? isRtl : isLtr;
  const getDirection = (element2) => get$e(element2, "direction") === "rtl" ? "rtl" : "ltr";
  var AttributeValue;
  (function(AttributeValue2) {
    AttributeValue2["TopToBottom"] = "toptobottom";
    AttributeValue2["BottomToTop"] = "bottomtotop";
  })(AttributeValue || (AttributeValue = {}));
  const Attribute = "data-alloy-vertical-dir";
  const isBottomToTopDir = (el) => closest$2(el, (current) => isElement$12(current) && get$f(current, "data-alloy-vertical-dir") === AttributeValue.BottomToTop);
  const schema$y = () => optionObjOf("layouts", [
    required$1("onLtr"),
    required$1("onRtl"),
    option$3("onBottomLtr"),
    option$3("onBottomRtl")
  ]);
  const get$5 = (elem, info, defaultLtr, defaultRtl, defaultBottomLtr, defaultBottomRtl, dirElement) => {
    const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
    const customLtr = info.layouts.map((ls) => ls.onLtr(elem));
    const customRtl = info.layouts.map((ls) => ls.onRtl(elem));
    const ltr = isBottomToTop ? info.layouts.bind((ls) => ls.onBottomLtr.map((f3) => f3(elem))).or(customLtr).getOr(defaultBottomLtr) : customLtr.getOr(defaultLtr);
    const rtl = isBottomToTop ? info.layouts.bind((ls) => ls.onBottomRtl.map((f3) => f3(elem))).or(customRtl).getOr(defaultBottomRtl) : customRtl.getOr(defaultRtl);
    const f2 = onDirection(ltr, rtl);
    return f2(elem);
  };
  const placement$4 = (component, anchorInfo, origin) => {
    const hotspot = anchorInfo.hotspot;
    const anchorBox = toBox(origin, hotspot.element);
    const layouts2 = get$5(component.element, anchorInfo, belowOrAbove(), belowOrAboveRtl(), aboveOrBelow(), aboveOrBelowRtl(), Optional.some(anchorInfo.hotspot.element));
    return Optional.some(nu$4({
      anchorBox,
      bubble: anchorInfo.bubble.getOr(fallback()),
      overrides: anchorInfo.overrides,
      layouts: layouts2
    }));
  };
  var HotspotAnchor = [
    required$1("hotspot"),
    option$3("bubble"),
    defaulted("overrides", {}),
    schema$y(),
    output$1("placement", placement$4)
  ];
  const placement$3 = (component, anchorInfo, origin) => {
    const pos = translate$2(origin, anchorInfo.x, anchorInfo.y);
    const anchorBox = bounds(pos.left, pos.top, anchorInfo.width, anchorInfo.height);
    const layouts2 = get$5(component.element, anchorInfo, all$1(), allRtl$1(), all$1(), allRtl$1(), Optional.none());
    return Optional.some(nu$4({
      anchorBox,
      bubble: anchorInfo.bubble,
      overrides: anchorInfo.overrides,
      layouts: layouts2
    }));
  };
  var MakeshiftAnchor = [
    required$1("x"),
    required$1("y"),
    defaulted("height", 0),
    defaulted("width", 0),
    defaulted("bubble", fallback()),
    defaulted("overrides", {}),
    schema$y(),
    output$1("placement", placement$3)
  ];
  const adt$7 = Adt.generate([
    { screen: ["point"] },
    {
      absolute: [
        "point",
        "scrollLeft",
        "scrollTop"
      ]
    }
  ]);
  const toFixed = (pos) => pos.fold(identity, (point2, scrollLeft, scrollTop) => point2.translate(-scrollLeft, -scrollTop));
  const toAbsolute = (pos) => pos.fold(identity, identity);
  const sum = (points) => foldl(points, (b2, a) => b2.translate(a.left, a.top), SugarPosition(0, 0));
  const sumAsFixed = (positions) => {
    const points = map$2(positions, toFixed);
    return sum(points);
  };
  const sumAsAbsolute = (positions) => {
    const points = map$2(positions, toAbsolute);
    return sum(points);
  };
  const screen = adt$7.screen;
  const absolute$1 = adt$7.absolute;
  const getOffset = (component, origin, anchorInfo) => {
    const win2 = defaultView(anchorInfo.root).dom;
    const hasSameOwner = (frame) => {
      const frameOwner = owner$4(frame);
      const compOwner = owner$4(component.element);
      return eq(frameOwner, compOwner);
    };
    return Optional.from(win2.frameElement).map(SugarElement.fromDom).filter(hasSameOwner).map(absolute$3);
  };
  const getRootPoint = (component, origin, anchorInfo) => {
    const doc = owner$4(component.element);
    const outerScroll = get$b(doc);
    const offset3 = getOffset(component, origin, anchorInfo).getOr(outerScroll);
    return absolute$1(offset3, outerScroll.left, outerScroll.top);
  };
  const getBox = (left3, top3, width3, height3) => {
    const point2 = screen(SugarPosition(left3, top3));
    return Optional.some(pointed(point2, width3, height3));
  };
  const calcNewAnchor = (optBox, rootPoint, anchorInfo, origin, elem) => optBox.map((box2) => {
    const points = [
      rootPoint,
      box2.point
    ];
    const topLeft = cata$1(origin, () => sumAsAbsolute(points), () => sumAsAbsolute(points), () => sumAsFixed(points));
    const anchorBox = rect(topLeft.left, topLeft.top, box2.width, box2.height);
    const layoutsLtr = anchorInfo.showAbove ? aboveOrBelow() : belowOrAbove();
    const layoutsRtl = anchorInfo.showAbove ? aboveOrBelowRtl() : belowOrAboveRtl();
    const layouts2 = get$5(elem, anchorInfo, layoutsLtr, layoutsRtl, layoutsLtr, layoutsRtl, Optional.none());
    return nu$4({
      anchorBox,
      bubble: anchorInfo.bubble.getOr(fallback()),
      overrides: anchorInfo.overrides,
      layouts: layouts2
    });
  });
  const placement$2 = (component, anchorInfo, origin) => {
    const rootPoint = getRootPoint(component, origin, anchorInfo);
    return anchorInfo.node.filter(inBody).bind((target) => {
      const rect2 = target.dom.getBoundingClientRect();
      const nodeBox = getBox(rect2.left, rect2.top, rect2.width, rect2.height);
      const elem = anchorInfo.node.getOr(component.element);
      return calcNewAnchor(nodeBox, rootPoint, anchorInfo, origin, elem);
    });
  };
  var NodeAnchor = [
    required$1("node"),
    required$1("root"),
    option$3("bubble"),
    schema$y(),
    defaulted("overrides", {}),
    defaulted("showAbove", false),
    output$1("placement", placement$2)
  ];
  const zeroWidth = "\uFEFF";
  const nbsp = " ";
  const create$32 = (start2, soffset, finish, foffset) => ({
    start: start2,
    soffset,
    finish,
    foffset
  });
  const SimRange = { create: create$32 };
  const adt$6 = Adt.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]);
  const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
  const getStart$1 = (situ) => situ.fold(identity, identity, identity);
  const before = adt$6.before;
  const on$1 = adt$6.on;
  const after$1 = adt$6.after;
  const Situ = {
    before,
    on: on$1,
    after: after$1,
    cata,
    getStart: getStart$1
  };
  const adt$5 = Adt.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]);
  const exactFromRange = (simRange) => adt$5.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
  const getStart = (selection) => selection.match({
    domRange: (rng) => SugarElement.fromDom(rng.startContainer),
    relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
    exact: (start2, _soffset, _finish, _foffset) => start2
  });
  const domRange = adt$5.domRange;
  const relative = adt$5.relative;
  const exact = adt$5.exact;
  const getWin = (selection) => {
    const start2 = getStart(selection);
    return defaultView(start2);
  };
  const range$1 = SimRange.create;
  const SimSelection = {
    domRange,
    relative,
    exact,
    exactFromRange,
    getWin,
    range: range$1
  };
  const setStart = (rng, situ) => {
    situ.fold((e) => {
      rng.setStartBefore(e.dom);
    }, (e, o) => {
      rng.setStart(e.dom, o);
    }, (e) => {
      rng.setStartAfter(e.dom);
    });
  };
  const setFinish = (rng, situ) => {
    situ.fold((e) => {
      rng.setEndBefore(e.dom);
    }, (e, o) => {
      rng.setEnd(e.dom, o);
    }, (e) => {
      rng.setEndAfter(e.dom);
    });
  };
  const relativeToNative = (win2, startSitu, finishSitu) => {
    const range2 = win2.document.createRange();
    setStart(range2, startSitu);
    setFinish(range2, finishSitu);
    return range2;
  };
  const exactToNative = (win2, start2, soffset, finish, foffset) => {
    const rng = win2.document.createRange();
    rng.setStart(start2.dom, soffset);
    rng.setEnd(finish.dom, foffset);
    return rng;
  };
  const toRect = (rect2) => ({
    left: rect2.left,
    top: rect2.top,
    right: rect2.right,
    bottom: rect2.bottom,
    width: rect2.width,
    height: rect2.height
  });
  const getFirstRect$1 = (rng) => {
    const rects = rng.getClientRects();
    const rect2 = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
    return rect2.width > 0 || rect2.height > 0 ? Optional.some(rect2).map(toRect) : Optional.none();
  };
  const getBounds$2 = (rng) => {
    const rect2 = rng.getBoundingClientRect();
    return rect2.width > 0 || rect2.height > 0 ? Optional.some(rect2).map(toRect) : Optional.none();
  };
  const adt$4 = Adt.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]);
  const fromRange = (win2, type2, range2) => type2(SugarElement.fromDom(range2.startContainer), range2.startOffset, SugarElement.fromDom(range2.endContainer), range2.endOffset);
  const getRanges = (win2, selection) => selection.match({
    domRange: (rng) => {
      return {
        ltr: constant$1(rng),
        rtl: Optional.none
      };
    },
    relative: (startSitu, finishSitu) => {
      return {
        ltr: cached(() => relativeToNative(win2, startSitu, finishSitu)),
        rtl: cached(() => Optional.some(relativeToNative(win2, finishSitu, startSitu)))
      };
    },
    exact: (start2, soffset, finish, foffset) => {
      return {
        ltr: cached(() => exactToNative(win2, start2, soffset, finish, foffset)),
        rtl: cached(() => Optional.some(exactToNative(win2, finish, foffset, start2, soffset)))
      };
    }
  });
  const doDiagnose = (win2, ranges) => {
    const rng = ranges.ltr();
    if (rng.collapsed) {
      const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
      return reversed.map((rev) => adt$4.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win2, adt$4.ltr, rng));
    } else {
      return fromRange(win2, adt$4.ltr, rng);
    }
  };
  const diagnose = (win2, selection) => {
    const ranges = getRanges(win2, selection);
    return doDiagnose(win2, ranges);
  };
  const asLtrRange = (win2, selection) => {
    const diagnosis = diagnose(win2, selection);
    return diagnosis.match({
      ltr: (start2, soffset, finish, foffset) => {
        const rng = win2.document.createRange();
        rng.setStart(start2.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
      },
      rtl: (start2, soffset, finish, foffset) => {
        const rng = win2.document.createRange();
        rng.setStart(finish.dom, foffset);
        rng.setEnd(start2.dom, soffset);
        return rng;
      }
    });
  };
  adt$4.ltr;
  adt$4.rtl;
  const ancestors = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);
  const descendants = (scope, selector) => all$3(selector, scope);
  const makeRange = (start2, soffset, finish, foffset) => {
    const doc = owner$4(start2);
    const rng = doc.dom.createRange();
    rng.setStart(start2.dom, soffset);
    rng.setEnd(finish.dom, foffset);
    return rng;
  };
  const after = (start2, soffset, finish, foffset) => {
    const r2 = makeRange(start2, soffset, finish, foffset);
    const same = eq(start2, finish) && soffset === foffset;
    return r2.collapsed && !same;
  };
  const getNativeSelection = (win2) => Optional.from(win2.getSelection());
  const readRange = (selection) => {
    if (selection.rangeCount > 0) {
      const firstRng = selection.getRangeAt(0);
      const lastRng = selection.getRangeAt(selection.rangeCount - 1);
      return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
    } else {
      return Optional.none();
    }
  };
  const doGetExact = (selection) => {
    if (selection.anchorNode === null || selection.focusNode === null) {
      return readRange(selection);
    } else {
      const anchor2 = SugarElement.fromDom(selection.anchorNode);
      const focus2 = SugarElement.fromDom(selection.focusNode);
      return after(anchor2, selection.anchorOffset, focus2, selection.focusOffset) ? Optional.some(SimRange.create(anchor2, selection.anchorOffset, focus2, selection.focusOffset)) : readRange(selection);
    }
  };
  const getExact = (win2) => getNativeSelection(win2).filter((sel) => sel.rangeCount > 0).bind(doGetExact);
  const getFirstRect = (win2, selection) => {
    const rng = asLtrRange(win2, selection);
    return getFirstRect$1(rng);
  };
  const getBounds$1 = (win2, selection) => {
    const rng = asLtrRange(win2, selection);
    return getBounds$2(rng);
  };
  const NodeValue = (is2, name3) => {
    const get2 = (element2) => {
      if (!is2(element2)) {
        throw new Error("Can only get " + name3 + " value of a " + name3 + " node");
      }
      return getOption(element2).getOr("");
    };
    const getOption = (element2) => is2(element2) ? Optional.from(element2.dom.nodeValue) : Optional.none();
    const set2 = (element2, value2) => {
      if (!is2(element2)) {
        throw new Error("Can only set raw " + name3 + " value of a " + name3 + " node");
      }
      element2.dom.nodeValue = value2;
    };
    return {
      get: get2,
      getOption,
      set: set2
    };
  };
  const api = NodeValue(isText, "text");
  const get$4 = (element2) => api.get(element2);
  const point = (element2, offset3) => ({
    element: element2,
    offset: offset3
  });
  const descendOnce$1 = (element2, offset3) => {
    const children$1 = children(element2);
    if (children$1.length === 0) {
      return point(element2, offset3);
    } else if (offset3 < children$1.length) {
      return point(children$1[offset3], 0);
    } else {
      const last2 = children$1[children$1.length - 1];
      const len = isText(last2) ? get$4(last2).length : children(last2).length;
      return point(last2, len);
    }
  };
  const descendOnce = (element2, offset3) => isText(element2) ? point(element2, offset3) : descendOnce$1(element2, offset3);
  const getAnchorSelection = (win2, anchorInfo) => {
    const getSelection = anchorInfo.getSelection.getOrThunk(() => () => getExact(win2));
    return getSelection().map((sel) => {
      const modStart = descendOnce(sel.start, sel.soffset);
      const modFinish = descendOnce(sel.finish, sel.foffset);
      return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
    });
  };
  const placement$1 = (component, anchorInfo, origin) => {
    const win2 = defaultView(anchorInfo.root).dom;
    const rootPoint = getRootPoint(component, origin, anchorInfo);
    const selectionBox = getAnchorSelection(win2, anchorInfo).bind((sel) => {
      const optRect = getBounds$1(win2, SimSelection.exactFromRange(sel)).orThunk(() => {
        const x = SugarElement.fromText(zeroWidth);
        before$1(sel.start, x);
        const rect2 = getFirstRect(win2, SimSelection.exact(x, 0, x, 1));
        remove$5(x);
        return rect2;
      });
      return optRect.bind((rawRect) => getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height));
    });
    const targetElement = getAnchorSelection(win2, anchorInfo).bind((sel) => isElement$12(sel.start) ? Optional.some(sel.start) : parentElement(sel.start));
    const elem = targetElement.getOr(component.element);
    return calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
  };
  var SelectionAnchor = [
    option$3("getSelection"),
    required$1("root"),
    option$3("bubble"),
    schema$y(),
    defaulted("overrides", {}),
    defaulted("showAbove", false),
    output$1("placement", placement$1)
  ];
  const labelPrefix$1 = "link-layout";
  const eastX = (anchor2) => anchor2.x + anchor2.width;
  const westX = (anchor2, element2) => anchor2.x - element2.width;
  const northY$1 = (anchor2, element2) => anchor2.y - element2.height + anchor2.height;
  const southY$1 = (anchor2) => anchor2.y;
  const southeast$1 = (anchor2, element2, bubbles) => nu$6(eastX(anchor2), southY$1(anchor2), bubbles.southeast(), southeast$3(), "southeast", boundsRestriction(anchor2, {
    left: 0,
    top: 2
  }), labelPrefix$1);
  const southwest$1 = (anchor2, element2, bubbles) => nu$6(westX(anchor2, element2), southY$1(anchor2), bubbles.southwest(), southwest$3(), "southwest", boundsRestriction(anchor2, {
    right: 1,
    top: 2
  }), labelPrefix$1);
  const northeast$1 = (anchor2, element2, bubbles) => nu$6(eastX(anchor2), northY$1(anchor2, element2), bubbles.northeast(), northeast$3(), "northeast", boundsRestriction(anchor2, {
    left: 0,
    bottom: 3
  }), labelPrefix$1);
  const northwest$1 = (anchor2, element2, bubbles) => nu$6(westX(anchor2, element2), northY$1(anchor2, element2), bubbles.northwest(), northwest$3(), "northwest", boundsRestriction(anchor2, {
    right: 1,
    bottom: 3
  }), labelPrefix$1);
  const all2 = () => [
    southeast$1,
    southwest$1,
    northeast$1,
    northwest$1
  ];
  const allRtl = () => [
    southwest$1,
    southeast$1,
    northwest$1,
    northeast$1
  ];
  const placement = (component, submenuInfo, origin) => {
    const anchorBox = toBox(origin, submenuInfo.item.element);
    const layouts2 = get$5(component.element, submenuInfo, all2(), allRtl(), all2(), allRtl(), Optional.none());
    return Optional.some(nu$4({
      anchorBox,
      bubble: fallback(),
      overrides: submenuInfo.overrides,
      layouts: layouts2
    }));
  };
  var SubmenuAnchor = [
    required$1("item"),
    schema$y(),
    defaulted("overrides", {}),
    output$1("placement", placement)
  ];
  var AnchorSchema = choose$1("type", {
    selection: SelectionAnchor,
    node: NodeAnchor,
    hotspot: HotspotAnchor,
    submenu: SubmenuAnchor,
    makeshift: MakeshiftAnchor
  });
  const TransitionSchema = [
    requiredArrayOf("classes", string),
    defaultedStringEnum("mode", "all", [
      "all",
      "layout",
      "placement"
    ])
  ];
  const PositionSchema = [
    defaulted("useFixed", never),
    option$3("getBounds")
  ];
  const PlacementSchema = [
    requiredOf("anchor", AnchorSchema),
    optionObjOf("transition", TransitionSchema)
  ];
  const getFixedOrigin = () => {
    const html2 = document.documentElement;
    return fixed$1(0, 0, html2.clientWidth, html2.clientHeight);
  };
  const getRelativeOrigin = (component) => {
    const position2 = absolute$3(component.element);
    const bounds2 = component.element.dom.getBoundingClientRect();
    return relative$1(position2.left, position2.top, bounds2.width, bounds2.height);
  };
  const place = (origin, anchoring, optBounds, placee, lastPlace, transition) => {
    const anchor2 = box(anchoring.anchorBox, origin);
    return simple(anchor2, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, optBounds, anchoring.overrides, transition);
  };
  const position$1 = (component, posConfig, posState, placee, placementSpec) => {
    const optWithinBounds = Optional.none();
    positionWithinBounds(component, posConfig, posState, placee, placementSpec, optWithinBounds);
  };
  const positionWithinBounds = (component, posConfig, posState, placee, placementSpec, optWithinBounds) => {
    const placeeDetail = asRawOrDie$1("placement.info", objOf(PlacementSchema), placementSpec);
    const anchorage = placeeDetail.anchor;
    const element2 = placee.element;
    const placeeState = posState.get(placee.uid);
    preserve$1(() => {
      set$8(element2, "position", "fixed");
      const oldVisibility = getRaw(element2, "visibility");
      set$8(element2, "visibility", "hidden");
      const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
      anchorage.placement(component, anchorage, origin).each((anchoring) => {
        const optBounds = optWithinBounds.orThunk(() => posConfig.getBounds.map(apply$1));
        const newState = place(origin, anchoring, optBounds, placee, placeeState, placeeDetail.transition);
        posState.set(placee.uid, newState);
      });
      oldVisibility.fold(() => {
        remove$6(element2, "visibility");
      }, (vis) => {
        set$8(element2, "visibility", vis);
      });
      if (getRaw(element2, "left").isNone() && getRaw(element2, "top").isNone() && getRaw(element2, "right").isNone() && getRaw(element2, "bottom").isNone() && is$1(getRaw(element2, "position"), "fixed")) {
        remove$6(element2, "position");
      }
    }, element2);
  };
  const getMode = (component, pConfig, _pState) => pConfig.useFixed() ? "fixed" : "absolute";
  const reset$1 = (component, pConfig, posState, placee) => {
    const element2 = placee.element;
    each$1([
      "position",
      "left",
      "right",
      "top",
      "bottom"
    ], (prop) => remove$6(element2, prop));
    reset$2(element2);
    posState.clear(placee.uid);
  };
  var PositionApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    position: position$1,
    positionWithinBounds,
    getMode,
    reset: reset$1
  });
  const init$g = () => {
    let state2 = {};
    const set2 = (id, data2) => {
      state2[id] = data2;
    };
    const get2 = (id) => get$g(state2, id);
    const clear3 = (id) => {
      if (isNonNullable(id)) {
        delete state2[id];
      } else {
        state2 = {};
      }
    };
    return nu$8({
      readState: () => state2,
      clear: clear3,
      set: set2,
      get: get2
    });
  };
  var PositioningState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$g
  });
  const Positioning = create$42({
    fields: PositionSchema,
    name: "positioning",
    active: ActivePosition,
    apis: PositionApis,
    state: PositioningState
  });
  const isConnected = (comp) => comp.getSystem().isConnected();
  const fireDetaching = (component) => {
    emit(component, detachedFromDom());
    const children2 = component.components();
    each$1(children2, fireDetaching);
  };
  const fireAttaching = (component) => {
    const children2 = component.components();
    each$1(children2, fireAttaching);
    emit(component, attachedToDom());
  };
  const virtualAttach = (parent2, child2) => {
    parent2.getSystem().addToWorld(child2);
    if (inBody(parent2.element)) {
      fireAttaching(child2);
    }
  };
  const virtualDetach = (comp) => {
    fireDetaching(comp);
    comp.getSystem().removeFromWorld(comp);
  };
  const attach$1 = (parent2, child2) => {
    append$2(parent2.element, child2.element);
  };
  const detachChildren$1 = (component) => {
    each$1(component.components(), (childComp) => remove$5(childComp.element));
    empty(component.element);
    component.syncComponents();
  };
  const replaceChildren = (component, newSpecs, buildNewChildren) => {
    const subs2 = component.components();
    detachChildren$1(component);
    const newChildren = buildNewChildren(newSpecs);
    const deleted = difference(subs2, newChildren);
    each$1(deleted, (comp) => {
      fireDetaching(comp);
      component.getSystem().removeFromWorld(comp);
    });
    each$1(newChildren, (childComp) => {
      if (!isConnected(childComp)) {
        component.getSystem().addToWorld(childComp);
        attach$1(component, childComp);
        if (inBody(component.element)) {
          fireAttaching(childComp);
        }
      } else {
        attach$1(component, childComp);
      }
    });
    component.syncComponents();
  };
  const virtualReplaceChildren = (component, newSpecs, buildNewChildren) => {
    const subs2 = component.components();
    const existingComps = bind$3(newSpecs, (spec) => getPremade(spec).toArray());
    each$1(subs2, (childComp) => {
      if (!contains$2(existingComps, childComp)) {
        virtualDetach(childComp);
      }
    });
    const newChildren = buildNewChildren(newSpecs);
    const deleted = difference(subs2, newChildren);
    each$1(deleted, (deletedComp) => {
      if (isConnected(deletedComp)) {
        virtualDetach(deletedComp);
      }
    });
    each$1(newChildren, (childComp) => {
      if (!isConnected(childComp)) {
        virtualAttach(component, childComp);
      }
    });
    component.syncComponents();
  };
  const attach = (parent2, child2) => {
    attachWith(parent2, child2, append$2);
  };
  const attachWith = (parent2, child2, insertion) => {
    parent2.getSystem().addToWorld(child2);
    insertion(parent2.element, child2.element);
    if (inBody(parent2.element)) {
      fireAttaching(child2);
    }
    parent2.syncComponents();
  };
  const doDetach = (component) => {
    fireDetaching(component);
    remove$5(component.element);
    component.getSystem().removeFromWorld(component);
  };
  const detach = (component) => {
    const parent$1 = parent(component.element).bind((p) => component.getSystem().getByDom(p).toOptional());
    doDetach(component);
    parent$1.each((p) => {
      p.syncComponents();
    });
  };
  const detachChildren = (component) => {
    const subs2 = component.components();
    each$1(subs2, doDetach);
    empty(component.element);
    component.syncComponents();
  };
  const attachSystem = (element2, guiSystem) => {
    attachSystemWith(element2, guiSystem, append$2);
  };
  const attachSystemAfter = (element2, guiSystem) => {
    attachSystemWith(element2, guiSystem, after$2);
  };
  const attachSystemWith = (element2, guiSystem, inserter) => {
    inserter(element2, guiSystem.element);
    const children$1 = children(guiSystem.element);
    each$1(children$1, (child2) => {
      guiSystem.getByDom(child2).each(fireAttaching);
    });
  };
  const detachSystem = (guiSystem) => {
    const children$1 = children(guiSystem.element);
    each$1(children$1, (child2) => {
      guiSystem.getByDom(child2).each(fireDetaching);
    });
    remove$5(guiSystem.element);
  };
  const rebuild = (sandbox, sConfig, sState, data2) => {
    sState.get().each((_data) => {
      detachChildren(sandbox);
    });
    const point2 = sConfig.getAttachPoint(sandbox);
    attach(point2, sandbox);
    const built = sandbox.getSystem().build(data2);
    attach(sandbox, built);
    sState.set(built);
    return built;
  };
  const open$1 = (sandbox, sConfig, sState, data2) => {
    const newState = rebuild(sandbox, sConfig, sState, data2);
    sConfig.onOpen(sandbox, newState);
    return newState;
  };
  const setContent = (sandbox, sConfig, sState, data2) => sState.get().map(() => rebuild(sandbox, sConfig, sState, data2));
  const openWhileCloaked = (sandbox, sConfig, sState, data2, transaction) => {
    cloak(sandbox, sConfig);
    open$1(sandbox, sConfig, sState, data2);
    transaction();
    decloak(sandbox, sConfig);
  };
  const close$1 = (sandbox, sConfig, sState) => {
    sState.get().each((data2) => {
      detachChildren(sandbox);
      detach(sandbox);
      sConfig.onClose(sandbox, data2);
      sState.clear();
    });
  };
  const isOpen$1 = (_sandbox, _sConfig, sState) => sState.isOpen();
  const isPartOf = (sandbox, sConfig, sState, queryElem) => isOpen$1(sandbox, sConfig, sState) && sState.get().exists((data2) => sConfig.isPartOf(sandbox, data2, queryElem));
  const getState$2 = (_sandbox, _sConfig, sState) => sState.get();
  const store = (sandbox, cssKey, attr2, newValue) => {
    getRaw(sandbox.element, cssKey).fold(() => {
      remove$7(sandbox.element, attr2);
    }, (v) => {
      set$9(sandbox.element, attr2, v);
    });
    set$8(sandbox.element, cssKey, newValue);
  };
  const restore = (sandbox, cssKey, attr2) => {
    getOpt(sandbox.element, attr2).fold(() => remove$6(sandbox.element, cssKey), (oldValue) => set$8(sandbox.element, cssKey, oldValue));
  };
  const cloak = (sandbox, sConfig, _sState) => {
    const sink = sConfig.getAttachPoint(sandbox);
    set$8(sandbox.element, "position", Positioning.getMode(sink));
    store(sandbox, "visibility", sConfig.cloakVisibilityAttr, "hidden");
  };
  const hasPosition = (element2) => exists([
    "top",
    "left",
    "right",
    "bottom"
  ], (pos) => getRaw(element2, pos).isSome());
  const decloak = (sandbox, sConfig, _sState) => {
    if (!hasPosition(sandbox.element)) {
      remove$6(sandbox.element, "position");
    }
    restore(sandbox, "visibility", sConfig.cloakVisibilityAttr);
  };
  var SandboxApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    cloak,
    decloak,
    open: open$1,
    openWhileCloaked,
    close: close$1,
    isOpen: isOpen$1,
    isPartOf,
    getState: getState$2,
    setContent
  });
  const events$g = (sandboxConfig, sandboxState) => derive$2([run$1(sandboxClose(), (sandbox, _simulatedEvent) => {
    close$1(sandbox, sandboxConfig, sandboxState);
  })]);
  var ActiveSandbox = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$g
  });
  var SandboxSchema = [
    onHandler("onOpen"),
    onHandler("onClose"),
    required$1("isPartOf"),
    required$1("getAttachPoint"),
    defaulted("cloakVisibilityAttr", "data-precloak-visibility")
  ];
  const init$f = () => {
    const contents2 = value$2();
    const readState = constant$1("not-implemented");
    return nu$8({
      readState,
      isOpen: contents2.isSet,
      clear: contents2.clear,
      set: contents2.set,
      get: contents2.get
    });
  };
  var SandboxState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$f
  });
  const Sandboxing = create$42({
    fields: SandboxSchema,
    name: "sandboxing",
    active: ActiveSandbox,
    apis: SandboxApis,
    state: SandboxState
  });
  const dismissPopups = constant$1("dismiss.popups");
  const repositionPopups = constant$1("reposition.popups");
  const mouseReleased = constant$1("mouse.released");
  const schema$x = objOfOnly([
    defaulted("isExtraPart", never),
    optionObjOf("fireEventInstead", [defaulted("event", dismissRequested())])
  ]);
  const receivingChannel$1 = (rawSpec) => {
    const detail = asRawOrDie$1("Dismissal", schema$x, rawSpec);
    return {
      [dismissPopups()]: {
        schema: objOfOnly([required$1("target")]),
        onReceive: (sandbox, data2) => {
          if (Sandboxing.isOpen(sandbox)) {
            const isPart = Sandboxing.isPartOf(sandbox, data2.target) || detail.isExtraPart(sandbox, data2.target);
            if (!isPart) {
              detail.fireEventInstead.fold(() => Sandboxing.close(sandbox), (fe) => emit(sandbox, fe.event));
            }
          }
        }
      }
    };
  };
  const schema$w = objOfOnly([
    optionObjOf("fireEventInstead", [defaulted("event", repositionRequested())]),
    requiredFunction("doReposition")
  ]);
  const receivingChannel = (rawSpec) => {
    const detail = asRawOrDie$1("Reposition", schema$w, rawSpec);
    return {
      [repositionPopups()]: {
        onReceive: (sandbox) => {
          if (Sandboxing.isOpen(sandbox)) {
            detail.fireEventInstead.fold(() => detail.doReposition(sandbox), (fe) => emit(sandbox, fe.event));
          }
        }
      }
    };
  };
  const onLoad$5 = (component, repConfig, repState) => {
    repConfig.store.manager.onLoad(component, repConfig, repState);
  };
  const onUnload$2 = (component, repConfig, repState) => {
    repConfig.store.manager.onUnload(component, repConfig, repState);
  };
  const setValue$3 = (component, repConfig, repState, data2) => {
    repConfig.store.manager.setValue(component, repConfig, repState, data2);
  };
  const getValue$3 = (component, repConfig, repState) => repConfig.store.manager.getValue(component, repConfig, repState);
  const getState$1 = (component, repConfig, repState) => repState;
  var RepresentApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad: onLoad$5,
    onUnload: onUnload$2,
    setValue: setValue$3,
    getValue: getValue$3,
    getState: getState$1
  });
  const events$f = (repConfig, repState) => {
    const es = repConfig.resetOnDom ? [
      runOnAttached((comp, _se) => {
        onLoad$5(comp, repConfig, repState);
      }),
      runOnDetached((comp, _se) => {
        onUnload$2(comp, repConfig, repState);
      })
    ] : [loadEvent(repConfig, repState, onLoad$5)];
    return derive$2(es);
  };
  var ActiveRepresenting = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$f
  });
  const memory$1 = () => {
    const data2 = Cell(null);
    const readState = () => ({
      mode: "memory",
      value: data2.get()
    });
    const isNotSet = () => data2.get() === null;
    const clear3 = () => {
      data2.set(null);
    };
    return nu$8({
      set: data2.set,
      get: data2.get,
      isNotSet,
      clear: clear3,
      readState
    });
  };
  const manual = () => {
    const readState = noop2;
    return nu$8({ readState });
  };
  const dataset = () => {
    const dataByValue = Cell({});
    const dataByText = Cell({});
    const readState = () => ({
      mode: "dataset",
      dataByValue: dataByValue.get(),
      dataByText: dataByText.get()
    });
    const clear3 = () => {
      dataByValue.set({});
      dataByText.set({});
    };
    const lookup2 = (itemString) => get$g(dataByValue.get(), itemString).orThunk(() => get$g(dataByText.get(), itemString));
    const update = (items) => {
      const currentDataByValue = dataByValue.get();
      const currentDataByText = dataByText.get();
      const newDataByValue = {};
      const newDataByText = {};
      each$1(items, (item3) => {
        newDataByValue[item3.value] = item3;
        get$g(item3, "meta").each((meta) => {
          get$g(meta, "text").each((text3) => {
            newDataByText[text3] = item3;
          });
        });
      });
      dataByValue.set({
        ...currentDataByValue,
        ...newDataByValue
      });
      dataByText.set({
        ...currentDataByText,
        ...newDataByText
      });
    };
    return nu$8({
      readState,
      lookup: lookup2,
      update,
      clear: clear3
    });
  };
  const init$e = (spec) => spec.store.manager.state(spec);
  var RepresentState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    memory: memory$1,
    dataset,
    manual,
    init: init$e
  });
  const setValue$2 = (component, repConfig, repState, data2) => {
    const store2 = repConfig.store;
    repState.update([data2]);
    store2.setValue(component, data2);
    repConfig.onSetValue(component, data2);
  };
  const getValue$2 = (component, repConfig, repState) => {
    const store2 = repConfig.store;
    const key = store2.getDataKey(component);
    return repState.lookup(key).getOrThunk(() => store2.getFallbackEntry(key));
  };
  const onLoad$4 = (component, repConfig, repState) => {
    const store2 = repConfig.store;
    store2.initialValue.each((data2) => {
      setValue$2(component, repConfig, repState, data2);
    });
  };
  const onUnload$1 = (component, repConfig, repState) => {
    repState.clear();
  };
  var DatasetStore = [
    option$3("initialValue"),
    required$1("getFallbackEntry"),
    required$1("getDataKey"),
    required$1("setValue"),
    output$1("manager", {
      setValue: setValue$2,
      getValue: getValue$2,
      onLoad: onLoad$4,
      onUnload: onUnload$1,
      state: dataset
    })
  ];
  const getValue$1 = (component, repConfig, _repState) => repConfig.store.getValue(component);
  const setValue$1 = (component, repConfig, _repState, data2) => {
    repConfig.store.setValue(component, data2);
    repConfig.onSetValue(component, data2);
  };
  const onLoad$3 = (component, repConfig, _repState) => {
    repConfig.store.initialValue.each((data2) => {
      repConfig.store.setValue(component, data2);
    });
  };
  var ManualStore = [
    required$1("getValue"),
    defaulted("setValue", noop2),
    option$3("initialValue"),
    output$1("manager", {
      setValue: setValue$1,
      getValue: getValue$1,
      onLoad: onLoad$3,
      onUnload: noop2,
      state: NoState.init
    })
  ];
  const setValue = (component, repConfig, repState, data2) => {
    repState.set(data2);
    repConfig.onSetValue(component, data2);
  };
  const getValue = (component, repConfig, repState) => repState.get();
  const onLoad$2 = (component, repConfig, repState) => {
    repConfig.store.initialValue.each((initVal) => {
      if (repState.isNotSet()) {
        repState.set(initVal);
      }
    });
  };
  const onUnload = (component, repConfig, repState) => {
    repState.clear();
  };
  var MemoryStore = [
    option$3("initialValue"),
    output$1("manager", {
      setValue,
      getValue,
      onLoad: onLoad$2,
      onUnload,
      state: memory$1
    })
  ];
  var RepresentSchema = [
    defaultedOf("store", { mode: "memory" }, choose$1("mode", {
      memory: MemoryStore,
      manual: ManualStore,
      dataset: DatasetStore
    })),
    onHandler("onSetValue"),
    defaulted("resetOnDom", false)
  ];
  const Representing = create$42({
    fields: RepresentSchema,
    name: "representing",
    active: ActiveRepresenting,
    apis: RepresentApis,
    extra: {
      setValueFrom: (component, source) => {
        const value2 = Representing.getValue(source);
        Representing.setValue(component, value2);
      }
    },
    state: RepresentState
  });
  const field = (name3, forbidden) => defaultedObjOf(name3, {}, map$2(forbidden, (f2) => forbid(f2.name(), "Cannot configure " + f2.name() + " for " + name3)).concat([customField("dump", identity)]));
  const get$3 = (data2) => data2.dump;
  const augment = (data2, original2) => ({
    ...derive$1(original2),
    ...data2.dump
  });
  const SketchBehaviours = {
    field,
    augment,
    get: get$3
  };
  const _placeholder = "placeholder";
  const adt$3 = Adt.generate([
    {
      single: [
        "required",
        "valueThunk"
      ]
    },
    {
      multiple: [
        "required",
        "valueThunks"
      ]
    }
  ]);
  const isSubstituted = (spec) => has$2(spec, "uiType");
  const subPlaceholder = (owner2, detail, compSpec, placeholders) => {
    if (owner2.exists((o) => o !== compSpec.owner)) {
      return adt$3.single(true, constant$1(compSpec));
    }
    return get$g(placeholders, compSpec.name).fold(() => {
      throw new Error("Unknown placeholder component: " + compSpec.name + "\nKnown: [" + keys(placeholders) + "]\nNamespace: " + owner2.getOr("none") + "\nSpec: " + JSON.stringify(compSpec, null, 2));
    }, (newSpec) => newSpec.replace());
  };
  const scan = (owner2, detail, compSpec, placeholders) => {
    if (isSubstituted(compSpec) && compSpec.uiType === _placeholder) {
      return subPlaceholder(owner2, detail, compSpec, placeholders);
    } else {
      return adt$3.single(false, constant$1(compSpec));
    }
  };
  const substitute = (owner2, detail, compSpec, placeholders) => {
    const base2 = scan(owner2, detail, compSpec, placeholders);
    return base2.fold((req, valueThunk2) => {
      const value2 = isSubstituted(compSpec) ? valueThunk2(detail, compSpec.config, compSpec.validated) : valueThunk2(detail);
      const childSpecs = get$g(value2, "components").getOr([]);
      const substituted = bind$3(childSpecs, (c) => substitute(owner2, detail, c, placeholders));
      return [{
        ...value2,
        components: substituted
      }];
    }, (req, valuesThunk) => {
      if (isSubstituted(compSpec)) {
        const values2 = valuesThunk(detail, compSpec.config, compSpec.validated);
        const preprocessor = compSpec.validated.preprocess.getOr(identity);
        return preprocessor(values2);
      } else {
        return valuesThunk(detail);
      }
    });
  };
  const substituteAll = (owner2, detail, components2, placeholders) => bind$3(components2, (c) => substitute(owner2, detail, c, placeholders));
  const oneReplace = (label2, replacements) => {
    let called = false;
    const used = () => called;
    const replace2 = () => {
      if (called) {
        throw new Error("Trying to use the same placeholder more than once: " + label2);
      }
      called = true;
      return replacements;
    };
    const required2 = () => replacements.fold((req, _2) => req, (req, _2) => req);
    return {
      name: constant$1(label2),
      required: required2,
      used,
      replace: replace2
    };
  };
  const substitutePlaces = (owner2, detail, components2, placeholders) => {
    const ps = map$1(placeholders, (ph, name3) => oneReplace(name3, ph));
    const outcome = substituteAll(owner2, detail, components2, ps);
    each(ps, (p) => {
      if (p.used() === false && p.required()) {
        throw new Error("Placeholder: " + p.name() + " was not found in components list\nNamespace: " + owner2.getOr("none") + "\nComponents: " + JSON.stringify(detail.components, null, 2));
      }
    });
    return outcome;
  };
  const single$2 = adt$3.single;
  const multiple = adt$3.multiple;
  const placeholder = constant$1(_placeholder);
  const adt$2 = Adt.generate([
    { required: ["data"] },
    { external: ["data"] },
    { optional: ["data"] },
    { group: ["data"] }
  ]);
  const fFactory = defaulted("factory", { sketch: identity });
  const fSchema = defaulted("schema", []);
  const fName = required$1("name");
  const fPname = field$1("pname", "pname", defaultedThunk((typeSpec) => "<alloy." + generate$6(typeSpec.name) + ">"), anyValue());
  const fGroupSchema = customField("schema", () => [option$3("preprocess")]);
  const fDefaults = defaulted("defaults", constant$1({}));
  const fOverrides = defaulted("overrides", constant$1({}));
  const requiredSpec = objOf([
    fFactory,
    fSchema,
    fName,
    fPname,
    fDefaults,
    fOverrides
  ]);
  const externalSpec = objOf([
    fFactory,
    fSchema,
    fName,
    fDefaults,
    fOverrides
  ]);
  const optionalSpec = objOf([
    fFactory,
    fSchema,
    fName,
    fPname,
    fDefaults,
    fOverrides
  ]);
  const groupSpec = objOf([
    fFactory,
    fGroupSchema,
    fName,
    required$1("unit"),
    fPname,
    fDefaults,
    fOverrides
  ]);
  const asNamedPart = (part2) => {
    return part2.fold(Optional.some, Optional.none, Optional.some, Optional.some);
  };
  const name$2 = (part2) => {
    const get2 = (data2) => data2.name;
    return part2.fold(get2, get2, get2, get2);
  };
  const asCommon = (part2) => {
    return part2.fold(identity, identity, identity, identity);
  };
  const convert = (adtConstructor, partSchema) => (spec) => {
    const data2 = asRawOrDie$1("Converting part type", partSchema, spec);
    return adtConstructor(data2);
  };
  const required = convert(adt$2.required, requiredSpec);
  const external = convert(adt$2.external, externalSpec);
  const optional = convert(adt$2.optional, optionalSpec);
  const group = convert(adt$2.group, groupSpec);
  const original = constant$1("entirety");
  var PartType = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    required,
    external,
    optional,
    group,
    asNamedPart,
    name: name$2,
    asCommon,
    original
  });
  const combine = (detail, data2, partSpec, partValidated) => deepMerge(data2.defaults(detail, partSpec, partValidated), partSpec, { uid: detail.partUids[data2.name] }, data2.overrides(detail, partSpec, partValidated));
  const subs = (owner2, detail, parts2) => {
    const internals = {};
    const externals = {};
    each$1(parts2, (part2) => {
      part2.fold((data2) => {
        internals[data2.pname] = single$2(true, (detail2, partSpec, partValidated) => data2.factory.sketch(combine(detail2, data2, partSpec, partValidated)));
      }, (data2) => {
        const partSpec = detail.parts[data2.name];
        externals[data2.name] = constant$1(data2.factory.sketch(combine(detail, data2, partSpec[original()]), partSpec));
      }, (data2) => {
        internals[data2.pname] = single$2(false, (detail2, partSpec, partValidated) => data2.factory.sketch(combine(detail2, data2, partSpec, partValidated)));
      }, (data2) => {
        internals[data2.pname] = multiple(true, (detail2, _partSpec, _partValidated) => {
          const units2 = detail2[data2.name];
          return map$2(units2, (u) => data2.factory.sketch(deepMerge(data2.defaults(detail2, u, _partValidated), u, data2.overrides(detail2, u))));
        });
      });
    });
    return {
      internals: constant$1(internals),
      externals: constant$1(externals)
    };
  };
  const generate$3 = (owner2, parts2) => {
    const r2 = {};
    each$1(parts2, (part2) => {
      asNamedPart(part2).each((np) => {
        const g = doGenerateOne(owner2, np.pname);
        r2[np.name] = (config2) => {
          const validated = asRawOrDie$1("Part: " + np.name + " in " + owner2, objOf(np.schema), config2);
          return {
            ...g,
            config: config2,
            validated
          };
        };
      });
    });
    return r2;
  };
  const doGenerateOne = (owner2, pname) => ({
    uiType: placeholder(),
    owner: owner2,
    name: pname
  });
  const generateOne$1 = (owner2, pname, config2) => ({
    uiType: placeholder(),
    owner: owner2,
    name: pname,
    config: config2,
    validated: {}
  });
  const schemas = (parts2) => bind$3(parts2, (part2) => part2.fold(Optional.none, Optional.some, Optional.none, Optional.none).map((data2) => requiredObjOf(data2.name, data2.schema.concat([snapshot(original())]))).toArray());
  const names = (parts2) => map$2(parts2, name$2);
  const substitutes = (owner2, detail, parts2) => subs(owner2, detail, parts2);
  const components$1 = (owner2, detail, internals) => substitutePlaces(Optional.some(owner2), detail, detail.components, internals);
  const getPart = (component, detail, partKey) => {
    const uid = detail.partUids[partKey];
    return component.getSystem().getByUid(uid).toOptional();
  };
  const getPartOrDie = (component, detail, partKey) => getPart(component, detail, partKey).getOrDie("Could not find part: " + partKey);
  const getParts = (component, detail, partKeys) => {
    const r2 = {};
    const uids2 = detail.partUids;
    const system = component.getSystem();
    each$1(partKeys, (pk) => {
      r2[pk] = constant$1(system.getByUid(uids2[pk]));
    });
    return r2;
  };
  const getAllParts = (component, detail) => {
    const system = component.getSystem();
    return map$1(detail.partUids, (pUid, _k) => constant$1(system.getByUid(pUid)));
  };
  const getAllPartNames = (detail) => keys(detail.partUids);
  const getPartsOrDie = (component, detail, partKeys) => {
    const r2 = {};
    const uids2 = detail.partUids;
    const system = component.getSystem();
    each$1(partKeys, (pk) => {
      r2[pk] = constant$1(system.getByUid(uids2[pk]).getOrDie());
    });
    return r2;
  };
  const defaultUids = (baseUid, partTypes) => {
    const partNames = names(partTypes);
    return wrapAll(map$2(partNames, (pn) => ({
      key: pn,
      value: baseUid + "-" + pn
    })));
  };
  const defaultUidsSchema = (partTypes) => field$1("partUids", "partUids", mergeWithThunk((spec) => defaultUids(spec.uid, partTypes)), anyValue());
  var AlloyParts = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    generate: generate$3,
    generateOne: generateOne$1,
    schemas,
    names,
    substitutes,
    components: components$1,
    defaultUids,
    defaultUidsSchema,
    getAllParts,
    getAllPartNames,
    getPart,
    getPartOrDie,
    getParts,
    getPartsOrDie
  });
  const base = (partSchemas, partUidsSchemas) => {
    const ps = partSchemas.length > 0 ? [requiredObjOf("parts", partSchemas)] : [];
    return ps.concat([
      required$1("uid"),
      defaulted("dom", {}),
      defaulted("components", []),
      snapshot("originalSpec"),
      defaulted("debug.sketcher", {})
    ]).concat(partUidsSchemas);
  };
  const asRawOrDie = (label2, schema2, spec, partSchemas, partUidsSchemas) => {
    const baseS = base(partSchemas, partUidsSchemas);
    return asRawOrDie$1(label2 + " [SpecSchema]", objOfOnly(baseS.concat(schema2)), spec);
  };
  const single$1 = (owner2, schema2, factory2, spec) => {
    const specWithUid = supplyUid(spec);
    const detail = asRawOrDie(owner2, schema2, specWithUid, [], []);
    return factory2(detail, specWithUid);
  };
  const composite$1 = (owner2, schema2, partTypes, factory2, spec) => {
    const specWithUid = supplyUid(spec);
    const partSchemas = schemas(partTypes);
    const partUidsSchema = defaultUidsSchema(partTypes);
    const detail = asRawOrDie(owner2, schema2, specWithUid, partSchemas, [partUidsSchema]);
    const subs2 = substitutes(owner2, detail, partTypes);
    const components2 = components$1(owner2, detail, subs2.internals());
    return factory2(detail, components2, specWithUid, subs2.externals());
  };
  const hasUid = (spec) => has$2(spec, "uid");
  const supplyUid = (spec) => {
    return hasUid(spec) ? spec : {
      ...spec,
      uid: generate$5("uid")
    };
  };
  const isSketchSpec = (spec) => {
    return spec.uid !== void 0;
  };
  const singleSchema = objOfOnly([
    required$1("name"),
    required$1("factory"),
    required$1("configFields"),
    defaulted("apis", {}),
    defaulted("extraApis", {})
  ]);
  const compositeSchema = objOfOnly([
    required$1("name"),
    required$1("factory"),
    required$1("configFields"),
    required$1("partFields"),
    defaulted("apis", {}),
    defaulted("extraApis", {})
  ]);
  const single = (rawConfig) => {
    const config2 = asRawOrDie$1("Sketcher for " + rawConfig.name, singleSchema, rawConfig);
    const sketch2 = (spec) => single$1(config2.name, config2.configFields, config2.factory, spec);
    const apis2 = map$1(config2.apis, makeApi);
    const extraApis = map$1(config2.extraApis, (f2, k) => markAsExtraApi(f2, k));
    return {
      name: config2.name,
      configFields: config2.configFields,
      sketch: sketch2,
      ...apis2,
      ...extraApis
    };
  };
  const composite = (rawConfig) => {
    const config2 = asRawOrDie$1("Sketcher for " + rawConfig.name, compositeSchema, rawConfig);
    const sketch2 = (spec) => composite$1(config2.name, config2.configFields, config2.partFields, config2.factory, spec);
    const parts2 = generate$3(config2.name, config2.partFields);
    const apis2 = map$1(config2.apis, makeApi);
    const extraApis = map$1(config2.extraApis, (f2, k) => markAsExtraApi(f2, k));
    return {
      name: config2.name,
      partFields: config2.partFields,
      configFields: config2.configFields,
      sketch: sketch2,
      parts: parts2,
      ...apis2,
      ...extraApis
    };
  };
  const inside = (target) => isTag("input")(target) && get$f(target, "type") !== "radio" || isTag("textarea")(target);
  const getCurrent = (component, composeConfig, _composeState) => composeConfig.find(component);
  var ComposeApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCurrent
  });
  const ComposeSchema = [required$1("find")];
  const Composing = create$42({
    fields: ComposeSchema,
    name: "composing",
    apis: ComposeApis
  });
  const nativeDisabled = [
    "input",
    "button",
    "textarea",
    "select"
  ];
  const onLoad$1 = (component, disableConfig, disableState) => {
    const f2 = disableConfig.disabled() ? disable : enable;
    f2(component, disableConfig);
  };
  const hasNative = (component, config2) => config2.useNative === true && contains$2(nativeDisabled, name$3(component.element));
  const nativeIsDisabled = (component) => has$1(component.element, "disabled");
  const nativeDisable = (component) => {
    set$9(component.element, "disabled", "disabled");
  };
  const nativeEnable = (component) => {
    remove$7(component.element, "disabled");
  };
  const ariaIsDisabled = (component) => get$f(component.element, "aria-disabled") === "true";
  const ariaDisable = (component) => {
    set$9(component.element, "aria-disabled", "true");
  };
  const ariaEnable = (component) => {
    set$9(component.element, "aria-disabled", "false");
  };
  const disable = (component, disableConfig, _disableState) => {
    disableConfig.disableClass.each((disableClass) => {
      add$2(component.element, disableClass);
    });
    const f2 = hasNative(component, disableConfig) ? nativeDisable : ariaDisable;
    f2(component);
    disableConfig.onDisabled(component);
  };
  const enable = (component, disableConfig, _disableState) => {
    disableConfig.disableClass.each((disableClass) => {
      remove$2(component.element, disableClass);
    });
    const f2 = hasNative(component, disableConfig) ? nativeEnable : ariaEnable;
    f2(component);
    disableConfig.onEnabled(component);
  };
  const isDisabled2 = (component, disableConfig) => hasNative(component, disableConfig) ? nativeIsDisabled(component) : ariaIsDisabled(component);
  const set$4 = (component, disableConfig, disableState, disabled) => {
    const f2 = disabled ? disable : enable;
    f2(component, disableConfig);
  };
  var DisableApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    enable,
    disable,
    isDisabled: isDisabled2,
    onLoad: onLoad$1,
    set: set$4
  });
  const exhibit$5 = (base2, disableConfig) => nu$7({ classes: disableConfig.disabled() ? disableConfig.disableClass.toArray() : [] });
  const events$e = (disableConfig, disableState) => derive$2([
    abort(execute$5(), (component, _simulatedEvent) => isDisabled2(component, disableConfig)),
    loadEvent(disableConfig, disableState, onLoad$1)
  ]);
  var ActiveDisable = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: exhibit$5,
    events: events$e
  });
  var DisableSchema = [
    defaultedFunction("disabled", never),
    defaulted("useNative", true),
    option$3("disableClass"),
    onHandler("onDisabled"),
    onHandler("onEnabled")
  ];
  const Disabling = create$42({
    fields: DisableSchema,
    name: "disabling",
    active: ActiveDisable,
    apis: DisableApis
  });
  const dehighlightAllExcept = (component, hConfig, hState, skip) => {
    const highlighted = descendants(component.element, "." + hConfig.highlightClass);
    each$1(highlighted, (h) => {
      const shouldSkip = exists(skip, (skipComp) => eq(skipComp.element, h));
      if (!shouldSkip) {
        remove$2(h, hConfig.highlightClass);
        component.getSystem().getByDom(h).each((target) => {
          hConfig.onDehighlight(component, target);
          emit(target, dehighlight$1());
        });
      }
    });
  };
  const dehighlightAll = (component, hConfig, hState) => dehighlightAllExcept(component, hConfig, hState, []);
  const dehighlight = (component, hConfig, hState, target) => {
    if (isHighlighted(component, hConfig, hState, target)) {
      remove$2(target.element, hConfig.highlightClass);
      hConfig.onDehighlight(component, target);
      emit(target, dehighlight$1());
    }
  };
  const highlight = (component, hConfig, hState, target) => {
    dehighlightAllExcept(component, hConfig, hState, [target]);
    if (!isHighlighted(component, hConfig, hState, target)) {
      add$2(target.element, hConfig.highlightClass);
      hConfig.onHighlight(component, target);
      emit(target, highlight$1());
    }
  };
  const highlightFirst = (component, hConfig, hState) => {
    getFirst(component, hConfig).each((firstComp) => {
      highlight(component, hConfig, hState, firstComp);
    });
  };
  const highlightLast = (component, hConfig, hState) => {
    getLast(component, hConfig).each((lastComp) => {
      highlight(component, hConfig, hState, lastComp);
    });
  };
  const highlightAt = (component, hConfig, hState, index) => {
    getByIndex(component, hConfig, hState, index).fold((err) => {
      throw err;
    }, (firstComp) => {
      highlight(component, hConfig, hState, firstComp);
    });
  };
  const highlightBy = (component, hConfig, hState, predicate) => {
    const candidates = getCandidates(component, hConfig);
    const targetComp = find$5(candidates, predicate);
    targetComp.each((c) => {
      highlight(component, hConfig, hState, c);
    });
  };
  const isHighlighted = (component, hConfig, hState, queryTarget) => has(queryTarget.element, hConfig.highlightClass);
  const getHighlighted = (component, hConfig, _hState) => descendant(component.element, "." + hConfig.highlightClass).bind((e) => component.getSystem().getByDom(e).toOptional());
  const getByIndex = (component, hConfig, hState, index) => {
    const items = descendants(component.element, "." + hConfig.itemClass);
    return Optional.from(items[index]).fold(() => Result.error(new Error("No element found with index " + index)), component.getSystem().getByDom);
  };
  const getFirst = (component, hConfig, _hState) => descendant(component.element, "." + hConfig.itemClass).bind((e) => component.getSystem().getByDom(e).toOptional());
  const getLast = (component, hConfig, _hState) => {
    const items = descendants(component.element, "." + hConfig.itemClass);
    const last2 = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
    return last2.bind((c) => component.getSystem().getByDom(c).toOptional());
  };
  const getDelta$2 = (component, hConfig, hState, delta) => {
    const items = descendants(component.element, "." + hConfig.itemClass);
    const current = findIndex$1(items, (item3) => has(item3, hConfig.highlightClass));
    return current.bind((selected) => {
      const dest = cycleBy(selected, delta, 0, items.length - 1);
      return component.getSystem().getByDom(items[dest]).toOptional();
    });
  };
  const getPrevious = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, -1);
  const getNext = (component, hConfig, hState) => getDelta$2(component, hConfig, hState, 1);
  const getCandidates = (component, hConfig, _hState) => {
    const items = descendants(component.element, "." + hConfig.itemClass);
    return cat(map$2(items, (i) => component.getSystem().getByDom(i).toOptional()));
  };
  var HighlightApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    dehighlightAll,
    dehighlight,
    highlight,
    highlightFirst,
    highlightLast,
    highlightAt,
    highlightBy,
    isHighlighted,
    getHighlighted,
    getFirst,
    getLast,
    getPrevious,
    getNext,
    getCandidates
  });
  var HighlightSchema = [
    required$1("highlightClass"),
    required$1("itemClass"),
    onHandler("onHighlight"),
    onHandler("onDehighlight")
  ];
  const Highlighting = create$42({
    fields: HighlightSchema,
    name: "highlighting",
    apis: HighlightApis
  });
  const BACKSPACE = [8];
  const TAB = [9];
  const ENTER = [13];
  const ESCAPE = [27];
  const SPACE = [32];
  const LEFT = [37];
  const UP = [38];
  const RIGHT = [39];
  const DOWN = [40];
  const cyclePrev = (values2, index, predicate) => {
    const before2 = reverse(values2.slice(0, index));
    const after2 = reverse(values2.slice(index + 1));
    return find$5(before2.concat(after2), predicate);
  };
  const tryPrev = (values2, index, predicate) => {
    const before2 = reverse(values2.slice(0, index));
    return find$5(before2, predicate);
  };
  const cycleNext = (values2, index, predicate) => {
    const before2 = values2.slice(0, index);
    const after2 = values2.slice(index + 1);
    return find$5(after2.concat(before2), predicate);
  };
  const tryNext = (values2, index, predicate) => {
    const after2 = values2.slice(index + 1);
    return find$5(after2, predicate);
  };
  const inSet = (keys2) => (event) => {
    const raw = event.raw;
    return contains$2(keys2, raw.which);
  };
  const and = (preds) => (event) => forall(preds, (pred) => pred(event));
  const isShift = (event) => {
    const raw = event.raw;
    return raw.shiftKey === true;
  };
  const isControl = (event) => {
    const raw = event.raw;
    return raw.ctrlKey === true;
  };
  const isNotShift = not(isShift);
  const rule = (matches, action) => ({
    matches,
    classification: action
  });
  const choose = (transitions, event) => {
    const transition = find$5(transitions, (t2) => t2.matches(event));
    return transition.map((t2) => t2.classification);
  };
  const reportFocusShifting = (component, prevFocus, newFocus) => {
    const noChange = prevFocus.exists((p) => newFocus.exists((n) => eq(n, p)));
    if (!noChange) {
      emitWith(component, focusShifted(), {
        prevFocus,
        newFocus
      });
    }
  };
  const dom$2 = () => {
    const get2 = (component) => search(component.element);
    const set2 = (component, focusee) => {
      const prevFocus = get2(component);
      component.getSystem().triggerFocus(focusee, component.element);
      const newFocus = get2(component);
      reportFocusShifting(component, prevFocus, newFocus);
    };
    return {
      get: get2,
      set: set2
    };
  };
  const highlights = () => {
    const get2 = (component) => Highlighting.getHighlighted(component).map((item3) => item3.element);
    const set2 = (component, element2) => {
      const prevFocus = get2(component);
      component.getSystem().getByDom(element2).fold(noop2, (item3) => {
        Highlighting.highlight(component, item3);
      });
      const newFocus = get2(component);
      reportFocusShifting(component, prevFocus, newFocus);
    };
    return {
      get: get2,
      set: set2
    };
  };
  var FocusInsideModes;
  (function(FocusInsideModes2) {
    FocusInsideModes2["OnFocusMode"] = "onFocus";
    FocusInsideModes2["OnEnterOrSpaceMode"] = "onEnterOrSpace";
    FocusInsideModes2["OnApiMode"] = "onApi";
  })(FocusInsideModes || (FocusInsideModes = {}));
  const typical = (infoSchema, stateInit, getKeydownRules2, getKeyupRules2, optFocusIn) => {
    const schema2 = () => infoSchema.concat([
      defaulted("focusManager", dom$2()),
      defaultedOf("focusInside", "onFocus", valueOf((val) => contains$2([
        "onFocus",
        "onEnterOrSpace",
        "onApi"
      ], val) ? Result.value(val) : Result.error("Invalid value for focusInside"))),
      output$1("handler", me),
      output$1("state", stateInit),
      output$1("sendFocusIn", optFocusIn)
    ]);
    const processKey = (component, simulatedEvent, getRules, keyingConfig, keyingState) => {
      const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
      return choose(rules, simulatedEvent.event).bind((rule2) => rule2(component, simulatedEvent, keyingConfig, keyingState));
    };
    const toEvents2 = (keyingConfig, keyingState) => {
      const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode ? Optional.none() : optFocusIn(keyingConfig).map((focusIn2) => run$1(focus$4(), (component, simulatedEvent) => {
        focusIn2(component, keyingConfig, keyingState);
        simulatedEvent.stop();
      }));
      const tryGoInsideComponent = (component, simulatedEvent) => {
        const isEnterOrSpace = inSet(SPACE.concat(ENTER))(simulatedEvent.event);
        if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && isSource(component, simulatedEvent)) {
          optFocusIn(keyingConfig).each((focusIn2) => {
            focusIn2(component, keyingConfig, keyingState);
            simulatedEvent.stop();
          });
        }
      };
      const keyboardEvents = [
        run$1(keydown(), (component, simulatedEvent) => {
          processKey(component, simulatedEvent, getKeydownRules2, keyingConfig, keyingState).fold(() => {
            tryGoInsideComponent(component, simulatedEvent);
          }, (_2) => {
            simulatedEvent.stop();
          });
        }),
        run$1(keyup(), (component, simulatedEvent) => {
          processKey(component, simulatedEvent, getKeyupRules2, keyingConfig, keyingState).each((_2) => {
            simulatedEvent.stop();
          });
        })
      ];
      return derive$2(onFocusHandler.toArray().concat(keyboardEvents));
    };
    const me = {
      schema: schema2,
      processKey,
      toEvents: toEvents2
    };
    return me;
  };
  const create$22 = (cyclicField) => {
    const schema2 = [
      option$3("onEscape"),
      option$3("onEnter"),
      defaulted("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
      defaulted("firstTabstop", 0),
      defaulted("useTabstopAt", always),
      option$3("visibilitySelector")
    ].concat([cyclicField]);
    const isVisible3 = (tabbingConfig, element2) => {
      const target = tabbingConfig.visibilitySelector.bind((sel) => closest$1(element2, sel)).getOr(element2);
      return get$d(target) > 0;
    };
    const findInitial = (component, tabbingConfig) => {
      const tabstops = descendants(component.element, tabbingConfig.selector);
      const visibles = filter$2(tabstops, (elem) => isVisible3(tabbingConfig, elem));
      return Optional.from(visibles[tabbingConfig.firstTabstop]);
    };
    const findCurrent2 = (component, tabbingConfig) => tabbingConfig.focusManager.get(component).bind((elem) => closest$1(elem, tabbingConfig.selector));
    const isTabstop = (tabbingConfig, element2) => isVisible3(tabbingConfig, element2) && tabbingConfig.useTabstopAt(element2);
    const focusIn2 = (component, tabbingConfig, _tabbingState) => {
      findInitial(component, tabbingConfig).each((target) => {
        tabbingConfig.focusManager.set(component, target);
      });
    };
    const goFromTabstop = (component, tabstops, stopIndex, tabbingConfig, cycle) => cycle(tabstops, stopIndex, (elem) => isTabstop(tabbingConfig, elem)).fold(() => tabbingConfig.cyclic ? Optional.some(true) : Optional.none(), (target) => {
      tabbingConfig.focusManager.set(component, target);
      return Optional.some(true);
    });
    const go2 = (component, _simulatedEvent, tabbingConfig, cycle) => {
      const tabstops = descendants(component.element, tabbingConfig.selector);
      return findCurrent2(component, tabbingConfig).bind((tabstop) => {
        const optStopIndex = findIndex$1(tabstops, curry(eq, tabstop));
        return optStopIndex.bind((stopIndex) => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));
      });
    };
    const goBackwards = (component, simulatedEvent, tabbingConfig) => {
      const navigate = tabbingConfig.cyclic ? cyclePrev : tryPrev;
      return go2(component, simulatedEvent, tabbingConfig, navigate);
    };
    const goForwards = (component, simulatedEvent, tabbingConfig) => {
      const navigate = tabbingConfig.cyclic ? cycleNext : tryNext;
      return go2(component, simulatedEvent, tabbingConfig, navigate);
    };
    const execute3 = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEnter.bind((f2) => f2(component, simulatedEvent));
    const exit = (component, simulatedEvent, tabbingConfig) => tabbingConfig.onEscape.bind((f2) => f2(component, simulatedEvent));
    const getKeydownRules2 = constant$1([
      rule(and([
        isShift,
        inSet(TAB)
      ]), goBackwards),
      rule(inSet(TAB), goForwards),
      rule(and([
        isNotShift,
        inSet(ENTER)
      ]), execute3)
    ]);
    const getKeyupRules2 = constant$1([rule(inSet(ESCAPE), exit)]);
    return typical(schema2, NoState.init, getKeydownRules2, getKeyupRules2, () => Optional.some(focusIn2));
  };
  var AcyclicType = create$22(customField("cyclic", never));
  var CyclicType = create$22(customField("cyclic", always));
  const doDefaultExecute = (component, _simulatedEvent, focused) => {
    dispatch(component, focused, execute$5());
    return Optional.some(true);
  };
  const defaultExecute = (component, simulatedEvent, focused) => {
    const isComplex = inside(focused) && inSet(SPACE)(simulatedEvent.event);
    return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
  };
  const stopEventForFirefox = (_component, _simulatedEvent) => Optional.some(true);
  const schema$v = [
    defaulted("execute", defaultExecute),
    defaulted("useSpace", false),
    defaulted("useEnter", true),
    defaulted("useControlEnter", false),
    defaulted("useDown", false)
  ];
  const execute$4 = (component, simulatedEvent, executeConfig) => executeConfig.execute(component, simulatedEvent, component.element);
  const getKeydownRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => {
    const spaceExec = executeConfig.useSpace && !inside(component.element) ? SPACE : [];
    const enterExec = executeConfig.useEnter ? ENTER : [];
    const downExec = executeConfig.useDown ? DOWN : [];
    const execKeys = spaceExec.concat(enterExec).concat(downExec);
    return [rule(inSet(execKeys), execute$4)].concat(executeConfig.useControlEnter ? [rule(and([
      isControl,
      inSet(ENTER)
    ]), execute$4)] : []);
  };
  const getKeyupRules$5 = (component, _simulatedEvent, executeConfig, _executeState) => executeConfig.useSpace && !inside(component.element) ? [rule(inSet(SPACE), stopEventForFirefox)] : [];
  var ExecutionType = typical(schema$v, NoState.init, getKeydownRules$5, getKeyupRules$5, () => Optional.none());
  const flatgrid$1 = () => {
    const dimensions = value$2();
    const setGridSize = (numRows, numColumns) => {
      dimensions.set({
        numRows,
        numColumns
      });
    };
    const getNumRows = () => dimensions.get().map((d) => d.numRows);
    const getNumColumns = () => dimensions.get().map((d) => d.numColumns);
    return nu$8({
      readState: () => dimensions.get().map((d) => ({
        numRows: String(d.numRows),
        numColumns: String(d.numColumns)
      })).getOr({
        numRows: "?",
        numColumns: "?"
      }),
      setGridSize,
      getNumRows,
      getNumColumns
    });
  };
  const init$d = (spec) => spec.state(spec);
  var KeyingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    flatgrid: flatgrid$1,
    init: init$d
  });
  const useH = (movement) => (component, simulatedEvent, config2, state2) => {
    const move2 = movement(component.element);
    return use(move2, component, simulatedEvent, config2, state2);
  };
  const west$1 = (moveLeft2, moveRight2) => {
    const movement = onDirection(moveLeft2, moveRight2);
    return useH(movement);
  };
  const east$1 = (moveLeft2, moveRight2) => {
    const movement = onDirection(moveRight2, moveLeft2);
    return useH(movement);
  };
  const useV = (move2) => (component, simulatedEvent, config2, state2) => use(move2, component, simulatedEvent, config2, state2);
  const use = (move2, component, simulatedEvent, config2, state2) => {
    const outcome = config2.focusManager.get(component).bind((focused) => move2(component.element, focused, config2, state2));
    return outcome.map((newFocus) => {
      config2.focusManager.set(component, newFocus);
      return true;
    });
  };
  const north$1 = useV;
  const south$1 = useV;
  const move$1 = useV;
  const isHidden$1 = (dom2) => dom2.offsetWidth <= 0 && dom2.offsetHeight <= 0;
  const isVisible2 = (element2) => !isHidden$1(element2.dom);
  const locate = (candidates, predicate) => findIndex$1(candidates, predicate).map((index) => ({
    index,
    candidates
  }));
  const locateVisible = (container, current, selector) => {
    const predicate = (x) => eq(x, current);
    const candidates = descendants(container, selector);
    const visible = filter$2(candidates, isVisible2);
    return locate(visible, predicate);
  };
  const findIndex = (elements, target) => findIndex$1(elements, (elem) => eq(target, elem));
  const withGrid = (values2, index, numCols, f2) => {
    const oldRow = Math.floor(index / numCols);
    const oldColumn = index % numCols;
    return f2(oldRow, oldColumn).bind((address) => {
      const newIndex = address.row * numCols + address.column;
      return newIndex >= 0 && newIndex < values2.length ? Optional.some(values2[newIndex]) : Optional.none();
    });
  };
  const cycleHorizontal$1 = (values2, index, numRows, numCols, delta) => withGrid(values2, index, numCols, (oldRow, oldColumn) => {
    const onLastRow = oldRow === numRows - 1;
    const colsInRow = onLastRow ? values2.length - oldRow * numCols : numCols;
    const newColumn = cycleBy(oldColumn, delta, 0, colsInRow - 1);
    return Optional.some({
      row: oldRow,
      column: newColumn
    });
  });
  const cycleVertical$1 = (values2, index, numRows, numCols, delta) => withGrid(values2, index, numCols, (oldRow, oldColumn) => {
    const newRow = cycleBy(oldRow, delta, 0, numRows - 1);
    const onLastRow = newRow === numRows - 1;
    const colsInRow = onLastRow ? values2.length - newRow * numCols : numCols;
    const newCol = clamp(oldColumn, 0, colsInRow - 1);
    return Optional.some({
      row: newRow,
      column: newCol
    });
  });
  const cycleRight$1 = (values2, index, numRows, numCols) => cycleHorizontal$1(values2, index, numRows, numCols, 1);
  const cycleLeft$1 = (values2, index, numRows, numCols) => cycleHorizontal$1(values2, index, numRows, numCols, -1);
  const cycleUp$1 = (values2, index, numRows, numCols) => cycleVertical$1(values2, index, numRows, numCols, -1);
  const cycleDown$1 = (values2, index, numRows, numCols) => cycleVertical$1(values2, index, numRows, numCols, 1);
  const schema$u = [
    required$1("selector"),
    defaulted("execute", defaultExecute),
    onKeyboardHandler("onEscape"),
    defaulted("captureTab", false),
    initSize()
  ];
  const focusIn$3 = (component, gridConfig, _gridState) => {
    descendant(component.element, gridConfig.selector).each((first2) => {
      gridConfig.focusManager.set(component, first2);
    });
  };
  const findCurrent$1 = (component, gridConfig) => gridConfig.focusManager.get(component).bind((elem) => closest$1(elem, gridConfig.selector));
  const execute$3 = (component, simulatedEvent, gridConfig, _gridState) => findCurrent$1(component, gridConfig).bind((focused) => gridConfig.execute(component, simulatedEvent, focused));
  const doMove$2 = (cycle) => (element2, focused, gridConfig, gridState) => locateVisible(element2, focused, gridConfig.selector).bind((identified) => cycle(identified.candidates, identified.index, gridState.getNumRows().getOr(gridConfig.initSize.numRows), gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)));
  const handleTab = (_component, _simulatedEvent, gridConfig) => gridConfig.captureTab ? Optional.some(true) : Optional.none();
  const doEscape$1 = (component, simulatedEvent, gridConfig) => gridConfig.onEscape(component, simulatedEvent);
  const moveLeft$3 = doMove$2(cycleLeft$1);
  const moveRight$3 = doMove$2(cycleRight$1);
  const moveNorth$1 = doMove$2(cycleUp$1);
  const moveSouth$1 = doMove$2(cycleDown$1);
  const getKeydownRules$4 = constant$1([
    rule(inSet(LEFT), west$1(moveLeft$3, moveRight$3)),
    rule(inSet(RIGHT), east$1(moveLeft$3, moveRight$3)),
    rule(inSet(UP), north$1(moveNorth$1)),
    rule(inSet(DOWN), south$1(moveSouth$1)),
    rule(and([
      isShift,
      inSet(TAB)
    ]), handleTab),
    rule(and([
      isNotShift,
      inSet(TAB)
    ]), handleTab),
    rule(inSet(SPACE.concat(ENTER)), execute$3)
  ]);
  const getKeyupRules$4 = constant$1([
    rule(inSet(ESCAPE), doEscape$1),
    rule(inSet(SPACE), stopEventForFirefox)
  ]);
  var FlatgridType = typical(schema$u, flatgrid$1, getKeydownRules$4, getKeyupRules$4, () => Optional.some(focusIn$3));
  const f = (container, selector, current, delta, getNewIndex) => {
    const isDisabledButton = (candidate) => name$3(candidate) === "button" && get$f(candidate, "disabled") === "disabled";
    const tryNewIndex = (initial, index, candidates) => getNewIndex(initial, index, delta, 0, candidates.length - 1, candidates[index], (newIndex) => isDisabledButton(candidates[newIndex]) ? tryNewIndex(initial, newIndex, candidates) : Optional.from(candidates[newIndex]));
    return locateVisible(container, current, selector).bind((identified) => {
      const index = identified.index;
      const candidates = identified.candidates;
      return tryNewIndex(index, index, candidates);
    });
  };
  const horizontalWithoutCycles = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min3, max3, oldCandidate, onNewIndex) => {
    const newIndex = clamp(v + d, min3, max3);
    return newIndex === prevIndex ? Optional.from(oldCandidate) : onNewIndex(newIndex);
  });
  const horizontal = (container, selector, current, delta) => f(container, selector, current, delta, (prevIndex, v, d, min3, max3, _oldCandidate, onNewIndex) => {
    const newIndex = cycleBy(v, d, min3, max3);
    return newIndex === prevIndex ? Optional.none() : onNewIndex(newIndex);
  });
  const schema$t = [
    required$1("selector"),
    defaulted("getInitial", Optional.none),
    defaulted("execute", defaultExecute),
    onKeyboardHandler("onEscape"),
    defaulted("executeOnMove", false),
    defaulted("allowVertical", true),
    defaulted("allowHorizontal", true),
    defaulted("cycles", true)
  ];
  const findCurrent = (component, flowConfig) => flowConfig.focusManager.get(component).bind((elem) => closest$1(elem, flowConfig.selector));
  const execute$2 = (component, simulatedEvent, flowConfig) => findCurrent(component, flowConfig).bind((focused) => flowConfig.execute(component, simulatedEvent, focused));
  const focusIn$2 = (component, flowConfig, _state) => {
    flowConfig.getInitial(component).orThunk(() => descendant(component.element, flowConfig.selector)).each((first2) => {
      flowConfig.focusManager.set(component, first2);
    });
  };
  const moveLeft$2 = (element2, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element2, info.selector, focused, -1);
  const moveRight$2 = (element2, focused, info) => (info.cycles ? horizontal : horizontalWithoutCycles)(element2, info.selector, focused, 1);
  const doMove$1 = (movement) => (component, simulatedEvent, flowConfig, flowState) => movement(component, simulatedEvent, flowConfig, flowState).bind(() => flowConfig.executeOnMove ? execute$2(component, simulatedEvent, flowConfig) : Optional.some(true));
  const doEscape = (component, simulatedEvent, flowConfig) => flowConfig.onEscape(component, simulatedEvent);
  const getKeydownRules$3 = (_component, _se, flowConfig, _flowState) => {
    const westMovers = [...flowConfig.allowHorizontal ? LEFT : []].concat(flowConfig.allowVertical ? UP : []);
    const eastMovers = [...flowConfig.allowHorizontal ? RIGHT : []].concat(flowConfig.allowVertical ? DOWN : []);
    return [
      rule(inSet(westMovers), doMove$1(west$1(moveLeft$2, moveRight$2))),
      rule(inSet(eastMovers), doMove$1(east$1(moveLeft$2, moveRight$2))),
      rule(inSet(ENTER), execute$2),
      rule(inSet(SPACE), execute$2)
    ];
  };
  const getKeyupRules$3 = constant$1([
    rule(inSet(SPACE), stopEventForFirefox),
    rule(inSet(ESCAPE), doEscape)
  ]);
  var FlowType = typical(schema$t, NoState.init, getKeydownRules$3, getKeyupRules$3, () => Optional.some(focusIn$2));
  const toCell = (matrix2, rowIndex, columnIndex) => Optional.from(matrix2[rowIndex]).bind((row) => Optional.from(row[columnIndex]).map((cell) => ({
    rowIndex,
    columnIndex,
    cell
  })));
  const cycleHorizontal = (matrix2, rowIndex, startCol, deltaCol) => {
    const row = matrix2[rowIndex];
    const colsInRow = row.length;
    const newColIndex = cycleBy(startCol, deltaCol, 0, colsInRow - 1);
    return toCell(matrix2, rowIndex, newColIndex);
  };
  const cycleVertical = (matrix2, colIndex, startRow, deltaRow) => {
    const nextRowIndex = cycleBy(startRow, deltaRow, 0, matrix2.length - 1);
    const colsInNextRow = matrix2[nextRowIndex].length;
    const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
    return toCell(matrix2, nextRowIndex, nextColIndex);
  };
  const moveHorizontal = (matrix2, rowIndex, startCol, deltaCol) => {
    const row = matrix2[rowIndex];
    const colsInRow = row.length;
    const newColIndex = clamp(startCol + deltaCol, 0, colsInRow - 1);
    return toCell(matrix2, rowIndex, newColIndex);
  };
  const moveVertical = (matrix2, colIndex, startRow, deltaRow) => {
    const nextRowIndex = clamp(startRow + deltaRow, 0, matrix2.length - 1);
    const colsInNextRow = matrix2[nextRowIndex].length;
    const nextColIndex = clamp(colIndex, 0, colsInNextRow - 1);
    return toCell(matrix2, nextRowIndex, nextColIndex);
  };
  const cycleRight = (matrix2, startRow, startCol) => cycleHorizontal(matrix2, startRow, startCol, 1);
  const cycleLeft = (matrix2, startRow, startCol) => cycleHorizontal(matrix2, startRow, startCol, -1);
  const cycleUp = (matrix2, startRow, startCol) => cycleVertical(matrix2, startCol, startRow, -1);
  const cycleDown = (matrix2, startRow, startCol) => cycleVertical(matrix2, startCol, startRow, 1);
  const moveLeft$1 = (matrix2, startRow, startCol) => moveHorizontal(matrix2, startRow, startCol, -1);
  const moveRight$1 = (matrix2, startRow, startCol) => moveHorizontal(matrix2, startRow, startCol, 1);
  const moveUp$1 = (matrix2, startRow, startCol) => moveVertical(matrix2, startCol, startRow, -1);
  const moveDown$1 = (matrix2, startRow, startCol) => moveVertical(matrix2, startCol, startRow, 1);
  const schema$s = [
    requiredObjOf("selectors", [
      required$1("row"),
      required$1("cell")
    ]),
    defaulted("cycles", true),
    defaulted("previousSelector", Optional.none),
    defaulted("execute", defaultExecute)
  ];
  const focusIn$1 = (component, matrixConfig, _state) => {
    const focused = matrixConfig.previousSelector(component).orThunk(() => {
      const selectors = matrixConfig.selectors;
      return descendant(component.element, selectors.cell);
    });
    focused.each((cell) => {
      matrixConfig.focusManager.set(component, cell);
    });
  };
  const execute$1 = (component, simulatedEvent, matrixConfig) => search(component.element).bind((focused) => matrixConfig.execute(component, simulatedEvent, focused));
  const toMatrix = (rows, matrixConfig) => map$2(rows, (row) => descendants(row, matrixConfig.selectors.cell));
  const doMove = (ifCycle, ifMove) => (element2, focused, matrixConfig) => {
    const move2 = matrixConfig.cycles ? ifCycle : ifMove;
    return closest$1(focused, matrixConfig.selectors.row).bind((inRow) => {
      const cellsInRow = descendants(inRow, matrixConfig.selectors.cell);
      return findIndex(cellsInRow, focused).bind((colIndex) => {
        const allRows = descendants(element2, matrixConfig.selectors.row);
        return findIndex(allRows, inRow).bind((rowIndex) => {
          const matrix2 = toMatrix(allRows, matrixConfig);
          return move2(matrix2, rowIndex, colIndex).map((next) => next.cell);
        });
      });
    });
  };
  const moveLeft = doMove(cycleLeft, moveLeft$1);
  const moveRight = doMove(cycleRight, moveRight$1);
  const moveNorth = doMove(cycleUp, moveUp$1);
  const moveSouth = doMove(cycleDown, moveDown$1);
  const getKeydownRules$2 = constant$1([
    rule(inSet(LEFT), west$1(moveLeft, moveRight)),
    rule(inSet(RIGHT), east$1(moveLeft, moveRight)),
    rule(inSet(UP), north$1(moveNorth)),
    rule(inSet(DOWN), south$1(moveSouth)),
    rule(inSet(SPACE.concat(ENTER)), execute$1)
  ]);
  const getKeyupRules$2 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
  var MatrixType = typical(schema$s, NoState.init, getKeydownRules$2, getKeyupRules$2, () => Optional.some(focusIn$1));
  const schema$r = [
    required$1("selector"),
    defaulted("execute", defaultExecute),
    defaulted("moveOnTab", false)
  ];
  const execute2 = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind((focused) => menuConfig.execute(component, simulatedEvent, focused));
  const focusIn = (component, menuConfig, _state) => {
    descendant(component.element, menuConfig.selector).each((first2) => {
      menuConfig.focusManager.set(component, first2);
    });
  };
  const moveUp = (element2, focused, info) => horizontal(element2, info.selector, focused, -1);
  const moveDown = (element2, focused, info) => horizontal(element2, info.selector, focused, 1);
  const fireShiftTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
  const fireTab = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? move$1(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
  const getKeydownRules$1 = constant$1([
    rule(inSet(UP), move$1(moveUp)),
    rule(inSet(DOWN), move$1(moveDown)),
    rule(and([
      isShift,
      inSet(TAB)
    ]), fireShiftTab),
    rule(and([
      isNotShift,
      inSet(TAB)
    ]), fireTab),
    rule(inSet(ENTER), execute2),
    rule(inSet(SPACE), execute2)
  ]);
  const getKeyupRules$1 = constant$1([rule(inSet(SPACE), stopEventForFirefox)]);
  var MenuType = typical(schema$r, NoState.init, getKeydownRules$1, getKeyupRules$1, () => Optional.some(focusIn));
  const schema$q = [
    onKeyboardHandler("onSpace"),
    onKeyboardHandler("onEnter"),
    onKeyboardHandler("onShiftEnter"),
    onKeyboardHandler("onLeft"),
    onKeyboardHandler("onRight"),
    onKeyboardHandler("onTab"),
    onKeyboardHandler("onShiftTab"),
    onKeyboardHandler("onUp"),
    onKeyboardHandler("onDown"),
    onKeyboardHandler("onEscape"),
    defaulted("stopSpaceKeyup", false),
    option$3("focusIn")
  ];
  const getKeydownRules = (component, simulatedEvent, specialInfo) => [
    rule(inSet(SPACE), specialInfo.onSpace),
    rule(and([
      isNotShift,
      inSet(ENTER)
    ]), specialInfo.onEnter),
    rule(and([
      isShift,
      inSet(ENTER)
    ]), specialInfo.onShiftEnter),
    rule(and([
      isShift,
      inSet(TAB)
    ]), specialInfo.onShiftTab),
    rule(and([
      isNotShift,
      inSet(TAB)
    ]), specialInfo.onTab),
    rule(inSet(UP), specialInfo.onUp),
    rule(inSet(DOWN), specialInfo.onDown),
    rule(inSet(LEFT), specialInfo.onLeft),
    rule(inSet(RIGHT), specialInfo.onRight),
    rule(inSet(SPACE), specialInfo.onSpace)
  ];
  const getKeyupRules = (component, simulatedEvent, specialInfo) => [
    ...specialInfo.stopSpaceKeyup ? [rule(inSet(SPACE), stopEventForFirefox)] : [],
    rule(inSet(ESCAPE), specialInfo.onEscape)
  ];
  var SpecialType = typical(schema$q, NoState.init, getKeydownRules, getKeyupRules, (specialInfo) => specialInfo.focusIn);
  const acyclic = AcyclicType.schema();
  const cyclic = CyclicType.schema();
  const flow = FlowType.schema();
  const flatgrid = FlatgridType.schema();
  const matrix = MatrixType.schema();
  const execution = ExecutionType.schema();
  const menu = MenuType.schema();
  const special = SpecialType.schema();
  var KeyboardBranches = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    acyclic,
    cyclic,
    flow,
    flatgrid,
    matrix,
    execution,
    menu,
    special
  });
  const isFlatgridState = (keyState) => hasNonNullableKey(keyState, "setGridSize");
  const Keying = createModes({
    branchKey: "mode",
    branches: KeyboardBranches,
    name: "keying",
    active: {
      events: (keyingConfig, keyingState) => {
        const handler = keyingConfig.handler;
        return handler.toEvents(keyingConfig, keyingState);
      }
    },
    apis: {
      focusIn: (component, keyConfig, keyState) => {
        keyConfig.sendFocusIn(keyConfig).fold(() => {
          component.getSystem().triggerFocus(component.element, component.element);
        }, (sendFocusIn) => {
          sendFocusIn(component, keyConfig, keyState);
        });
      },
      setGridSize: (component, keyConfig, keyState, numRows, numColumns) => {
        if (!isFlatgridState(keyState)) {
          console.error("Layout does not support setGridSize");
        } else {
          keyState.setGridSize(numRows, numColumns);
        }
      }
    },
    state: KeyingState
  });
  const withoutReuse = (parent2, data2) => {
    preserve$1(() => {
      replaceChildren(parent2, data2, () => map$2(data2, parent2.getSystem().build));
    }, parent2.element);
  };
  const withReuse = (parent2, data2) => {
    preserve$1(() => {
      virtualReplaceChildren(parent2, data2, () => {
        return patchSpecChildren(parent2.element, data2, parent2.getSystem().buildOrPatch);
      });
    }, parent2.element);
  };
  const virtualReplace = (component, replacee, replaceeIndex, childSpec) => {
    virtualDetach(replacee);
    const child2 = patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);
    virtualAttach(component, child2);
    component.syncComponents();
  };
  const insert = (component, insertion, childSpec) => {
    const child2 = component.getSystem().build(childSpec);
    attachWith(component, child2, insertion);
  };
  const replace = (component, replacee, replaceeIndex, childSpec) => {
    detach(replacee);
    insert(component, (p, c) => appendAt(p, c, replaceeIndex), childSpec);
  };
  const set$3 = (component, replaceConfig, replaceState, data2) => {
    const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;
    return replacer(component, data2);
  };
  const append2 = (component, replaceConfig, replaceState, appendee) => {
    insert(component, append$2, appendee);
  };
  const prepend = (component, replaceConfig, replaceState, prependee) => {
    insert(component, prepend$1, prependee);
  };
  const remove = (component, replaceConfig, replaceState, removee) => {
    const children2 = contents(component);
    const foundChild = find$5(children2, (child2) => eq(removee.element, child2.element));
    foundChild.each(detach);
  };
  const contents = (component, _replaceConfig) => component.components();
  const replaceAt = (component, replaceConfig, replaceState, replaceeIndex, replacer) => {
    const children2 = contents(component);
    return Optional.from(children2[replaceeIndex]).map((replacee) => {
      replacer.fold(() => detach(replacee), (r2) => {
        const replacer2 = replaceConfig.reuseDom ? virtualReplace : replace;
        replacer2(component, replacee, replaceeIndex, r2);
      });
      return replacee;
    });
  };
  const replaceBy = (component, replaceConfig, replaceState, replaceePred, replacer) => {
    const children2 = contents(component);
    return findIndex$1(children2, replaceePred).bind((replaceeIndex) => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));
  };
  var ReplaceApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    append: append2,
    prepend,
    remove,
    replaceAt,
    replaceBy,
    set: set$3,
    contents
  });
  const Replacing = create$42({
    fields: [defaultedBoolean("reuseDom", true)],
    name: "replacing",
    apis: ReplaceApis
  });
  const events$d = (name3, eventHandlers) => {
    const events2 = derive$2(eventHandlers);
    return create$42({
      fields: [required$1("enabled")],
      name: name3,
      active: { events: constant$1(events2) }
    });
  };
  const config = (name3, eventHandlers) => {
    const me = events$d(name3, eventHandlers);
    return {
      key: name3,
      value: {
        config: {},
        me,
        configAsRaw: constant$1({}),
        initialConfig: {},
        state: NoState
      }
    };
  };
  const focus$2 = (component, focusConfig) => {
    if (!focusConfig.ignore) {
      focus$3(component.element);
      focusConfig.onFocus(component);
    }
  };
  const blur = (component, focusConfig) => {
    if (!focusConfig.ignore) {
      blur$1(component.element);
    }
  };
  const isFocused = (component) => hasFocus(component.element);
  var FocusApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    focus: focus$2,
    blur,
    isFocused
  });
  const exhibit$4 = (base2, focusConfig) => {
    const mod = focusConfig.ignore ? {} : { attributes: { tabindex: "-1" } };
    return nu$7(mod);
  };
  const events$c = (focusConfig) => derive$2([run$1(focus$4(), (component, simulatedEvent) => {
    focus$2(component, focusConfig);
    simulatedEvent.stop();
  })].concat(focusConfig.stopMousedown ? [run$1(mousedown(), (_2, simulatedEvent) => {
    simulatedEvent.event.prevent();
  })] : []));
  var ActiveFocus = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: exhibit$4,
    events: events$c
  });
  var FocusSchema = [
    onHandler("onFocus"),
    defaulted("stopMousedown", false),
    defaulted("ignore", false)
  ];
  const Focusing = create$42({
    fields: FocusSchema,
    name: "focusing",
    active: ActiveFocus,
    apis: FocusApis
  });
  const SetupBehaviourCellState = (initialState) => {
    const init2 = () => {
      const cell = Cell(initialState);
      const get2 = () => cell.get();
      const set2 = (newState) => cell.set(newState);
      const clear3 = () => cell.set(initialState);
      const readState = () => cell.get();
      return {
        get: get2,
        set: set2,
        clear: clear3,
        readState
      };
    };
    return { init: init2 };
  };
  const updateAriaState = (component, toggleConfig, toggleState) => {
    const ariaInfo = toggleConfig.aria;
    ariaInfo.update(component, ariaInfo, toggleState.get());
  };
  const updateClass = (component, toggleConfig, toggleState) => {
    toggleConfig.toggleClass.each((toggleClass) => {
      if (toggleState.get()) {
        add$2(component.element, toggleClass);
      } else {
        remove$2(component.element, toggleClass);
      }
    });
  };
  const set$2 = (component, toggleConfig, toggleState, state2) => {
    const initialState = toggleState.get();
    toggleState.set(state2);
    updateClass(component, toggleConfig, toggleState);
    updateAriaState(component, toggleConfig, toggleState);
    if (initialState !== state2) {
      toggleConfig.onToggled(component, state2);
    }
  };
  const toggle$2 = (component, toggleConfig, toggleState) => {
    set$2(component, toggleConfig, toggleState, !toggleState.get());
  };
  const on2 = (component, toggleConfig, toggleState) => {
    set$2(component, toggleConfig, toggleState, true);
  };
  const off = (component, toggleConfig, toggleState) => {
    set$2(component, toggleConfig, toggleState, false);
  };
  const isOn = (component, toggleConfig, toggleState) => toggleState.get();
  const onLoad = (component, toggleConfig, toggleState) => {
    set$2(component, toggleConfig, toggleState, toggleConfig.selected);
  };
  var ToggleApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    onLoad,
    toggle: toggle$2,
    isOn,
    on: on2,
    off,
    set: set$2
  });
  const exhibit$3 = () => nu$7({});
  const events$b = (toggleConfig, toggleState) => {
    const execute3 = executeEvent(toggleConfig, toggleState, toggle$2);
    const load = loadEvent(toggleConfig, toggleState, onLoad);
    return derive$2(flatten([
      toggleConfig.toggleOnExecute ? [execute3] : [],
      [load]
    ]));
  };
  var ActiveToggle = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: exhibit$3,
    events: events$b
  });
  const updatePressed = (component, ariaInfo, status) => {
    set$9(component.element, "aria-pressed", status);
    if (ariaInfo.syncWithExpanded) {
      updateExpanded(component, ariaInfo, status);
    }
  };
  const updateSelected = (component, ariaInfo, status) => {
    set$9(component.element, "aria-selected", status);
  };
  const updateChecked = (component, ariaInfo, status) => {
    set$9(component.element, "aria-checked", status);
  };
  const updateExpanded = (component, ariaInfo, status) => {
    set$9(component.element, "aria-expanded", status);
  };
  var ToggleSchema = [
    defaulted("selected", false),
    option$3("toggleClass"),
    defaulted("toggleOnExecute", true),
    onHandler("onToggled"),
    defaultedOf("aria", { mode: "none" }, choose$1("mode", {
      pressed: [
        defaulted("syncWithExpanded", false),
        output$1("update", updatePressed)
      ],
      checked: [output$1("update", updateChecked)],
      expanded: [output$1("update", updateExpanded)],
      selected: [output$1("update", updateSelected)],
      none: [output$1("update", noop2)]
    }))
  ];
  const Toggling = create$42({
    fields: ToggleSchema,
    name: "toggling",
    active: ActiveToggle,
    apis: ToggleApis,
    state: SetupBehaviourCellState(false)
  });
  const pointerEvents = () => {
    const onClick = (component, simulatedEvent) => {
      simulatedEvent.stop();
      emitExecute(component);
    };
    return [
      run$1(click(), onClick),
      run$1(tap(), onClick),
      cutter(touchstart()),
      cutter(mousedown())
    ];
  };
  const events$a = (optAction) => {
    const executeHandler = (action) => runOnExecute$1((component, simulatedEvent) => {
      action(component);
      simulatedEvent.stop();
    });
    return derive$2(flatten([
      optAction.map(executeHandler).toArray(),
      pointerEvents()
    ]));
  };
  const hoverEvent = "alloy.item-hover";
  const focusEvent = "alloy.item-focus";
  const toggledEvent = "alloy.item-toggled";
  const onHover = (item3) => {
    if (search(item3.element).isNone() || Focusing.isFocused(item3)) {
      if (!Focusing.isFocused(item3)) {
        Focusing.focus(item3);
      }
      emitWith(item3, hoverEvent, { item: item3 });
    }
  };
  const onFocus$1 = (item3) => {
    emitWith(item3, focusEvent, { item: item3 });
  };
  const onToggled = (item3, state2) => {
    emitWith(item3, toggledEvent, {
      item: item3,
      state: state2
    });
  };
  const hover = constant$1(hoverEvent);
  const focus$1 = constant$1(focusEvent);
  const toggled = constant$1(toggledEvent);
  const getItemRole = (detail) => detail.toggling.map((toggling) => toggling.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem");
  const getTogglingSpec = (tConfig) => ({
    aria: { mode: "checked" },
    ...filter$1(tConfig, (_value, name3) => name3 !== "exclusive"),
    onToggled: (component, state2) => {
      if (isFunction2(tConfig.onToggled)) {
        tConfig.onToggled(component, state2);
      }
      onToggled(component, state2);
    }
  });
  const builder$2 = (detail) => ({
    dom: detail.dom,
    domModification: {
      ...detail.domModification,
      attributes: {
        "role": getItemRole(detail),
        ...detail.domModification.attributes,
        "aria-haspopup": detail.hasSubmenu,
        ...detail.hasSubmenu ? { "aria-expanded": false } : {}
      }
    },
    behaviours: SketchBehaviours.augment(detail.itemBehaviours, [
      detail.toggling.fold(Toggling.revoke, (tConfig) => Toggling.config(getTogglingSpec(tConfig))),
      Focusing.config({
        ignore: detail.ignoreFocus,
        stopMousedown: detail.ignoreFocus,
        onFocus: (component) => {
          onFocus$1(component);
        }
      }),
      Keying.config({ mode: "execution" }),
      Representing.config({
        store: {
          mode: "memory",
          initialValue: detail.data
        }
      }),
      config("item-type-events", [
        ...pointerEvents(),
        run$1(mouseover(), onHover),
        run$1(focusItem(), Focusing.focus)
      ])
    ]),
    components: detail.components,
    eventOrder: detail.eventOrder
  });
  const schema$p = [
    required$1("data"),
    required$1("components"),
    required$1("dom"),
    defaulted("hasSubmenu", false),
    option$3("toggling"),
    SketchBehaviours.field("itemBehaviours", [
      Toggling,
      Focusing,
      Keying,
      Representing
    ]),
    defaulted("ignoreFocus", false),
    defaulted("domModification", {}),
    output$1("builder", builder$2),
    defaulted("eventOrder", {})
  ];
  const builder$1 = (detail) => ({
    dom: detail.dom,
    components: detail.components,
    events: derive$2([stopper(focusItem())])
  });
  const schema$o = [
    required$1("dom"),
    required$1("components"),
    output$1("builder", builder$1)
  ];
  const owner$2 = constant$1("item-widget");
  const parts$h = constant$1([required({
    name: "widget",
    overrides: (detail) => {
      return {
        behaviours: derive$1([Representing.config({
          store: {
            mode: "manual",
            getValue: (_component) => {
              return detail.data;
            },
            setValue: noop2
          }
        })])
      };
    }
  })]);
  const builder = (detail) => {
    const subs2 = substitutes(owner$2(), detail, parts$h());
    const components2 = components$1(owner$2(), detail, subs2.internals());
    const focusWidget = (component) => getPart(component, detail, "widget").map((widget) => {
      Keying.focusIn(widget);
      return widget;
    });
    const onHorizontalArrow = (component, simulatedEvent) => inside(simulatedEvent.event.target) ? Optional.none() : (() => {
      if (detail.autofocus) {
        simulatedEvent.setSource(component.element);
        return Optional.none();
      } else {
        return Optional.none();
      }
    })();
    return {
      dom: detail.dom,
      components: components2,
      domModification: detail.domModification,
      events: derive$2([
        runOnExecute$1((component, simulatedEvent) => {
          focusWidget(component).each((_widget) => {
            simulatedEvent.stop();
          });
        }),
        run$1(mouseover(), onHover),
        run$1(focusItem(), (component, _simulatedEvent) => {
          if (detail.autofocus) {
            focusWidget(component);
          } else {
            Focusing.focus(component);
          }
        })
      ]),
      behaviours: SketchBehaviours.augment(detail.widgetBehaviours, [
        Representing.config({
          store: {
            mode: "memory",
            initialValue: detail.data
          }
        }),
        Focusing.config({
          ignore: detail.ignoreFocus,
          onFocus: (component) => {
            onFocus$1(component);
          }
        }),
        Keying.config({
          mode: "special",
          focusIn: detail.autofocus ? (component) => {
            focusWidget(component);
          } : revoke(),
          onLeft: onHorizontalArrow,
          onRight: onHorizontalArrow,
          onEscape: (component, simulatedEvent) => {
            if (!Focusing.isFocused(component) && !detail.autofocus) {
              Focusing.focus(component);
              return Optional.some(true);
            } else if (detail.autofocus) {
              simulatedEvent.setSource(component.element);
              return Optional.none();
            } else {
              return Optional.none();
            }
          }
        })
      ])
    };
  };
  const schema$n = [
    required$1("uid"),
    required$1("data"),
    required$1("components"),
    required$1("dom"),
    defaulted("autofocus", false),
    defaulted("ignoreFocus", false),
    SketchBehaviours.field("widgetBehaviours", [
      Representing,
      Focusing,
      Keying
    ]),
    defaulted("domModification", {}),
    defaultUidsSchema(parts$h()),
    output$1("builder", builder)
  ];
  const itemSchema$2 = choose$1("type", {
    widget: schema$n,
    item: schema$p,
    separator: schema$o
  });
  const configureGrid = (detail, movementInfo) => ({
    mode: "flatgrid",
    selector: "." + detail.markers.item,
    initSize: {
      numColumns: movementInfo.initSize.numColumns,
      numRows: movementInfo.initSize.numRows
    },
    focusManager: detail.focusManager
  });
  const configureMatrix = (detail, movementInfo) => ({
    mode: "matrix",
    selectors: {
      row: movementInfo.rowSelector,
      cell: "." + detail.markers.item
    },
    previousSelector: movementInfo.previousSelector,
    focusManager: detail.focusManager
  });
  const configureMenu = (detail, movementInfo) => ({
    mode: "menu",
    selector: "." + detail.markers.item,
    moveOnTab: movementInfo.moveOnTab,
    focusManager: detail.focusManager
  });
  const parts$g = constant$1([group({
    factory: {
      sketch: (spec) => {
        const itemInfo = asRawOrDie$1("menu.spec item", itemSchema$2, spec);
        return itemInfo.builder(itemInfo);
      }
    },
    name: "items",
    unit: "item",
    defaults: (detail, u) => {
      return has$2(u, "uid") ? u : {
        ...u,
        uid: generate$5("item")
      };
    },
    overrides: (detail, u) => {
      return {
        type: u.type,
        ignoreFocus: detail.fakeFocus,
        domModification: { classes: [detail.markers.item] }
      };
    }
  })]);
  const schema$m = constant$1([
    required$1("value"),
    required$1("items"),
    required$1("dom"),
    required$1("components"),
    defaulted("eventOrder", {}),
    field("menuBehaviours", [
      Highlighting,
      Representing,
      Composing,
      Keying
    ]),
    defaultedOf("movement", {
      mode: "menu",
      moveOnTab: true
    }, choose$1("mode", {
      grid: [
        initSize(),
        output$1("config", configureGrid)
      ],
      matrix: [
        output$1("config", configureMatrix),
        required$1("rowSelector"),
        defaulted("previousSelector", Optional.none)
      ],
      menu: [
        defaulted("moveOnTab", true),
        output$1("config", configureMenu)
      ]
    })),
    itemMarkers(),
    defaulted("fakeFocus", false),
    defaulted("focusManager", dom$2()),
    onHandler("onHighlight"),
    onHandler("onDehighlight")
  ]);
  const focus = constant$1("alloy.menu-focus");
  const deselectOtherRadioItems = (menu2, item3) => {
    const checkedRadioItems = descendants(menu2.element, '[role="menuitemradio"][aria-checked="true"]');
    each$1(checkedRadioItems, (ele) => {
      if (!eq(ele, item3.element)) {
        menu2.getSystem().getByDom(ele).each((c) => {
          Toggling.off(c);
        });
      }
    });
  };
  const make$7 = (detail, components2, _spec, _externals) => ({
    uid: detail.uid,
    dom: detail.dom,
    markers: detail.markers,
    behaviours: augment(detail.menuBehaviours, [
      Highlighting.config({
        highlightClass: detail.markers.selectedItem,
        itemClass: detail.markers.item,
        onHighlight: detail.onHighlight,
        onDehighlight: detail.onDehighlight
      }),
      Representing.config({
        store: {
          mode: "memory",
          initialValue: detail.value
        }
      }),
      Composing.config({ find: Optional.some }),
      Keying.config(detail.movement.config(detail, detail.movement))
    ]),
    events: derive$2([
      run$1(focus$1(), (menu2, simulatedEvent) => {
        const event = simulatedEvent.event;
        menu2.getSystem().getByDom(event.target).each((item3) => {
          Highlighting.highlight(menu2, item3);
          simulatedEvent.stop();
          emitWith(menu2, focus(), {
            menu: menu2,
            item: item3
          });
        });
      }),
      run$1(hover(), (menu2, simulatedEvent) => {
        const item3 = simulatedEvent.event.item;
        Highlighting.highlight(menu2, item3);
      }),
      run$1(toggled(), (menu2, simulatedEvent) => {
        const { item: item3, state: state2 } = simulatedEvent.event;
        if (state2 && get$f(item3.element, "role") === "menuitemradio") {
          deselectOtherRadioItems(menu2, item3);
        }
      })
    ]),
    components: components2,
    eventOrder: detail.eventOrder,
    domModification: { attributes: { role: "menu" } }
  });
  const Menu = composite({
    name: "Menu",
    configFields: schema$m(),
    partFields: parts$g(),
    factory: make$7
  });
  const transpose$1 = (obj) => tupleMap(obj, (v, k) => ({
    k: v,
    v: k
  }));
  const trace = (items, byItem, byMenu, finish) => get$g(byMenu, finish).bind((triggerItem) => get$g(items, triggerItem).bind((triggerMenu) => {
    const rest = trace(items, byItem, byMenu, triggerMenu);
    return Optional.some([triggerMenu].concat(rest));
  })).getOr([]);
  const generate$2 = (menus, expansions) => {
    const items = {};
    each(menus, (menuItems, menu2) => {
      each$1(menuItems, (item3) => {
        items[item3] = menu2;
      });
    });
    const byItem = expansions;
    const byMenu = transpose$1(expansions);
    const menuPaths = map$1(byMenu, (_triggerItem, submenu) => [submenu].concat(trace(items, byItem, byMenu, submenu)));
    return map$1(items, (menu2) => get$g(menuPaths, menu2).getOr([menu2]));
  };
  const init$c = () => {
    const expansions = Cell({});
    const menus = Cell({});
    const paths = Cell({});
    const primary2 = value$2();
    const directory = Cell({});
    const clear3 = () => {
      expansions.set({});
      menus.set({});
      paths.set({});
      primary2.clear();
    };
    const isClear = () => primary2.get().isNone();
    const setMenuBuilt = (menuName, built) => {
      menus.set({
        ...menus.get(),
        [menuName]: {
          type: "prepared",
          menu: built
        }
      });
    };
    const setContents = (sPrimary, sMenus, sExpansions, dir) => {
      primary2.set(sPrimary);
      expansions.set(sExpansions);
      menus.set(sMenus);
      directory.set(dir);
      const sPaths = generate$2(dir, sExpansions);
      paths.set(sPaths);
    };
    const getTriggeringItem = (menuValue) => find$4(expansions.get(), (v, _k) => v === menuValue);
    const getTriggerData = (menuValue, getItemByValue, path2) => getPreparedMenu(menuValue).bind((menu2) => getTriggeringItem(menuValue).bind((triggeringItemValue) => getItemByValue(triggeringItemValue).map((triggeredItem) => ({
      triggeredMenu: menu2,
      triggeringItem: triggeredItem,
      triggeringPath: path2
    }))));
    const getTriggeringPath = (itemValue, getItemByValue) => {
      const extraPath = filter$2(lookupItem(itemValue).toArray(), (menuValue) => getPreparedMenu(menuValue).isSome());
      return get$g(paths.get(), itemValue).bind((path2) => {
        const revPath = reverse(extraPath.concat(path2));
        const triggers = bind$3(revPath, (menuValue, menuIndex) => getTriggerData(menuValue, getItemByValue, revPath.slice(0, menuIndex + 1)).fold(() => is$1(primary2.get(), menuValue) ? [] : [Optional.none()], (data2) => [Optional.some(data2)]));
        return sequence(triggers);
      });
    };
    const expand2 = (itemValue) => get$g(expansions.get(), itemValue).map((menu2) => {
      const current = get$g(paths.get(), itemValue).getOr([]);
      return [menu2].concat(current);
    });
    const collapse = (itemValue) => get$g(paths.get(), itemValue).bind((path2) => path2.length > 1 ? Optional.some(path2.slice(1)) : Optional.none());
    const refresh2 = (itemValue) => get$g(paths.get(), itemValue);
    const getPreparedMenu = (menuValue) => lookupMenu(menuValue).bind(extractPreparedMenu);
    const lookupMenu = (menuValue) => get$g(menus.get(), menuValue);
    const lookupItem = (itemValue) => get$g(expansions.get(), itemValue);
    const otherMenus = (path2) => {
      const menuValues = directory.get();
      return difference(keys(menuValues), path2);
    };
    const getPrimary = () => primary2.get().bind(getPreparedMenu);
    const getMenus2 = () => menus.get();
    return {
      setMenuBuilt,
      setContents,
      expand: expand2,
      refresh: refresh2,
      collapse,
      lookupMenu,
      lookupItem,
      otherMenus,
      getPrimary,
      getMenus: getMenus2,
      clear: clear3,
      isClear,
      getTriggeringPath
    };
  };
  const extractPreparedMenu = (prep) => prep.type === "prepared" ? Optional.some(prep.menu) : Optional.none();
  const LayeredState = {
    init: init$c,
    extractPreparedMenu
  };
  const onMenuItemHighlightedEvent = generate$6("tiered-menu-item-highlight");
  const onMenuItemDehighlightedEvent = generate$6("tiered-menu-item-dehighlight");
  var HighlightOnOpen;
  (function(HighlightOnOpen2) {
    HighlightOnOpen2[HighlightOnOpen2["HighlightMenuAndItem"] = 0] = "HighlightMenuAndItem";
    HighlightOnOpen2[HighlightOnOpen2["HighlightJustMenu"] = 1] = "HighlightJustMenu";
    HighlightOnOpen2[HighlightOnOpen2["HighlightNone"] = 2] = "HighlightNone";
  })(HighlightOnOpen || (HighlightOnOpen = {}));
  const make$6 = (detail, _rawUiSpec) => {
    const submenuParentItems = value$2();
    const buildMenus = (container, primaryName, menus) => map$1(menus, (spec, name3) => {
      const makeSketch = () => Menu.sketch({
        ...spec,
        value: name3,
        markers: detail.markers,
        fakeFocus: detail.fakeFocus,
        onHighlight: (menuComp, itemComp) => {
          const highlightData = {
            menuComp,
            itemComp
          };
          emitWith(menuComp, onMenuItemHighlightedEvent, highlightData);
        },
        onDehighlight: (menuComp, itemComp) => {
          const dehighlightData = {
            menuComp,
            itemComp
          };
          emitWith(menuComp, onMenuItemDehighlightedEvent, dehighlightData);
        },
        focusManager: detail.fakeFocus ? highlights() : dom$2()
      });
      return name3 === primaryName ? {
        type: "prepared",
        menu: container.getSystem().build(makeSketch())
      } : {
        type: "notbuilt",
        nbMenu: makeSketch
      };
    });
    const layeredState = LayeredState.init();
    const setup2 = (container) => {
      const componentMap = buildMenus(container, detail.data.primary, detail.data.menus);
      const directory = toDirectory();
      layeredState.setContents(detail.data.primary, componentMap, detail.data.expansions, directory);
      return layeredState.getPrimary();
    };
    const getItemValue = (item3) => Representing.getValue(item3).value;
    const getItemByValue = (_container, menus, itemValue) => findMap(menus, (menu2) => {
      if (!menu2.getSystem().isConnected()) {
        return Optional.none();
      }
      const candidates = Highlighting.getCandidates(menu2);
      return find$5(candidates, (c) => getItemValue(c) === itemValue);
    });
    const toDirectory = (_container) => map$1(detail.data.menus, (data2, _menuName) => bind$3(data2.items, (item3) => item3.type === "separator" ? [] : [item3.data.value]));
    const setActiveMenu = Highlighting.highlight;
    const setActiveMenuAndItem = (container, menu2) => {
      setActiveMenu(container, menu2);
      Highlighting.getHighlighted(menu2).orThunk(() => Highlighting.getFirst(menu2)).each((item3) => {
        if (detail.fakeFocus) {
          Highlighting.highlight(menu2, item3);
        } else {
          dispatch(container, item3.element, focusItem());
        }
      });
    };
    const getMenus2 = (state2, menuValues) => cat(map$2(menuValues, (mv) => state2.lookupMenu(mv).bind((prep) => prep.type === "prepared" ? Optional.some(prep.menu) : Optional.none())));
    const closeOthers = (container, state2, path2) => {
      const others = getMenus2(state2, state2.otherMenus(path2));
      each$1(others, (o) => {
        remove$1(o.element, [detail.markers.backgroundMenu]);
        if (!detail.stayInDom) {
          Replacing.remove(container, o);
        }
      });
    };
    const getSubmenuParents = (container) => submenuParentItems.get().getOrThunk(() => {
      const r2 = {};
      const items = descendants(container.element, `.${detail.markers.item}`);
      const parentItems = filter$2(items, (i) => get$f(i, "aria-haspopup") === "true");
      each$1(parentItems, (i) => {
        container.getSystem().getByDom(i).each((itemComp) => {
          const key = getItemValue(itemComp);
          r2[key] = itemComp;
        });
      });
      submenuParentItems.set(r2);
      return r2;
    });
    const updateAriaExpansions = (container, path2) => {
      const parentItems = getSubmenuParents(container);
      each(parentItems, (v, k) => {
        const expanded = contains$2(path2, k);
        set$9(v.element, "aria-expanded", expanded);
      });
    };
    const updateMenuPath = (container, state2, path2) => Optional.from(path2[0]).bind((latestMenuName) => state2.lookupMenu(latestMenuName).bind((menuPrep) => {
      if (menuPrep.type === "notbuilt") {
        return Optional.none();
      } else {
        const activeMenu = menuPrep.menu;
        const rest = getMenus2(state2, path2.slice(1));
        each$1(rest, (r2) => {
          add$2(r2.element, detail.markers.backgroundMenu);
        });
        if (!inBody(activeMenu.element)) {
          Replacing.append(container, premade(activeMenu));
        }
        remove$1(activeMenu.element, [detail.markers.backgroundMenu]);
        setActiveMenuAndItem(container, activeMenu);
        closeOthers(container, state2, path2);
        return Optional.some(activeMenu);
      }
    }));
    let ExpandHighlightDecision;
    (function(ExpandHighlightDecision2) {
      ExpandHighlightDecision2[ExpandHighlightDecision2["HighlightSubmenu"] = 0] = "HighlightSubmenu";
      ExpandHighlightDecision2[ExpandHighlightDecision2["HighlightParent"] = 1] = "HighlightParent";
    })(ExpandHighlightDecision || (ExpandHighlightDecision = {}));
    const buildIfRequired = (container, menuName, menuPrep) => {
      if (menuPrep.type === "notbuilt") {
        const menu2 = container.getSystem().build(menuPrep.nbMenu());
        layeredState.setMenuBuilt(menuName, menu2);
        return menu2;
      } else {
        return menuPrep.menu;
      }
    };
    const expandRight = (container, item3, decision = ExpandHighlightDecision.HighlightSubmenu) => {
      if (item3.hasConfigured(Disabling) && Disabling.isDisabled(item3)) {
        return Optional.some(item3);
      } else {
        const value2 = getItemValue(item3);
        return layeredState.expand(value2).bind((path2) => {
          updateAriaExpansions(container, path2);
          return Optional.from(path2[0]).bind((menuName) => layeredState.lookupMenu(menuName).bind((activeMenuPrep) => {
            const activeMenu = buildIfRequired(container, menuName, activeMenuPrep);
            if (!inBody(activeMenu.element)) {
              Replacing.append(container, premade(activeMenu));
            }
            detail.onOpenSubmenu(container, item3, activeMenu, reverse(path2));
            if (decision === ExpandHighlightDecision.HighlightSubmenu) {
              Highlighting.highlightFirst(activeMenu);
              return updateMenuPath(container, layeredState, path2);
            } else {
              Highlighting.dehighlightAll(activeMenu);
              return Optional.some(item3);
            }
          }));
        });
      }
    };
    const collapseLeft = (container, item3) => {
      const value2 = getItemValue(item3);
      return layeredState.collapse(value2).bind((path2) => {
        updateAriaExpansions(container, path2);
        return updateMenuPath(container, layeredState, path2).map((activeMenu) => {
          detail.onCollapseMenu(container, item3, activeMenu);
          return activeMenu;
        });
      });
    };
    const updateView = (container, item3) => {
      const value2 = getItemValue(item3);
      return layeredState.refresh(value2).bind((path2) => {
        updateAriaExpansions(container, path2);
        return updateMenuPath(container, layeredState, path2);
      });
    };
    const onRight2 = (container, item3) => inside(item3.element) ? Optional.none() : expandRight(container, item3, ExpandHighlightDecision.HighlightSubmenu);
    const onLeft2 = (container, item3) => inside(item3.element) ? Optional.none() : collapseLeft(container, item3);
    const onEscape = (container, item3) => collapseLeft(container, item3).orThunk(() => detail.onEscape(container, item3).map(() => container));
    const keyOnItem = (f2) => (container, simulatedEvent) => {
      return closest$1(simulatedEvent.getSource(), `.${detail.markers.item}`).bind((target) => container.getSystem().getByDom(target).toOptional().bind((item3) => f2(container, item3).map(always)));
    };
    const events2 = derive$2([
      run$1(focus(), (tmenu, simulatedEvent) => {
        const item3 = simulatedEvent.event.item;
        layeredState.lookupItem(getItemValue(item3)).each(() => {
          const menu2 = simulatedEvent.event.menu;
          Highlighting.highlight(tmenu, menu2);
          const value2 = getItemValue(simulatedEvent.event.item);
          layeredState.refresh(value2).each((path2) => closeOthers(tmenu, layeredState, path2));
        });
      }),
      runOnExecute$1((component, simulatedEvent) => {
        const target = simulatedEvent.event.target;
        component.getSystem().getByDom(target).each((item3) => {
          const itemValue = getItemValue(item3);
          if (itemValue.indexOf("collapse-item") === 0) {
            collapseLeft(component, item3);
          }
          expandRight(component, item3, ExpandHighlightDecision.HighlightSubmenu).fold(() => {
            detail.onExecute(component, item3);
          }, noop2);
        });
      }),
      runOnAttached((container, _simulatedEvent) => {
        setup2(container).each((primary2) => {
          Replacing.append(container, premade(primary2));
          detail.onOpenMenu(container, primary2);
          if (detail.highlightOnOpen === HighlightOnOpen.HighlightMenuAndItem) {
            setActiveMenuAndItem(container, primary2);
          } else if (detail.highlightOnOpen === HighlightOnOpen.HighlightJustMenu) {
            setActiveMenu(container, primary2);
          }
        });
      }),
      run$1(onMenuItemHighlightedEvent, (tmenuComp, se) => {
        detail.onHighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
      }),
      run$1(onMenuItemDehighlightedEvent, (tmenuComp, se) => {
        detail.onDehighlightItem(tmenuComp, se.event.menuComp, se.event.itemComp);
      }),
      ...detail.navigateOnHover ? [run$1(hover(), (tmenu, simulatedEvent) => {
        const item3 = simulatedEvent.event.item;
        updateView(tmenu, item3);
        expandRight(tmenu, item3, ExpandHighlightDecision.HighlightParent);
        detail.onHover(tmenu, item3);
      })] : []
    ]);
    const getActiveItem = (container) => Highlighting.getHighlighted(container).bind(Highlighting.getHighlighted);
    const collapseMenuApi = (container) => {
      getActiveItem(container).each((currentItem) => {
        collapseLeft(container, currentItem);
      });
    };
    const highlightPrimary = (container) => {
      layeredState.getPrimary().each((primary2) => {
        setActiveMenuAndItem(container, primary2);
      });
    };
    const extractMenuFromContainer = (container) => Optional.from(container.components()[0]).filter((comp) => get$f(comp.element, "role") === "menu");
    const repositionMenus2 = (container) => {
      const maybeActivePrimary = layeredState.getPrimary().bind((primary2) => getActiveItem(container).bind((currentItem) => {
        const itemValue = getItemValue(currentItem);
        const allMenus = values(layeredState.getMenus());
        const preparedMenus = cat(map$2(allMenus, LayeredState.extractPreparedMenu));
        return layeredState.getTriggeringPath(itemValue, (v) => getItemByValue(container, preparedMenus, v));
      }).map((triggeringPath) => ({
        primary: primary2,
        triggeringPath
      })));
      maybeActivePrimary.fold(() => {
        extractMenuFromContainer(container).each((primaryMenu) => {
          detail.onRepositionMenu(container, primaryMenu, []);
        });
      }, ({ primary: primary2, triggeringPath }) => {
        detail.onRepositionMenu(container, primary2, triggeringPath);
      });
    };
    const apis2 = {
      collapseMenu: collapseMenuApi,
      highlightPrimary,
      repositionMenus: repositionMenus2
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      markers: detail.markers,
      behaviours: augment(detail.tmenuBehaviours, [
        Keying.config({
          mode: "special",
          onRight: keyOnItem(onRight2),
          onLeft: keyOnItem(onLeft2),
          onEscape: keyOnItem(onEscape),
          focusIn: (container, _keyInfo) => {
            layeredState.getPrimary().each((primary2) => {
              dispatch(container, primary2.element, focusItem());
            });
          }
        }),
        Highlighting.config({
          highlightClass: detail.markers.selectedMenu,
          itemClass: detail.markers.menu
        }),
        Composing.config({
          find: (container) => {
            return Highlighting.getHighlighted(container);
          }
        }),
        Replacing.config({})
      ]),
      eventOrder: detail.eventOrder,
      apis: apis2,
      events: events2
    };
  };
  const collapseItem$1 = constant$1("collapse-item");
  const tieredData = (primary2, menus, expansions) => ({
    primary: primary2,
    menus,
    expansions
  });
  const singleData = (name3, menu2) => ({
    primary: name3,
    menus: wrap$1(name3, menu2),
    expansions: {}
  });
  const collapseItem = (text3) => ({
    value: generate$6(collapseItem$1()),
    meta: { text: text3 }
  });
  const tieredMenu = single({
    name: "TieredMenu",
    configFields: [
      onStrictKeyboardHandler("onExecute"),
      onStrictKeyboardHandler("onEscape"),
      onStrictHandler("onOpenMenu"),
      onStrictHandler("onOpenSubmenu"),
      onHandler("onRepositionMenu"),
      onHandler("onCollapseMenu"),
      defaulted("highlightOnOpen", HighlightOnOpen.HighlightMenuAndItem),
      requiredObjOf("data", [
        required$1("primary"),
        required$1("menus"),
        required$1("expansions")
      ]),
      defaulted("fakeFocus", false),
      onHandler("onHighlightItem"),
      onHandler("onDehighlightItem"),
      onHandler("onHover"),
      tieredMenuMarkers(),
      required$1("dom"),
      defaulted("navigateOnHover", true),
      defaulted("stayInDom", false),
      field("tmenuBehaviours", [
        Keying,
        Highlighting,
        Composing,
        Replacing
      ]),
      defaulted("eventOrder", {})
    ],
    apis: {
      collapseMenu: (apis2, tmenu) => {
        apis2.collapseMenu(tmenu);
      },
      highlightPrimary: (apis2, tmenu) => {
        apis2.highlightPrimary(tmenu);
      },
      repositionMenus: (apis2, tmenu) => {
        apis2.repositionMenus(tmenu);
      }
    },
    factory: make$6,
    extraApis: {
      tieredData,
      singleData,
      collapseItem
    }
  });
  const makeMenu = (detail, menuSandbox, placementSpec, menuSpec, getBounds2) => {
    const lazySink = () => detail.lazySink(menuSandbox);
    const layouts2 = menuSpec.type === "horizontal" ? {
      layouts: {
        onLtr: () => belowOrAbove(),
        onRtl: () => belowOrAboveRtl()
      }
    } : {};
    const isFirstTierSubmenu = (triggeringPaths) => triggeringPaths.length === 2;
    const getSubmenuLayouts = (triggeringPaths) => isFirstTierSubmenu(triggeringPaths) ? layouts2 : {};
    return tieredMenu.sketch({
      dom: { tag: "div" },
      data: menuSpec.data,
      markers: menuSpec.menu.markers,
      highlightOnOpen: menuSpec.menu.highlightOnOpen,
      fakeFocus: menuSpec.menu.fakeFocus,
      onEscape: () => {
        Sandboxing.close(menuSandbox);
        detail.onEscape.map((handler) => handler(menuSandbox));
        return Optional.some(true);
      },
      onExecute: () => {
        return Optional.some(true);
      },
      onOpenMenu: (tmenu, menu2) => {
        Positioning.positionWithinBounds(lazySink().getOrDie(), menu2, placementSpec, getBounds2());
      },
      onOpenSubmenu: (tmenu, item3, submenu, triggeringPaths) => {
        const sink = lazySink().getOrDie();
        Positioning.position(sink, submenu, {
          anchor: {
            type: "submenu",
            item: item3,
            ...getSubmenuLayouts(triggeringPaths)
          }
        });
      },
      onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
        const sink = lazySink().getOrDie();
        Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds2());
        each$1(submenuTriggers, (st) => {
          const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
          Positioning.position(sink, st.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: st.triggeringItem,
              ...submenuLayouts
            }
          });
        });
      }
    });
  };
  const factory$o = (detail, spec) => {
    const isPartOfRelated = (sandbox, queryElem) => {
      const related = detail.getRelated(sandbox);
      return related.exists((rel) => isPartOf$1(rel, queryElem));
    };
    const setContent2 = (sandbox, thing) => {
      Sandboxing.setContent(sandbox, thing);
    };
    const showAt = (sandbox, thing, placementSpec) => {
      const getBounds2 = Optional.none;
      showWithinBounds(sandbox, thing, placementSpec, getBounds2);
    };
    const showWithinBounds = (sandbox, thing, placementSpec, getBounds2) => {
      const sink = detail.lazySink(sandbox).getOrDie();
      Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds2()));
      Representing.setValue(sandbox, Optional.some({
        mode: "position",
        config: placementSpec,
        getBounds: getBounds2
      }));
    };
    const showMenuAt = (sandbox, placementSpec, menuSpec) => {
      showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
    };
    const showMenuWithinBounds = (sandbox, placementSpec, menuSpec, getBounds2) => {
      const menu2 = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds2);
      Sandboxing.open(sandbox, menu2);
      Representing.setValue(sandbox, Optional.some({
        mode: "menu",
        menu: menu2
      }));
    };
    const hide2 = (sandbox) => {
      if (Sandboxing.isOpen(sandbox)) {
        Representing.setValue(sandbox, Optional.none());
        Sandboxing.close(sandbox);
      }
    };
    const getContent = (sandbox) => Sandboxing.getState(sandbox);
    const reposition2 = (sandbox) => {
      if (Sandboxing.isOpen(sandbox)) {
        Representing.getValue(sandbox).each((state2) => {
          switch (state2.mode) {
            case "menu":
              Sandboxing.getState(sandbox).each(tieredMenu.repositionMenus);
              break;
            case "position":
              const sink = detail.lazySink(sandbox).getOrDie();
              Positioning.positionWithinBounds(sink, sandbox, state2.config, state2.getBounds());
              break;
          }
        });
      }
    };
    const apis2 = {
      setContent: setContent2,
      showAt,
      showWithinBounds,
      showMenuAt,
      showMenuWithinBounds,
      hide: hide2,
      getContent,
      reposition: reposition2,
      isOpen: Sandboxing.isOpen
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      behaviours: augment(detail.inlineBehaviours, [
        Sandboxing.config({
          isPartOf: (sandbox, data2, queryElem) => {
            return isPartOf$1(data2, queryElem) || isPartOfRelated(sandbox, queryElem);
          },
          getAttachPoint: (sandbox) => {
            return detail.lazySink(sandbox).getOrDie();
          },
          onOpen: (sandbox) => {
            detail.onShow(sandbox);
          },
          onClose: (sandbox) => {
            detail.onHide(sandbox);
          }
        }),
        Representing.config({
          store: {
            mode: "memory",
            initialValue: Optional.none()
          }
        }),
        Receiving.config({
          channels: {
            ...receivingChannel$1({
              isExtraPart: spec.isExtraPart,
              ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
            }),
            ...receivingChannel({
              ...detail.fireRepositionEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({}),
              doReposition: reposition2
            })
          }
        })
      ]),
      eventOrder: detail.eventOrder,
      apis: apis2
    };
  };
  const InlineView = single({
    name: "InlineView",
    configFields: [
      required$1("lazySink"),
      onHandler("onShow"),
      onHandler("onHide"),
      optionFunction("onEscape"),
      field("inlineBehaviours", [
        Sandboxing,
        Representing,
        Receiving
      ]),
      optionObjOf("fireDismissalEventInstead", [defaulted("event", dismissRequested())]),
      optionObjOf("fireRepositionEventInstead", [defaulted("event", repositionRequested())]),
      defaulted("getRelated", Optional.none),
      defaulted("isExtraPart", never),
      defaulted("eventOrder", Optional.none)
    ],
    factory: factory$o,
    apis: {
      showAt: (apis2, component, anchor2, thing) => {
        apis2.showAt(component, anchor2, thing);
      },
      showWithinBounds: (apis2, component, anchor2, thing, bounds2) => {
        apis2.showWithinBounds(component, anchor2, thing, bounds2);
      },
      showMenuAt: (apis2, component, anchor2, menuSpec) => {
        apis2.showMenuAt(component, anchor2, menuSpec);
      },
      showMenuWithinBounds: (apis2, component, anchor2, menuSpec, bounds2) => {
        apis2.showMenuWithinBounds(component, anchor2, menuSpec, bounds2);
      },
      hide: (apis2, component) => {
        apis2.hide(component);
      },
      isOpen: (apis2, component) => apis2.isOpen(component),
      getContent: (apis2, component) => apis2.getContent(component),
      setContent: (apis2, component, thing) => {
        apis2.setContent(component, thing);
      },
      reposition: (apis2, component) => {
        apis2.reposition(component);
      }
    }
  });
  var global$9 = tinymce.util.Tools.resolve("tinymce.util.Delay");
  const factory$n = (detail) => {
    const events2 = events$a(detail.action);
    const tag = detail.dom.tag;
    const lookupAttr = (attr2) => get$g(detail.dom, "attributes").bind((attrs) => get$g(attrs, attr2));
    const getModAttributes = () => {
      if (tag === "button") {
        const type2 = lookupAttr("type").getOr("button");
        const roleAttrs = lookupAttr("role").map((role) => ({ role })).getOr({});
        return {
          type: type2,
          ...roleAttrs
        };
      } else {
        const role = detail.role.getOr(lookupAttr("role").getOr("button"));
        return { role };
      }
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: detail.components,
      events: events2,
      behaviours: SketchBehaviours.augment(detail.buttonBehaviours, [
        Focusing.config({}),
        Keying.config({
          mode: "execution",
          useSpace: true,
          useEnter: true
        })
      ]),
      domModification: { attributes: getModAttributes() },
      eventOrder: detail.eventOrder
    };
  };
  const Button2 = single({
    name: "Button",
    factory: factory$n,
    configFields: [
      defaulted("uid", void 0),
      required$1("dom"),
      defaulted("components", []),
      SketchBehaviours.field("buttonBehaviours", [
        Focusing,
        Keying
      ]),
      option$3("action"),
      option$3("role"),
      defaulted("eventOrder", {})
    ]
  });
  const record = (spec) => {
    const uid = isSketchSpec(spec) && hasNonNullableKey(spec, "uid") ? spec.uid : generate$5("memento");
    const get2 = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).getOrDie();
    const getOpt2 = (anyInSystem) => anyInSystem.getSystem().getByUid(uid).toOptional();
    const asSpec = () => ({
      ...spec,
      uid
    });
    return {
      get: get2,
      getOpt: getOpt2,
      asSpec
    };
  };
  var global$8 = tinymce.util.Tools.resolve("tinymce.util.I18n");
  const rtlTransform = {
    "indent": true,
    "outdent": true,
    "table-insert-column-after": true,
    "table-insert-column-before": true,
    "paste-column-after": true,
    "paste-column-before": true,
    "unordered-list": true,
    "list-bull-circle": true,
    "list-bull-default": true,
    "list-bull-square": true
  };
  const defaultIconName = "temporary-placeholder";
  const defaultIcon = (icons) => () => get$g(icons, defaultIconName).getOr("!not found!");
  const getIconName = (name3, icons) => {
    const lcName = name3.toLowerCase();
    if (global$8.isRtl()) {
      const rtlName = ensureTrailing(lcName, "-rtl");
      return has$2(icons, rtlName) ? rtlName : lcName;
    } else {
      return lcName;
    }
  };
  const lookupIcon = (name3, icons) => get$g(icons, getIconName(name3, icons));
  const get$2 = (name3, iconProvider) => {
    const icons = iconProvider();
    return lookupIcon(name3, icons).getOrThunk(defaultIcon(icons));
  };
  const getOr = (name3, iconProvider, fallbackIcon) => {
    const icons = iconProvider();
    return lookupIcon(name3, icons).or(fallbackIcon).getOrThunk(defaultIcon(icons));
  };
  const needsRtlTransform = (iconName) => global$8.isRtl() ? has$2(rtlTransform, iconName) : false;
  const addFocusableBehaviour = () => config("add-focusable", [runOnAttached((comp) => {
    child(comp.element, "svg").each((svg3) => set$9(svg3, "focusable", "false"));
  })]);
  const renderIcon$3 = (spec, iconName, icons, fallbackIcon) => {
    var _a, _b;
    const rtlIconClasses = needsRtlTransform(iconName) ? ["tox-icon--flip"] : [];
    const iconHtml = get$g(icons, getIconName(iconName, icons)).or(fallbackIcon).getOrThunk(defaultIcon(icons));
    return {
      dom: {
        tag: spec.tag,
        attributes: (_a = spec.attributes) !== null && _a !== void 0 ? _a : {},
        classes: spec.classes.concat(rtlIconClasses),
        innerHtml: iconHtml
      },
      behaviours: derive$1([
        ...(_b = spec.behaviours) !== null && _b !== void 0 ? _b : [],
        addFocusableBehaviour()
      ])
    };
  };
  const render$3 = (iconName, spec, iconProvider, fallbackIcon = Optional.none()) => renderIcon$3(spec, iconName, iconProvider(), fallbackIcon);
  const renderFirst = (iconNames, spec, iconProvider) => {
    const icons = iconProvider();
    const iconName = find$5(iconNames, (name3) => has$2(icons, getIconName(name3, icons)));
    return renderIcon$3(spec, iconName.getOr(defaultIconName), icons, Optional.none());
  };
  const notificationIconMap = {
    success: "checkmark",
    error: "warning",
    err: "error",
    warning: "warning",
    warn: "warning",
    info: "info"
  };
  const factory$m = (detail) => {
    const memBannerText = record({
      dom: {
        tag: "p",
        innerHtml: detail.translationProvider(detail.text)
      },
      behaviours: derive$1([Replacing.config({})])
    });
    const renderPercentBar = (percent) => ({
      dom: {
        tag: "div",
        classes: ["tox-bar"],
        styles: { width: `${percent}%` }
      }
    });
    const renderPercentText = (percent) => ({
      dom: {
        tag: "div",
        classes: ["tox-text"],
        innerHtml: `${percent}%`
      }
    });
    const memBannerProgress = record({
      dom: {
        tag: "div",
        classes: detail.progress ? [
          "tox-progress-bar",
          "tox-progress-indicator"
        ] : ["tox-progress-bar"]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-bar-container"]
          },
          components: [renderPercentBar(0)]
        },
        renderPercentText(0)
      ],
      behaviours: derive$1([Replacing.config({})])
    });
    const updateProgress = (comp, percent) => {
      if (comp.getSystem().isConnected()) {
        memBannerProgress.getOpt(comp).each((progress) => {
          Replacing.set(progress, [
            {
              dom: {
                tag: "div",
                classes: ["tox-bar-container"]
              },
              components: [renderPercentBar(percent)]
            },
            renderPercentText(percent)
          ]);
        });
      }
    };
    const updateText2 = (comp, text3) => {
      if (comp.getSystem().isConnected()) {
        const banner = memBannerText.get(comp);
        Replacing.set(banner, [text$2(text3)]);
      }
    };
    const apis2 = {
      updateProgress,
      updateText: updateText2
    };
    const iconChoices = flatten([
      detail.icon.toArray(),
      detail.level.toArray(),
      detail.level.bind((level) => Optional.from(notificationIconMap[level])).toArray()
    ]);
    const memButton = record(Button2.sketch({
      dom: {
        tag: "button",
        classes: [
          "tox-notification__dismiss",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ]
      },
      components: [render$3("close", {
        tag: "div",
        classes: ["tox-icon"],
        attributes: { "aria-label": detail.translationProvider("Close") }
      }, detail.iconProvider)],
      action: (comp) => {
        detail.onAction(comp);
      }
    }));
    const notificationIconSpec = renderFirst(iconChoices, {
      tag: "div",
      classes: ["tox-notification__icon"]
    }, detail.iconProvider);
    const notificationBodySpec = {
      dom: {
        tag: "div",
        classes: ["tox-notification__body"]
      },
      components: [memBannerText.asSpec()],
      behaviours: derive$1([Replacing.config({})])
    };
    const components2 = [
      notificationIconSpec,
      notificationBodySpec
    ];
    return {
      uid: detail.uid,
      dom: {
        tag: "div",
        attributes: { role: "alert" },
        classes: detail.level.map((level) => [
          "tox-notification",
          "tox-notification--in",
          `tox-notification--${level}`
        ]).getOr([
          "tox-notification",
          "tox-notification--in"
        ])
      },
      behaviours: derive$1([
        Focusing.config({}),
        config("notification-events", [run$1(focusin(), (comp) => {
          memButton.getOpt(comp).each(Focusing.focus);
        })])
      ]),
      components: components2.concat(detail.progress ? [memBannerProgress.asSpec()] : []).concat(!detail.closeButton ? [] : [memButton.asSpec()]),
      apis: apis2
    };
  };
  const Notification = single({
    name: "Notification",
    factory: factory$m,
    configFields: [
      option$3("level"),
      required$1("progress"),
      option$3("icon"),
      required$1("onAction"),
      required$1("text"),
      required$1("iconProvider"),
      required$1("translationProvider"),
      defaultedBoolean("closeButton", true)
    ],
    apis: {
      updateProgress: (apis2, comp, percent) => {
        apis2.updateProgress(comp, percent);
      },
      updateText: (apis2, comp, text3) => {
        apis2.updateText(comp, text3);
      }
    }
  });
  var NotificationManagerImpl = (editor, extras, uiMothership) => {
    const sharedBackstage = extras.backstage.shared;
    const getBounds2 = () => {
      const contentArea = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
      const win$1 = win();
      const x = clamp(win$1.x, contentArea.x, contentArea.right);
      const y = clamp(win$1.y, contentArea.y, contentArea.bottom);
      const right3 = Math.max(contentArea.right, win$1.right);
      const bottom3 = Math.max(contentArea.bottom, win$1.bottom);
      return Optional.some(bounds(x, y, right3 - x, bottom3 - y));
    };
    const open2 = (settings, closeCallback) => {
      const close3 = () => {
        closeCallback();
        InlineView.hide(notificationWrapper);
      };
      const notification = build$1(Notification.sketch({
        text: settings.text,
        level: contains$2([
          "success",
          "error",
          "warning",
          "warn",
          "info"
        ], settings.type) ? settings.type : void 0,
        progress: settings.progressBar === true,
        icon: settings.icon,
        closeButton: settings.closeButton,
        onAction: close3,
        iconProvider: sharedBackstage.providers.icons,
        translationProvider: sharedBackstage.providers.translate
      }));
      const notificationWrapper = build$1(InlineView.sketch({
        dom: {
          tag: "div",
          classes: ["tox-notifications-container"]
        },
        lazySink: sharedBackstage.getSink,
        fireDismissalEventInstead: {},
        ...sharedBackstage.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} }
      }));
      uiMothership.add(notificationWrapper);
      if (isNumber2(settings.timeout) && settings.timeout > 0) {
        global$9.setEditorTimeout(editor, () => {
          close3();
        }, settings.timeout);
      }
      const reposition2 = () => {
        const notificationSpec = premade(notification);
        const anchorOverrides2 = { maxHeightFunction: expandable$1() };
        const allNotifications = editor.notificationManager.getNotifications();
        if (allNotifications[0] === thisNotification) {
          const anchor2 = {
            ...sharedBackstage.anchors.banner(),
            overrides: anchorOverrides2
          };
          InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: anchor2 }, getBounds2);
        } else {
          indexOf(allNotifications, thisNotification).each((idx) => {
            const previousNotification = allNotifications[idx - 1].getEl();
            const nodeAnchor = {
              type: "node",
              root: body(),
              node: Optional.some(SugarElement.fromDom(previousNotification)),
              overrides: anchorOverrides2,
              layouts: {
                onRtl: () => [south$2],
                onLtr: () => [south$2]
              }
            };
            InlineView.showWithinBounds(notificationWrapper, notificationSpec, { anchor: nodeAnchor }, getBounds2);
          });
        }
      };
      const thisNotification = {
        close: close3,
        reposition: reposition2,
        text: (nuText) => {
          Notification.updateText(notification, nuText);
        },
        settings,
        getEl: () => notification.element.dom,
        progressBar: {
          value: (percent) => {
            Notification.updateProgress(notification, percent);
          }
        }
      };
      return thisNotification;
    };
    const close2 = (notification) => {
      notification.close();
    };
    const getArgs = (notification) => {
      return notification.settings;
    };
    return {
      open: open2,
      close: close2,
      getArgs
    };
  };
  var global$7 = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils");
  var global$6 = tinymce.util.Tools.resolve("tinymce.EditorManager");
  var global$5 = tinymce.util.Tools.resolve("tinymce.Env");
  var ToolbarMode$1;
  (function(ToolbarMode2) {
    ToolbarMode2["default"] = "wrap";
    ToolbarMode2["floating"] = "floating";
    ToolbarMode2["sliding"] = "sliding";
    ToolbarMode2["scrolling"] = "scrolling";
  })(ToolbarMode$1 || (ToolbarMode$1 = {}));
  var ToolbarLocation$1;
  (function(ToolbarLocation2) {
    ToolbarLocation2["auto"] = "auto";
    ToolbarLocation2["top"] = "top";
    ToolbarLocation2["bottom"] = "bottom";
  })(ToolbarLocation$1 || (ToolbarLocation$1 = {}));
  const option$2 = (name3) => (editor) => editor.options.get(name3);
  const wrapOptional = (fn3) => (editor) => Optional.from(fn3(editor));
  const register$e = (editor) => {
    const isPhone2 = global$5.deviceType.isPhone();
    const isMobile = global$5.deviceType.isTablet() || isPhone2;
    const registerOption = editor.options.register;
    const stringOrFalseProcessor = (value2) => isString2(value2) || value2 === false;
    const stringOrNumberProcessor = (value2) => isString2(value2) || isNumber2(value2);
    registerOption("skin", {
      processor: (value2) => isString2(value2) || value2 === false,
      default: "oxide"
    });
    registerOption("skin_url", { processor: "string" });
    registerOption("height", {
      processor: stringOrNumberProcessor,
      default: Math.max(editor.getElement().offsetHeight, 400)
    });
    registerOption("width", {
      processor: stringOrNumberProcessor,
      default: global$7.DOM.getStyle(editor.getElement(), "width")
    });
    registerOption("min_height", {
      processor: "number",
      default: 100
    });
    registerOption("min_width", { processor: "number" });
    registerOption("max_height", { processor: "number" });
    registerOption("max_width", { processor: "number" });
    registerOption("style_formats", { processor: "object[]" });
    registerOption("style_formats_merge", {
      processor: "boolean",
      default: false
    });
    registerOption("style_formats_autohide", {
      processor: "boolean",
      default: false
    });
    registerOption("line_height_formats", {
      processor: "string",
      default: "1 1.1 1.2 1.3 1.4 1.5 2"
    });
    registerOption("font_family_formats", {
      processor: "string",
      default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
    });
    registerOption("font_size_formats", {
      processor: "string",
      default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
    });
    registerOption("font_size_input_default_unit", {
      processor: "string",
      default: "pt"
    });
    registerOption("block_formats", {
      processor: "string",
      default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
    });
    registerOption("content_langs", { processor: "object[]" });
    registerOption("removed_menuitems", {
      processor: "string",
      default: ""
    });
    registerOption("menubar", {
      processor: (value2) => isString2(value2) || isBoolean2(value2),
      default: !isPhone2
    });
    registerOption("menu", {
      processor: "object",
      default: {}
    });
    registerOption("toolbar", {
      processor: (value2) => {
        if (isBoolean2(value2) || isString2(value2) || isArray2(value2)) {
          return {
            value: value2,
            valid: true
          };
        } else {
          return {
            valid: false,
            message: "Must be a boolean, string or array."
          };
        }
      },
      default: true
    });
    range$2(9, (num) => {
      registerOption("toolbar" + (num + 1), { processor: "string" });
    });
    registerOption("toolbar_mode", {
      processor: "string",
      default: isMobile ? "scrolling" : "floating"
    });
    registerOption("toolbar_groups", {
      processor: "object",
      default: {}
    });
    registerOption("toolbar_location", {
      processor: "string",
      default: ToolbarLocation$1.auto
    });
    registerOption("toolbar_persist", {
      processor: "boolean",
      default: false
    });
    registerOption("toolbar_sticky", {
      processor: "boolean",
      default: editor.inline
    });
    registerOption("toolbar_sticky_offset", {
      processor: "number",
      default: 0
    });
    registerOption("fixed_toolbar_container", {
      processor: "string",
      default: ""
    });
    registerOption("fixed_toolbar_container_target", { processor: "object" });
    registerOption("ui_mode", {
      processor: "string",
      default: "combined"
    });
    registerOption("file_picker_callback", { processor: "function" });
    registerOption("file_picker_validator_handler", { processor: "function" });
    registerOption("file_picker_types", { processor: "string" });
    registerOption("typeahead_urls", {
      processor: "boolean",
      default: true
    });
    registerOption("anchor_top", {
      processor: stringOrFalseProcessor,
      default: "#top"
    });
    registerOption("anchor_bottom", {
      processor: stringOrFalseProcessor,
      default: "#bottom"
    });
    registerOption("draggable_modal", {
      processor: "boolean",
      default: false
    });
    registerOption("statusbar", {
      processor: "boolean",
      default: true
    });
    registerOption("elementpath", {
      processor: "boolean",
      default: true
    });
    registerOption("branding", {
      processor: "boolean",
      default: true
    });
    registerOption("promotion", {
      processor: "boolean",
      default: true
    });
    registerOption("resize", {
      processor: (value2) => value2 === "both" || isBoolean2(value2),
      default: !global$5.deviceType.isTouch()
    });
    registerOption("sidebar_show", { processor: "string" });
  };
  const isReadOnly = option$2("readonly");
  const getHeightOption = option$2("height");
  const getWidthOption = option$2("width");
  const getMinWidthOption = wrapOptional(option$2("min_width"));
  const getMinHeightOption = wrapOptional(option$2("min_height"));
  const getMaxWidthOption = wrapOptional(option$2("max_width"));
  const getMaxHeightOption = wrapOptional(option$2("max_height"));
  const getUserStyleFormats = wrapOptional(option$2("style_formats"));
  const shouldMergeStyleFormats = option$2("style_formats_merge");
  const shouldAutoHideStyleFormats = option$2("style_formats_autohide");
  const getContentLanguages = option$2("content_langs");
  const getRemovedMenuItems = option$2("removed_menuitems");
  const getToolbarMode = option$2("toolbar_mode");
  const getToolbarGroups = option$2("toolbar_groups");
  const getToolbarLocation = option$2("toolbar_location");
  const fixedContainerSelector = option$2("fixed_toolbar_container");
  const fixedToolbarContainerTarget = option$2("fixed_toolbar_container_target");
  const isToolbarPersist = option$2("toolbar_persist");
  const getStickyToolbarOffset = option$2("toolbar_sticky_offset");
  const getMenubar = option$2("menubar");
  const getToolbar = option$2("toolbar");
  const getFilePickerCallback = option$2("file_picker_callback");
  const getFilePickerValidatorHandler = option$2("file_picker_validator_handler");
  const getFontSizeInputDefaultUnit = option$2("font_size_input_default_unit");
  const getFilePickerTypes = option$2("file_picker_types");
  const useTypeaheadUrls = option$2("typeahead_urls");
  const getAnchorTop = option$2("anchor_top");
  const getAnchorBottom = option$2("anchor_bottom");
  const isDraggableModal$1 = option$2("draggable_modal");
  const useStatusBar = option$2("statusbar");
  const useElementPath = option$2("elementpath");
  const useBranding = option$2("branding");
  const getResize = option$2("resize");
  const getPasteAsText = option$2("paste_as_text");
  const getSidebarShow = option$2("sidebar_show");
  const promotionEnabled = option$2("promotion");
  const isSkinDisabled = (editor) => editor.options.get("skin") === false;
  const isMenubarEnabled = (editor) => editor.options.get("menubar") !== false;
  const getSkinUrl = (editor) => {
    const skinUrl = editor.options.get("skin_url");
    if (isSkinDisabled(editor)) {
      return skinUrl;
    } else {
      if (skinUrl) {
        return editor.documentBaseURI.toAbsolute(skinUrl);
      } else {
        const skin2 = editor.options.get("skin");
        return global$6.baseURL + "/skins/ui/" + skin2;
      }
    }
  };
  const getLineHeightFormats = (editor) => editor.options.get("line_height_formats").split(" ");
  const isToolbarEnabled = (editor) => {
    const toolbar = getToolbar(editor);
    const isToolbarString = isString2(toolbar);
    const isToolbarObjectArray = isArray2(toolbar) && toolbar.length > 0;
    return !isMultipleToolbars(editor) && (isToolbarObjectArray || isToolbarString || toolbar === true);
  };
  const getMultipleToolbarsOption = (editor) => {
    const toolbars = range$2(9, (num) => editor.options.get("toolbar" + (num + 1)));
    const toolbarArray = filter$2(toolbars, isString2);
    return someIf(toolbarArray.length > 0, toolbarArray);
  };
  const isMultipleToolbars = (editor) => getMultipleToolbarsOption(editor).fold(() => {
    const toolbar = getToolbar(editor);
    return isArrayOf(toolbar, isString2) && toolbar.length > 0;
  }, always);
  const isToolbarLocationBottom = (editor) => getToolbarLocation(editor) === ToolbarLocation$1.bottom;
  const fixedContainerTarget = (editor) => {
    var _a;
    if (!editor.inline) {
      return Optional.none();
    }
    const selector = (_a = fixedContainerSelector(editor)) !== null && _a !== void 0 ? _a : "";
    if (selector.length > 0) {
      return descendant(body(), selector);
    }
    const element2 = fixedToolbarContainerTarget(editor);
    if (isNonNullable(element2)) {
      return Optional.some(SugarElement.fromDom(element2));
    }
    return Optional.none();
  };
  const useFixedContainer = (editor) => editor.inline && fixedContainerTarget(editor).isSome();
  const getUiContainer = (editor) => {
    const fixedContainer = fixedContainerTarget(editor);
    return fixedContainer.getOrThunk(() => getContentContainer(getRootNode2(SugarElement.fromDom(editor.getElement()))));
  };
  const isDistractionFree = (editor) => editor.inline && !isMenubarEnabled(editor) && !isToolbarEnabled(editor) && !isMultipleToolbars(editor);
  const isStickyToolbar = (editor) => {
    const isStickyToolbar2 = editor.options.get("toolbar_sticky");
    return (isStickyToolbar2 || editor.inline) && !useFixedContainer(editor) && !isDistractionFree(editor);
  };
  const isSplitUiMode = (editor) => !useFixedContainer(editor) && editor.options.get("ui_mode") === "split";
  const getMenus = (editor) => {
    const menu2 = editor.options.get("menu");
    return map$1(menu2, (menu3) => ({
      ...menu3,
      items: menu3.items
    }));
  };
  var Options = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get ToolbarMode() {
      return ToolbarMode$1;
    },
    get ToolbarLocation() {
      return ToolbarLocation$1;
    },
    register: register$e,
    getSkinUrl,
    isReadOnly,
    isSkinDisabled,
    getHeightOption,
    getWidthOption,
    getMinWidthOption,
    getMinHeightOption,
    getMaxWidthOption,
    getMaxHeightOption,
    getUserStyleFormats,
    shouldMergeStyleFormats,
    shouldAutoHideStyleFormats,
    getLineHeightFormats,
    getContentLanguages,
    getRemovedMenuItems,
    isMenubarEnabled,
    isMultipleToolbars,
    isToolbarEnabled,
    isToolbarPersist,
    getMultipleToolbarsOption,
    getUiContainer,
    useFixedContainer,
    isSplitUiMode,
    getToolbarMode,
    isDraggableModal: isDraggableModal$1,
    isDistractionFree,
    isStickyToolbar,
    getStickyToolbarOffset,
    getToolbarLocation,
    isToolbarLocationBottom,
    getToolbarGroups,
    getMenus,
    getMenubar,
    getToolbar,
    getFilePickerCallback,
    getFilePickerTypes,
    useTypeaheadUrls,
    getAnchorTop,
    getAnchorBottom,
    getFilePickerValidatorHandler,
    getFontSizeInputDefaultUnit,
    useStatusBar,
    useElementPath,
    promotionEnabled,
    useBranding,
    getResize,
    getPasteAsText,
    getSidebarShow
  });
  const autocompleteSelector = "[data-mce-autocompleter]";
  const detect$1 = (elm) => closest$1(elm, autocompleteSelector);
  const findIn = (elm) => descendant(elm, autocompleteSelector);
  const setup$e = (api2, editor) => {
    const redirectKeyToItem = (item3, e) => {
      emitWith(item3, keydown(), { raw: e });
    };
    const getItem = () => api2.getMenu().bind(Highlighting.getHighlighted);
    editor.on("keydown", (e) => {
      const keyCode = e.which;
      if (!api2.isActive()) {
        return;
      }
      if (api2.isMenuOpen()) {
        if (keyCode === 13) {
          getItem().each(emitExecute);
          e.preventDefault();
        } else if (keyCode === 40) {
          getItem().fold(() => {
            api2.getMenu().each(Highlighting.highlightFirst);
          }, (item3) => {
            redirectKeyToItem(item3, e);
          });
          e.preventDefault();
          e.stopImmediatePropagation();
        } else if (keyCode === 37 || keyCode === 38 || keyCode === 39) {
          getItem().each((item3) => {
            redirectKeyToItem(item3, e);
            e.preventDefault();
            e.stopImmediatePropagation();
          });
        }
      } else {
        if (keyCode === 13 || keyCode === 38 || keyCode === 40) {
          api2.cancelIfNecessary();
        }
      }
    });
    editor.on("NodeChange", (e) => {
      if (api2.isActive() && !api2.isProcessingAction() && detect$1(SugarElement.fromDom(e.element)).isNone()) {
        api2.cancelIfNecessary();
      }
    });
  };
  const AutocompleterEditorEvents = { setup: setup$e };
  var ItemResponse;
  (function(ItemResponse2) {
    ItemResponse2[ItemResponse2["CLOSE_ON_EXECUTE"] = 0] = "CLOSE_ON_EXECUTE";
    ItemResponse2[ItemResponse2["BUBBLE_TO_SANDBOX"] = 1] = "BUBBLE_TO_SANDBOX";
  })(ItemResponse || (ItemResponse = {}));
  var ItemResponse$1 = ItemResponse;
  const navClass = "tox-menu-nav__js";
  const selectableClass = "tox-collection__item";
  const colorClass = "tox-swatch";
  const presetClasses = {
    normal: navClass,
    color: colorClass
  };
  const tickedClass = "tox-collection__item--enabled";
  const groupHeadingClass = "tox-collection__group-heading";
  const iconClass = "tox-collection__item-icon";
  const textClass = "tox-collection__item-label";
  const accessoryClass = "tox-collection__item-accessory";
  const caretClass = "tox-collection__item-caret";
  const checkmarkClass = "tox-collection__item-checkmark";
  const activeClass = "tox-collection__item--active";
  const containerClass = "tox-collection__item-container";
  const containerColumnClass = "tox-collection__item-container--column";
  const containerRowClass = "tox-collection__item-container--row";
  const containerAlignRightClass = "tox-collection__item-container--align-right";
  const containerAlignLeftClass = "tox-collection__item-container--align-left";
  const containerValignTopClass = "tox-collection__item-container--valign-top";
  const containerValignMiddleClass = "tox-collection__item-container--valign-middle";
  const containerValignBottomClass = "tox-collection__item-container--valign-bottom";
  const classForPreset = (presets) => get$g(presetClasses, presets).getOr(navClass);
  const forMenu = (presets) => {
    if (presets === "color") {
      return "tox-swatches";
    } else {
      return "tox-menu";
    }
  };
  const classes = (presets) => ({
    backgroundMenu: "tox-background-menu",
    selectedMenu: "tox-selected-menu",
    selectedItem: "tox-collection__item--active",
    hasIcons: "tox-menu--has-icons",
    menu: forMenu(presets),
    tieredMenu: "tox-tiered-menu"
  });
  const markers = (presets) => {
    const menuClasses = classes(presets);
    return {
      backgroundMenu: menuClasses.backgroundMenu,
      selectedMenu: menuClasses.selectedMenu,
      menu: menuClasses.menu,
      selectedItem: menuClasses.selectedItem,
      item: classForPreset(presets)
    };
  };
  const dom$1 = (hasIcons, columns, presets) => {
    const menuClasses = classes(presets);
    return {
      tag: "div",
      classes: flatten([
        [
          menuClasses.menu,
          `tox-menu-${columns}-column`
        ],
        hasIcons ? [menuClasses.hasIcons] : []
      ])
    };
  };
  const components = [Menu.parts.items({})];
  const part = (hasIcons, columns, presets) => {
    const menuClasses = classes(presets);
    const d = {
      tag: "div",
      classes: flatten([[menuClasses.tieredMenu]])
    };
    return {
      dom: d,
      markers: markers(presets)
    };
  };
  const schema$l = constant$1([
    option$3("data"),
    defaulted("inputAttributes", {}),
    defaulted("inputStyles", {}),
    defaulted("tag", "input"),
    defaulted("inputClasses", []),
    onHandler("onSetValue"),
    defaulted("styles", {}),
    defaulted("eventOrder", {}),
    field("inputBehaviours", [
      Representing,
      Focusing
    ]),
    defaulted("selectOnFocus", true)
  ]);
  const focusBehaviours = (detail) => derive$1([Focusing.config({
    onFocus: !detail.selectOnFocus ? noop2 : (component) => {
      const input2 = component.element;
      const value2 = get$6(input2);
      input2.dom.setSelectionRange(0, value2.length);
    }
  })]);
  const behaviours = (detail) => ({
    ...focusBehaviours(detail),
    ...augment(detail.inputBehaviours, [Representing.config({
      store: {
        mode: "manual",
        ...detail.data.map((data2) => ({ initialValue: data2 })).getOr({}),
        getValue: (input2) => {
          return get$6(input2.element);
        },
        setValue: (input2, data2) => {
          const current = get$6(input2.element);
          if (current !== data2) {
            set$5(input2.element, data2);
          }
        }
      },
      onSetValue: detail.onSetValue
    })])
  });
  const dom = (detail) => ({
    tag: detail.tag,
    attributes: {
      type: "text",
      ...detail.inputAttributes
    },
    styles: detail.inputStyles,
    classes: detail.inputClasses
  });
  const factory$l = (detail, _spec) => ({
    uid: detail.uid,
    dom: dom(detail),
    components: [],
    behaviours: behaviours(detail),
    eventOrder: detail.eventOrder
  });
  const Input = single({
    name: "Input",
    configFields: schema$l(),
    factory: factory$l
  });
  const refetchTriggerEvent = generate$6("refetch-trigger-event");
  const redirectMenuItemInteractionEvent = generate$6("redirect-menu-item-interaction");
  const menuSearcherClass = "tox-menu__searcher";
  const findWithinSandbox = (sandboxComp) => {
    return descendant(sandboxComp.element, `.${menuSearcherClass}`).bind((inputElem) => sandboxComp.getSystem().getByDom(inputElem).toOptional());
  };
  const findWithinMenu = findWithinSandbox;
  const restoreState = (inputComp, searcherState) => {
    Representing.setValue(inputComp, searcherState.fetchPattern);
    inputComp.element.dom.selectionStart = searcherState.selectionStart;
    inputComp.element.dom.selectionEnd = searcherState.selectionEnd;
  };
  const saveState = (inputComp) => {
    const fetchPattern = Representing.getValue(inputComp);
    const selectionStart = inputComp.element.dom.selectionStart;
    const selectionEnd = inputComp.element.dom.selectionEnd;
    return {
      fetchPattern,
      selectionStart,
      selectionEnd
    };
  };
  const setActiveDescendant = (inputComp, active2) => {
    getOpt(active2.element, "id").each((id) => set$9(inputComp.element, "aria-activedescendant", id));
  };
  const renderMenuSearcher = (spec) => {
    const handleByBrowser = (comp, se) => {
      se.cut();
      return Optional.none();
    };
    const handleByHighlightedItem = (comp, se) => {
      const eventData = {
        interactionEvent: se.event,
        eventType: se.event.raw.type
      };
      emitWith(comp, redirectMenuItemInteractionEvent, eventData);
      return Optional.some(true);
    };
    const customSearcherEventsName = "searcher-events";
    return {
      dom: {
        tag: "div",
        classes: [selectableClass]
      },
      components: [Input.sketch({
        inputClasses: [
          menuSearcherClass,
          "tox-textfield"
        ],
        inputAttributes: {
          ...spec.placeholder.map((placeholder2) => ({ placeholder: spec.i18n(placeholder2) })).getOr({}),
          "type": "search",
          "aria-autocomplete": "list"
        },
        inputBehaviours: derive$1([
          config(customSearcherEventsName, [
            run$1(input(), (inputComp) => {
              emit(inputComp, refetchTriggerEvent);
            }),
            run$1(keydown(), (inputComp, se) => {
              if (se.event.raw.key === "Escape") {
                se.stop();
              }
            })
          ]),
          Keying.config({
            mode: "special",
            onLeft: handleByBrowser,
            onRight: handleByBrowser,
            onSpace: handleByBrowser,
            onEnter: handleByHighlightedItem,
            onEscape: handleByHighlightedItem,
            onUp: handleByHighlightedItem,
            onDown: handleByHighlightedItem
          })
        ]),
        eventOrder: {
          keydown: [
            customSearcherEventsName,
            Keying.name()
          ]
        }
      })]
    };
  };
  const searchResultsClass = "tox-collection--results__js";
  const augmentWithAria = (item3) => {
    var _a;
    if (item3.dom) {
      return {
        ...item3,
        dom: {
          ...item3.dom,
          attributes: {
            ...(_a = item3.dom.attributes) !== null && _a !== void 0 ? _a : {},
            "id": generate$6("aria-item-search-result-id"),
            "aria-selected": "false"
          }
        }
      };
    } else {
      return item3;
    }
  };
  const chunk = (rowDom, numColumns) => (items) => {
    const chunks = chunk$1(items, numColumns);
    return map$2(chunks, (c) => ({
      dom: rowDom,
      components: c
    }));
  };
  const forSwatch = (columns) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-swatches-menu"
      ]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-swatches"]
      },
      components: [Menu.parts.items({
        preprocess: columns !== "auto" ? chunk({
          tag: "div",
          classes: ["tox-swatches__row"]
        }, columns) : identity
      })]
    }]
  });
  const forToolbar = (columns) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection",
        "tox-collection--toolbar",
        "tox-collection--toolbar-lg"
      ]
    },
    components: [Menu.parts.items({
      preprocess: chunk({
        tag: "div",
        classes: ["tox-collection__group"]
      }, columns)
    })]
  });
  const preprocessCollection = (items, isSeparator2) => {
    const allSplits = [];
    let currentSplit = [];
    each$1(items, (item3, i) => {
      if (isSeparator2(item3, i)) {
        if (currentSplit.length > 0) {
          allSplits.push(currentSplit);
        }
        currentSplit = [];
        if (has$2(item3.dom, "innerHtml") || item3.components && item3.components.length > 0) {
          currentSplit.push(item3);
        }
      } else {
        currentSplit.push(item3);
      }
    });
    if (currentSplit.length > 0) {
      allSplits.push(currentSplit);
    }
    return map$2(allSplits, (s) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection__group"]
      },
      components: s
    }));
  };
  const insertItemsPlaceholder = (columns, initItems, onItem) => {
    return Menu.parts.items({
      preprocess: (rawItems) => {
        const enrichedItems = map$2(rawItems, onItem);
        if (columns !== "auto" && columns > 1) {
          return chunk({
            tag: "div",
            classes: ["tox-collection__group"]
          }, columns)(enrichedItems);
        } else {
          return preprocessCollection(enrichedItems, (_item, i) => initItems[i].type === "separator");
        }
      }
    });
  };
  const forCollection = (columns, initItems, _hasIcons = true) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-menu",
        "tox-collection"
      ].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
    },
    components: [insertItemsPlaceholder(columns, initItems, identity)]
  });
  const forCollectionWithSearchResults = (columns, initItems, _hasIcons = true) => {
    const ariaControlsSearchResults = generate$6("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection",
          searchResultsClass
        ].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
        attributes: { id: ariaControlsSearchResults }
      },
      components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]
    };
  };
  const forCollectionWithSearchField = (columns, initItems, searchField) => {
    const ariaControlsSearchResults = generate$6("aria-controls-search-results");
    return {
      dom: {
        tag: "div",
        classes: [
          "tox-menu",
          "tox-collection"
        ].concat(columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
      },
      components: [
        renderMenuSearcher({
          i18n: global$8.translate,
          placeholder: searchField.placeholder
        }),
        {
          dom: {
            tag: "div",
            classes: [
              ...columns === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
              searchResultsClass
            ],
            attributes: { id: ariaControlsSearchResults }
          },
          components: [insertItemsPlaceholder(columns, initItems, augmentWithAria)]
        }
      ]
    };
  };
  const forHorizontalCollection = (initItems, _hasIcons = true) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-collection",
        "tox-collection--horizontal"
      ]
    },
    components: [Menu.parts.items({ preprocess: (items) => preprocessCollection(items, (_item, i) => initItems[i].type === "separator") })]
  });
  const menuHasIcons = (xs) => exists(xs, (item3) => "icon" in item3 && item3.icon !== void 0);
  const handleError = (error3) => {
    console.error(formatError(error3));
    console.log(error3);
    return Optional.none();
  };
  const createHorizontalPartialMenuWithAlloyItems = (value2, _hasIcons, items, _columns, _menuLayout) => {
    const structure = forHorizontalCollection(items);
    return {
      value: value2,
      dom: structure.dom,
      components: structure.components,
      items
    };
  };
  const createPartialMenuWithAlloyItems = (value2, hasIcons, items, columns, menuLayout) => {
    const getNormalStructure = () => {
      if (menuLayout.menuType !== "searchable") {
        return forCollection(columns, items);
      } else {
        return menuLayout.searchMode.searchMode === "search-with-field" ? forCollectionWithSearchField(columns, items, menuLayout.searchMode) : forCollectionWithSearchResults(columns, items);
      }
    };
    if (menuLayout.menuType === "color") {
      const structure = forSwatch(columns);
      return {
        value: value2,
        dom: structure.dom,
        components: structure.components,
        items
      };
    } else if (menuLayout.menuType === "normal" && columns === "auto") {
      const structure = forCollection(columns, items);
      return {
        value: value2,
        dom: structure.dom,
        components: structure.components,
        items
      };
    } else if (menuLayout.menuType === "normal" || menuLayout.menuType === "searchable") {
      const structure = getNormalStructure();
      return {
        value: value2,
        dom: structure.dom,
        components: structure.components,
        items
      };
    } else if (menuLayout.menuType === "listpreview" && columns !== "auto") {
      const structure = forToolbar(columns);
      return {
        value: value2,
        dom: structure.dom,
        components: structure.components,
        items
      };
    } else {
      return {
        value: value2,
        dom: dom$1(hasIcons, columns, menuLayout.menuType),
        components,
        items
      };
    }
  };
  const type = requiredString("type");
  const name$1 = requiredString("name");
  const label = requiredString("label");
  const text$12 = requiredString("text");
  const title = requiredString("title");
  const icon = requiredString("icon");
  const value$1 = requiredString("value");
  const fetch$1 = requiredFunction("fetch");
  const getSubmenuItems = requiredFunction("getSubmenuItems");
  const onAction = requiredFunction("onAction");
  const onItemAction = requiredFunction("onItemAction");
  const onSetup = defaultedFunction("onSetup", () => noop2);
  const optionalName = optionString("name");
  const optionalText = optionString("text");
  const optionalIcon = optionString("icon");
  const optionalTooltip = optionString("tooltip");
  const optionalLabel = optionString("label");
  const optionalShortcut = optionString("shortcut");
  const optionalSelect = optionFunction("select");
  const active = defaultedBoolean("active", false);
  const borderless = defaultedBoolean("borderless", false);
  const enabled = defaultedBoolean("enabled", true);
  const primary = defaultedBoolean("primary", false);
  const defaultedColumns = (num) => defaulted("columns", num);
  const defaultedMeta = defaulted("meta", {});
  const defaultedOnAction = defaultedFunction("onAction", noop2);
  const defaultedType = (type2) => defaultedString("type", type2);
  const generatedName = (namePrefix) => field$1("name", "name", defaultedThunk(() => generate$6(`${namePrefix}-name`)), string);
  const generatedValue = (valuePrefix) => field$1("value", "value", defaultedThunk(() => generate$6(`${valuePrefix}-value`)), anyValue());
  const separatorMenuItemSchema = objOf([
    type,
    optionalText
  ]);
  const createSeparatorMenuItem = (spec) => asRaw("separatormenuitem", separatorMenuItemSchema, spec);
  const autocompleterItemSchema = objOf([
    defaultedType("autocompleteitem"),
    active,
    enabled,
    defaultedMeta,
    value$1,
    optionalText,
    optionalIcon
  ]);
  const createSeparatorItem = (spec) => asRaw("Autocompleter.Separator", separatorMenuItemSchema, spec);
  const createAutocompleterItem = (spec) => asRaw("Autocompleter.Item", autocompleterItemSchema, spec);
  const baseToolbarButtonFields = [
    enabled,
    optionalTooltip,
    optionalIcon,
    optionalText,
    onSetup
  ];
  const toolbarButtonSchema = objOf([
    type,
    onAction
  ].concat(baseToolbarButtonFields));
  const createToolbarButton = (spec) => asRaw("toolbarbutton", toolbarButtonSchema, spec);
  const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);
  const toggleButtonSchema = objOf(baseToolbarToggleButtonFields.concat([
    type,
    onAction
  ]));
  const createToggleButton = (spec) => asRaw("ToggleButton", toggleButtonSchema, spec);
  const contextBarFields = [
    defaultedFunction("predicate", never),
    defaultedStringEnum("scope", "node", [
      "node",
      "editor"
    ]),
    defaultedStringEnum("position", "selection", [
      "node",
      "selection",
      "line"
    ])
  ];
  const contextButtonFields = baseToolbarButtonFields.concat([
    defaultedType("contextformbutton"),
    primary,
    onAction,
    customField("original", identity)
  ]);
  const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
    defaultedType("contextformbutton"),
    primary,
    onAction,
    customField("original", identity)
  ]);
  const launchButtonFields = baseToolbarButtonFields.concat([defaultedType("contextformbutton")]);
  const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType("contextformtogglebutton")]);
  const toggleOrNormal = choose$1("type", {
    contextformbutton: contextButtonFields,
    contextformtogglebutton: contextToggleButtonFields
  });
  const contextFormSchema = objOf([
    defaultedType("contextform"),
    defaultedFunction("initValue", constant$1("")),
    optionalLabel,
    requiredArrayOf("commands", toggleOrNormal),
    optionOf("launch", choose$1("type", {
      contextformbutton: launchButtonFields,
      contextformtogglebutton: launchToggleButtonFields
    }))
  ].concat(contextBarFields));
  const createContextForm = (spec) => asRaw("ContextForm", contextFormSchema, spec);
  const contextToolbarSchema = objOf([
    defaultedType("contexttoolbar"),
    requiredString("items")
  ].concat(contextBarFields));
  const createContextToolbar = (spec) => asRaw("ContextToolbar", contextToolbarSchema, spec);
  const cardImageFields = [
    type,
    requiredString("src"),
    optionString("alt"),
    defaultedArrayOf("classes", [], string)
  ];
  const cardImageSchema = objOf(cardImageFields);
  const cardTextFields = [
    type,
    text$12,
    optionalName,
    defaultedArrayOf("classes", ["tox-collection__item-label"], string)
  ];
  const cardTextSchema = objOf(cardTextFields);
  const itemSchema$1 = valueThunk(() => choose$2("type", {
    cardimage: cardImageSchema,
    cardtext: cardTextSchema,
    cardcontainer: cardContainerSchema
  }));
  const cardContainerSchema = objOf([
    type,
    defaultedString("direction", "horizontal"),
    defaultedString("align", "left"),
    defaultedString("valign", "middle"),
    requiredArrayOf("items", itemSchema$1)
  ]);
  const commonMenuItemFields = [
    enabled,
    optionalText,
    optionalShortcut,
    generatedValue("menuitem"),
    defaultedMeta
  ];
  const cardMenuItemSchema = objOf([
    type,
    optionalLabel,
    requiredArrayOf("items", itemSchema$1),
    onSetup,
    defaultedOnAction
  ].concat(commonMenuItemFields));
  const createCardMenuItem = (spec) => asRaw("cardmenuitem", cardMenuItemSchema, spec);
  const choiceMenuItemSchema = objOf([
    type,
    active,
    optionalIcon
  ].concat(commonMenuItemFields));
  const createChoiceMenuItem = (spec) => asRaw("choicemenuitem", choiceMenuItemSchema, spec);
  const baseFields = [
    type,
    requiredString("fancytype"),
    defaultedOnAction
  ];
  const insertTableFields = [defaulted("initData", {})].concat(baseFields);
  const colorSwatchFields = [
    optionFunction("select"),
    defaultedObjOf("initData", {}, [
      defaultedBoolean("allowCustomColors", true),
      defaultedString("storageKey", "default"),
      optionArrayOf("colors", anyValue())
    ])
  ].concat(baseFields);
  const fancyMenuItemSchema = choose$1("fancytype", {
    inserttable: insertTableFields,
    colorswatch: colorSwatchFields
  });
  const createFancyMenuItem = (spec) => asRaw("fancymenuitem", fancyMenuItemSchema, spec);
  const menuItemSchema = objOf([
    type,
    onSetup,
    defaultedOnAction,
    optionalIcon
  ].concat(commonMenuItemFields));
  const createMenuItem = (spec) => asRaw("menuitem", menuItemSchema, spec);
  const nestedMenuItemSchema = objOf([
    type,
    getSubmenuItems,
    onSetup,
    optionalIcon
  ].concat(commonMenuItemFields));
  const createNestedMenuItem = (spec) => asRaw("nestedmenuitem", nestedMenuItemSchema, spec);
  const toggleMenuItemSchema = objOf([
    type,
    optionalIcon,
    active,
    onSetup,
    onAction
  ].concat(commonMenuItemFields));
  const createToggleMenuItem = (spec) => asRaw("togglemenuitem", toggleMenuItemSchema, spec);
  const detectSize = (comp, margin, selectorClass) => {
    const descendants$1 = descendants(comp.element, "." + selectorClass);
    if (descendants$1.length > 0) {
      const columnLength = findIndex$1(descendants$1, (c) => {
        const thisTop = c.dom.getBoundingClientRect().top;
        const cTop = descendants$1[0].dom.getBoundingClientRect().top;
        return Math.abs(thisTop - cTop) > margin;
      }).getOr(descendants$1.length);
      return Optional.some({
        numColumns: columnLength,
        numRows: Math.ceil(descendants$1.length / columnLength)
      });
    } else {
      return Optional.none();
    }
  };
  const namedEvents = (name3, handlers2) => derive$1([config(name3, handlers2)]);
  const unnamedEvents = (handlers2) => namedEvents(generate$6("unnamed-events"), handlers2);
  const SimpleBehaviours = {
    namedEvents,
    unnamedEvents
  };
  const ExclusivityChannel = generate$6("tooltip.exclusive");
  const ShowTooltipEvent = generate$6("tooltip.show");
  const HideTooltipEvent = generate$6("tooltip.hide");
  const hideAllExclusive = (component, _tConfig, _tState) => {
    component.getSystem().broadcastOn([ExclusivityChannel], {});
  };
  const setComponents = (component, tConfig, tState, specs) => {
    tState.getTooltip().each((tooltip) => {
      if (tooltip.getSystem().isConnected()) {
        Replacing.set(tooltip, specs);
      }
    });
  };
  var TooltippingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    hideAllExclusive,
    setComponents
  });
  const events$9 = (tooltipConfig, state2) => {
    const hide2 = (comp) => {
      state2.getTooltip().each((p) => {
        detach(p);
        tooltipConfig.onHide(comp, p);
        state2.clearTooltip();
      });
      state2.clearTimer();
    };
    const show2 = (comp) => {
      if (!state2.isShowing()) {
        hideAllExclusive(comp);
        const sink = tooltipConfig.lazySink(comp).getOrDie();
        const popup = comp.getSystem().build({
          dom: tooltipConfig.tooltipDom,
          components: tooltipConfig.tooltipComponents,
          events: derive$2(tooltipConfig.mode === "normal" ? [
            run$1(mouseover(), (_2) => {
              emit(comp, ShowTooltipEvent);
            }),
            run$1(mouseout(), (_2) => {
              emit(comp, HideTooltipEvent);
            })
          ] : []),
          behaviours: derive$1([Replacing.config({})])
        });
        state2.setTooltip(popup);
        attach(sink, popup);
        tooltipConfig.onShow(comp, popup);
        Positioning.position(sink, popup, { anchor: tooltipConfig.anchor(comp) });
      }
    };
    return derive$2(flatten([
      [
        run$1(ShowTooltipEvent, (comp) => {
          state2.resetTimer(() => {
            show2(comp);
          }, tooltipConfig.delay);
        }),
        run$1(HideTooltipEvent, (comp) => {
          state2.resetTimer(() => {
            hide2(comp);
          }, tooltipConfig.delay);
        }),
        run$1(receive(), (comp, message) => {
          const receivingData = message;
          if (!receivingData.universal) {
            if (contains$2(receivingData.channels, ExclusivityChannel)) {
              hide2(comp);
            }
          }
        }),
        runOnDetached((comp) => {
          hide2(comp);
        })
      ],
      tooltipConfig.mode === "normal" ? [
        run$1(focusin(), (comp) => {
          emit(comp, ShowTooltipEvent);
        }),
        run$1(postBlur(), (comp) => {
          emit(comp, HideTooltipEvent);
        }),
        run$1(mouseover(), (comp) => {
          emit(comp, ShowTooltipEvent);
        }),
        run$1(mouseout(), (comp) => {
          emit(comp, HideTooltipEvent);
        })
      ] : [
        run$1(highlight$1(), (comp, _se) => {
          emit(comp, ShowTooltipEvent);
        }),
        run$1(dehighlight$1(), (comp) => {
          emit(comp, HideTooltipEvent);
        })
      ]
    ]));
  };
  var ActiveTooltipping = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$9
  });
  var TooltippingSchema = [
    required$1("lazySink"),
    required$1("tooltipDom"),
    defaulted("exclusive", true),
    defaulted("tooltipComponents", []),
    defaulted("delay", 300),
    defaultedStringEnum("mode", "normal", [
      "normal",
      "follow-highlight"
    ]),
    defaulted("anchor", (comp) => ({
      type: "hotspot",
      hotspot: comp,
      layouts: {
        onLtr: constant$1([
          south$2,
          north$2,
          southeast$2,
          northeast$2,
          southwest$2,
          northwest$2
        ]),
        onRtl: constant$1([
          south$2,
          north$2,
          southeast$2,
          northeast$2,
          southwest$2,
          northwest$2
        ])
      }
    })),
    onHandler("onHide"),
    onHandler("onShow")
  ];
  const init$b = () => {
    const timer = value$2();
    const popup = value$2();
    const clearTimer = () => {
      timer.on(clearTimeout);
    };
    const resetTimer = (f2, delay) => {
      clearTimer();
      timer.set(setTimeout(f2, delay));
    };
    const readState = constant$1("not-implemented");
    return nu$8({
      getTooltip: popup.get,
      isShowing: popup.isSet,
      setTooltip: popup.set,
      clearTooltip: popup.clear,
      clearTimer,
      resetTimer,
      readState
    });
  };
  var TooltippingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$b
  });
  const Tooltipping = create$42({
    fields: TooltippingSchema,
    name: "tooltipping",
    active: ActiveTooltipping,
    state: TooltippingState,
    apis: TooltippingApis
  });
  const escape2 = (text3) => text3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const ReadOnlyChannel = "silver.readonly";
  const ReadOnlyDataSchema = objOf([requiredBoolean("readonly")]);
  const broadcastReadonly = (uiRefs, readonly) => {
    const outerContainer = uiRefs.mainUi.outerContainer;
    const target = outerContainer.element;
    const motherships = [
      uiRefs.mainUi.mothership,
      ...uiRefs.uiMotherships
    ];
    if (readonly) {
      each$1(motherships, (m) => {
        m.broadcastOn([dismissPopups()], { target });
      });
    }
    each$1(motherships, (m) => {
      m.broadcastOn([ReadOnlyChannel], { readonly });
    });
  };
  const setupReadonlyModeSwitch = (editor, uiRefs) => {
    editor.on("init", () => {
      if (editor.mode.isReadOnly()) {
        broadcastReadonly(uiRefs, true);
      }
    });
    editor.on("SwitchMode", () => broadcastReadonly(uiRefs, editor.mode.isReadOnly()));
    if (isReadOnly(editor)) {
      editor.mode.set("readonly");
    }
  };
  const receivingConfig = () => Receiving.config({
    channels: {
      [ReadOnlyChannel]: {
        schema: ReadOnlyDataSchema,
        onReceive: (comp, data2) => {
          Disabling.set(comp, data2.readonly);
        }
      }
    }
  });
  const item2 = (disabled) => Disabling.config({
    disabled,
    disableClass: "tox-collection__item--state-disabled"
  });
  const button = (disabled) => Disabling.config({ disabled });
  const splitButton = (disabled) => Disabling.config({
    disabled,
    disableClass: "tox-tbtn--disabled"
  });
  const toolbarButton = (disabled) => Disabling.config({
    disabled,
    disableClass: "tox-tbtn--disabled",
    useNative: false
  });
  const DisablingConfigs = {
    item: item2,
    button,
    splitButton,
    toolbarButton
  };
  const runWithApi = (info, comp) => {
    const api2 = info.getApi(comp);
    return (f2) => {
      f2(api2);
    };
  };
  const onControlAttached = (info, editorOffCell) => runOnAttached((comp) => {
    const run3 = runWithApi(info, comp);
    run3((api2) => {
      const onDestroy = info.onSetup(api2);
      if (isFunction2(onDestroy)) {
        editorOffCell.set(onDestroy);
      }
    });
  });
  const onControlDetached = (getApi2, editorOffCell) => runOnDetached((comp) => runWithApi(getApi2, comp)(editorOffCell.get()));
  const onMenuItemExecute = (info, itemResponse) => runOnExecute$1((comp, simulatedEvent) => {
    runWithApi(info, comp)(info.onAction);
    if (!info.triggersSubmenu && itemResponse === ItemResponse$1.CLOSE_ON_EXECUTE) {
      if (comp.getSystem().isConnected()) {
        emit(comp, sandboxClose());
      }
      simulatedEvent.stop();
    }
  });
  const menuItemEventOrder = {
    [execute$5()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "item-events"
    ]
  };
  const componentRenderPipeline = cat;
  const renderCommonItem = (spec, structure, itemResponse, providersBackstage) => {
    const editorOffCell = Cell(noop2);
    return {
      type: "item",
      dom: structure.dom,
      components: componentRenderPipeline(structure.optComponents),
      data: spec.data,
      eventOrder: menuItemEventOrder,
      hasSubmenu: spec.triggersSubmenu,
      itemBehaviours: derive$1([
        config("item-events", [
          onMenuItemExecute(spec, itemResponse),
          onControlAttached(spec, editorOffCell),
          onControlDetached(spec, editorOffCell)
        ]),
        DisablingConfigs.item(() => !spec.enabled || providersBackstage.isDisabled()),
        receivingConfig(),
        Replacing.config({})
      ].concat(spec.itemBehaviours))
    };
  };
  const buildData = (source) => ({
    value: source.value,
    meta: {
      text: source.text.getOr(""),
      ...source.meta
    }
  });
  const convertText = (source) => {
    const isMac = global$5.os.isMacOS() || global$5.os.isiOS();
    const mac = {
      alt: "⌥",
      ctrl: "⌃",
      shift: "⇧",
      meta: "⌘",
      access: "⌃⌥"
    };
    const other = {
      meta: "Ctrl",
      access: "Shift+Alt"
    };
    const replace2 = isMac ? mac : other;
    const shortcut = source.split("+");
    const updated = map$2(shortcut, (segment) => {
      const search2 = segment.toLowerCase().trim();
      return has$2(replace2, search2) ? replace2[search2] : segment;
    });
    return isMac ? updated.join("") : updated.join("+");
  };
  const renderIcon$2 = (name3, icons, classes2 = [iconClass]) => render$3(name3, {
    tag: "div",
    classes: classes2
  }, icons);
  const renderText = (text3) => ({
    dom: {
      tag: "div",
      classes: [textClass]
    },
    components: [text$2(global$8.translate(text3))]
  });
  const renderHtml = (html2, classes2) => ({
    dom: {
      tag: "div",
      classes: classes2,
      innerHtml: html2
    }
  });
  const renderStyledText = (style, text3) => ({
    dom: {
      tag: "div",
      classes: [textClass]
    },
    components: [{
      dom: {
        tag: style.tag,
        styles: style.styles
      },
      components: [text$2(global$8.translate(text3))]
    }]
  });
  const renderShortcut = (shortcut) => ({
    dom: {
      tag: "div",
      classes: [accessoryClass]
    },
    components: [text$2(convertText(shortcut))]
  });
  const renderCheckmark = (icons) => renderIcon$2("checkmark", icons, [checkmarkClass]);
  const renderSubmenuCaret = (icons) => renderIcon$2("chevron-right", icons, [caretClass]);
  const renderDownwardsCaret = (icons) => renderIcon$2("chevron-down", icons, [caretClass]);
  const renderContainer = (container, components2) => {
    const directionClass = container.direction === "vertical" ? containerColumnClass : containerRowClass;
    const alignClass = container.align === "left" ? containerAlignLeftClass : containerAlignRightClass;
    const getValignClass = () => {
      switch (container.valign) {
        case "top":
          return containerValignTopClass;
        case "middle":
          return containerValignMiddleClass;
        case "bottom":
          return containerValignBottomClass;
      }
    };
    return {
      dom: {
        tag: "div",
        classes: [
          containerClass,
          directionClass,
          alignClass,
          getValignClass()
        ]
      },
      components: components2
    };
  };
  const renderImage = (src, classes2, alt) => ({
    dom: {
      tag: "img",
      classes: classes2,
      attributes: {
        src,
        alt: alt.getOr("")
      }
    }
  });
  const renderColorStructure = (item3, providerBackstage, fallbackIcon) => {
    const colorPickerCommand = "custom";
    const removeColorCommand = "remove";
    const itemText = item3.ariaLabel;
    const itemValue = item3.value;
    const iconSvg = item3.iconContent.map((name3) => getOr(name3, providerBackstage.icons, fallbackIcon));
    const getDom = () => {
      const common = colorClass;
      const icon2 = iconSvg.getOr("");
      const attributes = itemText.map((text3) => ({ title: providerBackstage.translate(text3) })).getOr({});
      const baseDom = {
        tag: "div",
        attributes,
        classes: [common]
      };
      if (itemValue === colorPickerCommand) {
        return {
          ...baseDom,
          tag: "button",
          classes: [
            ...baseDom.classes,
            "tox-swatches__picker-btn"
          ],
          innerHtml: icon2
        };
      } else if (itemValue === removeColorCommand) {
        return {
          ...baseDom,
          classes: [
            ...baseDom.classes,
            "tox-swatch--remove"
          ],
          innerHtml: icon2
        };
      } else if (isNonNullable(itemValue)) {
        return {
          ...baseDom,
          attributes: {
            ...baseDom.attributes,
            "data-mce-color": itemValue
          },
          styles: { "background-color": itemValue },
          innerHtml: icon2
        };
      } else {
        return baseDom;
      }
    };
    return {
      dom: getDom(),
      optComponents: []
    };
  };
  const renderItemDomStructure = (ariaLabel) => {
    const domTitle = ariaLabel.map((label2) => ({ attributes: { title: global$8.translate(label2) } })).getOr({});
    return {
      tag: "div",
      classes: [
        navClass,
        selectableClass
      ],
      ...domTitle
    };
  };
  const renderNormalItemStructure = (info, providersBackstage, renderIcons, fallbackIcon) => {
    const iconSpec = {
      tag: "div",
      classes: [iconClass]
    };
    const renderIcon2 = (iconName) => render$3(iconName, iconSpec, providersBackstage.icons, fallbackIcon);
    const renderEmptyIcon = () => Optional.some({ dom: iconSpec });
    const leftIcon = renderIcons ? info.iconContent.map(renderIcon2).orThunk(renderEmptyIcon) : Optional.none();
    const checkmark = info.checkMark;
    const textRender = Optional.from(info.meta).fold(() => renderText, (meta) => has$2(meta, "style") ? curry(renderStyledText, meta.style) : renderText);
    const content = info.htmlContent.fold(() => info.textContent.map(textRender), (html2) => Optional.some(renderHtml(html2, [textClass])));
    const menuItem = {
      dom: renderItemDomStructure(info.ariaLabel),
      optComponents: [
        leftIcon,
        content,
        info.shortcutContent.map(renderShortcut),
        checkmark,
        info.caret
      ]
    };
    return menuItem;
  };
  const renderItemStructure = (info, providersBackstage, renderIcons, fallbackIcon = Optional.none()) => {
    if (info.presets === "color") {
      return renderColorStructure(info, providersBackstage, fallbackIcon);
    } else {
      return renderNormalItemStructure(info, providersBackstage, renderIcons, fallbackIcon);
    }
  };
  const tooltipBehaviour = (meta, sharedBackstage) => get$g(meta, "tooltipWorker").map((tooltipWorker) => [Tooltipping.config({
    lazySink: sharedBackstage.getSink,
    tooltipDom: {
      tag: "div",
      classes: ["tox-tooltip-worker-container"]
    },
    tooltipComponents: [],
    anchor: (comp) => ({
      type: "submenu",
      item: comp,
      overrides: { maxHeightFunction: expandable$1 }
    }),
    mode: "follow-highlight",
    onShow: (component, _tooltip) => {
      tooltipWorker((elm) => {
        Tooltipping.setComponents(component, [external$1({ element: SugarElement.fromDom(elm) })]);
      });
    }
  })]).getOr([]);
  const encodeText = (text3) => global$7.DOM.encode(text3);
  const replaceText = (text3, matchText) => {
    const translated = global$8.translate(text3);
    const encoded = encodeText(translated);
    if (matchText.length > 0) {
      const escapedMatchRegex = new RegExp(escape2(matchText), "gi");
      return encoded.replace(escapedMatchRegex, (match) => `<span class="tox-autocompleter-highlight">${match}</span>`);
    } else {
      return encoded;
    }
  };
  const renderAutocompleteItem = (spec, matchText, useText, presets, onItemValueHandler, itemResponse, sharedBackstage, renderIcons = true) => {
    const structure = renderItemStructure({
      presets,
      textContent: Optional.none(),
      htmlContent: useText ? spec.text.map((text3) => replaceText(text3, matchText)) : Optional.none(),
      ariaLabel: spec.text,
      iconContent: spec.icon,
      shortcutContent: Optional.none(),
      checkMark: Optional.none(),
      caret: Optional.none(),
      value: spec.value
    }, sharedBackstage.providers, renderIcons, spec.icon);
    return renderCommonItem({
      data: buildData(spec),
      enabled: spec.enabled,
      getApi: constant$1({}),
      onAction: (_api) => onItemValueHandler(spec.value, spec.meta),
      onSetup: constant$1(noop2),
      triggersSubmenu: false,
      itemBehaviours: tooltipBehaviour(spec.meta, sharedBackstage)
    }, structure, itemResponse, sharedBackstage.providers);
  };
  const render$2 = (items, extras) => map$2(items, (item3) => {
    switch (item3.type) {
      case "cardcontainer":
        return renderContainer(item3, render$2(item3.items, extras));
      case "cardimage":
        return renderImage(item3.src, item3.classes, item3.alt);
      case "cardtext":
        const shouldHighlight = item3.name.exists((name3) => contains$2(extras.cardText.highlightOn, name3));
        const matchText = shouldHighlight ? Optional.from(extras.cardText.matchText).getOr("") : "";
        return renderHtml(replaceText(item3.text, matchText), item3.classes);
    }
  });
  const renderCardMenuItem = (spec, itemResponse, sharedBackstage, extras) => {
    const getApi2 = (component) => ({
      isEnabled: () => !Disabling.isDisabled(component),
      setEnabled: (state2) => {
        Disabling.set(component, !state2);
        each$1(descendants(component.element, "*"), (elm) => {
          component.getSystem().getByDom(elm).each((comp) => {
            if (comp.hasConfigured(Disabling)) {
              Disabling.set(comp, !state2);
            }
          });
        });
      }
    });
    const structure = {
      dom: renderItemDomStructure(spec.label),
      optComponents: [Optional.some({
        dom: {
          tag: "div",
          classes: [
            containerClass,
            containerRowClass
          ]
        },
        components: render$2(spec.items, extras)
      })]
    };
    return renderCommonItem({
      data: buildData({
        text: Optional.none(),
        ...spec
      }),
      enabled: spec.enabled,
      getApi: getApi2,
      onAction: spec.onAction,
      onSetup: spec.onSetup,
      triggersSubmenu: false,
      itemBehaviours: Optional.from(extras.itemBehaviours).getOr([])
    }, structure, itemResponse, sharedBackstage.providers);
  };
  const renderChoiceItem = (spec, useText, presets, onItemValueHandler, isSelected, itemResponse, providersBackstage, renderIcons = true) => {
    const getApi2 = (component) => ({
      setActive: (state2) => {
        Toggling.set(component, state2);
      },
      isActive: () => Toggling.isOn(component),
      isEnabled: () => !Disabling.isDisabled(component),
      setEnabled: (state2) => Disabling.set(component, !state2)
    });
    const structure = renderItemStructure({
      presets,
      textContent: useText ? spec.text : Optional.none(),
      htmlContent: Optional.none(),
      ariaLabel: spec.text,
      iconContent: spec.icon,
      shortcutContent: useText ? spec.shortcut : Optional.none(),
      checkMark: useText ? Optional.some(renderCheckmark(providersBackstage.icons)) : Optional.none(),
      caret: Optional.none(),
      value: spec.value
    }, providersBackstage, renderIcons);
    return deepMerge(renderCommonItem({
      data: buildData(spec),
      enabled: spec.enabled,
      getApi: getApi2,
      onAction: (_api) => onItemValueHandler(spec.value),
      onSetup: (api2) => {
        api2.setActive(isSelected);
        return noop2;
      },
      triggersSubmenu: false,
      itemBehaviours: []
    }, structure, itemResponse, providersBackstage), {
      toggling: {
        toggleClass: tickedClass,
        toggleOnExecute: false,
        selected: spec.active,
        exclusive: true
      }
    });
  };
  const parts$f = generate$3(owner$2(), parts$h());
  const hexColour = (value2) => ({ value: normalizeHex(value2) });
  const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  const longformRegex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
  const isHexString = (hex) => shorthandRegex.test(hex) || longformRegex.test(hex);
  const normalizeHex = (hex) => removeLeading(hex, "#").toUpperCase();
  const fromString$1 = (hex) => isHexString(hex) ? Optional.some({ value: normalizeHex(hex) }) : Optional.none();
  const getLongForm = (hex) => {
    const hexString = hex.value.replace(shorthandRegex, (m, r2, g, b2) => r2 + r2 + g + g + b2 + b2);
    return { value: hexString };
  };
  const extractValues = (hex) => {
    const longForm = getLongForm(hex);
    const splitForm = longformRegex.exec(longForm.value);
    return splitForm === null ? [
      "FFFFFF",
      "FF",
      "FF",
      "FF"
    ] : splitForm;
  };
  const toHex = (component) => {
    const hex = component.toString(16);
    return (hex.length === 1 ? "0" + hex : hex).toUpperCase();
  };
  const fromRgba = (rgbaColour2) => {
    const value2 = toHex(rgbaColour2.red) + toHex(rgbaColour2.green) + toHex(rgbaColour2.blue);
    return hexColour(value2);
  };
  const min2 = Math.min;
  const max2 = Math.max;
  const round$1 = Math.round;
  const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
  const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
  const rgbaColour = (red2, green, blue, alpha) => ({
    red: red2,
    green,
    blue,
    alpha
  });
  const isRgbaComponent = (value2) => {
    const num = parseInt(value2, 10);
    return num.toString() === value2 && num >= 0 && num <= 255;
  };
  const fromHsv = (hsv) => {
    let r2;
    let g;
    let b2;
    const hue = (hsv.hue || 0) % 360;
    let saturation = hsv.saturation / 100;
    let brightness = hsv.value / 100;
    saturation = max2(0, min2(saturation, 1));
    brightness = max2(0, min2(brightness, 1));
    if (saturation === 0) {
      r2 = g = b2 = round$1(255 * brightness);
      return rgbaColour(r2, g, b2, 1);
    }
    const side = hue / 60;
    const chroma = brightness * saturation;
    const x = chroma * (1 - Math.abs(side % 2 - 1));
    const match = brightness - chroma;
    switch (Math.floor(side)) {
      case 0:
        r2 = chroma;
        g = x;
        b2 = 0;
        break;
      case 1:
        r2 = x;
        g = chroma;
        b2 = 0;
        break;
      case 2:
        r2 = 0;
        g = chroma;
        b2 = x;
        break;
      case 3:
        r2 = 0;
        g = x;
        b2 = chroma;
        break;
      case 4:
        r2 = x;
        g = 0;
        b2 = chroma;
        break;
      case 5:
        r2 = chroma;
        g = 0;
        b2 = x;
        break;
      default:
        r2 = g = b2 = 0;
    }
    r2 = round$1(255 * (r2 + match));
    g = round$1(255 * (g + match));
    b2 = round$1(255 * (b2 + match));
    return rgbaColour(r2, g, b2, 1);
  };
  const fromHex = (hexColour2) => {
    const result = extractValues(hexColour2);
    const red2 = parseInt(result[1], 16);
    const green = parseInt(result[2], 16);
    const blue = parseInt(result[3], 16);
    return rgbaColour(red2, green, blue, 1);
  };
  const fromStringValues = (red2, green, blue, alpha) => {
    const r2 = parseInt(red2, 10);
    const g = parseInt(green, 10);
    const b2 = parseInt(blue, 10);
    const a = parseFloat(alpha);
    return rgbaColour(r2, g, b2, a);
  };
  const fromString = (rgbaString) => {
    if (rgbaString === "transparent") {
      return Optional.some(rgbaColour(0, 0, 0, 0));
    }
    const rgbMatch = rgbRegex.exec(rgbaString);
    if (rgbMatch !== null) {
      return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], "1"));
    }
    const rgbaMatch = rgbaRegex.exec(rgbaString);
    if (rgbaMatch !== null) {
      return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
    }
    return Optional.none();
  };
  const toString3 = (rgba) => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;
  const red = rgbaColour(255, 0, 0, 1);
  const fireSkinLoaded$1 = (editor) => {
    editor.dispatch("SkinLoaded");
  };
  const fireSkinLoadError$1 = (editor, error3) => {
    editor.dispatch("SkinLoadError", error3);
  };
  const fireResizeEditor = (editor) => {
    editor.dispatch("ResizeEditor");
  };
  const fireResizeContent = (editor, e) => {
    editor.dispatch("ResizeContent", e);
  };
  const fireScrollContent = (editor, e) => {
    editor.dispatch("ScrollContent", e);
  };
  const fireTextColorChange = (editor, data2) => {
    editor.dispatch("TextColorChange", data2);
  };
  const fireAfterProgressState = (editor, state2) => {
    editor.dispatch("AfterProgressState", { state: state2 });
  };
  const fireResolveName = (editor, node) => editor.dispatch("ResolveName", {
    name: node.nodeName.toLowerCase(),
    target: node
  });
  const fireToggleToolbarDrawer = (editor, state2) => {
    editor.dispatch("ToggleToolbarDrawer", { state: state2 });
  };
  var global$4 = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
  const cacheStorage = {};
  const ColorCache = (storageId, max3 = 10) => {
    const storageString = global$4.getItem(storageId);
    const localstorage = isString2(storageString) ? JSON.parse(storageString) : [];
    const prune = (list2) => {
      const diff = max3 - list2.length;
      return diff < 0 ? list2.slice(0, max3) : list2;
    };
    const cache = prune(localstorage);
    const add2 = (key) => {
      indexOf(cache, key).each(remove2);
      cache.unshift(key);
      if (cache.length > max3) {
        cache.pop();
      }
      global$4.setItem(storageId, JSON.stringify(cache));
    };
    const remove2 = (idx) => {
      cache.splice(idx, 1);
    };
    const state2 = () => cache.slice(0);
    return {
      add: add2,
      state: state2
    };
  };
  const getCacheForId = (id) => get$g(cacheStorage, id).getOrThunk(() => {
    const storageId = `tinymce-custom-colors-${id}`;
    const currentData = global$4.getItem(storageId);
    if (isNullable(currentData)) {
      const legacyDefault = global$4.getItem("tinymce-custom-colors");
      global$4.setItem(storageId, isNonNullable(legacyDefault) ? legacyDefault : "[]");
    }
    const storage = ColorCache(storageId, 10);
    cacheStorage[id] = storage;
    return storage;
  });
  const getCurrentColors = (id) => map$2(getCacheForId(id).state(), (color) => ({
    type: "choiceitem",
    text: color,
    icon: "checkmark",
    value: color
  }));
  const addColor = (id, color) => {
    getCacheForId(id).add(color);
  };
  const hsvColour = (hue, saturation, value2) => ({
    hue,
    saturation,
    value: value2
  });
  const fromRgb = (rgbaColour2) => {
    let h = 0;
    let s = 0;
    let v = 0;
    const r2 = rgbaColour2.red / 255;
    const g = rgbaColour2.green / 255;
    const b2 = rgbaColour2.blue / 255;
    const minRGB = Math.min(r2, Math.min(g, b2));
    const maxRGB = Math.max(r2, Math.max(g, b2));
    if (minRGB === maxRGB) {
      v = minRGB;
      return hsvColour(0, 0, v * 100);
    }
    const d = r2 === minRGB ? g - b2 : b2 === minRGB ? r2 - g : b2 - r2;
    h = r2 === minRGB ? 3 : b2 === minRGB ? 1 : 5;
    h = 60 * (h - d / (maxRGB - minRGB));
    s = (maxRGB - minRGB) / maxRGB;
    v = maxRGB;
    return hsvColour(Math.round(h), Math.round(s * 100), Math.round(v * 100));
  };
  const hexToHsv = (hex) => fromRgb(fromHex(hex));
  const hsvToHex = (hsv) => fromRgba(fromHsv(hsv));
  const anyToHex = (color) => fromString$1(color).orThunk(() => fromString(color).map(fromRgba)).getOrThunk(() => {
    const canvas = document.createElement("canvas");
    canvas.height = 1;
    canvas.width = 1;
    const canvasContext = canvas.getContext("2d");
    canvasContext.clearRect(0, 0, canvas.width, canvas.height);
    canvasContext.fillStyle = "#FFFFFF";
    canvasContext.fillStyle = color;
    canvasContext.fillRect(0, 0, 1, 1);
    const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
    const r2 = rgba[0];
    const g = rgba[1];
    const b2 = rgba[2];
    const a = rgba[3];
    return fromRgba(rgbaColour(r2, g, b2, a));
  });
  const foregroundId = "forecolor";
  const backgroundId = "hilitecolor";
  const defaultCols = 5;
  const calcCols = (colors) => Math.max(defaultCols, Math.ceil(Math.sqrt(colors)));
  const calcColsOption = (editor, numColors) => {
    const calculatedCols = calcCols(numColors);
    const fallbackCols = option$1("color_cols")(editor);
    return defaultCols === calculatedCols ? fallbackCols : calculatedCols;
  };
  const mapColors = (colorMap) => {
    const colors = [];
    for (let i = 0; i < colorMap.length; i += 2) {
      colors.push({
        text: colorMap[i + 1],
        value: "#" + anyToHex(colorMap[i]).value,
        icon: "checkmark",
        type: "choiceitem"
      });
    }
    return colors;
  };
  const option$1 = (name3) => (editor) => editor.options.get(name3);
  const fallbackColor = "#000000";
  const register$d = (editor) => {
    const registerOption = editor.options.register;
    const colorProcessor = (value2) => {
      if (isArrayOf(value2, isString2)) {
        return {
          value: mapColors(value2),
          valid: true
        };
      } else {
        return {
          valid: false,
          message: "Must be an array of strings."
        };
      }
    };
    registerOption("color_map", {
      processor: colorProcessor,
      default: [
        "#BFEDD2",
        "Light Green",
        "#FBEEB8",
        "Light Yellow",
        "#F8CAC6",
        "Light Red",
        "#ECCAFA",
        "Light Purple",
        "#C2E0F4",
        "Light Blue",
        "#2DC26B",
        "Green",
        "#F1C40F",
        "Yellow",
        "#E03E2D",
        "Red",
        "#B96AD9",
        "Purple",
        "#3598DB",
        "Blue",
        "#169179",
        "Dark Turquoise",
        "#E67E23",
        "Orange",
        "#BA372A",
        "Dark Red",
        "#843FA1",
        "Dark Purple",
        "#236FA1",
        "Dark Blue",
        "#ECF0F1",
        "Light Gray",
        "#CED4D9",
        "Medium Gray",
        "#95A5A6",
        "Gray",
        "#7E8C8D",
        "Dark Gray",
        "#34495E",
        "Navy Blue",
        "#000000",
        "Black",
        "#ffffff",
        "White"
      ]
    });
    registerOption("color_map_background", { processor: colorProcessor });
    registerOption("color_map_foreground", { processor: colorProcessor });
    registerOption("color_cols", {
      processor: "number",
      default: calcCols(getColors$2(editor, "default").length)
    });
    registerOption("color_cols_foreground", {
      processor: "number",
      default: calcColsOption(editor, getColors$2(editor, foregroundId).length)
    });
    registerOption("color_cols_background", {
      processor: "number",
      default: calcColsOption(editor, getColors$2(editor, backgroundId).length)
    });
    registerOption("custom_colors", {
      processor: "boolean",
      default: true
    });
    registerOption("color_default_foreground", {
      processor: "string",
      default: fallbackColor
    });
    registerOption("color_default_background", {
      processor: "string",
      default: fallbackColor
    });
  };
  const colorColsOption = (editor, id) => {
    if (id === foregroundId) {
      return option$1("color_cols_foreground")(editor);
    } else if (id === backgroundId) {
      return option$1("color_cols_background")(editor);
    } else {
      return option$1("color_cols")(editor);
    }
  };
  const getColorCols$1 = (editor, id) => {
    const colorCols = colorColsOption(editor, id);
    return colorCols > 0 ? colorCols : defaultCols;
  };
  const hasCustomColors$1 = option$1("custom_colors");
  const getColors$2 = (editor, id) => {
    if (id === foregroundId && editor.options.isSet("color_map_foreground")) {
      return option$1("color_map_foreground")(editor);
    } else if (id === backgroundId && editor.options.isSet("color_map_background")) {
      return option$1("color_map_background")(editor);
    } else {
      return option$1("color_map")(editor);
    }
  };
  const getDefaultForegroundColor = option$1("color_default_foreground");
  const getDefaultBackgroundColor = option$1("color_default_background");
  const defaultBackgroundColor = "rgba(0, 0, 0, 0)";
  const isValidBackgroundColor = (value2) => fromString(value2).exists((c) => c.alpha !== 0);
  const getClosestCssBackgroundColorValue = (scope) => {
    return closest$4(scope, (node) => {
      if (isElement$12(node)) {
        const color = get$e(node, "background-color");
        return someIf(isValidBackgroundColor(color), color);
      } else {
        return Optional.none();
      }
    }).getOr(defaultBackgroundColor);
  };
  const getCurrentColor = (editor, format) => {
    const node = SugarElement.fromDom(editor.selection.getStart());
    const cssRgbValue = format === "hilitecolor" ? getClosestCssBackgroundColorValue(node) : get$e(node, "color");
    return fromString(cssRgbValue).map((rgba) => "#" + fromRgba(rgba).value);
  };
  const applyFormat = (editor, format, value2) => {
    editor.undoManager.transact(() => {
      editor.focus();
      editor.formatter.apply(format, { value: value2 });
      editor.nodeChanged();
    });
  };
  const removeFormat = (editor, format) => {
    editor.undoManager.transact(() => {
      editor.focus();
      editor.formatter.remove(format, { value: null }, void 0, true);
      editor.nodeChanged();
    });
  };
  const registerCommands = (editor) => {
    editor.addCommand("mceApplyTextcolor", (format, value2) => {
      applyFormat(editor, format, value2);
    });
    editor.addCommand("mceRemoveTextcolor", (format) => {
      removeFormat(editor, format);
    });
  };
  const getAdditionalColors = (hasCustom) => {
    const type2 = "choiceitem";
    const remove2 = {
      type: type2,
      text: "Remove color",
      icon: "color-swatch-remove-color",
      value: "remove"
    };
    const custom2 = {
      type: type2,
      text: "Custom color",
      icon: "color-picker",
      value: "custom"
    };
    return hasCustom ? [
      remove2,
      custom2
    ] : [remove2];
  };
  const applyColor = (editor, format, value2, onChoice) => {
    if (value2 === "custom") {
      const dialog = colorPickerDialog(editor);
      dialog((colorOpt) => {
        colorOpt.each((color) => {
          addColor(format, color);
          editor.execCommand("mceApplyTextcolor", format, color);
          onChoice(color);
        });
      }, getCurrentColor(editor, format).getOr(fallbackColor));
    } else if (value2 === "remove") {
      onChoice("");
      editor.execCommand("mceRemoveTextcolor", format);
    } else {
      onChoice(value2);
      editor.execCommand("mceApplyTextcolor", format, value2);
    }
  };
  const getColors$1 = (colors, id, hasCustom) => colors.concat(getCurrentColors(id).concat(getAdditionalColors(hasCustom)));
  const getFetch$1 = (colors, id, hasCustom) => (callback) => {
    callback(getColors$1(colors, id, hasCustom));
  };
  const setIconColor = (splitButtonApi, name3, newColor) => {
    const id = name3 === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
    splitButtonApi.setIconFill(id, newColor);
  };
  const select$1 = (editor, format) => (value2) => {
    const optCurrentHex = getCurrentColor(editor, format);
    return is$1(optCurrentHex, value2.toUpperCase());
  };
  const registerTextColorButton = (editor, name3, format, tooltip, lastColor) => {
    editor.ui.registry.addSplitButton(name3, {
      tooltip,
      presets: "color",
      icon: name3 === "forecolor" ? "text-color" : "highlight-bg-color",
      select: select$1(editor, format),
      columns: getColorCols$1(editor, format),
      fetch: getFetch$1(getColors$2(editor, format), format, hasCustomColors$1(editor)),
      onAction: (_splitButtonApi) => {
        applyColor(editor, format, lastColor.get(), noop2);
      },
      onItemAction: (_splitButtonApi, value2) => {
        applyColor(editor, format, value2, (newColor) => {
          lastColor.set(newColor);
          fireTextColorChange(editor, {
            name: name3,
            color: newColor
          });
        });
      },
      onSetup: (splitButtonApi) => {
        setIconColor(splitButtonApi, name3, lastColor.get());
        const handler = (e) => {
          if (e.name === name3) {
            setIconColor(splitButtonApi, e.name, e.color);
          }
        };
        editor.on("TextColorChange", handler);
        return () => {
          editor.off("TextColorChange", handler);
        };
      }
    });
  };
  const registerTextColorMenuItem = (editor, name3, format, text3, lastColor) => {
    editor.ui.registry.addNestedMenuItem(name3, {
      text: text3,
      icon: name3 === "forecolor" ? "text-color" : "highlight-bg-color",
      onSetup: (api2) => {
        setIconColor(api2, name3, lastColor.get());
        return noop2;
      },
      getSubmenuItems: () => [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        select: select$1(editor, format),
        initData: { storageKey: format },
        onAction: (data2) => {
          applyColor(editor, format, data2.value, (newColor) => {
            lastColor.set(newColor);
            fireTextColorChange(editor, {
              name: name3,
              color: newColor
            });
          });
        }
      }]
    });
  };
  const colorPickerDialog = (editor) => (callback, value2) => {
    let isValid = false;
    const onSubmit = (api2) => {
      const data2 = api2.getData();
      const hex = data2.colorpicker;
      if (isValid) {
        callback(Optional.from(hex));
        api2.close();
      } else {
        editor.windowManager.alert(editor.translate([
          "Invalid hex color code: {0}",
          hex
        ]));
      }
    };
    const onAction2 = (_api, details) => {
      if (details.name === "hex-valid") {
        isValid = details.value;
      }
    };
    const initialData = { colorpicker: value2 };
    editor.windowManager.open({
      title: "Color Picker",
      size: "normal",
      body: {
        type: "panel",
        items: [{
          type: "colorpicker",
          name: "colorpicker",
          label: "Color"
        }]
      },
      buttons: [
        {
          type: "cancel",
          name: "cancel",
          text: "Cancel"
        },
        {
          type: "submit",
          name: "save",
          text: "Save",
          primary: true
        }
      ],
      initialData,
      onAction: onAction2,
      onSubmit,
      onClose: noop2,
      onCancel: () => {
        callback(Optional.none());
      }
    });
  };
  const register$c = (editor) => {
    registerCommands(editor);
    const fallbackColorForeground = getDefaultForegroundColor(editor);
    const fallbackColorBackground = getDefaultBackgroundColor(editor);
    const lastForeColor = Cell(fallbackColorForeground);
    const lastBackColor = Cell(fallbackColorBackground);
    registerTextColorButton(editor, "forecolor", "forecolor", "Text color", lastForeColor);
    registerTextColorButton(editor, "backcolor", "hilitecolor", "Background color", lastBackColor);
    registerTextColorMenuItem(editor, "forecolor", "forecolor", "Text color", lastForeColor);
    registerTextColorMenuItem(editor, "backcolor", "hilitecolor", "Background color", lastBackColor);
  };
  const createPartialChoiceMenu = (value2, items, onItemValueHandler, columns, presets, itemResponse, select2, providersBackstage) => {
    const hasIcons = menuHasIcons(items);
    const presetItemTypes = presets !== "color" ? "normal" : "color";
    const alloyItems = createChoiceItems(items, onItemValueHandler, columns, presetItemTypes, itemResponse, select2, providersBackstage);
    const menuLayout = { menuType: presets };
    return createPartialMenuWithAlloyItems(value2, hasIcons, alloyItems, columns, menuLayout);
  };
  const createChoiceItems = (items, onItemValueHandler, columns, itemPresets, itemResponse, select2, providersBackstage) => cat(map$2(items, (item3) => {
    if (item3.type === "choiceitem") {
      return createChoiceMenuItem(item3).fold(handleError, (d) => Optional.some(renderChoiceItem(d, columns === 1, itemPresets, onItemValueHandler, select2(d.value), itemResponse, providersBackstage, menuHasIcons(items))));
    } else {
      return Optional.none();
    }
  }));
  const deriveMenuMovement = (columns, presets) => {
    const menuMarkers = markers(presets);
    if (columns === 1) {
      return {
        mode: "menu",
        moveOnTab: true
      };
    } else if (columns === "auto") {
      return {
        mode: "grid",
        selector: "." + menuMarkers.item,
        initSize: {
          numColumns: 1,
          numRows: 1
        }
      };
    } else {
      const rowClass = presets === "color" ? "tox-swatches__row" : "tox-collection__group";
      return {
        mode: "matrix",
        rowSelector: "." + rowClass,
        previousSelector: (menu2) => {
          return presets === "color" ? descendant(menu2.element, "[aria-checked=true]") : Optional.none();
        }
      };
    }
  };
  const deriveCollectionMovement = (columns, presets) => {
    if (columns === 1) {
      return {
        mode: "menu",
        moveOnTab: false,
        selector: ".tox-collection__item"
      };
    } else if (columns === "auto") {
      return {
        mode: "flatgrid",
        selector: ".tox-collection__item",
        initSize: {
          numColumns: 1,
          numRows: 1
        }
      };
    } else {
      return {
        mode: "matrix",
        selectors: {
          row: presets === "color" ? ".tox-swatches__row" : ".tox-collection__group",
          cell: presets === "color" ? `.${colorClass}` : `.${selectableClass}`
        }
      };
    }
  };
  const renderColorSwatchItem = (spec, backstage) => {
    const items = getColorItems(spec, backstage);
    const columns = backstage.colorinput.getColorCols(spec.initData.storageKey);
    const presets = "color";
    const menuSpec = createPartialChoiceMenu(generate$6("menu-value"), items, (value2) => {
      spec.onAction({ value: value2 });
    }, columns, presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), backstage.shared.providers);
    const widgetSpec = {
      ...menuSpec,
      markers: markers(presets),
      movement: deriveMenuMovement(columns, presets)
    };
    return {
      type: "widget",
      data: { value: generate$6("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: true,
      components: [parts$f.widget(Menu.sketch(widgetSpec))]
    };
  };
  const getColorItems = (spec, backstage) => {
    const useCustomColors = spec.initData.allowCustomColors && backstage.colorinput.hasCustomColors();
    return spec.initData.colors.fold(() => getColors$1(backstage.colorinput.getColors(spec.initData.storageKey), spec.initData.storageKey, useCustomColors), (colors) => colors.concat(getAdditionalColors(useCustomColors)));
  };
  const cellOverEvent = generate$6("cell-over");
  const cellExecuteEvent = generate$6("cell-execute");
  const makeCell = (row, col, labelId) => {
    const emitCellOver = (c) => emitWith(c, cellOverEvent, {
      row,
      col
    });
    const emitExecute2 = (c) => emitWith(c, cellExecuteEvent, {
      row,
      col
    });
    const onClick = (c, se) => {
      se.stop();
      emitExecute2(c);
    };
    return build$1({
      dom: {
        tag: "div",
        attributes: {
          role: "button",
          ["aria-labelledby"]: labelId
        }
      },
      behaviours: derive$1([
        config("insert-table-picker-cell", [
          run$1(mouseover(), Focusing.focus),
          run$1(execute$5(), emitExecute2),
          run$1(click(), onClick),
          run$1(tap(), onClick)
        ]),
        Toggling.config({
          toggleClass: "tox-insert-table-picker__selected",
          toggleOnExecute: false
        }),
        Focusing.config({ onFocus: emitCellOver })
      ])
    });
  };
  const makeCells = (labelId, numRows, numCols) => {
    const cells = [];
    for (let i = 0; i < numRows; i++) {
      const row = [];
      for (let j = 0; j < numCols; j++) {
        row.push(makeCell(i, j, labelId));
      }
      cells.push(row);
    }
    return cells;
  };
  const selectCells = (cells, selectedRow, selectedColumn, numRows, numColumns) => {
    for (let i = 0; i < numRows; i++) {
      for (let j = 0; j < numColumns; j++) {
        Toggling.set(cells[i][j], i <= selectedRow && j <= selectedColumn);
      }
    }
  };
  const makeComponents = (cells) => bind$3(cells, (cellRow) => map$2(cellRow, premade));
  const makeLabelText = (row, col) => text$2(`${col}x${row}`);
  const renderInsertTableMenuItem = (spec) => {
    const numRows = 10;
    const numColumns = 10;
    const sizeLabelId = generate$6("size-label");
    const cells = makeCells(sizeLabelId, numRows, numColumns);
    const emptyLabelText = makeLabelText(0, 0);
    const memLabel = record({
      dom: {
        tag: "span",
        classes: ["tox-insert-table-picker__label"],
        attributes: { id: sizeLabelId }
      },
      components: [emptyLabelText],
      behaviours: derive$1([Replacing.config({})])
    });
    return {
      type: "widget",
      data: { value: generate$6("widget-id") },
      dom: {
        tag: "div",
        classes: ["tox-fancymenuitem"]
      },
      autofocus: true,
      components: [parts$f.widget({
        dom: {
          tag: "div",
          classes: ["tox-insert-table-picker"]
        },
        components: makeComponents(cells).concat(memLabel.asSpec()),
        behaviours: derive$1([
          config("insert-table-picker", [
            runOnAttached((c) => {
              Replacing.set(memLabel.get(c), [emptyLabelText]);
            }),
            runWithTarget(cellOverEvent, (c, t2, e) => {
              const { row, col } = e.event;
              selectCells(cells, row, col, numRows, numColumns);
              Replacing.set(memLabel.get(c), [makeLabelText(row + 1, col + 1)]);
            }),
            runWithTarget(cellExecuteEvent, (c, _2, e) => {
              const { row, col } = e.event;
              spec.onAction({
                numRows: row + 1,
                numColumns: col + 1
              });
              emit(c, sandboxClose());
            })
          ]),
          Keying.config({
            initSize: {
              numRows,
              numColumns
            },
            mode: "flatgrid",
            selector: '[role="button"]'
          })
        ])
      })]
    };
  };
  const fancyMenuItems = {
    inserttable: renderInsertTableMenuItem,
    colorswatch: renderColorSwatchItem
  };
  const renderFancyMenuItem = (spec, backstage) => get$g(fancyMenuItems, spec.fancytype).map((render2) => render2(spec, backstage));
  const renderNestedItem = (spec, itemResponse, providersBackstage, renderIcons = true, downwardsCaret = false) => {
    const caret = downwardsCaret ? renderDownwardsCaret(providersBackstage.icons) : renderSubmenuCaret(providersBackstage.icons);
    const getApi2 = (component) => ({
      isEnabled: () => !Disabling.isDisabled(component),
      setEnabled: (state2) => Disabling.set(component, !state2),
      setIconFill: (id, value2) => {
        descendant(component.element, `svg path[id="${id}"], rect[id="${id}"]`).each((underlinePath) => {
          set$9(underlinePath, "fill", value2);
        });
      }
    });
    const structure = renderItemStructure({
      presets: "normal",
      iconContent: spec.icon,
      textContent: spec.text,
      htmlContent: Optional.none(),
      ariaLabel: spec.text,
      caret: Optional.some(caret),
      checkMark: Optional.none(),
      shortcutContent: spec.shortcut
    }, providersBackstage, renderIcons);
    return renderCommonItem({
      data: buildData(spec),
      getApi: getApi2,
      enabled: spec.enabled,
      onAction: noop2,
      onSetup: spec.onSetup,
      triggersSubmenu: true,
      itemBehaviours: []
    }, structure, itemResponse, providersBackstage);
  };
  const renderNormalItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
    const getApi2 = (component) => ({
      isEnabled: () => !Disabling.isDisabled(component),
      setEnabled: (state2) => Disabling.set(component, !state2)
    });
    const structure = renderItemStructure({
      presets: "normal",
      iconContent: spec.icon,
      textContent: spec.text,
      htmlContent: Optional.none(),
      ariaLabel: spec.text,
      caret: Optional.none(),
      checkMark: Optional.none(),
      shortcutContent: spec.shortcut
    }, providersBackstage, renderIcons);
    return renderCommonItem({
      data: buildData(spec),
      getApi: getApi2,
      enabled: spec.enabled,
      onAction: spec.onAction,
      onSetup: spec.onSetup,
      triggersSubmenu: false,
      itemBehaviours: []
    }, structure, itemResponse, providersBackstage);
  };
  const renderSeparatorItem = (spec) => ({
    type: "separator",
    dom: {
      tag: "div",
      classes: [
        selectableClass,
        groupHeadingClass
      ]
    },
    components: spec.text.map(text$2).toArray()
  });
  const renderToggleMenuItem = (spec, itemResponse, providersBackstage, renderIcons = true) => {
    const getApi2 = (component) => ({
      setActive: (state2) => {
        Toggling.set(component, state2);
      },
      isActive: () => Toggling.isOn(component),
      isEnabled: () => !Disabling.isDisabled(component),
      setEnabled: (state2) => Disabling.set(component, !state2)
    });
    const structure = renderItemStructure({
      iconContent: spec.icon,
      textContent: spec.text,
      htmlContent: Optional.none(),
      ariaLabel: spec.text,
      checkMark: Optional.some(renderCheckmark(providersBackstage.icons)),
      caret: Optional.none(),
      shortcutContent: spec.shortcut,
      presets: "normal",
      meta: spec.meta
    }, providersBackstage, renderIcons);
    return deepMerge(renderCommonItem({
      data: buildData(spec),
      enabled: spec.enabled,
      getApi: getApi2,
      onAction: spec.onAction,
      onSetup: spec.onSetup,
      triggersSubmenu: false,
      itemBehaviours: []
    }, structure, itemResponse, providersBackstage), {
      toggling: {
        toggleClass: tickedClass,
        toggleOnExecute: false,
        selected: spec.active
      }
    });
  };
  const autocomplete = renderAutocompleteItem;
  const separator$3 = renderSeparatorItem;
  const normal = renderNormalItem;
  const nested = renderNestedItem;
  const toggle$1 = renderToggleMenuItem;
  const fancy = renderFancyMenuItem;
  const card = renderCardMenuItem;
  const getCoupled = (component, coupleConfig, coupleState, name3) => coupleState.getOrCreate(component, coupleConfig, name3);
  const getExistingCoupled = (component, coupleConfig, coupleState, name3) => coupleState.getExisting(component, coupleConfig, name3);
  var CouplingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getCoupled,
    getExistingCoupled
  });
  var CouplingSchema = [requiredOf("others", setOf(Result.value, anyValue()))];
  const init$a = () => {
    const coupled = {};
    const lookupCoupled = (coupleConfig, coupledName) => {
      const available = keys(coupleConfig.others);
      if (available.length === 0) {
        throw new Error("Cannot find any known coupled components");
      } else {
        return get$g(coupled, coupledName);
      }
    };
    const getOrCreate = (component, coupleConfig, name3) => {
      return lookupCoupled(coupleConfig, name3).getOrThunk(() => {
        const builder2 = get$g(coupleConfig.others, name3).getOrDie("No information found for coupled component: " + name3);
        const spec = builder2(component);
        const built = component.getSystem().build(spec);
        coupled[name3] = built;
        return built;
      });
    };
    const getExisting = (component, coupleConfig, name3) => {
      return lookupCoupled(coupleConfig, name3).orThunk(() => {
        get$g(coupleConfig.others, name3).getOrDie("No information found for coupled component: " + name3);
        return Optional.none();
      });
    };
    const readState = constant$1({});
    return nu$8({
      readState,
      getExisting,
      getOrCreate
    });
  };
  var CouplingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$a
  });
  const Coupling = create$42({
    fields: CouplingSchema,
    name: "coupling",
    apis: CouplingApis,
    state: CouplingState
  });
  const nu$3 = (baseFn) => {
    let data2 = Optional.none();
    let callbacks = [];
    const map3 = (f2) => nu$3((nCallback) => {
      get2((data3) => {
        nCallback(f2(data3));
      });
    });
    const get2 = (nCallback) => {
      if (isReady()) {
        call(nCallback);
      } else {
        callbacks.push(nCallback);
      }
    };
    const set2 = (x) => {
      if (!isReady()) {
        data2 = Optional.some(x);
        run3(callbacks);
        callbacks = [];
      }
    };
    const isReady = () => data2.isSome();
    const run3 = (cbs) => {
      each$1(cbs, call);
    };
    const call = (cb) => {
      data2.each((x) => {
        setTimeout(() => {
          cb(x);
        }, 0);
      });
    };
    baseFn(set2);
    return {
      get: get2,
      map: map3,
      isReady
    };
  };
  const pure$1 = (a) => nu$3((callback) => {
    callback(a);
  });
  const LazyValue = {
    nu: nu$3,
    pure: pure$1
  };
  const errorReporter = (err) => {
    setTimeout(() => {
      throw err;
    }, 0);
  };
  const make$5 = (run3) => {
    const get2 = (callback) => {
      run3().then(callback, errorReporter);
    };
    const map3 = (fab) => {
      return make$5(() => run3().then(fab));
    };
    const bind3 = (aFutureB) => {
      return make$5(() => run3().then((v) => aFutureB(v).toPromise()));
    };
    const anonBind = (futureB) => {
      return make$5(() => run3().then(() => futureB.toPromise()));
    };
    const toLazy = () => {
      return LazyValue.nu(get2);
    };
    const toCached = () => {
      let cache = null;
      return make$5(() => {
        if (cache === null) {
          cache = run3();
        }
        return cache;
      });
    };
    const toPromise = run3;
    return {
      map: map3,
      bind: bind3,
      anonBind,
      toLazy,
      toCached,
      toPromise,
      get: get2
    };
  };
  const nu$2 = (baseFn) => {
    return make$5(() => new Promise(baseFn));
  };
  const pure = (a) => {
    return make$5(() => Promise.resolve(a));
  };
  const Future = {
    nu: nu$2,
    pure
  };
  const suffix = constant$1("sink");
  const partType$1 = constant$1(optional({
    name: suffix(),
    overrides: constant$1({
      dom: { tag: "div" },
      behaviours: derive$1([Positioning.config({ useFixed: always })]),
      events: derive$2([
        cutter(keydown()),
        cutter(mousedown()),
        cutter(click())
      ])
    })
  }));
  const getAnchor = (detail, component) => {
    const hotspot = detail.getHotspot(component).getOr(component);
    const type2 = "hotspot";
    const overrides = detail.getAnchorOverrides();
    return detail.layouts.fold(() => ({
      type: type2,
      hotspot,
      overrides
    }), (layouts2) => ({
      type: type2,
      hotspot,
      overrides,
      layouts: layouts2
    }));
  };
  const fetch2 = (detail, mapFetch, component) => {
    const fetcher = detail.fetch;
    return fetcher(component).map(mapFetch);
  };
  const openF = (detail, mapFetch, anchor2, component, sandbox, externals, highlightOnOpen) => {
    const futureData = fetch2(detail, mapFetch, component);
    const getLazySink = getSink(component, detail);
    return futureData.map((tdata) => tdata.bind((data2) => Optional.from(tieredMenu.sketch({
      ...externals.menu(),
      uid: generate$5(""),
      data: data2,
      highlightOnOpen,
      onOpenMenu: (tmenu, menu2) => {
        const sink = getLazySink().getOrDie();
        Positioning.position(sink, menu2, { anchor: anchor2 });
        Sandboxing.decloak(sandbox);
      },
      onOpenSubmenu: (tmenu, item3, submenu) => {
        const sink = getLazySink().getOrDie();
        Positioning.position(sink, submenu, {
          anchor: {
            type: "submenu",
            item: item3
          }
        });
        Sandboxing.decloak(sandbox);
      },
      onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
        const sink = getLazySink().getOrDie();
        Positioning.position(sink, primaryMenu, { anchor: anchor2 });
        each$1(submenuTriggers, (st) => {
          Positioning.position(sink, st.triggeredMenu, {
            anchor: {
              type: "submenu",
              item: st.triggeringItem
            }
          });
        });
      },
      onEscape: () => {
        Focusing.focus(component);
        Sandboxing.close(sandbox);
        return Optional.some(true);
      }
    }))));
  };
  const open = (detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen) => {
    const anchor2 = getAnchor(detail, hotspot);
    const processed = openF(detail, mapFetch, anchor2, hotspot, sandbox, externals, highlightOnOpen);
    return processed.map((tdata) => {
      tdata.fold(() => {
        if (Sandboxing.isOpen(sandbox)) {
          Sandboxing.close(sandbox);
        }
      }, (data2) => {
        Sandboxing.cloak(sandbox);
        Sandboxing.open(sandbox, data2);
        onOpenSync(sandbox);
      });
      return sandbox;
    });
  };
  const close = (detail, mapFetch, component, sandbox, _externals, _onOpenSync, _highlightOnOpen) => {
    Sandboxing.close(sandbox);
    return Future.pure(sandbox);
  };
  const togglePopup = (detail, mapFetch, hotspot, externals, onOpenSync, highlightOnOpen) => {
    const sandbox = Coupling.getCoupled(hotspot, "sandbox");
    const showing = Sandboxing.isOpen(sandbox);
    const action = showing ? close : open;
    return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
  };
  const matchWidth = (hotspot, container, useMinWidth) => {
    const menu2 = Composing.getCurrent(container).getOr(container);
    const buttonWidth = get$c(hotspot.element);
    if (useMinWidth) {
      set$8(menu2.element, "min-width", buttonWidth + "px");
    } else {
      set$7(menu2.element, buttonWidth);
    }
  };
  const getSink = (anyInSystem, sinkDetail) => anyInSystem.getSystem().getByUid(sinkDetail.uid + "-" + suffix()).map((internalSink) => () => Result.value(internalSink)).getOrThunk(() => sinkDetail.lazySink.fold(() => () => Result.error(new Error("No internal sink is specified, nor could an external sink be found")), (lazySinkFn) => () => lazySinkFn(anyInSystem)));
  const doRepositionMenus = (sandbox) => {
    Sandboxing.getState(sandbox).each((tmenu) => {
      tieredMenu.repositionMenus(tmenu);
    });
  };
  const makeSandbox$1 = (detail, hotspot, extras) => {
    const ariaControls = manager();
    const onOpen = (component, menu2) => {
      const anchor2 = getAnchor(detail, hotspot);
      ariaControls.link(hotspot.element);
      if (detail.matchWidth) {
        matchWidth(anchor2.hotspot, menu2, detail.useMinWidth);
      }
      detail.onOpen(anchor2, component, menu2);
      if (extras !== void 0 && extras.onOpen !== void 0) {
        extras.onOpen(component, menu2);
      }
    };
    const onClose = (component, menu2) => {
      ariaControls.unlink(hotspot.element);
      if (extras !== void 0 && extras.onClose !== void 0) {
        extras.onClose(component, menu2);
      }
    };
    const lazySink = getSink(hotspot, detail);
    return {
      dom: {
        tag: "div",
        classes: detail.sandboxClasses,
        attributes: {
          id: ariaControls.id,
          role: "listbox"
        }
      },
      behaviours: SketchBehaviours.augment(detail.sandboxBehaviours, [
        Representing.config({
          store: {
            mode: "memory",
            initialValue: hotspot
          }
        }),
        Sandboxing.config({
          onOpen,
          onClose,
          isPartOf: (container, data2, queryElem) => {
            return isPartOf$1(data2, queryElem) || isPartOf$1(hotspot, queryElem);
          },
          getAttachPoint: () => {
            return lazySink().getOrDie();
          }
        }),
        Composing.config({
          find: (sandbox) => {
            return Sandboxing.getState(sandbox).bind((menu2) => Composing.getCurrent(menu2));
          }
        }),
        Receiving.config({
          channels: {
            ...receivingChannel$1({ isExtraPart: never }),
            ...receivingChannel({ doReposition: doRepositionMenus })
          }
        })
      ])
    };
  };
  const repositionMenus = (comp) => {
    const sandbox = Coupling.getCoupled(comp, "sandbox");
    doRepositionMenus(sandbox);
  };
  const sandboxFields = () => [
    defaulted("sandboxClasses", []),
    SketchBehaviours.field("sandboxBehaviours", [
      Composing,
      Receiving,
      Sandboxing,
      Representing
    ])
  ];
  const schema$k = constant$1([
    required$1("dom"),
    required$1("fetch"),
    onHandler("onOpen"),
    onKeyboardHandler("onExecute"),
    defaulted("getHotspot", Optional.some),
    defaulted("getAnchorOverrides", constant$1({})),
    schema$y(),
    field("dropdownBehaviours", [
      Toggling,
      Coupling,
      Keying,
      Focusing
    ]),
    required$1("toggleClass"),
    defaulted("eventOrder", {}),
    option$3("lazySink"),
    defaulted("matchWidth", false),
    defaulted("useMinWidth", false),
    option$3("role")
  ].concat(sandboxFields()));
  const parts$e = constant$1([
    external({
      schema: [
        tieredMenuMarkers(),
        defaulted("fakeFocus", false)
      ],
      name: "menu",
      defaults: (detail) => {
        return { onExecute: detail.onExecute };
      }
    }),
    partType$1()
  ]);
  const factory$k = (detail, components2, _spec, externals) => {
    const lookupAttr = (attr2) => get$g(detail.dom, "attributes").bind((attrs) => get$g(attrs, attr2));
    const switchToMenu = (sandbox) => {
      Sandboxing.getState(sandbox).each((tmenu) => {
        tieredMenu.highlightPrimary(tmenu);
      });
    };
    const togglePopup$1 = (dropdownComp, onOpenSync, highlightOnOpen) => {
      return togglePopup(detail, identity, dropdownComp, externals, onOpenSync, highlightOnOpen);
    };
    const action = (component) => {
      const onOpenSync = switchToMenu;
      togglePopup$1(component, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
    };
    const apis2 = {
      expand: (comp) => {
        if (!Toggling.isOn(comp)) {
          togglePopup$1(comp, noop2, HighlightOnOpen.HighlightNone).get(noop2);
        }
      },
      open: (comp) => {
        if (!Toggling.isOn(comp)) {
          togglePopup$1(comp, noop2, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
        }
      },
      refetch: (comp) => {
        const optSandbox = Coupling.getExistingCoupled(comp, "sandbox");
        return optSandbox.fold(() => {
          return togglePopup$1(comp, noop2, HighlightOnOpen.HighlightMenuAndItem).map(noop2);
        }, (sandboxComp) => {
          return open(detail, identity, comp, sandboxComp, externals, noop2, HighlightOnOpen.HighlightMenuAndItem).map(noop2);
        });
      },
      isOpen: Toggling.isOn,
      close: (comp) => {
        if (Toggling.isOn(comp)) {
          togglePopup$1(comp, noop2, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
        }
      },
      repositionMenus: (comp) => {
        if (Toggling.isOn(comp)) {
          repositionMenus(comp);
        }
      }
    };
    const triggerExecute = (comp, _se) => {
      emitExecute(comp);
      return Optional.some(true);
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: augment(detail.dropdownBehaviours, [
        Toggling.config({
          toggleClass: detail.toggleClass,
          aria: { mode: "expanded" }
        }),
        Coupling.config({
          others: {
            sandbox: (hotspot) => {
              return makeSandbox$1(detail, hotspot, {
                onOpen: () => Toggling.on(hotspot),
                onClose: () => Toggling.off(hotspot)
              });
            }
          }
        }),
        Keying.config({
          mode: "special",
          onSpace: triggerExecute,
          onEnter: triggerExecute,
          onDown: (comp, _se) => {
            if (Dropdown2.isOpen(comp)) {
              const sandbox = Coupling.getCoupled(comp, "sandbox");
              switchToMenu(sandbox);
            } else {
              Dropdown2.open(comp);
            }
            return Optional.some(true);
          },
          onEscape: (comp, _se) => {
            if (Dropdown2.isOpen(comp)) {
              Dropdown2.close(comp);
              return Optional.some(true);
            } else {
              return Optional.none();
            }
          }
        }),
        Focusing.config({})
      ]),
      events: events$a(Optional.some(action)),
      eventOrder: {
        ...detail.eventOrder,
        [execute$5()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      apis: apis2,
      domModification: {
        attributes: {
          "aria-haspopup": "true",
          ...detail.role.fold(() => ({}), (role) => ({ role })),
          ...detail.dom.tag === "button" ? { type: lookupAttr("type").getOr("button") } : {}
        }
      }
    };
  };
  const Dropdown2 = composite({
    name: "Dropdown",
    configFields: schema$k(),
    partFields: parts$e(),
    factory: factory$k,
    apis: {
      open: (apis2, comp) => apis2.open(comp),
      refetch: (apis2, comp) => apis2.refetch(comp),
      expand: (apis2, comp) => apis2.expand(comp),
      close: (apis2, comp) => apis2.close(comp),
      isOpen: (apis2, comp) => apis2.isOpen(comp),
      repositionMenus: (apis2, comp) => apis2.repositionMenus(comp)
    }
  });
  const identifyMenuLayout = (searchMode) => {
    switch (searchMode.searchMode) {
      case "no-search": {
        return { menuType: "normal" };
      }
      default: {
        return {
          menuType: "searchable",
          searchMode
        };
      }
    }
  };
  const handleRefetchTrigger = (originalSandboxComp) => {
    const dropdown = Representing.getValue(originalSandboxComp);
    const optSearcherState = findWithinSandbox(originalSandboxComp).map(saveState);
    Dropdown2.refetch(dropdown).get(() => {
      const newSandboxComp = Coupling.getCoupled(dropdown, "sandbox");
      optSearcherState.each((searcherState) => findWithinSandbox(newSandboxComp).each((inputComp) => restoreState(inputComp, searcherState)));
    });
  };
  const handleRedirectToMenuItem = (sandboxComp, se) => {
    getActiveMenuItemFrom(sandboxComp).each((activeItem) => {
      retargetAndDispatchWith(sandboxComp, activeItem.element, se.event.eventType, se.event.interactionEvent);
    });
  };
  const getActiveMenuItemFrom = (sandboxComp) => {
    return Sandboxing.getState(sandboxComp).bind(Highlighting.getHighlighted).bind(Highlighting.getHighlighted);
  };
  const getSearchResults = (activeMenuComp) => {
    return has(activeMenuComp.element, searchResultsClass) ? Optional.some(activeMenuComp.element) : descendant(activeMenuComp.element, "." + searchResultsClass);
  };
  const updateAriaOnHighlight = (tmenuComp, menuComp, itemComp) => {
    findWithinMenu(tmenuComp).each((inputComp) => {
      setActiveDescendant(inputComp, itemComp);
      const optActiveResults = getSearchResults(menuComp);
      optActiveResults.each((resultsElem) => {
        getOpt(resultsElem, "id").each((controlledId) => set$9(inputComp.element, "aria-controls", controlledId));
      });
    });
    set$9(itemComp.element, "aria-selected", "true");
  };
  const updateAriaOnDehighlight = (tmenuComp, menuComp, itemComp) => {
    set$9(itemComp.element, "aria-selected", "false");
  };
  const focusSearchField = (tmenuComp) => {
    findWithinMenu(tmenuComp).each((searcherComp) => Focusing.focus(searcherComp));
  };
  const getSearchPattern = (dropdownComp) => {
    const optSandboxComp = Coupling.getExistingCoupled(dropdownComp, "sandbox");
    return optSandboxComp.bind(findWithinSandbox).map(saveState).map((state2) => state2.fetchPattern).getOr("");
  };
  var FocusMode;
  (function(FocusMode2) {
    FocusMode2[FocusMode2["ContentFocus"] = 0] = "ContentFocus";
    FocusMode2[FocusMode2["UiFocus"] = 1] = "UiFocus";
  })(FocusMode || (FocusMode = {}));
  const createMenuItemFromBridge = (item3, itemResponse, backstage, menuHasIcons2, isHorizontalMenu) => {
    const providersBackstage = backstage.shared.providers;
    const parseForHorizontalMenu = (menuitem) => !isHorizontalMenu ? menuitem : {
      ...menuitem,
      shortcut: Optional.none(),
      icon: menuitem.text.isSome() ? Optional.none() : menuitem.icon
    };
    switch (item3.type) {
      case "menuitem":
        return createMenuItem(item3).fold(handleError, (d) => Optional.some(normal(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons2)));
      case "nestedmenuitem":
        return createNestedMenuItem(item3).fold(handleError, (d) => Optional.some(nested(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons2, isHorizontalMenu)));
      case "togglemenuitem":
        return createToggleMenuItem(item3).fold(handleError, (d) => Optional.some(toggle$1(parseForHorizontalMenu(d), itemResponse, providersBackstage, menuHasIcons2)));
      case "separator":
        return createSeparatorMenuItem(item3).fold(handleError, (d) => Optional.some(separator$3(d)));
      case "fancymenuitem":
        return createFancyMenuItem(item3).fold(handleError, (d) => fancy(d, backstage));
      default: {
        console.error("Unknown item in general menu", item3);
        return Optional.none();
      }
    }
  };
  const createAutocompleteItems = (items, matchText, onItemValueHandler, columns, itemResponse, sharedBackstage, highlightOn) => {
    const renderText2 = columns === 1;
    const renderIcons = !renderText2 || menuHasIcons(items);
    return cat(map$2(items, (item3) => {
      switch (item3.type) {
        case "separator":
          return createSeparatorItem(item3).fold(handleError, (d) => Optional.some(separator$3(d)));
        case "cardmenuitem":
          return createCardMenuItem(item3).fold(handleError, (d) => Optional.some(card({
            ...d,
            onAction: (api2) => {
              d.onAction(api2);
              onItemValueHandler(d.value, d.meta);
            }
          }, itemResponse, sharedBackstage, {
            itemBehaviours: tooltipBehaviour(d.meta, sharedBackstage),
            cardText: {
              matchText,
              highlightOn
            }
          })));
        case "autocompleteitem":
        default:
          return createAutocompleterItem(item3).fold(handleError, (d) => Optional.some(autocomplete(d, matchText, renderText2, "normal", onItemValueHandler, itemResponse, sharedBackstage, renderIcons)));
      }
    }));
  };
  const createPartialMenu = (value2, items, itemResponse, backstage, isHorizontalMenu, searchMode) => {
    const hasIcons = menuHasIcons(items);
    const alloyItems = cat(map$2(items, (item3) => {
      const itemHasIcon = (i) => isHorizontalMenu ? !has$2(i, "text") : hasIcons;
      const createItem2 = (i) => createMenuItemFromBridge(i, itemResponse, backstage, itemHasIcon(i), isHorizontalMenu);
      if (item3.type === "nestedmenuitem" && item3.getSubmenuItems().length <= 0) {
        return createItem2({
          ...item3,
          enabled: false
        });
      } else {
        return createItem2(item3);
      }
    }));
    const menuLayout = identifyMenuLayout(searchMode);
    const createPartial = isHorizontalMenu ? createHorizontalPartialMenuWithAlloyItems : createPartialMenuWithAlloyItems;
    return createPartial(value2, hasIcons, alloyItems, 1, menuLayout);
  };
  const createTieredDataFrom = (partialMenu) => tieredMenu.singleData(partialMenu.value, partialMenu);
  const createInlineMenuFrom = (partialMenu, columns, focusMode, presets) => {
    const movement = deriveMenuMovement(columns, presets);
    const menuMarkers = markers(presets);
    return {
      data: createTieredDataFrom({
        ...partialMenu,
        movement,
        menuBehaviours: SimpleBehaviours.unnamedEvents(columns !== "auto" ? [] : [runOnAttached((comp, _se) => {
          detectSize(comp, 4, menuMarkers.item).each(({ numColumns, numRows }) => {
            Keying.setGridSize(comp, numRows, numColumns);
          });
        })])
      }),
      menu: {
        markers: markers(presets),
        fakeFocus: focusMode === FocusMode.ContentFocus
      }
    };
  };
  const getAutocompleterRange = (dom2, initRange) => {
    return detect$1(SugarElement.fromDom(initRange.startContainer)).map((elm) => {
      const range2 = dom2.createRng();
      range2.selectNode(elm.dom);
      return range2;
    });
  };
  const register$b = (editor, sharedBackstage) => {
    const processingAction = Cell(false);
    const activeState = Cell(false);
    const autocompleter = build$1(InlineView.sketch({
      dom: {
        tag: "div",
        classes: ["tox-autocompleter"]
      },
      components: [],
      fireDismissalEventInstead: {},
      inlineBehaviours: derive$1([config("dismissAutocompleter", [run$1(dismissRequested(), () => cancelIfNecessary())])]),
      lazySink: sharedBackstage.getSink
    }));
    const isMenuOpen = () => InlineView.isOpen(autocompleter);
    const isActive = activeState.get;
    const hideIfNecessary = () => {
      if (isMenuOpen()) {
        InlineView.hide(autocompleter);
      }
    };
    const getMenu = () => InlineView.getContent(autocompleter).bind((tmenu) => {
      return get$h(tmenu.components(), 0);
    });
    const cancelIfNecessary = () => editor.execCommand("mceAutocompleterClose");
    const getCombinedItems = (matches) => {
      const columns = findMap(matches, (m) => Optional.from(m.columns)).getOr(1);
      return bind$3(matches, (match) => {
        const choices = match.items;
        return createAutocompleteItems(choices, match.matchText, (itemValue, itemMeta) => {
          const nr = editor.selection.getRng();
          getAutocompleterRange(editor.dom, nr).each((range2) => {
            const autocompleterApi = {
              hide: () => cancelIfNecessary(),
              reload: (fetchOptions) => {
                hideIfNecessary();
                editor.execCommand("mceAutocompleterReload", false, { fetchOptions });
              }
            };
            processingAction.set(true);
            match.onAction(autocompleterApi, range2, itemValue, itemMeta);
            processingAction.set(false);
          });
        }, columns, ItemResponse$1.BUBBLE_TO_SANDBOX, sharedBackstage, match.highlightOn);
      });
    };
    const display = (lookupData, items) => {
      findIn(SugarElement.fromDom(editor.getBody())).each((element2) => {
        const columns = findMap(lookupData, (ld) => Optional.from(ld.columns)).getOr(1);
        InlineView.showMenuAt(autocompleter, {
          anchor: {
            type: "node",
            root: SugarElement.fromDom(editor.getBody()),
            node: Optional.from(element2)
          }
        }, createInlineMenuFrom(createPartialMenuWithAlloyItems("autocompleter-value", true, items, columns, { menuType: "normal" }), columns, FocusMode.ContentFocus, "normal"));
      });
      getMenu().each(Highlighting.highlightFirst);
    };
    const updateDisplay = (lookupData) => {
      const combinedItems = getCombinedItems(lookupData);
      if (combinedItems.length > 0) {
        display(lookupData, combinedItems);
      } else {
        hideIfNecessary();
      }
    };
    editor.on("AutocompleterStart", ({ lookupData }) => {
      activeState.set(true);
      processingAction.set(false);
      updateDisplay(lookupData);
    });
    editor.on("AutocompleterUpdate", ({ lookupData }) => updateDisplay(lookupData));
    editor.on("AutocompleterEnd", () => {
      hideIfNecessary();
      activeState.set(false);
      processingAction.set(false);
    });
    const autocompleterUiApi = {
      cancelIfNecessary,
      isMenuOpen,
      isActive,
      isProcessingAction: processingAction.get,
      getMenu
    };
    AutocompleterEditorEvents.setup(autocompleterUiApi, editor);
  };
  const Autocompleter = { register: register$b };
  const nonScrollingOverflows = [
    "visible",
    "hidden"
  ];
  const isScroller = (elem) => {
    if (isHTMLElement2(elem)) {
      const overflow2 = get$e(elem, "overflow");
      return trim$12(overflow2).length > 0 && !contains$2(nonScrollingOverflows, overflow2);
    } else {
      return false;
    }
  };
  const detect = (poupSinkElem) => {
    const scrollers = ancestors(poupSinkElem, isScroller);
    return head(scrollers).map((element2) => ({
      element: element2,
      others: scrollers.slice(1)
    }));
  };
  const detectWhenSplitUiMode = (editor, popupSinkElem) => isSplitUiMode(editor) ? detect(popupSinkElem) : Optional.none();
  const getBoundsFrom = (sc) => {
    const scrollableBoxes = [
      ...map$2(sc.others, box$1),
      win()
    ];
    return constrainByMany(box$1(sc.element), scrollableBoxes);
  };
  const closest = (scope, selector, isRoot) => closest$1(scope, selector, isRoot).isSome();
  const DelayedFunction = (fun, delay) => {
    let ref = null;
    const schedule = (...args) => {
      ref = setTimeout(() => {
        fun.apply(null, args);
        ref = null;
      }, delay);
    };
    const cancel = () => {
      if (ref !== null) {
        clearTimeout(ref);
        ref = null;
      }
    };
    return {
      cancel,
      schedule
    };
  };
  const SIGNIFICANT_MOVE = 5;
  const LONGPRESS_DELAY = 400;
  const getTouch = (event) => {
    const raw = event.raw;
    if (raw.touches === void 0 || raw.touches.length !== 1) {
      return Optional.none();
    }
    return Optional.some(raw.touches[0]);
  };
  const isFarEnough = (touch2, data2) => {
    const distX = Math.abs(touch2.clientX - data2.x);
    const distY = Math.abs(touch2.clientY - data2.y);
    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
  };
  const monitor = (settings) => {
    const startData = value$2();
    const longpressFired = Cell(false);
    const longpress$1 = DelayedFunction((event) => {
      settings.triggerEvent(longpress(), event);
      longpressFired.set(true);
    }, LONGPRESS_DELAY);
    const handleTouchstart = (event) => {
      getTouch(event).each((touch2) => {
        longpress$1.cancel();
        const data2 = {
          x: touch2.clientX,
          y: touch2.clientY,
          target: event.target
        };
        longpress$1.schedule(event);
        longpressFired.set(false);
        startData.set(data2);
      });
      return Optional.none();
    };
    const handleTouchmove = (event) => {
      longpress$1.cancel();
      getTouch(event).each((touch2) => {
        startData.on((data2) => {
          if (isFarEnough(touch2, data2)) {
            startData.clear();
          }
        });
      });
      return Optional.none();
    };
    const handleTouchend = (event) => {
      longpress$1.cancel();
      const isSame = (data2) => eq(data2.target, event.target);
      return startData.get().filter(isSame).map((_data) => {
        if (longpressFired.get()) {
          event.prevent();
          return false;
        } else {
          return settings.triggerEvent(tap(), event);
        }
      });
    };
    const handlers2 = wrapAll([
      {
        key: touchstart(),
        value: handleTouchstart
      },
      {
        key: touchmove(),
        value: handleTouchmove
      },
      {
        key: touchend(),
        value: handleTouchend
      }
    ]);
    const fireIfReady = (event, type2) => get$g(handlers2, type2).bind((handler) => handler(event));
    return { fireIfReady };
  };
  const isDangerous = (event) => {
    const keyEv = event.raw;
    return keyEv.which === BACKSPACE[0] && !contains$2([
      "input",
      "textarea"
    ], name$3(event.target)) && !closest(event.target, '[contenteditable="true"]');
  };
  const setup$d = (container, rawSettings) => {
    const settings = {
      stopBackspace: true,
      ...rawSettings
    };
    const pointerEvents2 = [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "gesturestart",
      "mousedown",
      "mouseup",
      "mouseover",
      "mousemove",
      "mouseout",
      "click"
    ];
    const tapEvent = monitor(settings);
    const simpleEvents = map$2(pointerEvents2.concat([
      "selectstart",
      "input",
      "contextmenu",
      "change",
      "transitionend",
      "transitioncancel",
      "drag",
      "dragstart",
      "dragend",
      "dragenter",
      "dragleave",
      "dragover",
      "drop",
      "keyup"
    ]), (type2) => bind2(container, type2, (event) => {
      tapEvent.fireIfReady(event, type2).each((tapStopped) => {
        if (tapStopped) {
          event.kill();
        }
      });
      const stopped = settings.triggerEvent(type2, event);
      if (stopped) {
        event.kill();
      }
    }));
    const pasteTimeout = value$2();
    const onPaste = bind2(container, "paste", (event) => {
      tapEvent.fireIfReady(event, "paste").each((tapStopped) => {
        if (tapStopped) {
          event.kill();
        }
      });
      const stopped = settings.triggerEvent("paste", event);
      if (stopped) {
        event.kill();
      }
      pasteTimeout.set(setTimeout(() => {
        settings.triggerEvent(postPaste(), event);
      }, 0));
    });
    const onKeydown = bind2(container, "keydown", (event) => {
      const stopped = settings.triggerEvent("keydown", event);
      if (stopped) {
        event.kill();
      } else if (settings.stopBackspace && isDangerous(event)) {
        event.prevent();
      }
    });
    const onFocusIn = bind2(container, "focusin", (event) => {
      const stopped = settings.triggerEvent("focusin", event);
      if (stopped) {
        event.kill();
      }
    });
    const focusoutTimeout = value$2();
    const onFocusOut = bind2(container, "focusout", (event) => {
      const stopped = settings.triggerEvent("focusout", event);
      if (stopped) {
        event.kill();
      }
      focusoutTimeout.set(setTimeout(() => {
        settings.triggerEvent(postBlur(), event);
      }, 0));
    });
    const unbind2 = () => {
      each$1(simpleEvents, (e) => {
        e.unbind();
      });
      onKeydown.unbind();
      onFocusIn.unbind();
      onFocusOut.unbind();
      onPaste.unbind();
      pasteTimeout.on(clearTimeout);
      focusoutTimeout.on(clearTimeout);
    };
    return { unbind: unbind2 };
  };
  const derive = (rawEvent, rawTarget) => {
    const source = get$g(rawEvent, "target").getOr(rawTarget);
    return Cell(source);
  };
  const fromSource = (event, source) => {
    const stopper2 = Cell(false);
    const cutter2 = Cell(false);
    const stop2 = () => {
      stopper2.set(true);
    };
    const cut = () => {
      cutter2.set(true);
    };
    return {
      stop: stop2,
      cut,
      isStopped: stopper2.get,
      isCut: cutter2.get,
      event,
      setSource: source.set,
      getSource: source.get
    };
  };
  const fromExternal = (event) => {
    const stopper2 = Cell(false);
    const stop2 = () => {
      stopper2.set(true);
    };
    return {
      stop: stop2,
      cut: noop2,
      isStopped: stopper2.get,
      isCut: never,
      event,
      setSource: die("Cannot set source of a broadcasted event"),
      getSource: die("Cannot get source of a broadcasted event")
    };
  };
  const adt$1 = Adt.generate([
    { stopped: [] },
    { resume: ["element"] },
    { complete: [] }
  ]);
  const doTriggerHandler = (lookup2, eventType, rawEvent, target, source, logger) => {
    const handler = lookup2(eventType, target);
    const simulatedEvent = fromSource(rawEvent, source);
    return handler.fold(() => {
      logger.logEventNoHandlers(eventType, target);
      return adt$1.complete();
    }, (handlerInfo) => {
      const descHandler = handlerInfo.descHandler;
      const eventHandler2 = getCurried(descHandler);
      eventHandler2(simulatedEvent);
      if (simulatedEvent.isStopped()) {
        logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
        return adt$1.stopped();
      } else if (simulatedEvent.isCut()) {
        logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
        return adt$1.complete();
      } else {
        return parent(handlerInfo.element).fold(() => {
          logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
          return adt$1.complete();
        }, (parent2) => {
          logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
          return adt$1.resume(parent2);
        });
      }
    });
  };
  const doTriggerOnUntilStopped = (lookup2, eventType, rawEvent, rawTarget, source, logger) => doTriggerHandler(lookup2, eventType, rawEvent, rawTarget, source, logger).fold(always, (parent2) => doTriggerOnUntilStopped(lookup2, eventType, rawEvent, parent2, source, logger), never);
  const triggerHandler = (lookup2, eventType, rawEvent, target, logger) => {
    const source = derive(rawEvent, target);
    return doTriggerHandler(lookup2, eventType, rawEvent, target, source, logger);
  };
  const broadcast = (listeners2, rawEvent, _logger) => {
    const simulatedEvent = fromExternal(rawEvent);
    each$1(listeners2, (listener) => {
      const descHandler = listener.descHandler;
      const handler = getCurried(descHandler);
      handler(simulatedEvent);
    });
    return simulatedEvent.isStopped();
  };
  const triggerUntilStopped = (lookup2, eventType, rawEvent, logger) => triggerOnUntilStopped(lookup2, eventType, rawEvent, rawEvent.target, logger);
  const triggerOnUntilStopped = (lookup2, eventType, rawEvent, rawTarget, logger) => {
    const source = derive(rawEvent, rawTarget);
    return doTriggerOnUntilStopped(lookup2, eventType, rawEvent, rawTarget, source, logger);
  };
  const eventHandler = (element2, descHandler) => ({
    element: element2,
    descHandler
  });
  const broadcastHandler = (id, handler) => ({
    id,
    descHandler: handler
  });
  const EventRegistry = () => {
    const registry = {};
    const registerId = (extraArgs, id, events2) => {
      each(events2, (v, k) => {
        const handlers2 = registry[k] !== void 0 ? registry[k] : {};
        handlers2[id] = curryArgs(v, extraArgs);
        registry[k] = handlers2;
      });
    };
    const findHandler2 = (handlers2, elem) => read$1(elem).bind((id) => get$g(handlers2, id)).map((descHandler) => eventHandler(elem, descHandler));
    const filterByType = (type2) => get$g(registry, type2).map((handlers2) => mapToArray(handlers2, (f2, id) => broadcastHandler(id, f2))).getOr([]);
    const find3 = (isAboveRoot, type2, target) => get$g(registry, type2).bind((handlers2) => closest$4(target, (elem) => findHandler2(handlers2, elem), isAboveRoot));
    const unregisterId = (id) => {
      each(registry, (handlersById, _eventName) => {
        if (has$2(handlersById, id)) {
          delete handlersById[id];
        }
      });
    };
    return {
      registerId,
      unregisterId,
      filterByType,
      find: find3
    };
  };
  const Registry = () => {
    const events2 = EventRegistry();
    const components2 = {};
    const readOrTag = (component) => {
      const elem = component.element;
      return read$1(elem).getOrThunk(() => write2("uid-", component.element));
    };
    const failOnDuplicate = (component, tagId) => {
      const conflict = components2[tagId];
      if (conflict === component) {
        unregister(component);
      } else {
        throw new Error('The tagId "' + tagId + '" is already used by: ' + element(conflict.element) + "\nCannot use it for: " + element(component.element) + "\nThe conflicting element is" + (inBody(conflict.element) ? " " : " not ") + "already in the DOM");
      }
    };
    const register2 = (component) => {
      const tagId = readOrTag(component);
      if (hasNonNullableKey(components2, tagId)) {
        failOnDuplicate(component, tagId);
      }
      const extraArgs = [component];
      events2.registerId(extraArgs, tagId, component.events);
      components2[tagId] = component;
    };
    const unregister = (component) => {
      read$1(component.element).each((tagId) => {
        delete components2[tagId];
        events2.unregisterId(tagId);
      });
    };
    const filter3 = (type2) => events2.filterByType(type2);
    const find3 = (isAboveRoot, type2, target) => events2.find(isAboveRoot, type2, target);
    const getById = (id) => get$g(components2, id);
    return {
      find: find3,
      filter: filter3,
      register: register2,
      unregister,
      getById
    };
  };
  const factory$j = (detail) => {
    const { attributes, ...domWithoutAttributes } = detail.dom;
    return {
      uid: detail.uid,
      dom: {
        tag: "div",
        attributes: {
          role: "presentation",
          ...attributes
        },
        ...domWithoutAttributes
      },
      components: detail.components,
      behaviours: get$3(detail.containerBehaviours),
      events: detail.events,
      domModification: detail.domModification,
      eventOrder: detail.eventOrder
    };
  };
  const Container = single({
    name: "Container",
    factory: factory$j,
    configFields: [
      defaulted("components", []),
      field("containerBehaviours", []),
      defaulted("events", {}),
      defaulted("domModification", {}),
      defaulted("eventOrder", {})
    ]
  });
  const takeover = (root2) => {
    const isAboveRoot = (el) => parent(root2.element).fold(always, (parent2) => eq(el, parent2));
    const registry = Registry();
    const lookup2 = (eventName, target) => registry.find(isAboveRoot, eventName, target);
    const domEvents = setup$d(root2.element, {
      triggerEvent: (eventName, event) => {
        return monitorEvent(eventName, event.target, (logger) => triggerUntilStopped(lookup2, eventName, event, logger));
      }
    });
    const systemApi = {
      debugInfo: constant$1("real"),
      triggerEvent: (eventName, target, data2) => {
        monitorEvent(eventName, target, (logger) => triggerOnUntilStopped(lookup2, eventName, data2, target, logger));
      },
      triggerFocus: (target, originator) => {
        read$1(target).fold(() => {
          focus$3(target);
        }, (_alloyId) => {
          monitorEvent(focus$4(), target, (logger) => {
            triggerHandler(lookup2, focus$4(), {
              originator,
              kill: noop2,
              prevent: noop2,
              target
            }, target, logger);
            return false;
          });
        });
      },
      triggerEscape: (comp, simulatedEvent) => {
        systemApi.triggerEvent("keydown", comp.element, simulatedEvent.event);
      },
      getByUid: (uid) => {
        return getByUid(uid);
      },
      getByDom: (elem) => {
        return getByDom(elem);
      },
      build: build$1,
      buildOrPatch,
      addToGui: (c) => {
        add2(c);
      },
      removeFromGui: (c) => {
        remove2(c);
      },
      addToWorld: (c) => {
        addToWorld(c);
      },
      removeFromWorld: (c) => {
        removeFromWorld(c);
      },
      broadcast: (message) => {
        broadcast$1(message);
      },
      broadcastOn: (channels, message) => {
        broadcastOn(channels, message);
      },
      broadcastEvent: (eventName, event) => {
        broadcastEvent(eventName, event);
      },
      isConnected: always
    };
    const addToWorld = (component) => {
      component.connect(systemApi);
      if (!isText(component.element)) {
        registry.register(component);
        each$1(component.components(), addToWorld);
        systemApi.triggerEvent(systemInit(), component.element, { target: component.element });
      }
    };
    const removeFromWorld = (component) => {
      if (!isText(component.element)) {
        each$1(component.components(), removeFromWorld);
        registry.unregister(component);
      }
      component.disconnect();
    };
    const add2 = (component) => {
      attach(root2, component);
    };
    const remove2 = (component) => {
      detach(component);
    };
    const destroy2 = () => {
      domEvents.unbind();
      remove$5(root2.element);
    };
    const broadcastData = (data2) => {
      const receivers = registry.filter(receive());
      each$1(receivers, (receiver) => {
        const descHandler = receiver.descHandler;
        const handler = getCurried(descHandler);
        handler(data2);
      });
    };
    const broadcast$1 = (message) => {
      broadcastData({
        universal: true,
        data: message
      });
    };
    const broadcastOn = (channels, message) => {
      broadcastData({
        universal: false,
        channels,
        data: message
      });
    };
    const broadcastEvent = (eventName, event) => {
      const listeners2 = registry.filter(eventName);
      return broadcast(listeners2, event);
    };
    const getByUid = (uid) => registry.getById(uid).fold(() => Result.error(new Error('Could not find component with uid: "' + uid + '" in system.')), Result.value);
    const getByDom = (elem) => {
      const uid = read$1(elem).getOr("not found");
      return getByUid(uid);
    };
    addToWorld(root2);
    return {
      root: root2,
      element: root2.element,
      destroy: destroy2,
      add: add2,
      remove: remove2,
      getByUid,
      getByDom,
      addToWorld,
      removeFromWorld,
      broadcast: broadcast$1,
      broadcastOn,
      broadcastEvent
    };
  };
  const renderBar = (spec, backstage) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-bar",
        "tox-form__controls-h-stack"
      ]
    },
    components: map$2(spec.items, backstage.interpreter)
  });
  const schema$j = constant$1([
    defaulted("prefix", "form-field"),
    field("fieldBehaviours", [
      Composing,
      Representing
    ])
  ]);
  const parts$d = constant$1([
    optional({
      schema: [required$1("dom")],
      name: "label"
    }),
    optional({
      factory: {
        sketch: (spec) => {
          return {
            uid: spec.uid,
            dom: {
              tag: "span",
              styles: { display: "none" },
              attributes: { "aria-hidden": "true" },
              innerHtml: spec.text
            }
          };
        }
      },
      schema: [required$1("text")],
      name: "aria-descriptor"
    }),
    required({
      factory: {
        sketch: (spec) => {
          const excludeFactory = exclude(spec, ["factory"]);
          return spec.factory.sketch(excludeFactory);
        }
      },
      schema: [required$1("factory")],
      name: "field"
    })
  ]);
  const factory$i = (detail, components2, _spec, _externals) => {
    const behaviours2 = augment(detail.fieldBehaviours, [
      Composing.config({
        find: (container) => {
          return getPart(container, detail, "field");
        }
      }),
      Representing.config({
        store: {
          mode: "manual",
          getValue: (field2) => {
            return Composing.getCurrent(field2).bind(Representing.getValue);
          },
          setValue: (field2, value2) => {
            Composing.getCurrent(field2).each((current) => {
              Representing.setValue(current, value2);
            });
          }
        }
      })
    ]);
    const events2 = derive$2([runOnAttached((component, _simulatedEvent) => {
      const ps = getParts(component, detail, [
        "label",
        "field",
        "aria-descriptor"
      ]);
      ps.field().each((field2) => {
        const id = generate$6(detail.prefix);
        ps.label().each((label2) => {
          set$9(label2.element, "for", id);
          set$9(field2.element, "id", id);
        });
        ps["aria-descriptor"]().each((descriptor) => {
          const descriptorId = generate$6(detail.prefix);
          set$9(descriptor.element, "id", descriptorId);
          set$9(field2.element, "aria-describedby", descriptorId);
        });
      });
    })]);
    const apis2 = {
      getField: (container) => getPart(container, detail, "field"),
      getLabel: (container) => getPart(container, detail, "label")
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: behaviours2,
      events: events2,
      apis: apis2
    };
  };
  const FormField = composite({
    name: "FormField",
    configFields: schema$j(),
    partFields: parts$d(),
    factory: factory$i,
    apis: {
      getField: (apis2, comp) => apis2.getField(comp),
      getLabel: (apis2, comp) => apis2.getLabel(comp)
    }
  });
  const exhibit$2 = (base2, tabConfig) => nu$7({
    attributes: wrapAll([{
      key: tabConfig.tabAttr,
      value: "true"
    }])
  });
  var ActiveTabstopping = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit: exhibit$2
  });
  var TabstopSchema = [defaulted("tabAttr", "data-alloy-tabstop")];
  const Tabstopping = create$42({
    fields: TabstopSchema,
    name: "tabstopping",
    active: ActiveTabstopping
  });
  var global$3 = tinymce.util.Tools.resolve("tinymce.html.Entities");
  const renderFormFieldWith = (pLabel, pField, extraClasses, extraBehaviours) => {
    const spec = renderFormFieldSpecWith(pLabel, pField, extraClasses, extraBehaviours);
    return FormField.sketch(spec);
  };
  const renderFormField = (pLabel, pField) => renderFormFieldWith(pLabel, pField, [], []);
  const renderFormFieldSpecWith = (pLabel, pField, extraClasses, extraBehaviours) => ({
    dom: renderFormFieldDomWith(extraClasses),
    components: pLabel.toArray().concat([pField]),
    fieldBehaviours: derive$1(extraBehaviours)
  });
  const renderFormFieldDom = () => renderFormFieldDomWith([]);
  const renderFormFieldDomWith = (extraClasses) => ({
    tag: "div",
    classes: ["tox-form__group"].concat(extraClasses)
  });
  const renderLabel$3 = (label2, providersBackstage) => FormField.parts.label({
    dom: {
      tag: "label",
      classes: ["tox-label"]
    },
    components: [text$2(providersBackstage.translate(label2))]
  });
  const formChangeEvent = generate$6("form-component-change");
  const formCloseEvent = generate$6("form-close");
  const formCancelEvent = generate$6("form-cancel");
  const formActionEvent = generate$6("form-action");
  const formSubmitEvent = generate$6("form-submit");
  const formBlockEvent = generate$6("form-block");
  const formUnblockEvent = generate$6("form-unblock");
  const formTabChangeEvent = generate$6("form-tabchange");
  const formResizeEvent = generate$6("form-resize");
  const renderCollection = (spec, providersBackstage, initialData) => {
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const runOnItem = (f2) => (comp, se) => {
      closest$1(se.event.target, "[data-collection-item-value]").each((target) => {
        f2(comp, se, target, get$f(target, "data-collection-item-value"));
      });
    };
    const setContents = (comp, items) => {
      const htmlLines = map$2(items, (item3) => {
        const itemText = global$8.translate(item3.text);
        const textContent = spec.columns === 1 ? `<div class="tox-collection__item-label">${itemText}</div>` : "";
        const iconContent = `<div class="tox-collection__item-icon">${item3.icon}</div>`;
        const mapItemName = {
          "_": " ",
          " - ": " ",
          "-": " "
        };
        const ariaLabel = itemText.replace(/\_| \- |\-/g, (match) => mapItemName[match]);
        const disabledClass = providersBackstage.isDisabled() ? " tox-collection__item--state-disabled" : "";
        return `<div class="tox-collection__item${disabledClass}" tabindex="-1" data-collection-item-value="${global$3.encodeAllRaw(item3.value)}" title="${ariaLabel}" aria-label="${ariaLabel}">${iconContent}${textContent}</div>`;
      });
      const chunks = spec.columns !== "auto" && spec.columns > 1 ? chunk$1(htmlLines, spec.columns) : [htmlLines];
      const html2 = map$2(chunks, (ch) => `<div class="tox-collection__group">${ch.join("")}</div>`);
      set$6(comp.element, html2.join(""));
    };
    const onClick = runOnItem((comp, se, tgt, itemValue) => {
      se.stop();
      if (!providersBackstage.isDisabled()) {
        emitWith(comp, formActionEvent, {
          name: spec.name,
          value: itemValue
        });
      }
    });
    const collectionEvents = [
      run$1(mouseover(), runOnItem((comp, se, tgt) => {
        focus$3(tgt);
      })),
      run$1(click(), onClick),
      run$1(tap(), onClick),
      run$1(focusin(), runOnItem((comp, se, tgt) => {
        descendant(comp.element, "." + activeClass).each((currentActive) => {
          remove$2(currentActive, activeClass);
        });
        add$2(tgt, activeClass);
      })),
      run$1(focusout(), runOnItem((comp) => {
        descendant(comp.element, "." + activeClass).each((currentActive) => {
          remove$2(currentActive, activeClass);
        });
      })),
      runOnExecute$1(runOnItem((comp, se, tgt, itemValue) => {
        emitWith(comp, formActionEvent, {
          name: spec.name,
          value: itemValue
        });
      }))
    ];
    const iterCollectionItems = (comp, applyAttributes) => map$2(descendants(comp.element, ".tox-collection__item"), applyAttributes);
    const pField = FormField.parts.field({
      dom: {
        tag: "div",
        classes: ["tox-collection"].concat(spec.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
      },
      components: [],
      factory: { sketch: identity },
      behaviours: derive$1([
        Disabling.config({
          disabled: providersBackstage.isDisabled,
          onDisabled: (comp) => {
            iterCollectionItems(comp, (childElm) => {
              add$2(childElm, "tox-collection__item--state-disabled");
              set$9(childElm, "aria-disabled", true);
            });
          },
          onEnabled: (comp) => {
            iterCollectionItems(comp, (childElm) => {
              remove$2(childElm, "tox-collection__item--state-disabled");
              remove$7(childElm, "aria-disabled");
            });
          }
        }),
        receivingConfig(),
        Replacing.config({}),
        Representing.config({
          store: {
            mode: "memory",
            initialValue: initialData.getOr([])
          },
          onSetValue: (comp, items) => {
            setContents(comp, items);
            if (spec.columns === "auto") {
              detectSize(comp, 5, "tox-collection__item").each(({ numRows, numColumns }) => {
                Keying.setGridSize(comp, numRows, numColumns);
              });
            }
            emit(comp, formResizeEvent);
          }
        }),
        Tabstopping.config({}),
        Keying.config(deriveCollectionMovement(spec.columns, "normal")),
        config("collection-events", collectionEvents)
      ]),
      eventOrder: {
        [execute$5()]: [
          "disabling",
          "alloy.base.behaviour",
          "collection-events"
        ]
      }
    });
    const extraClasses = ["tox-form__group--collection"];
    return renderFormFieldWith(pLabel, pField, extraClasses, []);
  };
  const ariaElements = [
    "input",
    "textarea"
  ];
  const isAriaElement = (elem) => {
    const name3 = name$3(elem);
    return contains$2(ariaElements, name3);
  };
  const markValid = (component, invalidConfig) => {
    const elem = invalidConfig.getRoot(component).getOr(component.element);
    remove$2(elem, invalidConfig.invalidClass);
    invalidConfig.notify.each((notifyInfo) => {
      if (isAriaElement(component.element)) {
        set$9(component.element, "aria-invalid", false);
      }
      notifyInfo.getContainer(component).each((container) => {
        set$6(container, notifyInfo.validHtml);
      });
      notifyInfo.onValid(component);
    });
  };
  const markInvalid = (component, invalidConfig, invalidState, text3) => {
    const elem = invalidConfig.getRoot(component).getOr(component.element);
    add$2(elem, invalidConfig.invalidClass);
    invalidConfig.notify.each((notifyInfo) => {
      if (isAriaElement(component.element)) {
        set$9(component.element, "aria-invalid", true);
      }
      notifyInfo.getContainer(component).each((container) => {
        set$6(container, text3);
      });
      notifyInfo.onInvalid(component, text3);
    });
  };
  const query = (component, invalidConfig, _invalidState) => invalidConfig.validator.fold(() => Future.pure(Result.value(true)), (validatorInfo) => validatorInfo.validate(component));
  const run2 = (component, invalidConfig, invalidState) => {
    invalidConfig.notify.each((notifyInfo) => {
      notifyInfo.onValidate(component);
    });
    return query(component, invalidConfig).map((valid) => {
      if (component.getSystem().isConnected()) {
        return valid.fold((err) => {
          markInvalid(component, invalidConfig, invalidState, err);
          return Result.error(err);
        }, (v) => {
          markValid(component, invalidConfig);
          return Result.value(v);
        });
      } else {
        return Result.error("No longer in system");
      }
    });
  };
  const isInvalid = (component, invalidConfig) => {
    const elem = invalidConfig.getRoot(component).getOr(component.element);
    return has(elem, invalidConfig.invalidClass);
  };
  var InvalidateApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    markValid,
    markInvalid,
    query,
    run: run2,
    isInvalid
  });
  const events$8 = (invalidConfig, invalidState) => invalidConfig.validator.map((validatorInfo) => derive$2([run$1(validatorInfo.onEvent, (component) => {
    run2(component, invalidConfig, invalidState).get(identity);
  })].concat(validatorInfo.validateOnLoad ? [runOnAttached((component) => {
    run2(component, invalidConfig, invalidState).get(noop2);
  })] : []))).getOr({});
  var ActiveInvalidate = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$8
  });
  var InvalidateSchema = [
    required$1("invalidClass"),
    defaulted("getRoot", Optional.none),
    optionObjOf("notify", [
      defaulted("aria", "alert"),
      defaulted("getContainer", Optional.none),
      defaulted("validHtml", ""),
      onHandler("onValid"),
      onHandler("onInvalid"),
      onHandler("onValidate")
    ]),
    optionObjOf("validator", [
      required$1("validate"),
      defaulted("onEvent", "input"),
      defaulted("validateOnLoad", true)
    ])
  ];
  const Invalidating = create$42({
    fields: InvalidateSchema,
    name: "invalidating",
    active: ActiveInvalidate,
    apis: InvalidateApis,
    extra: {
      validation: (validator2) => {
        return (component) => {
          const v = Representing.getValue(component);
          return Future.pure(validator2(v));
        };
      }
    }
  });
  const exhibit$1 = () => nu$7({
    styles: {
      "-webkit-user-select": "none",
      "user-select": "none",
      "-ms-user-select": "none",
      "-moz-user-select": "-moz-none"
    },
    attributes: { unselectable: "on" }
  });
  const events$7 = () => derive$2([abort(selectstart(), always)]);
  var ActiveUnselecting = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$7,
    exhibit: exhibit$1
  });
  const Unselecting = create$42({
    fields: [],
    name: "unselecting",
    active: ActiveUnselecting
  });
  const renderPanelButton = (spec, sharedBackstage) => Dropdown2.sketch({
    dom: spec.dom,
    components: spec.components,
    toggleClass: "mce-active",
    dropdownBehaviours: derive$1([
      DisablingConfigs.button(sharedBackstage.providers.isDisabled),
      receivingConfig(),
      Unselecting.config({}),
      Tabstopping.config({})
    ]),
    layouts: spec.layouts,
    sandboxClasses: ["tox-dialog__popups"],
    lazySink: sharedBackstage.getSink,
    fetch: (comp) => Future.nu((callback) => spec.fetch(callback)).map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6("menu-value"), items, (value2) => {
      spec.onItemAction(comp, value2);
    }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, never, sharedBackstage.providers), { movement: deriveMenuMovement(spec.columns, spec.presets) })))),
    parts: { menu: part(false, 1, spec.presets) }
  });
  const colorInputChangeEvent = generate$6("color-input-change");
  const colorSwatchChangeEvent = generate$6("color-swatch-change");
  const colorPickerCancelEvent = generate$6("color-picker-cancel");
  const renderColorInput = (spec, sharedBackstage, colorInputBackstage, initialData) => {
    const pField = FormField.parts.field({
      factory: Input,
      inputClasses: ["tox-textfield"],
      data: initialData,
      onSetValue: (c) => Invalidating.run(c).get(noop2),
      inputBehaviours: derive$1([
        Disabling.config({ disabled: sharedBackstage.providers.isDisabled }),
        receivingConfig(),
        Tabstopping.config({}),
        Invalidating.config({
          invalidClass: "tox-textbox-field-invalid",
          getRoot: (comp) => parentElement(comp.element),
          notify: {
            onValid: (comp) => {
              const val = Representing.getValue(comp);
              emitWith(comp, colorInputChangeEvent, { color: val });
            }
          },
          validator: {
            validateOnLoad: false,
            validate: (input2) => {
              const inputValue = Representing.getValue(input2);
              if (inputValue.length === 0) {
                return Future.pure(Result.value(true));
              } else {
                const span = SugarElement.fromTag("span");
                set$8(span, "background-color", inputValue);
                const res2 = getRaw(span, "background-color").fold(() => Result.error("blah"), (_2) => Result.value(inputValue));
                return Future.pure(res2);
              }
            }
          }
        })
      ]),
      selectOnFocus: false
    });
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, sharedBackstage.providers));
    const emitSwatchChange = (colorBit, value2) => {
      emitWith(colorBit, colorSwatchChangeEvent, { value: value2 });
    };
    const onItemAction2 = (comp, value2) => {
      memColorButton.getOpt(comp).each((colorBit) => {
        if (value2 === "custom") {
          colorInputBackstage.colorPicker((valueOpt) => {
            valueOpt.fold(() => emit(colorBit, colorPickerCancelEvent), (value3) => {
              emitSwatchChange(colorBit, value3);
              addColor(spec.storageKey, value3);
            });
          }, "#ffffff");
        } else if (value2 === "remove") {
          emitSwatchChange(colorBit, "");
        } else {
          emitSwatchChange(colorBit, value2);
        }
      });
    };
    const memColorButton = record(renderPanelButton({
      dom: {
        tag: "span",
        attributes: { "aria-label": sharedBackstage.providers.translate("Color swatch") }
      },
      layouts: {
        onRtl: () => [
          southwest$2,
          southeast$2,
          south$2
        ],
        onLtr: () => [
          southeast$2,
          southwest$2,
          south$2
        ]
      },
      components: [],
      fetch: getFetch$1(colorInputBackstage.getColors(spec.storageKey), spec.storageKey, colorInputBackstage.hasCustomColors()),
      columns: colorInputBackstage.getColorCols(spec.storageKey),
      presets: "color",
      onItemAction: onItemAction2
    }, sharedBackstage));
    return FormField.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: pLabel.toArray().concat([{
        dom: {
          tag: "div",
          classes: ["tox-color-input"]
        },
        components: [
          pField,
          memColorButton.asSpec()
        ]
      }]),
      fieldBehaviours: derive$1([config("form-field-events", [
        run$1(colorInputChangeEvent, (comp, se) => {
          memColorButton.getOpt(comp).each((colorButton) => {
            set$8(colorButton.element, "background-color", se.event.color);
          });
          emitWith(comp, formChangeEvent, { name: spec.name });
        }),
        run$1(colorSwatchChangeEvent, (comp, se) => {
          FormField.getField(comp).each((field2) => {
            Representing.setValue(field2, se.event.value);
            Composing.getCurrent(comp).each(Focusing.focus);
          });
        }),
        run$1(colorPickerCancelEvent, (comp, _se) => {
          FormField.getField(comp).each((_field) => {
            Composing.getCurrent(comp).each(Focusing.focus);
          });
        })
      ])])
    });
  };
  const labelPart = optional({
    schema: [required$1("dom")],
    name: "label"
  });
  const edgePart = (name3) => optional({
    name: "" + name3 + "-edge",
    overrides: (detail) => {
      const action = detail.model.manager.edgeActions[name3];
      return action.fold(() => ({}), (a) => ({
        events: derive$2([
          runActionExtra(touchstart(), (comp, se, d) => a(comp, d), [detail]),
          runActionExtra(mousedown(), (comp, se, d) => a(comp, d), [detail]),
          runActionExtra(mousemove(), (comp, se, det) => {
            if (det.mouseIsDown.get()) {
              a(comp, det);
            }
          }, [detail])
        ])
      }));
    }
  });
  const tlEdgePart = edgePart("top-left");
  const tedgePart = edgePart("top");
  const trEdgePart = edgePart("top-right");
  const redgePart = edgePart("right");
  const brEdgePart = edgePart("bottom-right");
  const bedgePart = edgePart("bottom");
  const blEdgePart = edgePart("bottom-left");
  const ledgePart = edgePart("left");
  const thumbPart = required({
    name: "thumb",
    defaults: constant$1({ dom: { styles: { position: "absolute" } } }),
    overrides: (detail) => {
      return {
        events: derive$2([
          redirectToPart(touchstart(), detail, "spectrum"),
          redirectToPart(touchmove(), detail, "spectrum"),
          redirectToPart(touchend(), detail, "spectrum"),
          redirectToPart(mousedown(), detail, "spectrum"),
          redirectToPart(mousemove(), detail, "spectrum"),
          redirectToPart(mouseup(), detail, "spectrum")
        ])
      };
    }
  });
  const spectrumPart = required({
    schema: [customField("mouseIsDown", () => Cell(false))],
    name: "spectrum",
    overrides: (detail) => {
      const modelDetail = detail.model;
      const model = modelDetail.manager;
      const setValueFrom2 = (component, simulatedEvent) => model.getValueFromEvent(simulatedEvent).map((value2) => model.setValueFrom(component, detail, value2));
      return {
        behaviours: derive$1([
          Keying.config({
            mode: "special",
            onLeft: (spectrum) => model.onLeft(spectrum, detail),
            onRight: (spectrum) => model.onRight(spectrum, detail),
            onUp: (spectrum) => model.onUp(spectrum, detail),
            onDown: (spectrum) => model.onDown(spectrum, detail)
          }),
          Focusing.config({})
        ]),
        events: derive$2([
          run$1(touchstart(), setValueFrom2),
          run$1(touchmove(), setValueFrom2),
          run$1(mousedown(), setValueFrom2),
          run$1(mousemove(), (spectrum, se) => {
            if (detail.mouseIsDown.get()) {
              setValueFrom2(spectrum, se);
            }
          })
        ])
      };
    }
  });
  var SliderParts = [
    labelPart,
    ledgePart,
    redgePart,
    tedgePart,
    bedgePart,
    tlEdgePart,
    trEdgePart,
    blEdgePart,
    brEdgePart,
    thumbPart,
    spectrumPart
  ];
  const _sliderChangeEvent = "slider.change.value";
  const sliderChangeEvent = constant$1(_sliderChangeEvent);
  const isTouchEvent$2 = (evt) => evt.type.indexOf("touch") !== -1;
  const getEventSource = (simulatedEvent) => {
    const evt = simulatedEvent.event.raw;
    if (isTouchEvent$2(evt)) {
      const touchEvent = evt;
      return touchEvent.touches !== void 0 && touchEvent.touches.length === 1 ? Optional.some(touchEvent.touches[0]).map((t2) => SugarPosition(t2.clientX, t2.clientY)) : Optional.none();
    } else {
      const mouseEvent = evt;
      return mouseEvent.clientX !== void 0 ? Optional.some(mouseEvent).map((me) => SugarPosition(me.clientX, me.clientY)) : Optional.none();
    }
  };
  const t = "top", r = "right", b = "bottom", l = "left";
  const minX = (detail) => detail.model.minX;
  const minY = (detail) => detail.model.minY;
  const min1X = (detail) => detail.model.minX - 1;
  const min1Y = (detail) => detail.model.minY - 1;
  const maxX = (detail) => detail.model.maxX;
  const maxY = (detail) => detail.model.maxY;
  const max1X = (detail) => detail.model.maxX + 1;
  const max1Y = (detail) => detail.model.maxY + 1;
  const range = (detail, max3, min3) => max3(detail) - min3(detail);
  const xRange = (detail) => range(detail, maxX, minX);
  const yRange = (detail) => range(detail, maxY, minY);
  const halfX = (detail) => xRange(detail) / 2;
  const halfY = (detail) => yRange(detail) / 2;
  const step = (detail) => detail.stepSize;
  const snap = (detail) => detail.snapToGrid;
  const snapStart = (detail) => detail.snapStart;
  const rounded = (detail) => detail.rounded;
  const hasEdge = (detail, edgeName) => detail[edgeName + "-edge"] !== void 0;
  const hasLEdge = (detail) => hasEdge(detail, l);
  const hasREdge = (detail) => hasEdge(detail, r);
  const hasTEdge = (detail) => hasEdge(detail, t);
  const hasBEdge = (detail) => hasEdge(detail, b);
  const currentValue = (detail) => detail.model.value.get();
  const xyValue = (x, y) => ({
    x,
    y
  });
  const fireSliderChange$3 = (component, value2) => {
    emitWith(component, sliderChangeEvent(), { value: value2 });
  };
  const setToTLEdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(min1X(detail), min1Y(detail)));
  };
  const setToTEdge = (edge2, detail) => {
    fireSliderChange$3(edge2, min1Y(detail));
  };
  const setToTEdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(halfX(detail), min1Y(detail)));
  };
  const setToTREdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(max1X(detail), min1Y(detail)));
  };
  const setToREdge = (edge2, detail) => {
    fireSliderChange$3(edge2, max1X(detail));
  };
  const setToREdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(max1X(detail), halfY(detail)));
  };
  const setToBREdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(max1X(detail), max1Y(detail)));
  };
  const setToBEdge = (edge2, detail) => {
    fireSliderChange$3(edge2, max1Y(detail));
  };
  const setToBEdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(halfX(detail), max1Y(detail)));
  };
  const setToBLEdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(min1X(detail), max1Y(detail)));
  };
  const setToLEdge = (edge2, detail) => {
    fireSliderChange$3(edge2, min1X(detail));
  };
  const setToLEdgeXY = (edge2, detail) => {
    fireSliderChange$3(edge2, xyValue(min1X(detail), halfY(detail)));
  };
  const reduceBy = (value2, min3, max3, step2) => {
    if (value2 < min3) {
      return value2;
    } else if (value2 > max3) {
      return max3;
    } else if (value2 === min3) {
      return min3 - 1;
    } else {
      return Math.max(min3, value2 - step2);
    }
  };
  const increaseBy = (value2, min3, max3, step2) => {
    if (value2 > max3) {
      return value2;
    } else if (value2 < min3) {
      return min3;
    } else if (value2 === max3) {
      return max3 + 1;
    } else {
      return Math.min(max3, value2 + step2);
    }
  };
  const capValue = (value2, min3, max3) => Math.max(min3, Math.min(max3, value2));
  const snapValueOf = (value2, min3, max3, step2, snapStart2) => snapStart2.fold(() => {
    const initValue = value2 - min3;
    const extraValue = Math.round(initValue / step2) * step2;
    return capValue(min3 + extraValue, min3 - 1, max3 + 1);
  }, (start2) => {
    const remainder = (value2 - start2) % step2;
    const adjustment = Math.round(remainder / step2);
    const rawSteps = Math.floor((value2 - start2) / step2);
    const maxSteps = Math.floor((max3 - start2) / step2);
    const numSteps = Math.min(maxSteps, rawSteps + adjustment);
    const r2 = start2 + numSteps * step2;
    return Math.max(start2, r2);
  });
  const findOffsetOf = (value2, min3, max3) => Math.min(max3, Math.max(value2, min3)) - min3;
  const findValueOf = (args) => {
    const { min: min3, max: max3, range: range2, value: value2, step: step2, snap: snap2, snapStart: snapStart2, rounded: rounded2, hasMinEdge, hasMaxEdge, minBound, maxBound, screenRange } = args;
    const capMin = hasMinEdge ? min3 - 1 : min3;
    const capMax = hasMaxEdge ? max3 + 1 : max3;
    if (value2 < minBound) {
      return capMin;
    } else if (value2 > maxBound) {
      return capMax;
    } else {
      const offset3 = findOffsetOf(value2, minBound, maxBound);
      const newValue = capValue(offset3 / screenRange * range2 + min3, capMin, capMax);
      if (snap2 && newValue >= min3 && newValue <= max3) {
        return snapValueOf(newValue, min3, max3, step2, snapStart2);
      } else if (rounded2) {
        return Math.round(newValue);
      } else {
        return newValue;
      }
    }
  };
  const findOffsetOfValue$2 = (args) => {
    const { min: min3, max: max3, range: range2, value: value2, hasMinEdge, hasMaxEdge, maxBound, maxOffset, centerMinEdge, centerMaxEdge } = args;
    if (value2 < min3) {
      return hasMinEdge ? 0 : centerMinEdge;
    } else if (value2 > max3) {
      return hasMaxEdge ? maxBound : centerMaxEdge;
    } else {
      return (value2 - min3) / range2 * maxOffset;
    }
  };
  const top2 = "top", right2 = "right", bottom2 = "bottom", left2 = "left", width2 = "width", height2 = "height";
  const getBounds = (component) => component.element.dom.getBoundingClientRect();
  const getBoundsProperty = (bounds2, property) => bounds2[property];
  const getMinXBounds = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, left2);
  };
  const getMaxXBounds = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, right2);
  };
  const getMinYBounds = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, top2);
  };
  const getMaxYBounds = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, bottom2);
  };
  const getXScreenRange = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, width2);
  };
  const getYScreenRange = (component) => {
    const bounds2 = getBounds(component);
    return getBoundsProperty(bounds2, height2);
  };
  const getCenterOffsetOf = (componentMinEdge, componentMaxEdge, spectrumMinEdge) => (componentMinEdge + componentMaxEdge) / 2 - spectrumMinEdge;
  const getXCenterOffSetOf = (component, spectrum) => {
    const componentBounds = getBounds(component);
    const spectrumBounds = getBounds(spectrum);
    const componentMinEdge = getBoundsProperty(componentBounds, left2);
    const componentMaxEdge = getBoundsProperty(componentBounds, right2);
    const spectrumMinEdge = getBoundsProperty(spectrumBounds, left2);
    return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
  };
  const getYCenterOffSetOf = (component, spectrum) => {
    const componentBounds = getBounds(component);
    const spectrumBounds = getBounds(spectrum);
    const componentMinEdge = getBoundsProperty(componentBounds, top2);
    const componentMaxEdge = getBoundsProperty(componentBounds, bottom2);
    const spectrumMinEdge = getBoundsProperty(spectrumBounds, top2);
    return getCenterOffsetOf(componentMinEdge, componentMaxEdge, spectrumMinEdge);
  };
  const fireSliderChange$2 = (spectrum, value2) => {
    emitWith(spectrum, sliderChangeEvent(), { value: value2 });
  };
  const findValueOfOffset$1 = (spectrum, detail, left3) => {
    const args = {
      min: minX(detail),
      max: maxX(detail),
      range: xRange(detail),
      value: left3,
      step: step(detail),
      snap: snap(detail),
      snapStart: snapStart(detail),
      rounded: rounded(detail),
      hasMinEdge: hasLEdge(detail),
      hasMaxEdge: hasREdge(detail),
      minBound: getMinXBounds(spectrum),
      maxBound: getMaxXBounds(spectrum),
      screenRange: getXScreenRange(spectrum)
    };
    return findValueOf(args);
  };
  const setValueFrom$2 = (spectrum, detail, value2) => {
    const xValue = findValueOfOffset$1(spectrum, detail, value2);
    const sliderVal = xValue;
    fireSliderChange$2(spectrum, sliderVal);
    return xValue;
  };
  const setToMin$2 = (spectrum, detail) => {
    const min3 = minX(detail);
    fireSliderChange$2(spectrum, min3);
  };
  const setToMax$2 = (spectrum, detail) => {
    const max3 = maxX(detail);
    fireSliderChange$2(spectrum, max3);
  };
  const moveBy$2 = (direction, spectrum, detail) => {
    const f2 = direction > 0 ? increaseBy : reduceBy;
    const xValue = f2(currentValue(detail), minX(detail), maxX(detail), step(detail));
    fireSliderChange$2(spectrum, xValue);
    return Optional.some(xValue);
  };
  const handleMovement$2 = (direction) => (spectrum, detail) => moveBy$2(direction, spectrum, detail).map(always);
  const getValueFromEvent$2 = (simulatedEvent) => {
    const pos = getEventSource(simulatedEvent);
    return pos.map((p) => p.left);
  };
  const findOffsetOfValue$1 = (spectrum, detail, value2, minEdge, maxEdge) => {
    const minOffset = 0;
    const maxOffset = getXScreenRange(spectrum);
    const centerMinEdge = minEdge.bind((edge2) => Optional.some(getXCenterOffSetOf(edge2, spectrum))).getOr(minOffset);
    const centerMaxEdge = maxEdge.bind((edge2) => Optional.some(getXCenterOffSetOf(edge2, spectrum))).getOr(maxOffset);
    const args = {
      min: minX(detail),
      max: maxX(detail),
      range: xRange(detail),
      value: value2,
      hasMinEdge: hasLEdge(detail),
      hasMaxEdge: hasREdge(detail),
      minBound: getMinXBounds(spectrum),
      minOffset,
      maxBound: getMaxXBounds(spectrum),
      maxOffset,
      centerMinEdge,
      centerMaxEdge
    };
    return findOffsetOfValue$2(args);
  };
  const findPositionOfValue$1 = (slider, spectrum, value2, minEdge, maxEdge, detail) => {
    const offset3 = findOffsetOfValue$1(spectrum, detail, value2, minEdge, maxEdge);
    return getMinXBounds(spectrum) - getMinXBounds(slider) + offset3;
  };
  const setPositionFromValue$2 = (slider, thumb, detail, edges) => {
    const value2 = currentValue(detail);
    const pos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value2, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
    const thumbRadius = get$c(thumb.element) / 2;
    set$8(thumb.element, "left", pos - thumbRadius + "px");
  };
  const onLeft$2 = handleMovement$2(-1);
  const onRight$2 = handleMovement$2(1);
  const onUp$2 = Optional.none;
  const onDown$2 = Optional.none;
  const edgeActions$2 = {
    "top-left": Optional.none(),
    "top": Optional.none(),
    "top-right": Optional.none(),
    "right": Optional.some(setToREdge),
    "bottom-right": Optional.none(),
    "bottom": Optional.none(),
    "bottom-left": Optional.none(),
    "left": Optional.some(setToLEdge)
  };
  var HorizontalModel = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: setValueFrom$2,
    setToMin: setToMin$2,
    setToMax: setToMax$2,
    findValueOfOffset: findValueOfOffset$1,
    getValueFromEvent: getValueFromEvent$2,
    findPositionOfValue: findPositionOfValue$1,
    setPositionFromValue: setPositionFromValue$2,
    onLeft: onLeft$2,
    onRight: onRight$2,
    onUp: onUp$2,
    onDown: onDown$2,
    edgeActions: edgeActions$2
  });
  const fireSliderChange$1 = (spectrum, value2) => {
    emitWith(spectrum, sliderChangeEvent(), { value: value2 });
  };
  const findValueOfOffset = (spectrum, detail, top3) => {
    const args = {
      min: minY(detail),
      max: maxY(detail),
      range: yRange(detail),
      value: top3,
      step: step(detail),
      snap: snap(detail),
      snapStart: snapStart(detail),
      rounded: rounded(detail),
      hasMinEdge: hasTEdge(detail),
      hasMaxEdge: hasBEdge(detail),
      minBound: getMinYBounds(spectrum),
      maxBound: getMaxYBounds(spectrum),
      screenRange: getYScreenRange(spectrum)
    };
    return findValueOf(args);
  };
  const setValueFrom$1 = (spectrum, detail, value2) => {
    const yValue = findValueOfOffset(spectrum, detail, value2);
    const sliderVal = yValue;
    fireSliderChange$1(spectrum, sliderVal);
    return yValue;
  };
  const setToMin$1 = (spectrum, detail) => {
    const min3 = minY(detail);
    fireSliderChange$1(spectrum, min3);
  };
  const setToMax$1 = (spectrum, detail) => {
    const max3 = maxY(detail);
    fireSliderChange$1(spectrum, max3);
  };
  const moveBy$1 = (direction, spectrum, detail) => {
    const f2 = direction > 0 ? increaseBy : reduceBy;
    const yValue = f2(currentValue(detail), minY(detail), maxY(detail), step(detail));
    fireSliderChange$1(spectrum, yValue);
    return Optional.some(yValue);
  };
  const handleMovement$1 = (direction) => (spectrum, detail) => moveBy$1(direction, spectrum, detail).map(always);
  const getValueFromEvent$1 = (simulatedEvent) => {
    const pos = getEventSource(simulatedEvent);
    return pos.map((p) => {
      return p.top;
    });
  };
  const findOffsetOfValue = (spectrum, detail, value2, minEdge, maxEdge) => {
    const minOffset = 0;
    const maxOffset = getYScreenRange(spectrum);
    const centerMinEdge = minEdge.bind((edge2) => Optional.some(getYCenterOffSetOf(edge2, spectrum))).getOr(minOffset);
    const centerMaxEdge = maxEdge.bind((edge2) => Optional.some(getYCenterOffSetOf(edge2, spectrum))).getOr(maxOffset);
    const args = {
      min: minY(detail),
      max: maxY(detail),
      range: yRange(detail),
      value: value2,
      hasMinEdge: hasTEdge(detail),
      hasMaxEdge: hasBEdge(detail),
      minBound: getMinYBounds(spectrum),
      minOffset,
      maxBound: getMaxYBounds(spectrum),
      maxOffset,
      centerMinEdge,
      centerMaxEdge
    };
    return findOffsetOfValue$2(args);
  };
  const findPositionOfValue = (slider, spectrum, value2, minEdge, maxEdge, detail) => {
    const offset3 = findOffsetOfValue(spectrum, detail, value2, minEdge, maxEdge);
    return getMinYBounds(spectrum) - getMinYBounds(slider) + offset3;
  };
  const setPositionFromValue$1 = (slider, thumb, detail, edges) => {
    const value2 = currentValue(detail);
    const pos = findPositionOfValue(slider, edges.getSpectrum(slider), value2, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
    const thumbRadius = get$d(thumb.element) / 2;
    set$8(thumb.element, "top", pos - thumbRadius + "px");
  };
  const onLeft$1 = Optional.none;
  const onRight$1 = Optional.none;
  const onUp$1 = handleMovement$1(-1);
  const onDown$1 = handleMovement$1(1);
  const edgeActions$1 = {
    "top-left": Optional.none(),
    "top": Optional.some(setToTEdge),
    "top-right": Optional.none(),
    "right": Optional.none(),
    "bottom-right": Optional.none(),
    "bottom": Optional.some(setToBEdge),
    "bottom-left": Optional.none(),
    "left": Optional.none()
  };
  var VerticalModel = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom: setValueFrom$1,
    setToMin: setToMin$1,
    setToMax: setToMax$1,
    findValueOfOffset,
    getValueFromEvent: getValueFromEvent$1,
    findPositionOfValue,
    setPositionFromValue: setPositionFromValue$1,
    onLeft: onLeft$1,
    onRight: onRight$1,
    onUp: onUp$1,
    onDown: onDown$1,
    edgeActions: edgeActions$1
  });
  const fireSliderChange = (spectrum, value2) => {
    emitWith(spectrum, sliderChangeEvent(), { value: value2 });
  };
  const sliderValue = (x, y) => ({
    x,
    y
  });
  const setValueFrom = (spectrum, detail, value2) => {
    const xValue = findValueOfOffset$1(spectrum, detail, value2.left);
    const yValue = findValueOfOffset(spectrum, detail, value2.top);
    const val = sliderValue(xValue, yValue);
    fireSliderChange(spectrum, val);
    return val;
  };
  const moveBy = (direction, isVerticalMovement, spectrum, detail) => {
    const f2 = direction > 0 ? increaseBy : reduceBy;
    const xValue = isVerticalMovement ? currentValue(detail).x : f2(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
    const yValue = !isVerticalMovement ? currentValue(detail).y : f2(currentValue(detail).y, minY(detail), maxY(detail), step(detail));
    fireSliderChange(spectrum, sliderValue(xValue, yValue));
    return Optional.some(xValue);
  };
  const handleMovement = (direction, isVerticalMovement) => (spectrum, detail) => moveBy(direction, isVerticalMovement, spectrum, detail).map(always);
  const setToMin = (spectrum, detail) => {
    const mX = minX(detail);
    const mY = minY(detail);
    fireSliderChange(spectrum, sliderValue(mX, mY));
  };
  const setToMax = (spectrum, detail) => {
    const mX = maxX(detail);
    const mY = maxY(detail);
    fireSliderChange(spectrum, sliderValue(mX, mY));
  };
  const getValueFromEvent = (simulatedEvent) => getEventSource(simulatedEvent);
  const setPositionFromValue = (slider, thumb, detail, edges) => {
    const value2 = currentValue(detail);
    const xPos = findPositionOfValue$1(slider, edges.getSpectrum(slider), value2.x, edges.getLeftEdge(slider), edges.getRightEdge(slider), detail);
    const yPos = findPositionOfValue(slider, edges.getSpectrum(slider), value2.y, edges.getTopEdge(slider), edges.getBottomEdge(slider), detail);
    const thumbXRadius = get$c(thumb.element) / 2;
    const thumbYRadius = get$d(thumb.element) / 2;
    set$8(thumb.element, "left", xPos - thumbXRadius + "px");
    set$8(thumb.element, "top", yPos - thumbYRadius + "px");
  };
  const onLeft = handleMovement(-1, false);
  const onRight = handleMovement(1, false);
  const onUp = handleMovement(-1, true);
  const onDown = handleMovement(1, true);
  const edgeActions = {
    "top-left": Optional.some(setToTLEdgeXY),
    "top": Optional.some(setToTEdgeXY),
    "top-right": Optional.some(setToTREdgeXY),
    "right": Optional.some(setToREdgeXY),
    "bottom-right": Optional.some(setToBREdgeXY),
    "bottom": Optional.some(setToBEdgeXY),
    "bottom-left": Optional.some(setToBLEdgeXY),
    "left": Optional.some(setToLEdgeXY)
  };
  var TwoDModel = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setValueFrom,
    setToMin,
    setToMax,
    getValueFromEvent,
    setPositionFromValue,
    onLeft,
    onRight,
    onUp,
    onDown,
    edgeActions
  });
  const SliderSchema = [
    defaulted("stepSize", 1),
    defaulted("onChange", noop2),
    defaulted("onChoose", noop2),
    defaulted("onInit", noop2),
    defaulted("onDragStart", noop2),
    defaulted("onDragEnd", noop2),
    defaulted("snapToGrid", false),
    defaulted("rounded", true),
    option$3("snapStart"),
    requiredOf("model", choose$1("mode", {
      x: [
        defaulted("minX", 0),
        defaulted("maxX", 100),
        customField("value", (spec) => Cell(spec.mode.minX)),
        required$1("getInitialValue"),
        output$1("manager", HorizontalModel)
      ],
      y: [
        defaulted("minY", 0),
        defaulted("maxY", 100),
        customField("value", (spec) => Cell(spec.mode.minY)),
        required$1("getInitialValue"),
        output$1("manager", VerticalModel)
      ],
      xy: [
        defaulted("minX", 0),
        defaulted("maxX", 100),
        defaulted("minY", 0),
        defaulted("maxY", 100),
        customField("value", (spec) => Cell({
          x: spec.mode.minX,
          y: spec.mode.minY
        })),
        required$1("getInitialValue"),
        output$1("manager", TwoDModel)
      ]
    })),
    field("sliderBehaviours", [
      Keying,
      Representing
    ]),
    customField("mouseIsDown", () => Cell(false))
  ];
  const sketch$2 = (detail, components2, _spec, _externals) => {
    const getThumb = (component) => getPartOrDie(component, detail, "thumb");
    const getSpectrum = (component) => getPartOrDie(component, detail, "spectrum");
    const getLeftEdge = (component) => getPart(component, detail, "left-edge");
    const getRightEdge = (component) => getPart(component, detail, "right-edge");
    const getTopEdge = (component) => getPart(component, detail, "top-edge");
    const getBottomEdge = (component) => getPart(component, detail, "bottom-edge");
    const modelDetail = detail.model;
    const model = modelDetail.manager;
    const refresh2 = (slider, thumb) => {
      model.setPositionFromValue(slider, thumb, detail, {
        getLeftEdge,
        getRightEdge,
        getTopEdge,
        getBottomEdge,
        getSpectrum
      });
    };
    const setValue2 = (slider, newValue) => {
      modelDetail.value.set(newValue);
      const thumb = getThumb(slider);
      refresh2(slider, thumb);
    };
    const changeValue = (slider, newValue) => {
      setValue2(slider, newValue);
      const thumb = getThumb(slider);
      detail.onChange(slider, thumb, newValue);
      return Optional.some(true);
    };
    const resetToMin = (slider) => {
      model.setToMin(slider, detail);
    };
    const resetToMax = (slider) => {
      model.setToMax(slider, detail);
    };
    const choose2 = (slider) => {
      const fireOnChoose = () => {
        getPart(slider, detail, "thumb").each((thumb) => {
          const value2 = modelDetail.value.get();
          detail.onChoose(slider, thumb, value2);
        });
      };
      const wasDown = detail.mouseIsDown.get();
      detail.mouseIsDown.set(false);
      if (wasDown) {
        fireOnChoose();
      }
    };
    const onDragStart = (slider, simulatedEvent) => {
      simulatedEvent.stop();
      detail.mouseIsDown.set(true);
      detail.onDragStart(slider, getThumb(slider));
    };
    const onDragEnd = (slider, simulatedEvent) => {
      simulatedEvent.stop();
      detail.onDragEnd(slider, getThumb(slider));
      choose2(slider);
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: augment(detail.sliderBehaviours, [
        Keying.config({
          mode: "special",
          focusIn: (slider) => {
            return getPart(slider, detail, "spectrum").map(Keying.focusIn).map(always);
          }
        }),
        Representing.config({
          store: {
            mode: "manual",
            getValue: (_2) => {
              return modelDetail.value.get();
            },
            setValue: setValue2
          }
        }),
        Receiving.config({ channels: { [mouseReleased()]: { onReceive: choose2 } } })
      ]),
      events: derive$2([
        run$1(sliderChangeEvent(), (slider, simulatedEvent) => {
          changeValue(slider, simulatedEvent.event.value);
        }),
        runOnAttached((slider, _simulatedEvent) => {
          const getInitial = modelDetail.getInitialValue();
          modelDetail.value.set(getInitial);
          const thumb = getThumb(slider);
          refresh2(slider, thumb);
          const spectrum = getSpectrum(slider);
          detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
        }),
        run$1(touchstart(), onDragStart),
        run$1(touchend(), onDragEnd),
        run$1(mousedown(), onDragStart),
        run$1(mouseup(), onDragEnd)
      ]),
      apis: {
        resetToMin,
        resetToMax,
        setValue: setValue2,
        refresh: refresh2
      },
      domModification: { styles: { position: "relative" } }
    };
  };
  const Slider = composite({
    name: "Slider",
    configFields: SliderSchema,
    partFields: SliderParts,
    factory: sketch$2,
    apis: {
      setValue: (apis2, slider, value2) => {
        apis2.setValue(slider, value2);
      },
      resetToMin: (apis2, slider) => {
        apis2.resetToMin(slider);
      },
      resetToMax: (apis2, slider) => {
        apis2.resetToMax(slider);
      },
      refresh: (apis2, slider) => {
        apis2.refresh(slider);
      }
    }
  });
  const fieldsUpdate = generate$6("rgb-hex-update");
  const sliderUpdate = generate$6("slider-update");
  const paletteUpdate = generate$6("palette-update");
  const sliderFactory = (translate2, getClass) => {
    const spectrum = Slider.parts.spectrum({
      dom: {
        tag: "div",
        classes: [getClass("hue-slider-spectrum")],
        attributes: { role: "presentation" }
      }
    });
    const thumb = Slider.parts.thumb({
      dom: {
        tag: "div",
        classes: [getClass("hue-slider-thumb")],
        attributes: { role: "presentation" }
      }
    });
    return Slider.sketch({
      dom: {
        tag: "div",
        classes: [getClass("hue-slider")],
        attributes: { role: "presentation" }
      },
      rounded: false,
      model: {
        mode: "y",
        getInitialValue: constant$1(0)
      },
      components: [
        spectrum,
        thumb
      ],
      sliderBehaviours: derive$1([Focusing.config({})]),
      onChange: (slider, _thumb, value2) => {
        emitWith(slider, sliderUpdate, { value: value2 });
      }
    });
  };
  const owner$1 = "form";
  const schema$i = [field("formBehaviours", [Representing])];
  const getPartName$1 = (name3) => "<alloy.field." + name3 + ">";
  const sketch$1 = (fSpec) => {
    const parts2 = (() => {
      const record2 = [];
      const field2 = (name3, config2) => {
        record2.push(name3);
        return generateOne$1(owner$1, getPartName$1(name3), config2);
      };
      return {
        field: field2,
        record: constant$1(record2)
      };
    })();
    const spec = fSpec(parts2);
    const partNames = parts2.record();
    const fieldParts = map$2(partNames, (n) => required({
      name: n,
      pname: getPartName$1(n)
    }));
    return composite$1(owner$1, schema$i, fieldParts, make$4, spec);
  };
  const toResult = (o, e) => o.fold(() => Result.error(e), Result.value);
  const make$4 = (detail, components2) => ({
    uid: detail.uid,
    dom: detail.dom,
    components: components2,
    behaviours: augment(detail.formBehaviours, [Representing.config({
      store: {
        mode: "manual",
        getValue: (form) => {
          const resPs = getAllParts(form, detail);
          return map$1(resPs, (resPThunk, pName) => resPThunk().bind((v) => {
            const opt = Composing.getCurrent(v);
            return toResult(opt, new Error(`Cannot find a current component to extract the value from for form part '${pName}': ` + element(v.element)));
          }).map(Representing.getValue));
        },
        setValue: (form, values2) => {
          each(values2, (newValue, key) => {
            getPart(form, detail, key).each((wrapper) => {
              Composing.getCurrent(wrapper).each((field2) => {
                Representing.setValue(field2, newValue);
              });
            });
          });
        }
      }
    })]),
    apis: {
      getField: (form, key) => {
        return getPart(form, detail, key).bind(Composing.getCurrent);
      }
    }
  });
  const Form = {
    getField: makeApi((apis2, component, key) => apis2.getField(component, key)),
    sketch: sketch$1
  };
  const validInput = generate$6("valid-input");
  const invalidInput = generate$6("invalid-input");
  const validatingInput = generate$6("validating-input");
  const translatePrefix = "colorcustom.rgb.";
  const rgbFormFactory = (translate2, getClass, onValidHexx, onInvalidHexx) => {
    const invalidation = (label2, isValid) => Invalidating.config({
      invalidClass: getClass("invalid"),
      notify: {
        onValidate: (comp) => {
          emitWith(comp, validatingInput, { type: label2 });
        },
        onValid: (comp) => {
          emitWith(comp, validInput, {
            type: label2,
            value: Representing.getValue(comp)
          });
        },
        onInvalid: (comp) => {
          emitWith(comp, invalidInput, {
            type: label2,
            value: Representing.getValue(comp)
          });
        }
      },
      validator: {
        validate: (comp) => {
          const value2 = Representing.getValue(comp);
          const res2 = isValid(value2) ? Result.value(true) : Result.error(translate2("aria.input.invalid"));
          return Future.pure(res2);
        },
        validateOnLoad: false
      }
    });
    const renderTextField2 = (isValid, name3, label2, description, data2) => {
      const helptext = translate2(translatePrefix + "range");
      const pLabel = FormField.parts.label({
        dom: {
          tag: "label",
          attributes: { "aria-label": description }
        },
        components: [text$2(label2)]
      });
      const pField = FormField.parts.field({
        data: data2,
        factory: Input,
        inputAttributes: {
          type: "text",
          ...name3 === "hex" ? { "aria-live": "polite" } : {}
        },
        inputClasses: [getClass("textfield")],
        inputBehaviours: derive$1([
          invalidation(name3, isValid),
          Tabstopping.config({})
        ]),
        onSetValue: (input2) => {
          if (Invalidating.isInvalid(input2)) {
            const run3 = Invalidating.run(input2);
            run3.get(noop2);
          }
        }
      });
      const comps = [
        pLabel,
        pField
      ];
      const concats = name3 !== "hex" ? [FormField.parts["aria-descriptor"]({ text: helptext })] : [];
      const components2 = comps.concat(concats);
      return {
        dom: {
          tag: "div",
          attributes: { role: "presentation" }
        },
        components: components2
      };
    };
    const copyRgbToHex = (form, rgba) => {
      const hex = fromRgba(rgba);
      Form.getField(form, "hex").each((hexField) => {
        if (!Focusing.isFocused(hexField)) {
          Representing.setValue(form, { hex: hex.value });
        }
      });
      return hex;
    };
    const copyRgbToForm = (form, rgb) => {
      const red2 = rgb.red;
      const green = rgb.green;
      const blue = rgb.blue;
      Representing.setValue(form, {
        red: red2,
        green,
        blue
      });
    };
    const memPreview = record({
      dom: {
        tag: "div",
        classes: [getClass("rgba-preview")],
        styles: { "background-color": "white" },
        attributes: { role: "presentation" }
      }
    });
    const updatePreview = (anyInSystem, hex) => {
      memPreview.getOpt(anyInSystem).each((preview) => {
        set$8(preview.element, "background-color", "#" + hex.value);
      });
    };
    const factory2 = () => {
      const state2 = {
        red: Cell(Optional.some(255)),
        green: Cell(Optional.some(255)),
        blue: Cell(Optional.some(255)),
        hex: Cell(Optional.some("ffffff"))
      };
      const copyHexToRgb = (form, hex) => {
        const rgb = fromHex(hex);
        copyRgbToForm(form, rgb);
        setValueRgb(rgb);
      };
      const get2 = (prop) => state2[prop].get();
      const set2 = (prop, value2) => {
        state2[prop].set(value2);
      };
      const getValueRgb = () => get2("red").bind((red2) => get2("green").bind((green) => get2("blue").map((blue) => rgbaColour(red2, green, blue, 1))));
      const setValueRgb = (rgb) => {
        const red2 = rgb.red;
        const green = rgb.green;
        const blue = rgb.blue;
        set2("red", Optional.some(red2));
        set2("green", Optional.some(green));
        set2("blue", Optional.some(blue));
      };
      const onInvalidInput = (form, simulatedEvent) => {
        const data2 = simulatedEvent.event;
        if (data2.type !== "hex") {
          set2(data2.type, Optional.none());
        } else {
          onInvalidHexx(form);
        }
      };
      const onValidHex = (form, value2) => {
        onValidHexx(form);
        const hex = hexColour(value2);
        set2("hex", Optional.some(hex.value));
        const rgb = fromHex(hex);
        copyRgbToForm(form, rgb);
        setValueRgb(rgb);
        emitWith(form, fieldsUpdate, { hex });
        updatePreview(form, hex);
      };
      const onValidRgb = (form, prop, value2) => {
        const val = parseInt(value2, 10);
        set2(prop, Optional.some(val));
        getValueRgb().each((rgb) => {
          const hex = copyRgbToHex(form, rgb);
          emitWith(form, fieldsUpdate, { hex });
          updatePreview(form, hex);
        });
      };
      const isHexInputEvent = (data2) => data2.type === "hex";
      const onValidInput = (form, simulatedEvent) => {
        const data2 = simulatedEvent.event;
        if (isHexInputEvent(data2)) {
          onValidHex(form, data2.value);
        } else {
          onValidRgb(form, data2.type, data2.value);
        }
      };
      const formPartStrings = (key) => ({
        label: translate2(translatePrefix + key + ".label"),
        description: translate2(translatePrefix + key + ".description")
      });
      const redStrings = formPartStrings("red");
      const greenStrings = formPartStrings("green");
      const blueStrings = formPartStrings("blue");
      const hexStrings = formPartStrings("hex");
      return deepMerge(Form.sketch((parts2) => ({
        dom: {
          tag: "form",
          classes: [getClass("rgb-form")],
          attributes: { "aria-label": translate2("aria.color.picker") }
        },
        components: [
          parts2.field("red", FormField.sketch(renderTextField2(isRgbaComponent, "red", redStrings.label, redStrings.description, 255))),
          parts2.field("green", FormField.sketch(renderTextField2(isRgbaComponent, "green", greenStrings.label, greenStrings.description, 255))),
          parts2.field("blue", FormField.sketch(renderTextField2(isRgbaComponent, "blue", blueStrings.label, blueStrings.description, 255))),
          parts2.field("hex", FormField.sketch(renderTextField2(isHexString, "hex", hexStrings.label, hexStrings.description, "ffffff"))),
          memPreview.asSpec()
        ],
        formBehaviours: derive$1([
          Invalidating.config({ invalidClass: getClass("form-invalid") }),
          config("rgb-form-events", [
            run$1(validInput, onValidInput),
            run$1(invalidInput, onInvalidInput),
            run$1(validatingInput, onInvalidInput)
          ])
        ])
      })), {
        apis: {
          updateHex: (form, hex) => {
            Representing.setValue(form, { hex: hex.value });
            copyHexToRgb(form, hex);
            updatePreview(form, hex);
          }
        }
      });
    };
    const rgbFormSketcher = single({
      factory: factory2,
      name: "RgbForm",
      configFields: [],
      apis: {
        updateHex: (apis2, form, hex) => {
          apis2.updateHex(form, hex);
        }
      },
      extraApis: {}
    });
    return rgbFormSketcher;
  };
  const paletteFactory = (_translate, getClass) => {
    const spectrumPart2 = Slider.parts.spectrum({
      dom: {
        tag: "canvas",
        attributes: { role: "presentation" },
        classes: [getClass("sv-palette-spectrum")]
      }
    });
    const thumbPart2 = Slider.parts.thumb({
      dom: {
        tag: "div",
        attributes: { role: "presentation" },
        classes: [getClass("sv-palette-thumb")],
        innerHtml: `<div class=${getClass("sv-palette-inner-thumb")} role="presentation"></div>`
      }
    });
    const setColour = (canvas, rgba) => {
      const { width: width3, height: height3 } = canvas;
      const ctx = canvas.getContext("2d");
      if (ctx === null) {
        return;
      }
      ctx.fillStyle = rgba;
      ctx.fillRect(0, 0, width3, height3);
      const grdWhite = ctx.createLinearGradient(0, 0, width3, 0);
      grdWhite.addColorStop(0, "rgba(255,255,255,1)");
      grdWhite.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grdWhite;
      ctx.fillRect(0, 0, width3, height3);
      const grdBlack = ctx.createLinearGradient(0, 0, 0, height3);
      grdBlack.addColorStop(0, "rgba(0,0,0,0)");
      grdBlack.addColorStop(1, "rgba(0,0,0,1)");
      ctx.fillStyle = grdBlack;
      ctx.fillRect(0, 0, width3, height3);
    };
    const setPaletteHue = (slider, hue) => {
      const canvas = slider.components()[0].element.dom;
      const hsv = hsvColour(hue, 100, 100);
      const rgba = fromHsv(hsv);
      setColour(canvas, toString3(rgba));
    };
    const setPaletteThumb = (slider, hex) => {
      const hsv = fromRgb(fromHex(hex));
      Slider.setValue(slider, {
        x: hsv.saturation,
        y: 100 - hsv.value
      });
    };
    const factory2 = (_detail) => {
      const getInitialValue = constant$1({
        x: 0,
        y: 0
      });
      const onChange = (slider, _thumb, value2) => {
        emitWith(slider, paletteUpdate, { value: value2 });
      };
      const onInit = (_slider, _thumb, spectrum, _value) => {
        setColour(spectrum.element.dom, toString3(red));
      };
      const sliderBehaviours = derive$1([
        Composing.config({ find: Optional.some }),
        Focusing.config({})
      ]);
      return Slider.sketch({
        dom: {
          tag: "div",
          attributes: { role: "presentation" },
          classes: [getClass("sv-palette")]
        },
        model: {
          mode: "xy",
          getInitialValue
        },
        rounded: false,
        components: [
          spectrumPart2,
          thumbPart2
        ],
        onChange,
        onInit,
        sliderBehaviours
      });
    };
    const saturationBrightnessPaletteSketcher = single({
      factory: factory2,
      name: "SaturationBrightnessPalette",
      configFields: [],
      apis: {
        setHue: (_apis, slider, hue) => {
          setPaletteHue(slider, hue);
        },
        setThumb: (_apis, slider, hex) => {
          setPaletteThumb(slider, hex);
        }
      },
      extraApis: {}
    });
    return saturationBrightnessPaletteSketcher;
  };
  const makeFactory = (translate2, getClass) => {
    const factory2 = (detail) => {
      const rgbForm = rgbFormFactory(translate2, getClass, detail.onValidHex, detail.onInvalidHex);
      const sbPalette = paletteFactory(translate2, getClass);
      const hueSliderToDegrees = (hue) => (100 - hue) / 100 * 360;
      const hueDegreesToSlider = (hue) => 100 - hue / 360 * 100;
      const state2 = {
        paletteRgba: Cell(red),
        paletteHue: Cell(0)
      };
      const memSlider = record(sliderFactory(translate2, getClass));
      const memPalette = record(sbPalette.sketch({}));
      const memRgb = record(rgbForm.sketch({}));
      const updatePalette = (anyInSystem, _hex, hue) => {
        memPalette.getOpt(anyInSystem).each((palette) => {
          sbPalette.setHue(palette, hue);
        });
      };
      const updateFields = (anyInSystem, hex) => {
        memRgb.getOpt(anyInSystem).each((form) => {
          rgbForm.updateHex(form, hex);
        });
      };
      const updateSlider = (anyInSystem, _hex, hue) => {
        memSlider.getOpt(anyInSystem).each((slider) => {
          Slider.setValue(slider, hueDegreesToSlider(hue));
        });
      };
      const updatePaletteThumb = (anyInSystem, hex) => {
        memPalette.getOpt(anyInSystem).each((palette) => {
          sbPalette.setThumb(palette, hex);
        });
      };
      const updateState = (hex, hue) => {
        const rgba = fromHex(hex);
        state2.paletteRgba.set(rgba);
        state2.paletteHue.set(hue);
      };
      const runUpdates = (anyInSystem, hex, hue, updates) => {
        updateState(hex, hue);
        each$1(updates, (update) => {
          update(anyInSystem, hex, hue);
        });
      };
      const onPaletteUpdate = () => {
        const updates = [updateFields];
        return (form, simulatedEvent) => {
          const value2 = simulatedEvent.event.value;
          const oldHue = state2.paletteHue.get();
          const newHsv = hsvColour(oldHue, value2.x, 100 - value2.y);
          const newHex = hsvToHex(newHsv);
          runUpdates(form, newHex, oldHue, updates);
        };
      };
      const onSliderUpdate = () => {
        const updates = [
          updatePalette,
          updateFields
        ];
        return (form, simulatedEvent) => {
          const hue = hueSliderToDegrees(simulatedEvent.event.value);
          const oldRgb = state2.paletteRgba.get();
          const oldHsv = fromRgb(oldRgb);
          const newHsv = hsvColour(hue, oldHsv.saturation, oldHsv.value);
          const newHex = hsvToHex(newHsv);
          runUpdates(form, newHex, hue, updates);
        };
      };
      const onFieldsUpdate = () => {
        const updates = [
          updatePalette,
          updateSlider,
          updatePaletteThumb
        ];
        return (form, simulatedEvent) => {
          const hex = simulatedEvent.event.hex;
          const hsv = hexToHsv(hex);
          runUpdates(form, hex, hsv.hue, updates);
        };
      };
      return {
        uid: detail.uid,
        dom: detail.dom,
        components: [
          memPalette.asSpec(),
          memSlider.asSpec(),
          memRgb.asSpec()
        ],
        behaviours: derive$1([
          config("colour-picker-events", [
            run$1(fieldsUpdate, onFieldsUpdate()),
            run$1(paletteUpdate, onPaletteUpdate()),
            run$1(sliderUpdate, onSliderUpdate())
          ]),
          Composing.config({ find: (comp) => memRgb.getOpt(comp) }),
          Keying.config({ mode: "acyclic" })
        ])
      };
    };
    const colourPickerSketcher = single({
      name: "ColourPicker",
      configFields: [
        required$1("dom"),
        defaulted("onValidHex", noop2),
        defaulted("onInvalidHex", noop2)
      ],
      factory: factory2
    });
    return colourPickerSketcher;
  };
  const self2 = () => Composing.config({ find: Optional.some });
  const memento$1 = (mem) => Composing.config({ find: mem.getOpt });
  const childAt = (index) => Composing.config({ find: (comp) => child$2(comp.element, index).bind((element2) => comp.getSystem().getByDom(element2).toOptional()) });
  const ComposingConfigs = {
    self: self2,
    memento: memento$1,
    childAt
  };
  const processors = objOf([
    defaulted("preprocess", identity),
    defaulted("postprocess", identity)
  ]);
  const memento = (mem, rawProcessors) => {
    const ps = asRawOrDie$1("RepresentingConfigs.memento processors", processors, rawProcessors);
    return Representing.config({
      store: {
        mode: "manual",
        getValue: (comp) => {
          const other = mem.get(comp);
          const rawValue = Representing.getValue(other);
          return ps.postprocess(rawValue);
        },
        setValue: (comp, rawValue) => {
          const newValue = ps.preprocess(rawValue);
          const other = mem.get(comp);
          Representing.setValue(other, newValue);
        }
      }
    });
  };
  const withComp = (optInitialValue, getter, setter) => Representing.config({
    store: {
      mode: "manual",
      ...optInitialValue.map((initialValue) => ({ initialValue })).getOr({}),
      getValue: getter,
      setValue: setter
    }
  });
  const withElement = (initialValue, getter, setter) => withComp(initialValue, (c) => getter(c.element), (c, v) => setter(c.element, v));
  const domValue = (optInitialValue) => withElement(optInitialValue, get$6, set$5);
  const domHtml = (optInitialValue) => withElement(optInitialValue, get$9, set$6);
  const memory = (initialValue) => Representing.config({
    store: {
      mode: "memory",
      initialValue
    }
  });
  const RepresentingConfigs = {
    memento,
    withElement,
    withComp,
    domValue,
    domHtml,
    memory
  };
  const english = {
    "colorcustom.rgb.red.label": "R",
    "colorcustom.rgb.red.description": "Red component",
    "colorcustom.rgb.green.label": "G",
    "colorcustom.rgb.green.description": "Green component",
    "colorcustom.rgb.blue.label": "B",
    "colorcustom.rgb.blue.description": "Blue component",
    "colorcustom.rgb.hex.label": "#",
    "colorcustom.rgb.hex.description": "Hex color code",
    "colorcustom.rgb.range": "Range 0 to 255",
    "aria.color.picker": "Color Picker",
    "aria.input.invalid": "Invalid input"
  };
  const translate$1 = (providerBackstage) => (key) => {
    return providerBackstage.translate(english[key]);
  };
  const renderColorPicker = (_spec, providerBackstage, initialData) => {
    const getClass = (key) => "tox-" + key;
    const colourPickerFactory = makeFactory(translate$1(providerBackstage), getClass);
    const onValidHex = (form) => {
      emitWith(form, formActionEvent, {
        name: "hex-valid",
        value: true
      });
    };
    const onInvalidHex = (form) => {
      emitWith(form, formActionEvent, {
        name: "hex-valid",
        value: false
      });
    };
    const memPicker = record(colourPickerFactory.sketch({
      dom: {
        tag: "div",
        classes: [getClass("color-picker-container")],
        attributes: { role: "presentation" }
      },
      onValidHex,
      onInvalidHex
    }));
    return {
      dom: { tag: "div" },
      components: [memPicker.asSpec()],
      behaviours: derive$1([
        RepresentingConfigs.withComp(initialData, (comp) => {
          const picker = memPicker.get(comp);
          const optRgbForm = Composing.getCurrent(picker);
          const optHex = optRgbForm.bind((rgbForm) => {
            const formValues = Representing.getValue(rgbForm);
            return formValues.hex;
          });
          return optHex.map((hex) => "#" + removeLeading(hex, "#")).getOr("");
        }, (comp, newValue) => {
          const pattern2 = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/;
          const valOpt = Optional.from(pattern2.exec(newValue)).bind((matches) => get$h(matches, 1));
          const picker = memPicker.get(comp);
          const optRgbForm = Composing.getCurrent(picker);
          optRgbForm.fold(() => {
            console.log("Can not find form");
          }, (rgbForm) => {
            Representing.setValue(rgbForm, { hex: valOpt.getOr("") });
            Form.getField(rgbForm, "hex").each((hexField) => {
              emit(hexField, input());
            });
          });
        }),
        ComposingConfigs.self()
      ])
    };
  };
  var global$2 = tinymce.util.Tools.resolve("tinymce.Resource");
  const isOldCustomEditor = (spec) => has$2(spec, "init");
  const renderCustomEditor = (spec) => {
    const editorApi = value$2();
    const memReplaced = record({ dom: { tag: spec.tag } });
    const initialValue = value$2();
    return {
      dom: {
        tag: "div",
        classes: ["tox-custom-editor"]
      },
      behaviours: derive$1([
        config("custom-editor-events", [runOnAttached((component) => {
          memReplaced.getOpt(component).each((ta) => {
            (isOldCustomEditor(spec) ? spec.init(ta.element.dom) : global$2.load(spec.scriptId, spec.scriptUrl).then((init2) => init2(ta.element.dom, spec.settings))).then((ea) => {
              initialValue.on((cvalue) => {
                ea.setValue(cvalue);
              });
              initialValue.clear();
              editorApi.set(ea);
            });
          });
        })]),
        RepresentingConfigs.withComp(Optional.none(), () => editorApi.get().fold(() => initialValue.get().getOr(""), (ed) => ed.getValue()), (component, value2) => {
          editorApi.get().fold(() => initialValue.set(value2), (ed) => ed.setValue(value2));
        }),
        ComposingConfigs.self()
      ]),
      components: [memReplaced.asSpec()]
    };
  };
  var global$1 = tinymce.util.Tools.resolve("tinymce.util.Tools");
  const filterByExtension = (files, providersBackstage) => {
    const allowedImageFileTypes = global$1.explode(providersBackstage.getOption("images_file_types"));
    const isFileInAllowedTypes = (file2) => exists(allowedImageFileTypes, (type2) => endsWith2(file2.name.toLowerCase(), `.${type2.toLowerCase()}`));
    return filter$2(from(files), isFileInAllowedTypes);
  };
  const renderDropZone = (spec, providersBackstage, initialData) => {
    const stopper2 = (_2, se) => {
      se.stop();
    };
    const sequence2 = (actions2) => (comp, se) => {
      each$1(actions2, (a) => {
        a(comp, se);
      });
    };
    const onDrop = (comp, se) => {
      var _a;
      if (!Disabling.isDisabled(comp)) {
        const transferEvent = se.event.raw;
        handleFiles(comp, (_a = transferEvent.dataTransfer) === null || _a === void 0 ? void 0 : _a.files);
      }
    };
    const onSelect = (component, simulatedEvent) => {
      const input2 = simulatedEvent.event.raw.target;
      handleFiles(component, input2.files);
    };
    const handleFiles = (component, files) => {
      if (files) {
        Representing.setValue(component, filterByExtension(files, providersBackstage));
        emitWith(component, formChangeEvent, { name: spec.name });
      }
    };
    const memInput = record({
      dom: {
        tag: "input",
        attributes: {
          type: "file",
          accept: "image/*"
        },
        styles: { display: "none" }
      },
      behaviours: derive$1([config("input-file-events", [
        cutter(click()),
        cutter(tap())
      ])])
    });
    const renderField = (s) => ({
      uid: s.uid,
      dom: {
        tag: "div",
        classes: ["tox-dropzone-container"]
      },
      behaviours: derive$1([
        RepresentingConfigs.memory(initialData.getOr([])),
        ComposingConfigs.self(),
        Disabling.config({}),
        Toggling.config({
          toggleClass: "dragenter",
          toggleOnExecute: false
        }),
        config("dropzone-events", [
          run$1("dragenter", sequence2([
            stopper2,
            Toggling.toggle
          ])),
          run$1("dragleave", sequence2([
            stopper2,
            Toggling.toggle
          ])),
          run$1("dragover", stopper2),
          run$1("drop", sequence2([
            stopper2,
            onDrop
          ])),
          run$1(change(), onSelect)
        ])
      ]),
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dropzone"],
          styles: {}
        },
        components: [
          {
            dom: { tag: "p" },
            components: [text$2(providersBackstage.translate("Drop an image here"))]
          },
          Button2.sketch({
            dom: {
              tag: "button",
              styles: { position: "relative" },
              classes: [
                "tox-button",
                "tox-button--secondary"
              ]
            },
            components: [
              text$2(providersBackstage.translate("Browse for an image")),
              memInput.asSpec()
            ],
            action: (comp) => {
              const inputComp = memInput.get(comp);
              inputComp.element.dom.click();
            },
            buttonBehaviours: derive$1([
              Tabstopping.config({}),
              DisablingConfigs.button(providersBackstage.isDisabled),
              receivingConfig()
            ])
          })
        ]
      }]
    });
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const pField = FormField.parts.field({ factory: { sketch: renderField } });
    return renderFormFieldWith(pLabel, pField, ["tox-form__group--stretched"], []);
  };
  const renderGrid = (spec, backstage) => ({
    dom: {
      tag: "div",
      classes: [
        "tox-form__grid",
        `tox-form__grid--${spec.columns}col`
      ]
    },
    components: map$2(spec.items, backstage.interpreter)
  });
  const beforeObject = generate$6("alloy-fake-before-tabstop");
  const afterObject = generate$6("alloy-fake-after-tabstop");
  const craftWithClasses = (classes2) => {
    return {
      dom: {
        tag: "div",
        styles: {
          width: "1px",
          height: "1px",
          outline: "none"
        },
        attributes: { tabindex: "0" },
        classes: classes2
      },
      behaviours: derive$1([
        Focusing.config({ ignore: true }),
        Tabstopping.config({})
      ])
    };
  };
  const craft = (spec) => {
    return {
      dom: {
        tag: "div",
        classes: ["tox-navobj"]
      },
      components: [
        craftWithClasses([beforeObject]),
        spec,
        craftWithClasses([afterObject])
      ],
      behaviours: derive$1([ComposingConfigs.childAt(1)])
    };
  };
  const triggerTab = (placeholder2, shiftKey) => {
    emitWith(placeholder2, keydown(), {
      raw: {
        which: 9,
        shiftKey
      }
    });
  };
  const onFocus = (container, targetComp) => {
    const target = targetComp.element;
    if (has(target, beforeObject)) {
      triggerTab(container, true);
    } else if (has(target, afterObject)) {
      triggerTab(container, false);
    }
  };
  const isPseudoStop = (element2) => {
    return closest(element2, [
      "." + beforeObject,
      "." + afterObject
    ].join(","), never);
  };
  const getDynamicSource = (initialData) => {
    const cachedValue = Cell(initialData.getOr(""));
    return {
      getValue: (_frameComponent) => cachedValue.get(),
      setValue: (frameComponent, html2) => {
        if (cachedValue.get() !== html2) {
          set$9(frameComponent.element, "srcdoc", html2);
        }
        cachedValue.set(html2);
      }
    };
  };
  const renderIFrame = (spec, providersBackstage, initialData) => {
    const isSandbox = spec.sandboxed;
    const isTransparent = spec.transparent;
    const baseClass = "tox-dialog__iframe";
    const attributes = {
      ...spec.label.map((title2) => ({ title: title2 })).getOr({}),
      ...initialData.map((html2) => ({ srcdoc: html2 })).getOr({}),
      ...isSandbox ? { sandbox: "allow-scripts allow-same-origin" } : {}
    };
    const sourcing = getDynamicSource(initialData);
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const factory2 = (newSpec) => craft({
      uid: newSpec.uid,
      dom: {
        tag: "iframe",
        attributes,
        classes: isTransparent ? [baseClass] : [
          baseClass,
          `${baseClass}--opaque`
        ]
      },
      behaviours: derive$1([
        Tabstopping.config({}),
        Focusing.config({}),
        RepresentingConfigs.withComp(initialData, sourcing.getValue, sourcing.setValue)
      ])
    });
    const pField = FormField.parts.field({ factory: { sketch: factory2 } });
    return renderFormFieldWith(pLabel, pField, ["tox-form__group--stretched"], []);
  };
  const image = (image2) => new Promise((resolve2, reject) => {
    const loaded = () => {
      destroy2();
      resolve2(image2);
    };
    const listeners2 = [
      bind2(image2, "load", loaded),
      bind2(image2, "error", () => {
        destroy2();
        reject("Unable to load data from image: " + image2.dom.src);
      })
    ];
    const destroy2 = () => each$1(listeners2, (l2) => l2.unbind());
    if (image2.dom.complete) {
      loaded();
    }
  });
  const calculateImagePosition = (panelWidth, panelHeight, imageWidth, imageHeight, zoom) => {
    const width3 = imageWidth * zoom;
    const height3 = imageHeight * zoom;
    const left3 = Math.max(0, panelWidth / 2 - width3 / 2);
    const top3 = Math.max(0, panelHeight / 2 - height3 / 2);
    return {
      left: left3.toString() + "px",
      top: top3.toString() + "px",
      width: width3.toString() + "px",
      height: height3.toString() + "px"
    };
  };
  const zoomToFit = (panel2, width3, height3) => {
    const panelW = get$c(panel2);
    const panelH = get$d(panel2);
    return Math.min(panelW / width3, panelH / height3, 1);
  };
  const renderImagePreview = (spec, initialData) => {
    const cachedData = Cell(initialData.getOr({ url: "" }));
    const memImage = record({
      dom: {
        tag: "img",
        classes: ["tox-imagepreview__image"],
        attributes: initialData.map((data2) => ({ src: data2.url })).getOr({})
      }
    });
    const memContainer = record({
      dom: {
        tag: "div",
        classes: ["tox-imagepreview__container"],
        attributes: { role: "presentation" }
      },
      components: [memImage.asSpec()]
    });
    const setValue2 = (frameComponent, data2) => {
      const translatedData = { url: data2.url };
      data2.zoom.each((z) => translatedData.zoom = z);
      data2.cachedWidth.each((z) => translatedData.cachedWidth = z);
      data2.cachedHeight.each((z) => translatedData.cachedHeight = z);
      cachedData.set(translatedData);
      const applyFramePositioning = () => {
        const { cachedWidth, cachedHeight, zoom } = translatedData;
        if (!isUndefined2(cachedWidth) && !isUndefined2(cachedHeight)) {
          if (isUndefined2(zoom)) {
            const z = zoomToFit(frameComponent.element, cachedWidth, cachedHeight);
            translatedData.zoom = z;
          }
          const position2 = calculateImagePosition(get$c(frameComponent.element), get$d(frameComponent.element), cachedWidth, cachedHeight, translatedData.zoom);
          memContainer.getOpt(frameComponent).each((container) => {
            setAll(container.element, position2);
          });
        }
      };
      memImage.getOpt(frameComponent).each((imageComponent) => {
        const img = imageComponent.element;
        if (data2.url !== get$f(img, "src")) {
          set$9(img, "src", data2.url);
          remove$2(frameComponent.element, "tox-imagepreview__loaded");
        }
        applyFramePositioning();
        image(img).then((img2) => {
          if (frameComponent.getSystem().isConnected()) {
            add$2(frameComponent.element, "tox-imagepreview__loaded");
            translatedData.cachedWidth = img2.dom.naturalWidth;
            translatedData.cachedHeight = img2.dom.naturalHeight;
            applyFramePositioning();
          }
        });
      });
    };
    const styles2 = {};
    spec.height.each((h) => styles2.height = h);
    const fakeValidatedData = initialData.map((d) => ({
      url: d.url,
      zoom: Optional.from(d.zoom),
      cachedWidth: Optional.from(d.cachedWidth),
      cachedHeight: Optional.from(d.cachedHeight)
    }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-imagepreview"],
        styles: styles2,
        attributes: { role: "presentation" }
      },
      components: [memContainer.asSpec()],
      behaviours: derive$1([
        ComposingConfigs.self(),
        RepresentingConfigs.withComp(fakeValidatedData, () => cachedData.get(), setValue2)
      ])
    };
  };
  const renderLabel$2 = (spec, backstageShared) => {
    const label2 = {
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [text$2(backstageShared.providers.translate(spec.label))]
    };
    const comps = map$2(spec.items, backstageShared.interpreter);
    return {
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [
        label2,
        ...comps
      ],
      behaviours: derive$1([
        ComposingConfigs.self(),
        Replacing.config({}),
        RepresentingConfigs.domHtml(Optional.none()),
        Keying.config({ mode: "acyclic" })
      ])
    };
  };
  const internalToolbarButtonExecute = generate$6("toolbar.button.execute");
  const onToolbarButtonExecute = (info) => runOnExecute$1((comp, _simulatedEvent) => {
    runWithApi(info, comp)((itemApi) => {
      emitWith(comp, internalToolbarButtonExecute, { buttonApi: itemApi });
      info.onAction(itemApi);
    });
  });
  const commonButtonDisplayEvent = generate$6("common-button-display-events");
  const toolbarButtonEventOrder = {
    [execute$5()]: [
      "disabling",
      "alloy.base.behaviour",
      "toggling",
      "toolbar-button-events"
    ],
    [attachedToDom()]: [
      "toolbar-button-events",
      commonButtonDisplayEvent
    ],
    [mousedown()]: [
      "focusing",
      "alloy.base.behaviour",
      commonButtonDisplayEvent
    ]
  };
  const forceInitialSize = (comp) => set$8(comp.element, "width", get$e(comp.element, "width"));
  const renderIcon$1 = (iconName, iconsProvider, behaviours2) => render$3(iconName, {
    tag: "span",
    classes: [
      "tox-icon",
      "tox-tbtn__icon-wrap"
    ],
    behaviours: behaviours2
  }, iconsProvider);
  const renderIconFromPack$1 = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, []);
  const renderReplaceableIconFromPack = (iconName, iconsProvider) => renderIcon$1(iconName, iconsProvider, [Replacing.config({})]);
  const renderLabel$1 = (text3, prefix2, providersBackstage) => ({
    dom: {
      tag: "span",
      classes: [`${prefix2}__select-label`]
    },
    components: [text$2(providersBackstage.translate(text3))],
    behaviours: derive$1([Replacing.config({})])
  });
  const updateMenuText = generate$6("update-menu-text");
  const updateMenuIcon = generate$6("update-menu-icon");
  const renderCommonDropdown = (spec, prefix2, sharedBackstage) => {
    const editorOffCell = Cell(noop2);
    const optMemDisplayText = spec.text.map((text3) => record(renderLabel$1(text3, prefix2, sharedBackstage.providers)));
    const optMemDisplayIcon = spec.icon.map((iconName) => record(renderReplaceableIconFromPack(iconName, sharedBackstage.providers.icons)));
    const onLeftOrRightInMenu = (comp, se) => {
      const dropdown = Representing.getValue(comp);
      Focusing.focus(dropdown);
      emitWith(dropdown, "keydown", { raw: se.event.raw });
      Dropdown2.close(dropdown);
      return Optional.some(true);
    };
    const role = spec.role.fold(() => ({}), (role2) => ({ role: role2 }));
    const tooltipAttributes = spec.tooltip.fold(() => ({}), (tooltip) => {
      const translatedTooltip = sharedBackstage.providers.translate(tooltip);
      return {
        "title": translatedTooltip,
        "aria-label": translatedTooltip
      };
    });
    const iconSpec = render$3("chevron-down", {
      tag: "div",
      classes: [`${prefix2}__select-chevron`]
    }, sharedBackstage.providers.icons);
    const fixWidthBehaviourName = generate$6("common-button-display-events");
    const memDropdown = record(Dropdown2.sketch({
      ...spec.uid ? { uid: spec.uid } : {},
      ...role,
      dom: {
        tag: "button",
        classes: [
          prefix2,
          `${prefix2}--select`
        ].concat(map$2(spec.classes, (c) => `${prefix2}--${c}`)),
        attributes: { ...tooltipAttributes }
      },
      components: componentRenderPipeline([
        optMemDisplayIcon.map((mem) => mem.asSpec()),
        optMemDisplayText.map((mem) => mem.asSpec()),
        Optional.some(iconSpec)
      ]),
      matchWidth: true,
      useMinWidth: true,
      onOpen: (anchor2, dropdownComp, tmenuComp) => {
        if (spec.searchable) {
          focusSearchField(tmenuComp);
        }
      },
      dropdownBehaviours: derive$1([
        ...spec.dropdownBehaviours,
        DisablingConfigs.button(() => spec.disabled || sharedBackstage.providers.isDisabled()),
        receivingConfig(),
        Unselecting.config({}),
        Replacing.config({}),
        config("dropdown-events", [
          onControlAttached(spec, editorOffCell),
          onControlDetached(spec, editorOffCell)
        ]),
        config(fixWidthBehaviourName, [runOnAttached((comp, _se) => forceInitialSize(comp))]),
        config("menubutton-update-display-text", [
          run$1(updateMenuText, (comp, se) => {
            optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
              Replacing.set(displayText, [text$2(sharedBackstage.providers.translate(se.event.text))]);
            });
          }),
          run$1(updateMenuIcon, (comp, se) => {
            optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
              Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, sharedBackstage.providers.icons)]);
            });
          })
        ])
      ]),
      eventOrder: deepMerge(toolbarButtonEventOrder, {
        mousedown: [
          "focusing",
          "alloy.base.behaviour",
          "item-type-events",
          "normal-dropdown-events"
        ],
        [attachedToDom()]: [
          "toolbar-button-events",
          "dropdown-events",
          fixWidthBehaviourName
        ]
      }),
      sandboxBehaviours: derive$1([
        Keying.config({
          mode: "special",
          onLeft: onLeftOrRightInMenu,
          onRight: onLeftOrRightInMenu
        }),
        config("dropdown-sandbox-events", [
          run$1(refetchTriggerEvent, (originalSandboxComp, se) => {
            handleRefetchTrigger(originalSandboxComp);
            se.stop();
          }),
          run$1(redirectMenuItemInteractionEvent, (sandboxComp, se) => {
            handleRedirectToMenuItem(sandboxComp, se);
            se.stop();
          })
        ])
      ]),
      lazySink: sharedBackstage.getSink,
      toggleClass: `${prefix2}--active`,
      parts: {
        menu: {
          ...part(false, spec.columns, spec.presets),
          fakeFocus: spec.searchable,
          onHighlightItem: updateAriaOnHighlight,
          onCollapseMenu: (tmenuComp, itemCompCausingCollapse, nowActiveMenuComp) => {
            Highlighting.getHighlighted(nowActiveMenuComp).each((itemComp) => {
              updateAriaOnHighlight(tmenuComp, nowActiveMenuComp, itemComp);
            });
          },
          onDehighlightItem: updateAriaOnDehighlight
        }
      },
      fetch: (comp) => Future.nu(curry(spec.fetch, comp))
    }));
    return memDropdown.asSpec();
  };
  const isMenuItemReference = (item3) => isString2(item3);
  const isSeparator$2 = (item3) => item3.type === "separator";
  const isExpandingMenuItem = (item3) => has$2(item3, "getSubmenuItems");
  const separator$2 = { type: "separator" };
  const unwrapReferences = (items, menuItems) => {
    const realItems = foldl(items, (acc, item3) => {
      if (isMenuItemReference(item3)) {
        if (item3 === "") {
          return acc;
        } else if (item3 === "|") {
          return acc.length > 0 && !isSeparator$2(acc[acc.length - 1]) ? acc.concat([separator$2]) : acc;
        } else if (has$2(menuItems, item3.toLowerCase())) {
          return acc.concat([menuItems[item3.toLowerCase()]]);
        } else {
          return acc;
        }
      } else {
        return acc.concat([item3]);
      }
    }, []);
    if (realItems.length > 0 && isSeparator$2(realItems[realItems.length - 1])) {
      realItems.pop();
    }
    return realItems;
  };
  const getFromExpandingItem = (item3, menuItems) => {
    const submenuItems = item3.getSubmenuItems();
    const rest = expand(submenuItems, menuItems);
    const newMenus = deepMerge(rest.menus, { [item3.value]: rest.items });
    const newExpansions = deepMerge(rest.expansions, { [item3.value]: item3.value });
    return {
      item: item3,
      menus: newMenus,
      expansions: newExpansions
    };
  };
  const generateValueIfRequired = (item3) => {
    const itemValue = get$g(item3, "value").getOrThunk(() => generate$6("generated-menu-item"));
    return deepMerge({ value: itemValue }, item3);
  };
  const expand = (items, menuItems) => {
    const realItems = unwrapReferences(isString2(items) ? items.split(" ") : items, menuItems);
    return foldr(realItems, (acc, item3) => {
      if (isExpandingMenuItem(item3)) {
        const itemWithValue = generateValueIfRequired(item3);
        const newData = getFromExpandingItem(itemWithValue, menuItems);
        return {
          menus: deepMerge(acc.menus, newData.menus),
          items: [
            newData.item,
            ...acc.items
          ],
          expansions: deepMerge(acc.expansions, newData.expansions)
        };
      } else {
        return {
          ...acc,
          items: [
            item3,
            ...acc.items
          ]
        };
      }
    }, {
      menus: {},
      expansions: {},
      items: []
    });
  };
  const getSearchModeForField = (settings) => {
    return settings.search.fold(() => ({ searchMode: "no-search" }), (searchSettings) => ({
      searchMode: "search-with-field",
      placeholder: searchSettings.placeholder
    }));
  };
  const getSearchModeForResults = (settings) => {
    return settings.search.fold(() => ({ searchMode: "no-search" }), (_2) => ({ searchMode: "search-with-results" }));
  };
  const build = (items, itemResponse, backstage, settings) => {
    const primary2 = generate$6("primary-menu");
    const data2 = expand(items, backstage.shared.providers.menuItems());
    if (data2.items.length === 0) {
      return Optional.none();
    }
    const mainMenuSearchMode = getSearchModeForField(settings);
    const mainMenu = createPartialMenu(primary2, data2.items, itemResponse, backstage, settings.isHorizontalMenu, mainMenuSearchMode);
    const submenuSearchMode = getSearchModeForResults(settings);
    const submenus = map$1(data2.menus, (menuItems, menuName) => createPartialMenu(menuName, menuItems, itemResponse, backstage, false, submenuSearchMode));
    const menus = deepMerge(submenus, wrap$1(primary2, mainMenu));
    return Optional.from(tieredMenu.tieredData(primary2, menus, data2.expansions));
  };
  const isSingleListItem = (item3) => !has$2(item3, "items");
  const dataAttribute = "data-value";
  const fetchItems = (dropdownComp, name3, items, selectedValue) => map$2(items, (item3) => {
    if (!isSingleListItem(item3)) {
      return {
        type: "nestedmenuitem",
        text: item3.text,
        getSubmenuItems: () => fetchItems(dropdownComp, name3, item3.items, selectedValue)
      };
    } else {
      return {
        type: "togglemenuitem",
        text: item3.text,
        value: item3.value,
        active: item3.value === selectedValue,
        onAction: () => {
          Representing.setValue(dropdownComp, item3.value);
          emitWith(dropdownComp, formChangeEvent, { name: name3 });
          Focusing.focus(dropdownComp);
        }
      };
    }
  });
  const findItemByValue = (items, value2) => findMap(items, (item3) => {
    if (!isSingleListItem(item3)) {
      return findItemByValue(item3.items, value2);
    } else {
      return someIf(item3.value === value2, item3);
    }
  });
  const renderListBox = (spec, backstage, initialData) => {
    const providersBackstage = backstage.shared.providers;
    const initialItem = initialData.bind((value2) => findItemByValue(spec.items, value2)).orThunk(() => head(spec.items).filter(isSingleListItem));
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const pField = FormField.parts.field({
      dom: {},
      factory: {
        sketch: (sketchSpec) => renderCommonDropdown({
          uid: sketchSpec.uid,
          text: initialItem.map((item3) => item3.text),
          icon: Optional.none(),
          tooltip: spec.label,
          role: Optional.none(),
          fetch: (comp, callback) => {
            const items = fetchItems(comp, spec.name, spec.items, Representing.getValue(comp));
            callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
              isHorizontalMenu: false,
              search: Optional.none()
            }));
          },
          onSetup: constant$1(noop2),
          getApi: constant$1({}),
          columns: 1,
          presets: "normal",
          classes: [],
          dropdownBehaviours: [
            Tabstopping.config({}),
            RepresentingConfigs.withComp(initialItem.map((item3) => item3.value), (comp) => get$f(comp.element, dataAttribute), (comp, data2) => {
              findItemByValue(spec.items, data2).each((item3) => {
                set$9(comp.element, dataAttribute, item3.value);
                emitWith(comp, updateMenuText, { text: item3.text });
              });
            })
          ]
        }, "tox-listbox", backstage.shared)
      }
    });
    const listBoxWrap = {
      dom: {
        tag: "div",
        classes: ["tox-listboxfield"]
      },
      components: [pField]
    };
    return FormField.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: flatten([
        pLabel.toArray(),
        [listBoxWrap]
      ]),
      fieldBehaviours: derive$1([Disabling.config({
        disabled: constant$1(!spec.enabled),
        onDisabled: (comp) => {
          FormField.getField(comp).each(Disabling.disable);
        },
        onEnabled: (comp) => {
          FormField.getField(comp).each(Disabling.enable);
        }
      })])
    });
  };
  const renderPanel = (spec, backstage) => ({
    dom: {
      tag: "div",
      classes: spec.classes
    },
    components: map$2(spec.items, backstage.shared.interpreter)
  });
  const factory$h = (detail, _spec) => {
    const options = map$2(detail.options, (option3) => ({
      dom: {
        tag: "option",
        value: option3.value,
        innerHtml: option3.text
      }
    }));
    const initialValues = detail.data.map((v) => wrap$1("initialValue", v)).getOr({});
    return {
      uid: detail.uid,
      dom: {
        tag: "select",
        classes: detail.selectClasses,
        attributes: detail.selectAttributes
      },
      components: options,
      behaviours: augment(detail.selectBehaviours, [
        Focusing.config({}),
        Representing.config({
          store: {
            mode: "manual",
            getValue: (select2) => {
              return get$6(select2.element);
            },
            setValue: (select2, newValue) => {
              const found = find$5(detail.options, (opt) => opt.value === newValue);
              if (found.isSome()) {
                set$5(select2.element, newValue);
              }
            },
            ...initialValues
          }
        })
      ])
    };
  };
  const HtmlSelect = single({
    name: "HtmlSelect",
    configFields: [
      required$1("options"),
      field("selectBehaviours", [
        Focusing,
        Representing
      ]),
      defaulted("selectClasses", []),
      defaulted("selectAttributes", {}),
      option$3("data")
    ],
    factory: factory$h
  });
  const renderSelectBox = (spec, providersBackstage, initialData) => {
    const translatedOptions = map$2(spec.items, (item3) => ({
      text: providersBackstage.translate(item3.text),
      value: item3.value
    }));
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const pField = FormField.parts.field({
      dom: {},
      ...initialData.map((data2) => ({ data: data2 })).getOr({}),
      selectAttributes: { size: spec.size },
      options: translatedOptions,
      factory: HtmlSelect,
      selectBehaviours: derive$1([
        Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
        Tabstopping.config({}),
        config("selectbox-change", [run$1(change(), (component, _2) => {
          emitWith(component, formChangeEvent, { name: spec.name });
        })])
      ])
    });
    const chevron = spec.size > 1 ? Optional.none() : Optional.some(render$3("chevron-down", {
      tag: "div",
      classes: ["tox-selectfield__icon-js"]
    }, providersBackstage.icons));
    const selectWrap = {
      dom: {
        tag: "div",
        classes: ["tox-selectfield"]
      },
      components: flatten([
        [pField],
        chevron.toArray()
      ])
    };
    return FormField.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: flatten([
        pLabel.toArray(),
        [selectWrap]
      ]),
      fieldBehaviours: derive$1([
        Disabling.config({
          disabled: () => !spec.enabled || providersBackstage.isDisabled(),
          onDisabled: (comp) => {
            FormField.getField(comp).each(Disabling.disable);
          },
          onEnabled: (comp) => {
            FormField.getField(comp).each(Disabling.enable);
          }
        }),
        receivingConfig()
      ])
    });
  };
  const schema$h = constant$1([
    defaulted("field1Name", "field1"),
    defaulted("field2Name", "field2"),
    onStrictHandler("onLockedChange"),
    markers$1(["lockClass"]),
    defaulted("locked", false),
    SketchBehaviours.field("coupledFieldBehaviours", [
      Composing,
      Representing
    ])
  ]);
  const getField2 = (comp, detail, partName) => getPart(comp, detail, partName).bind(Composing.getCurrent);
  const coupledPart = (selfName, otherName) => required({
    factory: FormField,
    name: selfName,
    overrides: (detail) => {
      return {
        fieldBehaviours: derive$1([config("coupled-input-behaviour", [run$1(input(), (me) => {
          getField2(me, detail, otherName).each((other) => {
            getPart(me, detail, "lock").each((lock) => {
              if (Toggling.isOn(lock)) {
                detail.onLockedChange(me, other, lock);
              }
            });
          });
        })])])
      };
    }
  });
  const parts$c = constant$1([
    coupledPart("field1", "field2"),
    coupledPart("field2", "field1"),
    required({
      factory: Button2,
      schema: [required$1("dom")],
      name: "lock",
      overrides: (detail) => {
        return {
          buttonBehaviours: derive$1([Toggling.config({
            selected: detail.locked,
            toggleClass: detail.markers.lockClass,
            aria: { mode: "pressed" }
          })])
        };
      }
    })
  ]);
  const factory$g = (detail, components2, _spec, _externals) => ({
    uid: detail.uid,
    dom: detail.dom,
    components: components2,
    behaviours: SketchBehaviours.augment(detail.coupledFieldBehaviours, [
      Composing.config({ find: Optional.some }),
      Representing.config({
        store: {
          mode: "manual",
          getValue: (comp) => {
            const parts2 = getPartsOrDie(comp, detail, [
              "field1",
              "field2"
            ]);
            return {
              [detail.field1Name]: Representing.getValue(parts2.field1()),
              [detail.field2Name]: Representing.getValue(parts2.field2())
            };
          },
          setValue: (comp, value2) => {
            const parts2 = getPartsOrDie(comp, detail, [
              "field1",
              "field2"
            ]);
            if (hasNonNullableKey(value2, detail.field1Name)) {
              Representing.setValue(parts2.field1(), value2[detail.field1Name]);
            }
            if (hasNonNullableKey(value2, detail.field2Name)) {
              Representing.setValue(parts2.field2(), value2[detail.field2Name]);
            }
          }
        }
      })
    ]),
    apis: {
      getField1: (component) => getPart(component, detail, "field1"),
      getField2: (component) => getPart(component, detail, "field2"),
      getLock: (component) => getPart(component, detail, "lock")
    }
  });
  const FormCoupledInputs = composite({
    name: "FormCoupledInputs",
    configFields: schema$h(),
    partFields: parts$c(),
    factory: factory$g,
    apis: {
      getField1: (apis2, component) => apis2.getField1(component),
      getField2: (apis2, component) => apis2.getField2(component),
      getLock: (apis2, component) => apis2.getLock(component)
    }
  });
  const formatSize = (size) => {
    const unitDec = {
      "": 0,
      "px": 0,
      "pt": 1,
      "mm": 1,
      "pc": 2,
      "ex": 2,
      "em": 2,
      "ch": 2,
      "rem": 2,
      "cm": 3,
      "in": 4,
      "%": 4
    };
    const maxDecimal = (unit) => unit in unitDec ? unitDec[unit] : 1;
    let numText = size.value.toFixed(maxDecimal(size.unit));
    if (numText.indexOf(".") !== -1) {
      numText = numText.replace(/\.?0*$/, "");
    }
    return numText + size.unit;
  };
  const parseSize = (sizeText) => {
    const numPattern = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/;
    const match = numPattern.exec(sizeText);
    if (match !== null) {
      const value2 = parseFloat(match[1]);
      const unit = match[2];
      return Result.value({
        value: value2,
        unit
      });
    } else {
      return Result.error(sizeText);
    }
  };
  const convertUnit = (size, unit) => {
    const inInch = {
      "": 96,
      "px": 96,
      "pt": 72,
      "cm": 2.54,
      "pc": 12,
      "mm": 25.4,
      "in": 1
    };
    const supported3 = (u) => has$2(inInch, u);
    if (size.unit === unit) {
      return Optional.some(size.value);
    } else if (supported3(size.unit) && supported3(unit)) {
      if (inInch[size.unit] === inInch[unit]) {
        return Optional.some(size.value);
      } else {
        return Optional.some(size.value / inInch[size.unit] * inInch[unit]);
      }
    } else {
      return Optional.none();
    }
  };
  const noSizeConversion = (_input) => Optional.none();
  const ratioSizeConversion = (scale, unit) => (size) => convertUnit(size, unit).map((value2) => ({
    value: value2 * scale,
    unit
  }));
  const makeRatioConverter = (currentFieldText, otherFieldText) => {
    const cValue = parseSize(currentFieldText).toOptional();
    const oValue = parseSize(otherFieldText).toOptional();
    return lift2(cValue, oValue, (cSize, oSize) => convertUnit(cSize, oSize.unit).map((val) => oSize.value / val).map((r2) => ratioSizeConversion(r2, oSize.unit)).getOr(noSizeConversion)).getOr(noSizeConversion);
  };
  const renderSizeInput = (spec, providersBackstage) => {
    let converter = noSizeConversion;
    const ratioEvent = generate$6("ratio-event");
    const makeIcon = (iconName) => render$3(iconName, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-lock-icon__" + iconName
      ]
    }, providersBackstage.icons);
    const pLock = FormCoupledInputs.parts.lock({
      dom: {
        tag: "button",
        classes: [
          "tox-lock",
          "tox-button",
          "tox-button--naked",
          "tox-button--icon"
        ],
        attributes: { title: providersBackstage.translate(spec.label.getOr("Constrain proportions")) }
      },
      components: [
        makeIcon("lock"),
        makeIcon("unlock")
      ],
      buttonBehaviours: derive$1([
        Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
        receivingConfig(),
        Tabstopping.config({})
      ])
    });
    const formGroup = (components2) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: components2
    });
    const getFieldPart = (isField1) => FormField.parts.field({
      factory: Input,
      inputClasses: ["tox-textfield"],
      inputBehaviours: derive$1([
        Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
        receivingConfig(),
        Tabstopping.config({}),
        config("size-input-events", [
          run$1(focusin(), (component, _simulatedEvent) => {
            emitWith(component, ratioEvent, { isField1 });
          }),
          run$1(change(), (component, _simulatedEvent) => {
            emitWith(component, formChangeEvent, { name: spec.name });
          })
        ])
      ]),
      selectOnFocus: false
    });
    const getLabel = (label2) => ({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [text$2(providersBackstage.translate(label2))]
    });
    const widthField = FormCoupledInputs.parts.field1(formGroup([
      FormField.parts.label(getLabel("Width")),
      getFieldPart(true)
    ]));
    const heightField = FormCoupledInputs.parts.field2(formGroup([
      FormField.parts.label(getLabel("Height")),
      getFieldPart(false)
    ]));
    return FormCoupledInputs.sketch({
      dom: {
        tag: "div",
        classes: ["tox-form__group"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: [
          widthField,
          heightField,
          formGroup([
            getLabel(nbsp),
            pLock
          ])
        ]
      }],
      field1Name: "width",
      field2Name: "height",
      locked: true,
      markers: { lockClass: "tox-locked" },
      onLockedChange: (current, other, _lock) => {
        parseSize(Representing.getValue(current)).each((size) => {
          converter(size).each((newSize) => {
            Representing.setValue(other, formatSize(newSize));
          });
        });
      },
      coupledFieldBehaviours: derive$1([
        Disabling.config({
          disabled: () => !spec.enabled || providersBackstage.isDisabled(),
          onDisabled: (comp) => {
            FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.disable);
            FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.disable);
            FormCoupledInputs.getLock(comp).each(Disabling.disable);
          },
          onEnabled: (comp) => {
            FormCoupledInputs.getField1(comp).bind(FormField.getField).each(Disabling.enable);
            FormCoupledInputs.getField2(comp).bind(FormField.getField).each(Disabling.enable);
            FormCoupledInputs.getLock(comp).each(Disabling.enable);
          }
        }),
        receivingConfig(),
        config("size-input-events2", [run$1(ratioEvent, (component, simulatedEvent) => {
          const isField1 = simulatedEvent.event.isField1;
          const optCurrent = isField1 ? FormCoupledInputs.getField1(component) : FormCoupledInputs.getField2(component);
          const optOther = isField1 ? FormCoupledInputs.getField2(component) : FormCoupledInputs.getField1(component);
          const value1 = optCurrent.map(Representing.getValue).getOr("");
          const value2 = optOther.map(Representing.getValue).getOr("");
          converter = makeRatioConverter(value1, value2);
        })])
      ])
    });
  };
  const renderSlider = (spec, providerBackstage, initialData) => {
    const labelPart2 = Slider.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [text$2(providerBackstage.translate(spec.label))]
    });
    const spectrum = Slider.parts.spectrum({
      dom: {
        tag: "div",
        classes: ["tox-slider__rail"],
        attributes: { role: "presentation" }
      }
    });
    const thumb = Slider.parts.thumb({
      dom: {
        tag: "div",
        classes: ["tox-slider__handle"],
        attributes: { role: "presentation" }
      }
    });
    return Slider.sketch({
      dom: {
        tag: "div",
        classes: ["tox-slider"],
        attributes: { role: "presentation" }
      },
      model: {
        mode: "x",
        minX: spec.min,
        maxX: spec.max,
        getInitialValue: constant$1(initialData.getOrThunk(() => (Math.abs(spec.max) - Math.abs(spec.min)) / 2))
      },
      components: [
        labelPart2,
        spectrum,
        thumb
      ],
      sliderBehaviours: derive$1([
        ComposingConfigs.self(),
        Focusing.config({})
      ]),
      onChoose: (component, thumb2, value2) => {
        emitWith(component, formChangeEvent, {
          name: spec.name,
          value: value2
        });
      }
    });
  };
  const renderTable = (spec, providersBackstage) => {
    const renderTh = (text3) => ({
      dom: {
        tag: "th",
        innerHtml: providersBackstage.translate(text3)
      }
    });
    const renderHeader2 = (header) => ({
      dom: { tag: "thead" },
      components: [{
        dom: { tag: "tr" },
        components: map$2(header, renderTh)
      }]
    });
    const renderTd = (text3) => ({
      dom: {
        tag: "td",
        innerHtml: providersBackstage.translate(text3)
      }
    });
    const renderTr = (row) => ({
      dom: { tag: "tr" },
      components: map$2(row, renderTd)
    });
    const renderRows = (rows) => ({
      dom: { tag: "tbody" },
      components: map$2(rows, renderTr)
    });
    return {
      dom: {
        tag: "table",
        classes: ["tox-dialog__table"]
      },
      components: [
        renderHeader2(spec.header),
        renderRows(spec.cells)
      ],
      behaviours: derive$1([
        Tabstopping.config({}),
        Focusing.config({})
      ])
    };
  };
  const renderTextField = (spec, providersBackstage) => {
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const baseInputBehaviours = [
      Disabling.config({ disabled: () => spec.disabled || providersBackstage.isDisabled() }),
      receivingConfig(),
      Keying.config({
        mode: "execution",
        useEnter: spec.multiline !== true,
        useControlEnter: spec.multiline === true,
        execute: (comp) => {
          emit(comp, formSubmitEvent);
          return Optional.some(true);
        }
      }),
      config("textfield-change", [
        run$1(input(), (component, _2) => {
          emitWith(component, formChangeEvent, { name: spec.name });
        }),
        run$1(postPaste(), (component, _2) => {
          emitWith(component, formChangeEvent, { name: spec.name });
        })
      ]),
      Tabstopping.config({})
    ];
    const validatingBehaviours = spec.validation.map((vl) => Invalidating.config({
      getRoot: (input2) => {
        return parentElement(input2.element);
      },
      invalidClass: "tox-invalid",
      validator: {
        validate: (input2) => {
          const v = Representing.getValue(input2);
          const result = vl.validator(v);
          return Future.pure(result === true ? Result.value(v) : Result.error(result));
        },
        validateOnLoad: vl.validateOnLoad
      }
    })).toArray();
    const placeholder2 = spec.placeholder.fold(constant$1({}), (p) => ({ placeholder: providersBackstage.translate(p) }));
    const inputMode = spec.inputMode.fold(constant$1({}), (mode) => ({ inputmode: mode }));
    const inputAttributes = {
      ...placeholder2,
      ...inputMode
    };
    const pField = FormField.parts.field({
      tag: spec.multiline === true ? "textarea" : "input",
      ...spec.data.map((data2) => ({ data: data2 })).getOr({}),
      inputAttributes,
      inputClasses: [spec.classname],
      inputBehaviours: derive$1(flatten([
        baseInputBehaviours,
        validatingBehaviours
      ])),
      selectOnFocus: false,
      factory: Input
    });
    const pTextField = spec.multiline ? {
      dom: {
        tag: "div",
        classes: ["tox-textarea-wrap"]
      },
      components: [pField]
    } : pField;
    const extraClasses = spec.flex ? ["tox-form__group--stretched"] : [];
    const extraClasses2 = extraClasses.concat(spec.maximized ? ["tox-form-group--maximize"] : []);
    const extraBehaviours = [
      Disabling.config({
        disabled: () => spec.disabled || providersBackstage.isDisabled(),
        onDisabled: (comp) => {
          FormField.getField(comp).each(Disabling.disable);
        },
        onEnabled: (comp) => {
          FormField.getField(comp).each(Disabling.enable);
        }
      }),
      receivingConfig()
    ];
    return renderFormFieldWith(pLabel, pTextField, extraClasses2, extraBehaviours);
  };
  const renderInput = (spec, providersBackstage, initialData) => renderTextField({
    name: spec.name,
    multiline: false,
    label: spec.label,
    inputMode: spec.inputMode,
    placeholder: spec.placeholder,
    flex: false,
    disabled: !spec.enabled,
    classname: "tox-textfield",
    validation: Optional.none(),
    maximized: spec.maximized,
    data: initialData
  }, providersBackstage);
  const renderTextarea = (spec, providersBackstage, initialData) => renderTextField({
    name: spec.name,
    multiline: true,
    label: spec.label,
    inputMode: Optional.none(),
    placeholder: spec.placeholder,
    flex: true,
    disabled: !spec.enabled,
    classname: "tox-textarea",
    validation: Optional.none(),
    maximized: spec.maximized,
    data: initialData
  }, providersBackstage);
  const getAnimationRoot = (component, slideConfig) => slideConfig.getAnimationRoot.fold(() => component.element, (get2) => get2(component));
  const getDimensionProperty = (slideConfig) => slideConfig.dimension.property;
  const getDimension = (slideConfig, elem) => slideConfig.dimension.getDimension(elem);
  const disableTransitions = (component, slideConfig) => {
    const root2 = getAnimationRoot(component, slideConfig);
    remove$1(root2, [
      slideConfig.shrinkingClass,
      slideConfig.growingClass
    ]);
  };
  const setShrunk = (component, slideConfig) => {
    remove$2(component.element, slideConfig.openClass);
    add$2(component.element, slideConfig.closedClass);
    set$8(component.element, getDimensionProperty(slideConfig), "0px");
    reflow2(component.element);
  };
  const setGrown = (component, slideConfig) => {
    remove$2(component.element, slideConfig.closedClass);
    add$2(component.element, slideConfig.openClass);
    remove$6(component.element, getDimensionProperty(slideConfig));
  };
  const doImmediateShrink = (component, slideConfig, slideState, _calculatedSize) => {
    slideState.setCollapsed();
    set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
    disableTransitions(component, slideConfig);
    setShrunk(component, slideConfig);
    slideConfig.onStartShrink(component);
    slideConfig.onShrunk(component);
  };
  const doStartShrink = (component, slideConfig, slideState, calculatedSize) => {
    const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));
    slideState.setCollapsed();
    set$8(component.element, getDimensionProperty(slideConfig), size);
    reflow2(component.element);
    const root2 = getAnimationRoot(component, slideConfig);
    remove$2(root2, slideConfig.growingClass);
    add$2(root2, slideConfig.shrinkingClass);
    setShrunk(component, slideConfig);
    slideConfig.onStartShrink(component);
  };
  const doStartSmartShrink = (component, slideConfig, slideState) => {
    const size = getDimension(slideConfig, component.element);
    const shrinker = size === "0px" ? doImmediateShrink : doStartShrink;
    shrinker(component, slideConfig, slideState, Optional.some(size));
  };
  const doStartGrow = (component, slideConfig, slideState) => {
    const root2 = getAnimationRoot(component, slideConfig);
    const wasShrinking = has(root2, slideConfig.shrinkingClass);
    const beforeSize = getDimension(slideConfig, component.element);
    setGrown(component, slideConfig);
    const fullSize = getDimension(slideConfig, component.element);
    const startPartialGrow = () => {
      set$8(component.element, getDimensionProperty(slideConfig), beforeSize);
      reflow2(component.element);
    };
    const startCompleteGrow = () => {
      setShrunk(component, slideConfig);
    };
    const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
    setStartSize();
    remove$2(root2, slideConfig.shrinkingClass);
    add$2(root2, slideConfig.growingClass);
    setGrown(component, slideConfig);
    set$8(component.element, getDimensionProperty(slideConfig), fullSize);
    slideState.setExpanded();
    slideConfig.onStartGrow(component);
  };
  const refresh$4 = (component, slideConfig, slideState) => {
    if (slideState.isExpanded()) {
      remove$6(component.element, getDimensionProperty(slideConfig));
      const fullSize = getDimension(slideConfig, component.element);
      set$8(component.element, getDimensionProperty(slideConfig), fullSize);
    }
  };
  const grow = (component, slideConfig, slideState) => {
    if (!slideState.isExpanded()) {
      doStartGrow(component, slideConfig, slideState);
    }
  };
  const shrink = (component, slideConfig, slideState) => {
    if (slideState.isExpanded()) {
      doStartSmartShrink(component, slideConfig, slideState);
    }
  };
  const immediateShrink = (component, slideConfig, slideState) => {
    if (slideState.isExpanded()) {
      doImmediateShrink(component, slideConfig, slideState);
    }
  };
  const hasGrown = (component, slideConfig, slideState) => slideState.isExpanded();
  const hasShrunk = (component, slideConfig, slideState) => slideState.isCollapsed();
  const isGrowing = (component, slideConfig, _slideState) => {
    const root2 = getAnimationRoot(component, slideConfig);
    return has(root2, slideConfig.growingClass) === true;
  };
  const isShrinking = (component, slideConfig, _slideState) => {
    const root2 = getAnimationRoot(component, slideConfig);
    return has(root2, slideConfig.shrinkingClass) === true;
  };
  const isTransitioning = (component, slideConfig, slideState) => isGrowing(component, slideConfig) || isShrinking(component, slideConfig);
  const toggleGrow = (component, slideConfig, slideState) => {
    const f2 = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
    f2(component, slideConfig, slideState);
  };
  const immediateGrow = (component, slideConfig, slideState) => {
    if (!slideState.isExpanded()) {
      setGrown(component, slideConfig);
      set$8(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
      disableTransitions(component, slideConfig);
      slideState.setExpanded();
      slideConfig.onStartGrow(component);
      slideConfig.onGrown(component);
    }
  };
  var SlidingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: refresh$4,
    grow,
    shrink,
    immediateShrink,
    hasGrown,
    hasShrunk,
    isGrowing,
    isShrinking,
    isTransitioning,
    toggleGrow,
    disableTransitions,
    immediateGrow
  });
  const exhibit = (base2, slideConfig, _slideState) => {
    const expanded = slideConfig.expanded;
    return expanded ? nu$7({
      classes: [slideConfig.openClass],
      styles: {}
    }) : nu$7({
      classes: [slideConfig.closedClass],
      styles: wrap$1(slideConfig.dimension.property, "0px")
    });
  };
  const events$6 = (slideConfig, slideState) => derive$2([runOnSource(transitionend(), (component, simulatedEvent) => {
    const raw = simulatedEvent.event.raw;
    if (raw.propertyName === slideConfig.dimension.property) {
      disableTransitions(component, slideConfig);
      if (slideState.isExpanded()) {
        remove$6(component.element, slideConfig.dimension.property);
      }
      const notify = slideState.isExpanded() ? slideConfig.onGrown : slideConfig.onShrunk;
      notify(component);
    }
  })]);
  var ActiveSliding = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    exhibit,
    events: events$6
  });
  var SlidingSchema = [
    required$1("closedClass"),
    required$1("openClass"),
    required$1("shrinkingClass"),
    required$1("growingClass"),
    option$3("getAnimationRoot"),
    onHandler("onShrunk"),
    onHandler("onStartShrink"),
    onHandler("onGrown"),
    onHandler("onStartGrow"),
    defaulted("expanded", false),
    requiredOf("dimension", choose$1("property", {
      width: [
        output$1("property", "width"),
        output$1("getDimension", (elem) => get$c(elem) + "px")
      ],
      height: [
        output$1("property", "height"),
        output$1("getDimension", (elem) => get$d(elem) + "px")
      ]
    }))
  ];
  const init$9 = (spec) => {
    const state2 = Cell(spec.expanded);
    const readState = () => "expanded: " + state2.get();
    return nu$8({
      isExpanded: () => state2.get() === true,
      isCollapsed: () => state2.get() === false,
      setCollapsed: curry(state2.set, false),
      setExpanded: curry(state2.set, true),
      readState
    });
  };
  var SlidingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$9
  });
  const Sliding = create$42({
    fields: SlidingSchema,
    name: "sliding",
    active: ActiveSliding,
    apis: SlidingApis,
    state: SlidingState
  });
  const getMenuButtonApi = (component) => ({
    isEnabled: () => !Disabling.isDisabled(component),
    setEnabled: (state2) => Disabling.set(component, !state2),
    setActive: (state2) => {
      const elm = component.element;
      if (state2) {
        add$2(elm, "tox-tbtn--enabled");
        set$9(elm, "aria-pressed", true);
      } else {
        remove$2(elm, "tox-tbtn--enabled");
        remove$7(elm, "aria-pressed");
      }
    },
    isActive: () => has(component.element, "tox-tbtn--enabled"),
    setText: (text3) => {
      emitWith(component, updateMenuText, { text: text3 });
    },
    setIcon: (icon2) => emitWith(component, updateMenuIcon, { icon: icon2 })
  });
  const renderMenuButton = (spec, prefix2, backstage, role, tabstopping = true) => {
    return renderCommonDropdown({
      text: spec.text,
      icon: spec.icon,
      tooltip: spec.tooltip,
      searchable: spec.search.isSome(),
      role,
      fetch: (dropdownComp, callback) => {
        const fetchContext = { pattern: spec.search.isSome() ? getSearchPattern(dropdownComp) : "" };
        spec.fetch((items) => {
          callback(build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
            isHorizontalMenu: false,
            search: spec.search
          }));
        }, fetchContext, getMenuButtonApi(dropdownComp));
      },
      onSetup: spec.onSetup,
      getApi: getMenuButtonApi,
      columns: 1,
      presets: "normal",
      classes: [],
      dropdownBehaviours: [...tabstopping ? [Tabstopping.config({})] : []]
    }, prefix2, backstage.shared);
  };
  const getFetch = (items, getButton, backstage) => {
    const getMenuItemAction = (item3) => (api2) => {
      const newValue = !api2.isActive();
      api2.setActive(newValue);
      item3.storage.set(newValue);
      backstage.shared.getSink().each((sink) => {
        getButton().getOpt(sink).each((orig) => {
          focus$3(orig.element);
          emitWith(orig, formActionEvent, {
            name: item3.name,
            value: item3.storage.get()
          });
        });
      });
    };
    const getMenuItemSetup = (item3) => (api2) => {
      api2.setActive(item3.storage.get());
    };
    return (success) => {
      success(map$2(items, (item3) => {
        const text3 = item3.text.fold(() => ({}), (text4) => ({ text: text4 }));
        return {
          type: item3.type,
          active: false,
          ...text3,
          onAction: getMenuItemAction(item3),
          onSetup: getMenuItemSetup(item3)
        };
      }));
    };
  };
  const renderLabel = (text3) => ({
    dom: {
      tag: "span",
      classes: ["tox-tree__label"],
      attributes: {
        "title": text3,
        "aria-label": text3
      }
    },
    components: [text$2(text3)]
  });
  const leafLabelEventsId = generate$6("leaf-label-event-id");
  const renderLeafLabel = ({ leaf: leaf2, onLeafAction, visible, treeId, backstage }) => {
    const internalMenuButton = leaf2.menu.map((btn) => renderMenuButton(btn, "tox-mbtn", backstage, Optional.none(), visible));
    const components2 = [renderLabel(leaf2.title)];
    internalMenuButton.each((btn) => components2.push(btn));
    return Button2.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--leaf__label",
          "tox-trbtn"
        ].concat(visible ? ["tox-tree--leaf__label--visible"] : [])
      },
      components: components2,
      role: "treeitem",
      action: (button2) => {
        onLeafAction(leaf2.id);
        button2.getSystem().broadcastOn([`update-active-item-${treeId}`], { value: leaf2.id });
      },
      eventOrder: {
        [keydown()]: [
          leafLabelEventsId,
          "keying"
        ]
      },
      buttonBehaviours: derive$1([
        ...visible ? [Tabstopping.config({})] : [],
        Toggling.config({
          toggleClass: "tox-trbtn--enabled",
          toggleOnExecute: false,
          aria: { mode: "selected" }
        }),
        Receiving.config({
          channels: {
            [`update-active-item-${treeId}`]: {
              onReceive: (comp, message) => {
                (message.value === leaf2.id ? Toggling.on : Toggling.off)(comp);
              }
            }
          }
        }),
        config(leafLabelEventsId, [run$1(keydown(), (comp, se) => {
          const isLeftArrowKey = se.event.raw.code === "ArrowLeft";
          const isRightArrowKey = se.event.raw.code === "ArrowRight";
          if (isLeftArrowKey) {
            ancestor(comp.element, ".tox-tree--directory").each((dirElement) => {
              comp.getSystem().getByDom(dirElement).each((dirComp) => {
                child(dirElement, ".tox-tree--directory__label").each((dirLabelElement) => {
                  dirComp.getSystem().getByDom(dirLabelElement).each(Focusing.focus);
                });
              });
            });
            se.stop();
          } else if (isRightArrowKey) {
            se.stop();
          }
        })])
      ])
    });
  };
  const renderIcon = (iconName, iconsProvider, behaviours2) => render$3(iconName, {
    tag: "span",
    classes: [
      "tox-tree__icon-wrap",
      "tox-icon"
    ],
    behaviours: behaviours2
  }, iconsProvider);
  const renderIconFromPack = (iconName, iconsProvider) => renderIcon(iconName, iconsProvider, []);
  const directoryLabelEventsId = generate$6("directory-label-event-id");
  const renderDirectoryLabel = ({ directory, visible, noChildren, backstage }) => {
    const internalMenuButton = directory.menu.map((btn) => renderMenuButton(btn, "tox-mbtn", backstage, Optional.none()));
    const components2 = [
      {
        dom: {
          tag: "div",
          classes: ["tox-chevron"]
        },
        components: [renderIconFromPack("chevron-right", backstage.shared.providers.icons)]
      },
      renderLabel(directory.title)
    ];
    internalMenuButton.each((btn) => {
      components2.push(btn);
    });
    const expandChildren = (button2) => {
      ancestor(button2.element, ".tox-tree--directory").each((directoryEle) => {
        button2.getSystem().getByDom(directoryEle).each((directoryComp) => Toggling.toggle(directoryComp));
      });
    };
    return Button2.sketch({
      dom: {
        tag: "div",
        classes: [
          "tox-tree--directory__label",
          "tox-trbtn"
        ].concat(visible ? ["tox-tree--directory__label--visible"] : [])
      },
      components: components2,
      action: expandChildren,
      eventOrder: {
        [keydown()]: [
          directoryLabelEventsId,
          "keying"
        ]
      },
      buttonBehaviours: derive$1([
        ...visible ? [Tabstopping.config({})] : [],
        config(directoryLabelEventsId, [run$1(keydown(), (comp, se) => {
          const isRightArrowKey = se.event.raw.code === "ArrowRight";
          const isLeftArrowKey = se.event.raw.code === "ArrowLeft";
          if (isRightArrowKey && noChildren) {
            se.stop();
          }
          if (isRightArrowKey || isLeftArrowKey) {
            ancestor(comp.element, ".tox-tree--directory").each((directoryEle) => {
              comp.getSystem().getByDom(directoryEle).each((directoryComp) => {
                if (!Toggling.isOn(directoryComp) && isRightArrowKey || Toggling.isOn(directoryComp) && isLeftArrowKey) {
                  expandChildren(comp);
                  se.stop();
                } else if (isLeftArrowKey && !Toggling.isOn(directoryComp)) {
                  ancestor(directoryComp.element, ".tox-tree--directory").each((parentDirElement) => {
                    child(parentDirElement, ".tox-tree--directory__label").each((parentDirLabelElement) => {
                      directoryComp.getSystem().getByDom(parentDirLabelElement).each(Focusing.focus);
                    });
                  });
                  se.stop();
                }
              });
            });
          }
        })])
      ])
    });
  };
  const renderDirectoryChildren = ({ children: children2, onLeafAction, visible, treeId, backstage }) => {
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree--directory__children"]
      },
      components: children2.map((item3) => {
        return item3.type === "leaf" ? renderLeafLabel({
          leaf: item3,
          onLeafAction,
          visible,
          treeId,
          backstage
        }) : renderDirectory({
          directory: item3,
          onLeafAction,
          labelTabstopping: visible,
          treeId,
          backstage
        });
      }),
      behaviours: derive$1([
        Sliding.config({
          dimension: { property: "height" },
          closedClass: "tox-tree--directory__children--closed",
          openClass: "tox-tree--directory__children--open",
          growingClass: "tox-tree--directory__children--growing",
          shrinkingClass: "tox-tree--directory__children--shrinking"
        }),
        Replacing.config({})
      ])
    };
  };
  const renderDirectory = ({ directory, onLeafAction, labelTabstopping, treeId, backstage }) => {
    const { children: children2 } = directory;
    const computedChildrenComponents = (visible) => children2.map((item3) => {
      return item3.type === "leaf" ? renderLeafLabel({
        leaf: item3,
        onLeafAction,
        visible,
        treeId,
        backstage
      }) : renderDirectory({
        directory: item3,
        onLeafAction,
        labelTabstopping: visible,
        treeId,
        backstage
      });
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree--directory"],
        attributes: { role: "treeitem" }
      },
      components: [
        renderDirectoryLabel({
          directory,
          visible: labelTabstopping,
          noChildren: directory.children.length === 0,
          backstage
        }),
        renderDirectoryChildren({
          children: children2,
          onLeafAction,
          visible: false,
          treeId,
          backstage
        })
      ],
      behaviours: derive$1([Toggling.config({
        ...directory.children.length > 0 ? { aria: { mode: "expanded" } } : {},
        toggleClass: "tox-tree--directory--expanded",
        onToggled: (comp, childrenVisible) => {
          const childrenComp = comp.components()[1];
          const newChildren = computedChildrenComponents(childrenVisible);
          if (childrenVisible) {
            Sliding.grow(childrenComp);
          } else {
            Sliding.shrink(childrenComp);
          }
          Replacing.set(childrenComp, newChildren);
        }
      })])
    };
  };
  const renderTree = (spec, backstage) => {
    const onLeafAction = spec.onLeafAction.getOr(noop2);
    const treeId = generate$6("tree-id");
    const children2 = spec.items.map((item3) => {
      return item3.type === "leaf" ? renderLeafLabel({
        leaf: item3,
        onLeafAction,
        visible: true,
        treeId,
        backstage
      }) : renderDirectory({
        directory: item3,
        onLeafAction,
        labelTabstopping: true,
        treeId,
        backstage
      });
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-tree"],
        attributes: { role: "tree" }
      },
      components: children2,
      behaviours: derive$1([Keying.config({
        mode: "flow",
        selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
        cycles: false
      })])
    };
  };
  const events$5 = (streamConfig, streamState) => {
    const streams = streamConfig.stream.streams;
    const processor = streams.setup(streamConfig, streamState);
    return derive$2([
      run$1(streamConfig.event, processor),
      runOnDetached(() => streamState.cancel())
    ].concat(streamConfig.cancelEvent.map((e) => [run$1(e, () => streamState.cancel())]).getOr([])));
  };
  var ActiveStreaming = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$5
  });
  const first = (fn3, rate) => {
    let timer = null;
    const cancel = () => {
      if (!isNull2(timer)) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const throttle2 = (...args) => {
      if (isNull2(timer)) {
        timer = setTimeout(() => {
          timer = null;
          fn3.apply(null, args);
        }, rate);
      }
    };
    return {
      cancel,
      throttle: throttle2
    };
  };
  const last = (fn3, rate) => {
    let timer = null;
    const cancel = () => {
      if (!isNull2(timer)) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const throttle2 = (...args) => {
      cancel();
      timer = setTimeout(() => {
        timer = null;
        fn3.apply(null, args);
      }, rate);
    };
    return {
      cancel,
      throttle: throttle2
    };
  };
  const throttle = (_config) => {
    const state2 = Cell(null);
    const readState = () => ({ timer: state2.get() !== null ? "set" : "unset" });
    const setTimer = (t2) => {
      state2.set(t2);
    };
    const cancel = () => {
      const t2 = state2.get();
      if (t2 !== null) {
        t2.cancel();
      }
    };
    return nu$8({
      readState,
      setTimer,
      cancel
    });
  };
  const init$8 = (spec) => spec.stream.streams.state(spec);
  var StreamingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    throttle,
    init: init$8
  });
  const setup$c = (streamInfo, streamState) => {
    const sInfo = streamInfo.stream;
    const throttler = last(streamInfo.onStream, sInfo.delay);
    streamState.setTimer(throttler);
    return (component, simulatedEvent) => {
      throttler.throttle(component, simulatedEvent);
      if (sInfo.stopEvent) {
        simulatedEvent.stop();
      }
    };
  };
  var StreamingSchema = [
    requiredOf("stream", choose$1("mode", {
      throttle: [
        required$1("delay"),
        defaulted("stopEvent", true),
        output$1("streams", {
          setup: setup$c,
          state: throttle
        })
      ]
    })),
    defaulted("event", "input"),
    option$3("cancelEvent"),
    onStrictHandler("onStream")
  ];
  const Streaming = create$42({
    fields: StreamingSchema,
    name: "streaming",
    active: ActiveStreaming,
    state: StreamingState
  });
  const setValueFromItem = (model, input2, item3) => {
    const itemData = Representing.getValue(item3);
    Representing.setValue(input2, itemData);
    setCursorAtEnd(input2);
  };
  const setSelectionOn = (input2, f2) => {
    const el = input2.element;
    const value2 = get$6(el);
    const node = el.dom;
    if (get$f(el, "type") !== "number") {
      f2(node, value2);
    }
  };
  const setCursorAtEnd = (input2) => {
    setSelectionOn(input2, (node, value2) => node.setSelectionRange(value2.length, value2.length));
  };
  const setSelectionToEnd = (input2, startOffset) => {
    setSelectionOn(input2, (node, value2) => node.setSelectionRange(startOffset, value2.length));
  };
  const attemptSelectOver = (model, input2, item3) => {
    if (!model.selectsOver) {
      return Optional.none();
    } else {
      const currentValue2 = Representing.getValue(input2);
      const inputDisplay = model.getDisplayText(currentValue2);
      const itemValue = Representing.getValue(item3);
      const itemDisplay = model.getDisplayText(itemValue);
      return itemDisplay.indexOf(inputDisplay) === 0 ? Optional.some(() => {
        setValueFromItem(model, input2, item3);
        setSelectionToEnd(input2, inputDisplay.length);
      }) : Optional.none();
    }
  };
  const itemExecute = constant$1("alloy.typeahead.itemexecute");
  const make$3 = (detail, components2, spec, externals) => {
    const navigateList = (comp, simulatedEvent, highlighter) => {
      detail.previewing.set(false);
      const sandbox = Coupling.getCoupled(comp, "sandbox");
      if (Sandboxing.isOpen(sandbox)) {
        Composing.getCurrent(sandbox).each((menu2) => {
          Highlighting.getHighlighted(menu2).fold(() => {
            highlighter(menu2);
          }, () => {
            dispatchEvent(sandbox, menu2.element, "keydown", simulatedEvent);
          });
        });
      } else {
        const onOpenSync = (sandbox2) => {
          Composing.getCurrent(sandbox2).each(highlighter);
        };
        open(detail, mapFetch(comp), comp, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
      }
    };
    const focusBehaviours$1 = focusBehaviours(detail);
    const mapFetch = (comp) => (tdata) => tdata.map((data2) => {
      const menus = values(data2.menus);
      const items = bind$3(menus, (menu2) => filter$2(menu2.items, (item3) => item3.type === "item"));
      const repState = Representing.getState(comp);
      repState.update(map$2(items, (item3) => item3.data));
      return data2;
    });
    const getActiveMenu = (sandboxComp) => Composing.getCurrent(sandboxComp);
    const typeaheadCustomEvents = "typeaheadevents";
    const behaviours2 = [
      Focusing.config({}),
      Representing.config({
        onSetValue: detail.onSetValue,
        store: {
          mode: "dataset",
          getDataKey: (comp) => get$6(comp.element),
          getFallbackEntry: (itemString) => ({
            value: itemString,
            meta: {}
          }),
          setValue: (comp, data2) => {
            set$5(comp.element, detail.model.getDisplayText(data2));
          },
          ...detail.initialData.map((d) => wrap$1("initialValue", d)).getOr({})
        }
      }),
      Streaming.config({
        stream: {
          mode: "throttle",
          delay: detail.responseTime,
          stopEvent: false
        },
        onStream: (component, _simulatedEvent) => {
          const sandbox = Coupling.getCoupled(component, "sandbox");
          const focusInInput = Focusing.isFocused(component);
          if (focusInInput) {
            if (get$6(component.element).length >= detail.minChars) {
              const previousValue = getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu).map(Representing.getValue));
              detail.previewing.set(true);
              const onOpenSync = (_sandbox) => {
                getActiveMenu(sandbox).each((activeMenu) => {
                  previousValue.fold(() => {
                    if (detail.model.selectsOver) {
                      Highlighting.highlightFirst(activeMenu);
                    }
                  }, (pv) => {
                    Highlighting.highlightBy(activeMenu, (item3) => {
                      const itemData = Representing.getValue(item3);
                      return itemData.value === pv.value;
                    });
                    Highlighting.getHighlighted(activeMenu).orThunk(() => {
                      Highlighting.highlightFirst(activeMenu);
                      return Optional.none();
                    });
                  });
                });
              };
              open(detail, mapFetch(component), component, sandbox, externals, onOpenSync, HighlightOnOpen.HighlightJustMenu).get(noop2);
            }
          }
        },
        cancelEvent: typeaheadCancel()
      }),
      Keying.config({
        mode: "special",
        onDown: (comp, simulatedEvent) => {
          navigateList(comp, simulatedEvent, Highlighting.highlightFirst);
          return Optional.some(true);
        },
        onEscape: (comp) => {
          const sandbox = Coupling.getCoupled(comp, "sandbox");
          if (Sandboxing.isOpen(sandbox)) {
            Sandboxing.close(sandbox);
            return Optional.some(true);
          }
          return Optional.none();
        },
        onUp: (comp, simulatedEvent) => {
          navigateList(comp, simulatedEvent, Highlighting.highlightLast);
          return Optional.some(true);
        },
        onEnter: (comp) => {
          const sandbox = Coupling.getCoupled(comp, "sandbox");
          const sandboxIsOpen = Sandboxing.isOpen(sandbox);
          if (sandboxIsOpen && !detail.previewing.get()) {
            return getActiveMenu(sandbox).bind((activeMenu) => Highlighting.getHighlighted(activeMenu)).map((item3) => {
              emitWith(comp, itemExecute(), { item: item3 });
              return true;
            });
          } else {
            const currentValue2 = Representing.getValue(comp);
            emit(comp, typeaheadCancel());
            detail.onExecute(sandbox, comp, currentValue2);
            if (sandboxIsOpen) {
              Sandboxing.close(sandbox);
            }
            return Optional.some(true);
          }
        }
      }),
      Toggling.config({
        toggleClass: detail.markers.openClass,
        aria: { mode: "expanded" }
      }),
      Coupling.config({
        others: {
          sandbox: (hotspot) => {
            return makeSandbox$1(detail, hotspot, {
              onOpen: () => Toggling.on(hotspot),
              onClose: () => Toggling.off(hotspot)
            });
          }
        }
      }),
      config(typeaheadCustomEvents, [
        runOnAttached((typeaheadComp) => {
          detail.lazyTypeaheadComp.set(Optional.some(typeaheadComp));
        }),
        runOnDetached((_typeaheadComp) => {
          detail.lazyTypeaheadComp.set(Optional.none());
        }),
        runOnExecute$1((comp) => {
          const onOpenSync = noop2;
          togglePopup(detail, mapFetch(comp), comp, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
        }),
        run$1(itemExecute(), (comp, se) => {
          const sandbox = Coupling.getCoupled(comp, "sandbox");
          setValueFromItem(detail.model, comp, se.event.item);
          emit(comp, typeaheadCancel());
          detail.onItemExecute(comp, sandbox, se.event.item, Representing.getValue(comp));
          Sandboxing.close(sandbox);
          setCursorAtEnd(comp);
        })
      ].concat(detail.dismissOnBlur ? [run$1(postBlur(), (typeahead) => {
        const sandbox = Coupling.getCoupled(typeahead, "sandbox");
        if (search(sandbox.element).isNone()) {
          Sandboxing.close(sandbox);
        }
      })] : []))
    ];
    const eventOrder = {
      [detachedFromDom()]: [
        Representing.name(),
        Streaming.name(),
        typeaheadCustomEvents
      ],
      ...detail.eventOrder
    };
    return {
      uid: detail.uid,
      dom: dom(deepMerge(detail, {
        inputAttributes: {
          "role": "combobox",
          "aria-autocomplete": "list",
          "aria-haspopup": "true"
        }
      })),
      behaviours: {
        ...focusBehaviours$1,
        ...augment(detail.typeaheadBehaviours, behaviours2)
      },
      eventOrder
    };
  };
  const schema$g = constant$1([
    option$3("lazySink"),
    required$1("fetch"),
    defaulted("minChars", 5),
    defaulted("responseTime", 1e3),
    onHandler("onOpen"),
    defaulted("getHotspot", Optional.some),
    defaulted("getAnchorOverrides", constant$1({})),
    defaulted("layouts", Optional.none()),
    defaulted("eventOrder", {}),
    defaultedObjOf("model", {}, [
      defaulted("getDisplayText", (itemData) => itemData.meta !== void 0 && itemData.meta.text !== void 0 ? itemData.meta.text : itemData.value),
      defaulted("selectsOver", true),
      defaulted("populateFromBrowse", true)
    ]),
    onHandler("onSetValue"),
    onKeyboardHandler("onExecute"),
    onHandler("onItemExecute"),
    defaulted("inputClasses", []),
    defaulted("inputAttributes", {}),
    defaulted("inputStyles", {}),
    defaulted("matchWidth", true),
    defaulted("useMinWidth", false),
    defaulted("dismissOnBlur", true),
    markers$1(["openClass"]),
    option$3("initialData"),
    field("typeaheadBehaviours", [
      Focusing,
      Representing,
      Streaming,
      Keying,
      Toggling,
      Coupling
    ]),
    customField("lazyTypeaheadComp", () => Cell(Optional.none)),
    customField("previewing", () => Cell(true))
  ].concat(schema$l()).concat(sandboxFields()));
  const parts$b = constant$1([external({
    schema: [tieredMenuMarkers()],
    name: "menu",
    overrides: (detail) => {
      return {
        fakeFocus: true,
        onHighlightItem: (_tmenu, menu2, item3) => {
          if (!detail.previewing.get()) {
            detail.lazyTypeaheadComp.get().each((input2) => {
              if (detail.model.populateFromBrowse) {
                setValueFromItem(detail.model, input2, item3);
              }
            });
          } else {
            detail.lazyTypeaheadComp.get().each((input2) => {
              attemptSelectOver(detail.model, input2, item3).fold(() => {
                if (detail.model.selectsOver) {
                  Highlighting.dehighlight(menu2, item3);
                  detail.previewing.set(true);
                } else {
                  detail.previewing.set(false);
                }
              }, (selectOverTextInInput) => {
                selectOverTextInInput();
                detail.previewing.set(false);
              });
            });
          }
        },
        onExecute: (_menu, item3) => {
          return detail.lazyTypeaheadComp.get().map((typeahead) => {
            emitWith(typeahead, itemExecute(), { item: item3 });
            return true;
          });
        },
        onHover: (menu2, item3) => {
          detail.previewing.set(false);
          detail.lazyTypeaheadComp.get().each((input2) => {
            if (detail.model.populateFromBrowse) {
              setValueFromItem(detail.model, input2, item3);
            }
          });
        }
      };
    }
  })]);
  const Typeahead = composite({
    name: "Typeahead",
    configFields: schema$g(),
    partFields: parts$b(),
    factory: make$3
  });
  const wrap = (delegate) => {
    const toCached = () => {
      return wrap(delegate.toCached());
    };
    const bindFuture = (f2) => {
      return wrap(delegate.bind((resA) => resA.fold((err) => Future.pure(Result.error(err)), (a) => f2(a))));
    };
    const bindResult = (f2) => {
      return wrap(delegate.map((resA) => resA.bind(f2)));
    };
    const mapResult = (f2) => {
      return wrap(delegate.map((resA) => resA.map(f2)));
    };
    const mapError2 = (f2) => {
      return wrap(delegate.map((resA) => resA.mapError(f2)));
    };
    const foldResult = (whenError, whenValue) => {
      return delegate.map((res2) => res2.fold(whenError, whenValue));
    };
    const withTimeout = (timeout, errorThunk) => {
      return wrap(Future.nu((callback) => {
        let timedOut = false;
        const timer = setTimeout(() => {
          timedOut = true;
          callback(Result.error(errorThunk()));
        }, timeout);
        delegate.get((result) => {
          if (!timedOut) {
            clearTimeout(timer);
            callback(result);
          }
        });
      }));
    };
    return {
      ...delegate,
      toCached,
      bindFuture,
      bindResult,
      mapResult,
      mapError: mapError2,
      foldResult,
      withTimeout
    };
  };
  const nu$1 = (worker) => {
    return wrap(Future.nu(worker));
  };
  const value = (value2) => {
    return wrap(Future.pure(Result.value(value2)));
  };
  const error2 = (error3) => {
    return wrap(Future.pure(Result.error(error3)));
  };
  const fromResult = (result) => {
    return wrap(Future.pure(result));
  };
  const fromFuture = (future) => {
    return wrap(future.map(Result.value));
  };
  const fromPromise = (promise) => {
    return nu$1((completer) => {
      promise.then((value2) => {
        completer(Result.value(value2));
      }, (error3) => {
        completer(Result.error(error3));
      });
    });
  };
  const FutureResult = {
    nu: nu$1,
    wrap,
    pure: value,
    value,
    error: error2,
    fromResult,
    fromFuture,
    fromPromise
  };
  const renderCommonSpec = (spec, actionOpt, extraBehaviours = [], dom2, components2, providersBackstage) => {
    const action = actionOpt.fold(() => ({}), (action2) => ({ action: action2 }));
    const common = {
      buttonBehaviours: derive$1([
        DisablingConfigs.button(() => !spec.enabled || providersBackstage.isDisabled()),
        receivingConfig(),
        Tabstopping.config({}),
        config("button press", [
          preventDefault("click"),
          preventDefault("mousedown")
        ])
      ].concat(extraBehaviours)),
      eventOrder: {
        click: [
          "button press",
          "alloy.base.behaviour"
        ],
        mousedown: [
          "button press",
          "alloy.base.behaviour"
        ]
      },
      ...action
    };
    const domFinal = deepMerge(common, { dom: dom2 });
    return deepMerge(domFinal, { components: components2 });
  };
  const renderIconButtonSpec = (spec, action, providersBackstage, extraBehaviours = []) => {
    const tooltipAttributes = spec.tooltip.map((tooltip) => ({
      "aria-label": providersBackstage.translate(tooltip),
      "title": providersBackstage.translate(tooltip)
    })).getOr({});
    const dom2 = {
      tag: "button",
      classes: ["tox-tbtn"],
      attributes: tooltipAttributes
    };
    const icon2 = spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons));
    const components2 = componentRenderPipeline([icon2]);
    return renderCommonSpec(spec, action, extraBehaviours, dom2, components2, providersBackstage);
  };
  const calculateClassesFromButtonType = (buttonType) => {
    switch (buttonType) {
      case "primary":
        return ["tox-button"];
      case "toolbar":
        return ["tox-tbtn"];
      case "secondary":
      default:
        return [
          "tox-button",
          "tox-button--secondary"
        ];
    }
  };
  const renderButtonSpec = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
    const translatedText = providersBackstage.translate(spec.text);
    const icon2 = spec.icon.map((iconName) => renderIconFromPack$1(iconName, providersBackstage.icons));
    const components2 = [icon2.getOrThunk(() => text$2(translatedText))];
    const buttonType = spec.buttonType.getOr(!spec.primary && !spec.borderless ? "secondary" : "primary");
    const baseClasses = calculateClassesFromButtonType(buttonType);
    const classes2 = [
      ...baseClasses,
      ...icon2.isSome() ? ["tox-button--icon"] : [],
      ...spec.borderless ? ["tox-button--naked"] : [],
      ...extraClasses
    ];
    const dom2 = {
      tag: "button",
      classes: classes2,
      attributes: { title: translatedText }
    };
    return renderCommonSpec(spec, action, extraBehaviours, dom2, components2, providersBackstage);
  };
  const renderButton$1 = (spec, action, providersBackstage, extraBehaviours = [], extraClasses = []) => {
    const buttonSpec = renderButtonSpec(spec, Optional.some(action), providersBackstage, extraBehaviours, extraClasses);
    return Button2.sketch(buttonSpec);
  };
  const getAction = (name3, buttonType) => (comp) => {
    if (buttonType === "custom") {
      emitWith(comp, formActionEvent, {
        name: name3,
        value: {}
      });
    } else if (buttonType === "submit") {
      emit(comp, formSubmitEvent);
    } else if (buttonType === "cancel") {
      emit(comp, formCancelEvent);
    } else {
      console.error("Unknown button type: ", buttonType);
    }
  };
  const isMenuFooterButtonSpec = (spec, buttonType) => buttonType === "menu";
  const isNormalFooterButtonSpec = (spec, buttonType) => buttonType === "custom" || buttonType === "cancel" || buttonType === "submit";
  const isToggleButtonSpec = (spec, buttonType) => buttonType === "togglebutton";
  const renderToggleButton = (spec, providers) => {
    var _a, _b, _c;
    const optMemIcon = Optional.from(spec.icon).map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);
    const action = (comp) => {
      emitWith(comp, formActionEvent, {
        name: spec.name,
        value: {
          setIcon: (newIcon) => {
            optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
              Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);
            }));
          }
        }
      });
    };
    const buttonSpec = {
      ...spec,
      name: (_a = spec.name) !== null && _a !== void 0 ? _a : "",
      primary: spec.buttonType === "primary",
      buttonType: Optional.from(spec.buttonType),
      tooltip: Optional.from(spec.tooltip),
      icon: Optional.from(spec.name),
      enabled: (_b = spec.enabled) !== null && _b !== void 0 ? _b : false,
      borderless: false
    };
    const tooltipAttributes = buttonSpec.tooltip.map((tooltip) => ({
      "aria-label": providers.translate(tooltip),
      "title": providers.translate(tooltip)
    })).getOr({});
    const buttonTypeClasses = calculateClassesFromButtonType((_c = spec.buttonType) !== null && _c !== void 0 ? _c : "secondary");
    const showIconAndText = !!spec.icon && !!spec.text;
    const dom2 = {
      tag: "button",
      classes: [
        ...buttonTypeClasses.concat(["tox-button--icon"]),
        ...spec.active ? ["tox-button--enabled"] : [],
        ...showIconAndText ? ["tox-button--icon-and-text"] : []
      ],
      attributes: tooltipAttributes
    };
    const extraBehaviours = [];
    const translatedText = providers.translate(spec.text);
    const translatedTextComponed = text$2(translatedText);
    const iconComp = componentRenderPipeline([optMemIcon.map((memIcon) => memIcon.asSpec())]);
    const components2 = [
      ...iconComp,
      ...showIconAndText ? [translatedTextComponed] : []
    ];
    const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom2, components2, providers);
    return Button2.sketch(iconButtonSpec);
  };
  const renderFooterButton = (spec, buttonType, backstage) => {
    if (isMenuFooterButtonSpec(spec, buttonType)) {
      const getButton = () => memButton;
      const menuButtonSpec = spec;
      const fixedSpec = {
        ...spec,
        type: "menubutton",
        search: Optional.none(),
        onSetup: (api2) => {
          api2.setEnabled(spec.enabled);
          return noop2;
        },
        fetch: getFetch(menuButtonSpec.items, getButton, backstage)
      };
      const memButton = record(renderMenuButton(fixedSpec, "tox-tbtn", backstage, Optional.none()));
      return memButton.asSpec();
    } else if (isNormalFooterButtonSpec(spec, buttonType)) {
      const action = getAction(spec.name, buttonType);
      const buttonSpec = {
        ...spec,
        borderless: false
      };
      return renderButton$1(buttonSpec, action, backstage.shared.providers, []);
    } else if (isToggleButtonSpec(spec, buttonType)) {
      const buttonSpec = {
        ...spec,
        tooltip: spec.tooltip,
        text: spec.text.getOrUndefined(),
        buttonType: spec.buttonType.getOrUndefined()
      };
      return renderToggleButton(buttonSpec, backstage.shared.providers);
    } else {
      console.error("Unknown footer button type: ", buttonType);
      throw new Error("Unknown footer button type");
    }
  };
  const renderDialogButton = (spec, providersBackstage) => {
    const action = getAction(spec.name, "custom");
    return renderFormField(Optional.none(), FormField.parts.field({
      factory: Button2,
      ...renderButtonSpec(spec, Optional.some(action), providersBackstage, [
        RepresentingConfigs.memory(""),
        ComposingConfigs.self()
      ])
    }));
  };
  const separator$1 = { type: "separator" };
  const toMenuItem = (target) => ({
    type: "menuitem",
    value: target.url,
    text: target.title,
    meta: { attach: target.attach },
    onAction: noop2
  });
  const staticMenuItem = (title2, url) => ({
    type: "menuitem",
    value: url,
    text: title2,
    meta: { attach: void 0 },
    onAction: noop2
  });
  const toMenuItems = (targets) => map$2(targets, toMenuItem);
  const filterLinkTargets = (type2, targets) => filter$2(targets, (target) => target.type === type2);
  const filteredTargets = (type2, targets) => toMenuItems(filterLinkTargets(type2, targets));
  const headerTargets = (linkInfo) => filteredTargets("header", linkInfo.targets);
  const anchorTargets = (linkInfo) => filteredTargets("anchor", linkInfo.targets);
  const anchorTargetTop = (linkInfo) => Optional.from(linkInfo.anchorTop).map((url) => staticMenuItem("<top>", url)).toArray();
  const anchorTargetBottom = (linkInfo) => Optional.from(linkInfo.anchorBottom).map((url) => staticMenuItem("<bottom>", url)).toArray();
  const historyTargets = (history) => map$2(history, (url) => staticMenuItem(url, url));
  const joinMenuLists = (items) => {
    return foldl(items, (a, b2) => {
      const bothEmpty = a.length === 0 || b2.length === 0;
      return bothEmpty ? a.concat(b2) : a.concat(separator$1, b2);
    }, []);
  };
  const filterByQuery = (term, menuItems) => {
    const lowerCaseTerm = term.toLowerCase();
    return filter$2(menuItems, (item3) => {
      var _a;
      const text3 = item3.meta !== void 0 && item3.meta.text !== void 0 ? item3.meta.text : item3.text;
      const value2 = (_a = item3.value) !== null && _a !== void 0 ? _a : "";
      return contains$1(text3.toLowerCase(), lowerCaseTerm) || contains$1(value2.toLowerCase(), lowerCaseTerm);
    });
  };
  const getItems = (fileType, input2, urlBackstage) => {
    const urlInputValue = Representing.getValue(input2);
    const term = urlInputValue.meta.text !== void 0 ? urlInputValue.meta.text : urlInputValue.value;
    const info = urlBackstage.getLinkInformation();
    return info.fold(() => [], (linkInfo) => {
      const history = filterByQuery(term, historyTargets(urlBackstage.getHistory(fileType)));
      return fileType === "file" ? joinMenuLists([
        history,
        filterByQuery(term, headerTargets(linkInfo)),
        filterByQuery(term, flatten([
          anchorTargetTop(linkInfo),
          anchorTargets(linkInfo),
          anchorTargetBottom(linkInfo)
        ]))
      ]) : history;
    });
  };
  const errorId = generate$6("aria-invalid");
  const renderUrlInput = (spec, backstage, urlBackstage, initialData) => {
    const providersBackstage = backstage.shared.providers;
    const updateHistory = (component) => {
      const urlEntry = Representing.getValue(component);
      urlBackstage.addToHistory(urlEntry.value, spec.filetype);
    };
    const typeaheadSpec = {
      ...initialData.map((initialData2) => ({ initialData: initialData2 })).getOr({}),
      dismissOnBlur: true,
      inputClasses: ["tox-textfield"],
      sandboxClasses: ["tox-dialog__popups"],
      inputAttributes: {
        "aria-errormessage": errorId,
        "type": "url"
      },
      minChars: 0,
      responseTime: 0,
      fetch: (input2) => {
        const items = getItems(spec.filetype, input2, urlBackstage);
        const tdata = build(items, ItemResponse$1.BUBBLE_TO_SANDBOX, backstage, {
          isHorizontalMenu: false,
          search: Optional.none()
        });
        return Future.pure(tdata);
      },
      getHotspot: (comp) => memUrlBox.getOpt(comp),
      onSetValue: (comp, _newValue) => {
        if (comp.hasConfigured(Invalidating)) {
          Invalidating.run(comp).get(noop2);
        }
      },
      typeaheadBehaviours: derive$1([
        ...urlBackstage.getValidationHandler().map((handler) => Invalidating.config({
          getRoot: (comp) => parentElement(comp.element),
          invalidClass: "tox-control-wrap--status-invalid",
          notify: {
            onInvalid: (comp, err) => {
              memInvalidIcon.getOpt(comp).each((invalidComp) => {
                set$9(invalidComp.element, "title", providersBackstage.translate(err));
              });
            }
          },
          validator: {
            validate: (input2) => {
              const urlEntry = Representing.getValue(input2);
              return FutureResult.nu((completer) => {
                handler({
                  type: spec.filetype,
                  url: urlEntry.value
                }, (validation) => {
                  if (validation.status === "invalid") {
                    const err = Result.error(validation.message);
                    completer(err);
                  } else {
                    const val = Result.value(validation.message);
                    completer(val);
                  }
                });
              });
            },
            validateOnLoad: false
          }
        })).toArray(),
        Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() }),
        Tabstopping.config({}),
        config("urlinput-events", [
          run$1(input(), (comp) => {
            const currentValue2 = get$6(comp.element);
            const trimmedValue = currentValue2.trim();
            if (trimmedValue !== currentValue2) {
              set$5(comp.element, trimmedValue);
            }
            if (spec.filetype === "file") {
              emitWith(comp, formChangeEvent, { name: spec.name });
            }
          }),
          run$1(change(), (comp) => {
            emitWith(comp, formChangeEvent, { name: spec.name });
            updateHistory(comp);
          }),
          run$1(postPaste(), (comp) => {
            emitWith(comp, formChangeEvent, { name: spec.name });
            updateHistory(comp);
          })
        ])
      ]),
      eventOrder: {
        [input()]: [
          "streaming",
          "urlinput-events",
          "invalidating"
        ]
      },
      model: {
        getDisplayText: (itemData) => itemData.value,
        selectsOver: false,
        populateFromBrowse: false
      },
      markers: { openClass: "tox-textfield--popup-open" },
      lazySink: backstage.shared.getSink,
      parts: { menu: part(false, 1, "normal") },
      onExecute: (_menu, component, _entry) => {
        emitWith(component, formSubmitEvent, {});
      },
      onItemExecute: (typeahead, _sandbox, _item, _value) => {
        updateHistory(typeahead);
        emitWith(typeahead, formChangeEvent, { name: spec.name });
      }
    };
    const pField = FormField.parts.field({
      ...typeaheadSpec,
      factory: Typeahead
    });
    const pLabel = spec.label.map((label2) => renderLabel$3(label2, providersBackstage));
    const makeIcon = (name3, errId, icon2 = name3, label2 = name3) => render$3(icon2, {
      tag: "div",
      classes: [
        "tox-icon",
        "tox-control-wrap__status-icon-" + name3
      ],
      attributes: {
        "title": providersBackstage.translate(label2),
        "aria-live": "polite",
        ...errId.fold(() => ({}), (id) => ({ id }))
      }
    }, providersBackstage.icons);
    const memInvalidIcon = record(makeIcon("invalid", Optional.some(errorId), "warning"));
    const memStatus = record({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap__status-icon-wrap"]
      },
      components: [memInvalidIcon.asSpec()]
    });
    const optUrlPicker = urlBackstage.getUrlPicker(spec.filetype);
    const browseUrlEvent = generate$6("browser.url.event");
    const memUrlBox = record({
      dom: {
        tag: "div",
        classes: ["tox-control-wrap"]
      },
      components: [
        pField,
        memStatus.asSpec()
      ],
      behaviours: derive$1([Disabling.config({ disabled: () => !spec.enabled || providersBackstage.isDisabled() })])
    });
    const memUrlPickerButton = record(renderButton$1({
      name: spec.name,
      icon: Optional.some("browse"),
      text: spec.label.getOr(""),
      enabled: spec.enabled,
      primary: false,
      buttonType: Optional.none(),
      borderless: true
    }, (component) => emit(component, browseUrlEvent), providersBackstage, [], ["tox-browse-url"]));
    const controlHWrapper = () => ({
      dom: {
        tag: "div",
        classes: ["tox-form__controls-h-stack"]
      },
      components: flatten([
        [memUrlBox.asSpec()],
        optUrlPicker.map(() => memUrlPickerButton.asSpec()).toArray()
      ])
    });
    const openUrlPicker = (comp) => {
      Composing.getCurrent(comp).each((field2) => {
        const componentData = Representing.getValue(field2);
        const urlData = {
          fieldname: spec.name,
          ...componentData
        };
        optUrlPicker.each((picker) => {
          picker(urlData).get((chosenData) => {
            Representing.setValue(field2, chosenData);
            emitWith(comp, formChangeEvent, { name: spec.name });
          });
        });
      });
    };
    return FormField.sketch({
      dom: renderFormFieldDom(),
      components: pLabel.toArray().concat([controlHWrapper()]),
      fieldBehaviours: derive$1([
        Disabling.config({
          disabled: () => !spec.enabled || providersBackstage.isDisabled(),
          onDisabled: (comp) => {
            FormField.getField(comp).each(Disabling.disable);
            memUrlPickerButton.getOpt(comp).each(Disabling.disable);
          },
          onEnabled: (comp) => {
            FormField.getField(comp).each(Disabling.enable);
            memUrlPickerButton.getOpt(comp).each(Disabling.enable);
          }
        }),
        receivingConfig(),
        config("url-input-events", [run$1(browseUrlEvent, openUrlPicker)])
      ])
    });
  };
  const renderAlertBanner = (spec, providersBackstage) => Container.sketch({
    dom: {
      tag: "div",
      attributes: { role: "alert" },
      classes: [
        "tox-notification",
        "tox-notification--in",
        `tox-notification--${spec.level}`
      ]
    },
    components: [
      {
        dom: {
          tag: "div",
          classes: ["tox-notification__icon"]
        },
        components: [Button2.sketch({
          dom: {
            tag: "button",
            classes: [
              "tox-button",
              "tox-button--naked",
              "tox-button--icon"
            ],
            innerHtml: get$2(spec.icon, providersBackstage.icons),
            attributes: { title: providersBackstage.translate(spec.iconTooltip) }
          },
          action: (comp) => {
            emitWith(comp, formActionEvent, {
              name: "alert-banner",
              value: spec.url
            });
          },
          buttonBehaviours: derive$1([addFocusableBehaviour()])
        })]
      },
      {
        dom: {
          tag: "div",
          classes: ["tox-notification__body"],
          innerHtml: providersBackstage.translate(spec.text)
        }
      }
    ]
  });
  const set$1 = (element2, status) => {
    element2.dom.checked = status;
  };
  const get$1 = (element2) => element2.dom.checked;
  const renderCheckbox = (spec, providerBackstage, initialData) => {
    const toggleCheckboxHandler = (comp) => {
      comp.element.dom.click();
      return Optional.some(true);
    };
    const pField = FormField.parts.field({
      factory: { sketch: identity },
      dom: {
        tag: "input",
        classes: ["tox-checkbox__input"],
        attributes: { type: "checkbox" }
      },
      behaviours: derive$1([
        ComposingConfigs.self(),
        Disabling.config({ disabled: () => !spec.enabled || providerBackstage.isDisabled() }),
        Tabstopping.config({}),
        Focusing.config({}),
        RepresentingConfigs.withElement(initialData, get$1, set$1),
        Keying.config({
          mode: "special",
          onEnter: toggleCheckboxHandler,
          onSpace: toggleCheckboxHandler,
          stopSpaceKeyup: true
        }),
        config("checkbox-events", [run$1(change(), (component, _2) => {
          emitWith(component, formChangeEvent, { name: spec.name });
        })])
      ])
    });
    const pLabel = FormField.parts.label({
      dom: {
        tag: "span",
        classes: ["tox-checkbox__label"]
      },
      components: [text$2(providerBackstage.translate(spec.label))],
      behaviours: derive$1([Unselecting.config({})])
    });
    const makeIcon = (className) => {
      const iconName = className === "checked" ? "selected" : "unselected";
      return render$3(iconName, {
        tag: "span",
        classes: [
          "tox-icon",
          "tox-checkbox-icon__" + className
        ]
      }, providerBackstage.icons);
    };
    const memIcons = record({
      dom: {
        tag: "div",
        classes: ["tox-checkbox__icons"]
      },
      components: [
        makeIcon("checked"),
        makeIcon("unchecked")
      ]
    });
    return FormField.sketch({
      dom: {
        tag: "label",
        classes: ["tox-checkbox"]
      },
      components: [
        pField,
        memIcons.asSpec(),
        pLabel
      ],
      fieldBehaviours: derive$1([
        Disabling.config({
          disabled: () => !spec.enabled || providerBackstage.isDisabled(),
          disableClass: "tox-checkbox--disabled",
          onDisabled: (comp) => {
            FormField.getField(comp).each(Disabling.disable);
          },
          onEnabled: (comp) => {
            FormField.getField(comp).each(Disabling.enable);
          }
        }),
        receivingConfig()
      ])
    });
  };
  const renderHtmlPanel = (spec) => {
    if (spec.presets === "presentation") {
      return Container.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"],
          innerHtml: spec.html
        }
      });
    } else {
      return Container.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"],
          innerHtml: spec.html,
          attributes: { role: "document" }
        },
        containerBehaviours: derive$1([
          Tabstopping.config({}),
          Focusing.config({})
        ])
      });
    }
  };
  const make$2 = (render2) => {
    return (parts2, spec, dialogData, backstage) => get$g(spec, "name").fold(() => render2(spec, backstage, Optional.none()), (fieldName) => parts2.field(fieldName, render2(spec, backstage, get$g(dialogData, fieldName))));
  };
  const makeIframe = (render2) => (parts2, spec, dialogData, backstage) => {
    const iframeSpec = deepMerge(spec, { source: "dynamic" });
    return make$2(render2)(parts2, iframeSpec, dialogData, backstage);
  };
  const factories = {
    bar: make$2((spec, backstage) => renderBar(spec, backstage.shared)),
    collection: make$2((spec, backstage, data2) => renderCollection(spec, backstage.shared.providers, data2)),
    alertbanner: make$2((spec, backstage) => renderAlertBanner(spec, backstage.shared.providers)),
    input: make$2((spec, backstage, data2) => renderInput(spec, backstage.shared.providers, data2)),
    textarea: make$2((spec, backstage, data2) => renderTextarea(spec, backstage.shared.providers, data2)),
    label: make$2((spec, backstage) => renderLabel$2(spec, backstage.shared)),
    iframe: makeIframe((spec, backstage, data2) => renderIFrame(spec, backstage.shared.providers, data2)),
    button: make$2((spec, backstage) => renderDialogButton(spec, backstage.shared.providers)),
    checkbox: make$2((spec, backstage, data2) => renderCheckbox(spec, backstage.shared.providers, data2)),
    colorinput: make$2((spec, backstage, data2) => renderColorInput(spec, backstage.shared, backstage.colorinput, data2)),
    colorpicker: make$2((spec, backstage, data2) => renderColorPicker(spec, backstage.shared.providers, data2)),
    dropzone: make$2((spec, backstage, data2) => renderDropZone(spec, backstage.shared.providers, data2)),
    grid: make$2((spec, backstage) => renderGrid(spec, backstage.shared)),
    listbox: make$2((spec, backstage, data2) => renderListBox(spec, backstage, data2)),
    selectbox: make$2((spec, backstage, data2) => renderSelectBox(spec, backstage.shared.providers, data2)),
    sizeinput: make$2((spec, backstage) => renderSizeInput(spec, backstage.shared.providers)),
    slider: make$2((spec, backstage, data2) => renderSlider(spec, backstage.shared.providers, data2)),
    urlinput: make$2((spec, backstage, data2) => renderUrlInput(spec, backstage, backstage.urlinput, data2)),
    customeditor: make$2(renderCustomEditor),
    htmlpanel: make$2(renderHtmlPanel),
    imagepreview: make$2((spec, _2, data2) => renderImagePreview(spec, data2)),
    table: make$2((spec, backstage) => renderTable(spec, backstage.shared.providers)),
    tree: make$2((spec, backstage) => renderTree(spec, backstage)),
    panel: make$2((spec, backstage) => renderPanel(spec, backstage))
  };
  const noFormParts = {
    field: (_name, spec) => spec,
    record: constant$1([])
  };
  const interpretInForm = (parts2, spec, dialogData, oldBackstage) => {
    const newBackstage = deepMerge(oldBackstage, { shared: { interpreter: (childSpec) => interpretParts(parts2, childSpec, dialogData, newBackstage) } });
    return interpretParts(parts2, spec, dialogData, newBackstage);
  };
  const interpretParts = (parts2, spec, dialogData, backstage) => get$g(factories, spec.type).fold(() => {
    console.error(`Unknown factory type "${spec.type}", defaulting to container: `, spec);
    return spec;
  }, (factory2) => factory2(parts2, spec, dialogData, backstage));
  const interpretWithoutForm = (spec, dialogData, backstage) => interpretParts(noFormParts, spec, dialogData, backstage);
  const labelPrefix = "layout-inset";
  const westEdgeX = (anchor2) => anchor2.x;
  const middleX = (anchor2, element2) => anchor2.x + anchor2.width / 2 - element2.width / 2;
  const eastEdgeX = (anchor2, element2) => anchor2.x + anchor2.width - element2.width;
  const northY = (anchor2) => anchor2.y;
  const southY = (anchor2, element2) => anchor2.y + anchor2.height - element2.height;
  const centreY = (anchor2, element2) => anchor2.y + anchor2.height / 2 - element2.height / 2;
  const southwest = (anchor2, element2, bubbles) => nu$6(eastEdgeX(anchor2, element2), southY(anchor2, element2), bubbles.insetSouthwest(), northwest$3(), "southwest", boundsRestriction(anchor2, {
    right: 0,
    bottom: 3
  }), labelPrefix);
  const southeast = (anchor2, element2, bubbles) => nu$6(westEdgeX(anchor2), southY(anchor2, element2), bubbles.insetSoutheast(), northeast$3(), "southeast", boundsRestriction(anchor2, {
    left: 1,
    bottom: 3
  }), labelPrefix);
  const northwest = (anchor2, element2, bubbles) => nu$6(eastEdgeX(anchor2, element2), northY(anchor2), bubbles.insetNorthwest(), southwest$3(), "northwest", boundsRestriction(anchor2, {
    right: 0,
    top: 2
  }), labelPrefix);
  const northeast = (anchor2, element2, bubbles) => nu$6(westEdgeX(anchor2), northY(anchor2), bubbles.insetNortheast(), southeast$3(), "northeast", boundsRestriction(anchor2, {
    left: 1,
    top: 2
  }), labelPrefix);
  const north = (anchor2, element2, bubbles) => nu$6(middleX(anchor2, element2), northY(anchor2), bubbles.insetNorth(), south$3(), "north", boundsRestriction(anchor2, { top: 2 }), labelPrefix);
  const south = (anchor2, element2, bubbles) => nu$6(middleX(anchor2, element2), southY(anchor2, element2), bubbles.insetSouth(), north$3(), "south", boundsRestriction(anchor2, { bottom: 3 }), labelPrefix);
  const east = (anchor2, element2, bubbles) => nu$6(eastEdgeX(anchor2, element2), centreY(anchor2, element2), bubbles.insetEast(), west$3(), "east", boundsRestriction(anchor2, { right: 0 }), labelPrefix);
  const west = (anchor2, element2, bubbles) => nu$6(westEdgeX(anchor2), centreY(anchor2, element2), bubbles.insetWest(), east$3(), "west", boundsRestriction(anchor2, { left: 1 }), labelPrefix);
  const lookupPreserveLayout = (lastPlacement) => {
    switch (lastPlacement) {
      case "north":
        return north;
      case "northeast":
        return northeast;
      case "northwest":
        return northwest;
      case "south":
        return south;
      case "southeast":
        return southeast;
      case "southwest":
        return southwest;
      case "east":
        return east;
      case "west":
        return west;
    }
  };
  const preserve = (anchor2, element2, bubbles, placee, bounds2) => {
    const layout2 = getPlacement(placee).map(lookupPreserveLayout).getOr(north);
    return layout2(anchor2, element2, bubbles, placee, bounds2);
  };
  const lookupFlippedLayout = (lastPlacement) => {
    switch (lastPlacement) {
      case "north":
        return south;
      case "northeast":
        return southeast;
      case "northwest":
        return southwest;
      case "south":
        return north;
      case "southeast":
        return northeast;
      case "southwest":
        return northwest;
      case "east":
        return west;
      case "west":
        return east;
    }
  };
  const flip2 = (anchor2, element2, bubbles, placee, bounds2) => {
    const layout2 = getPlacement(placee).map(lookupFlippedLayout).getOr(north);
    return layout2(anchor2, element2, bubbles, placee, bounds2);
  };
  const bubbleAlignments$2 = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: [],
    alignRight: [],
    right: [],
    left: [],
    bottom: [],
    top: []
  };
  const getInlineDialogAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
    const bubbleSize2 = 12;
    const overrides = { maxHeightFunction: expandable$1() };
    const editableAreaAnchor = () => ({
      type: "node",
      root: getContentContainer(getRootNode2(contentAreaElement())),
      node: Optional.from(contentAreaElement()),
      bubble: nu$5(bubbleSize2, bubbleSize2, bubbleAlignments$2),
      layouts: {
        onRtl: () => [northeast],
        onLtr: () => [northwest]
      },
      overrides
    });
    const standardAnchor = () => ({
      type: "hotspot",
      hotspot: lazyAnchorbar(),
      bubble: nu$5(-bubbleSize2, bubbleSize2, bubbleAlignments$2),
      layouts: {
        onRtl: () => [
          southeast$2,
          southwest$2,
          south$2
        ],
        onLtr: () => [
          southwest$2,
          southeast$2,
          south$2
        ]
      },
      overrides
    });
    return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
  };
  const getBannerAnchor = (contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor) => {
    const editableAreaAnchor = () => ({
      type: "node",
      root: getContentContainer(getRootNode2(contentAreaElement())),
      node: Optional.from(contentAreaElement()),
      layouts: {
        onRtl: () => [north],
        onLtr: () => [north]
      }
    });
    const standardAnchor = () => ({
      type: "hotspot",
      hotspot: lazyAnchorbar(),
      layouts: {
        onRtl: () => [south$2],
        onLtr: () => [south$2]
      }
    });
    return () => lazyUseEditableAreaAnchor() ? editableAreaAnchor() : standardAnchor();
  };
  const getCursorAnchor = (editor, bodyElement) => () => ({
    type: "selection",
    root: bodyElement(),
    getSelection: () => {
      const rng = editor.selection.getRng();
      return Optional.some(SimSelection.range(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
    }
  });
  const getNodeAnchor$1 = (bodyElement) => (element2) => ({
    type: "node",
    root: bodyElement(),
    node: element2
  });
  const getAnchors = (editor, lazyAnchorbar, isToolbarTop) => {
    const useFixedToolbarContainer = useFixedContainer(editor);
    const bodyElement = () => SugarElement.fromDom(editor.getBody());
    const contentAreaElement = () => SugarElement.fromDom(editor.getContentAreaContainer());
    const lazyUseEditableAreaAnchor = () => useFixedToolbarContainer || !isToolbarTop();
    return {
      inlineDialog: getInlineDialogAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
      banner: getBannerAnchor(contentAreaElement, lazyAnchorbar, lazyUseEditableAreaAnchor),
      cursor: getCursorAnchor(editor, bodyElement),
      node: getNodeAnchor$1(bodyElement)
    };
  };
  const colorPicker = (editor) => (callback, value2) => {
    const dialog = colorPickerDialog(editor);
    dialog(callback, value2);
  };
  const hasCustomColors = (editor) => () => hasCustomColors$1(editor);
  const getColors = (editor) => (id) => getColors$2(editor, id);
  const getColorCols = (editor) => (id) => getColorCols$1(editor, id);
  const ColorInputBackstage = (editor) => ({
    colorPicker: colorPicker(editor),
    hasCustomColors: hasCustomColors(editor),
    getColors: getColors(editor),
    getColorCols: getColorCols(editor)
  });
  const isDraggableModal = (editor) => () => isDraggableModal$1(editor);
  const DialogBackstage = (editor) => ({ isDraggableModal: isDraggableModal(editor) });
  const HeaderBackstage = (editor) => {
    const mode = Cell(isToolbarLocationBottom(editor) ? "bottom" : "top");
    return {
      isPositionedAtTop: () => mode.get() === "top",
      getDockingMode: mode.get,
      setDockingMode: mode.set
    };
  };
  const isNestedFormat = (format) => hasNonNullableKey(format, "items");
  const isFormatReference = (format) => hasNonNullableKey(format, "format");
  const defaultStyleFormats = [
    {
      title: "Headings",
      items: [
        {
          title: "Heading 1",
          format: "h1"
        },
        {
          title: "Heading 2",
          format: "h2"
        },
        {
          title: "Heading 3",
          format: "h3"
        },
        {
          title: "Heading 4",
          format: "h4"
        },
        {
          title: "Heading 5",
          format: "h5"
        },
        {
          title: "Heading 6",
          format: "h6"
        }
      ]
    },
    {
      title: "Inline",
      items: [
        {
          title: "Bold",
          format: "bold"
        },
        {
          title: "Italic",
          format: "italic"
        },
        {
          title: "Underline",
          format: "underline"
        },
        {
          title: "Strikethrough",
          format: "strikethrough"
        },
        {
          title: "Superscript",
          format: "superscript"
        },
        {
          title: "Subscript",
          format: "subscript"
        },
        {
          title: "Code",
          format: "code"
        }
      ]
    },
    {
      title: "Blocks",
      items: [
        {
          title: "Paragraph",
          format: "p"
        },
        {
          title: "Blockquote",
          format: "blockquote"
        },
        {
          title: "Div",
          format: "div"
        },
        {
          title: "Pre",
          format: "pre"
        }
      ]
    },
    {
      title: "Align",
      items: [
        {
          title: "Left",
          format: "alignleft"
        },
        {
          title: "Center",
          format: "aligncenter"
        },
        {
          title: "Right",
          format: "alignright"
        },
        {
          title: "Justify",
          format: "alignjustify"
        }
      ]
    }
  ];
  const isNestedFormats = (format) => has$2(format, "items");
  const isBlockFormat = (format) => has$2(format, "block");
  const isInlineFormat = (format) => has$2(format, "inline");
  const isSelectorFormat = (format) => has$2(format, "selector");
  const mapFormats = (userFormats) => foldl(userFormats, (acc, fmt) => {
    if (isNestedFormats(fmt)) {
      const result = mapFormats(fmt.items);
      return {
        customFormats: acc.customFormats.concat(result.customFormats),
        formats: acc.formats.concat([{
          title: fmt.title,
          items: result.formats
        }])
      };
    } else if (isInlineFormat(fmt) || isBlockFormat(fmt) || isSelectorFormat(fmt)) {
      const formatName = isString2(fmt.name) ? fmt.name : fmt.title.toLowerCase();
      const formatNameWithPrefix = `custom-${formatName}`;
      return {
        customFormats: acc.customFormats.concat([{
          name: formatNameWithPrefix,
          format: fmt
        }]),
        formats: acc.formats.concat([{
          title: fmt.title,
          format: formatNameWithPrefix,
          icon: fmt.icon
        }])
      };
    } else {
      return {
        ...acc,
        formats: acc.formats.concat(fmt)
      };
    }
  }, {
    customFormats: [],
    formats: []
  });
  const registerCustomFormats = (editor, userFormats) => {
    const result = mapFormats(userFormats);
    const registerFormats = (customFormats) => {
      each$1(customFormats, (fmt) => {
        if (!editor.formatter.has(fmt.name)) {
          editor.formatter.register(fmt.name, fmt.format);
        }
      });
    };
    if (editor.formatter) {
      registerFormats(result.customFormats);
    } else {
      editor.on("init", () => {
        registerFormats(result.customFormats);
      });
    }
    return result.formats;
  };
  const getStyleFormats = (editor) => getUserStyleFormats(editor).map((userFormats) => {
    const registeredUserFormats = registerCustomFormats(editor, userFormats);
    return shouldMergeStyleFormats(editor) ? defaultStyleFormats.concat(registeredUserFormats) : registeredUserFormats;
  }).getOr(defaultStyleFormats);
  const isSeparator$1 = (format) => {
    const keys$1 = keys(format);
    return keys$1.length === 1 && contains$2(keys$1, "title");
  };
  const processBasic = (item3, isSelectedFor, getPreviewFor) => ({
    ...item3,
    type: "formatter",
    isSelected: isSelectedFor(item3.format),
    getStylePreview: getPreviewFor(item3.format)
  });
  const register$a = (editor, formats, isSelectedFor, getPreviewFor) => {
    const enrichSupported = (item3) => processBasic(item3, isSelectedFor, getPreviewFor);
    const enrichMenu = (item3) => {
      const newItems = doEnrich(item3.items);
      return {
        ...item3,
        type: "submenu",
        getStyleItems: constant$1(newItems)
      };
    };
    const enrichCustom = (item3) => {
      const formatName = isString2(item3.name) ? item3.name : generate$6(item3.title);
      const formatNameWithPrefix = `custom-${formatName}`;
      const newItem = {
        ...item3,
        type: "formatter",
        format: formatNameWithPrefix,
        isSelected: isSelectedFor(formatNameWithPrefix),
        getStylePreview: getPreviewFor(formatNameWithPrefix)
      };
      editor.formatter.register(formatName, newItem);
      return newItem;
    };
    const doEnrich = (items) => map$2(items, (item3) => {
      if (isNestedFormat(item3)) {
        return enrichMenu(item3);
      } else if (isFormatReference(item3)) {
        return enrichSupported(item3);
      } else if (isSeparator$1(item3)) {
        return {
          ...item3,
          type: "separator"
        };
      } else {
        return enrichCustom(item3);
      }
    });
    return doEnrich(formats);
  };
  const init$7 = (editor) => {
    const isSelectedFor = (format) => () => editor.formatter.match(format);
    const getPreviewFor = (format) => () => {
      const fmt = editor.formatter.get(format);
      return fmt !== void 0 ? Optional.some({
        tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
        styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
      }) : Optional.none();
    };
    const settingsFormats = Cell([]);
    const eventsFormats = Cell([]);
    const replaceSettings = Cell(false);
    editor.on("PreInit", (_e) => {
      const formats = getStyleFormats(editor);
      const enriched = register$a(editor, formats, isSelectedFor, getPreviewFor);
      settingsFormats.set(enriched);
    });
    editor.on("addStyleModifications", (e) => {
      const modifications = register$a(editor, e.items, isSelectedFor, getPreviewFor);
      eventsFormats.set(modifications);
      replaceSettings.set(e.replace);
    });
    const getData2 = () => {
      const fromSettings = replaceSettings.get() ? [] : settingsFormats.get();
      const fromEvents = eventsFormats.get();
      return fromSettings.concat(fromEvents);
    };
    return { getData: getData2 };
  };
  const isElement2 = (node) => isNonNullable(node) && node.nodeType === 1;
  const trim2 = global$1.trim;
  const hasContentEditableState = (value2) => {
    return (node) => {
      if (isElement2(node)) {
        if (node.contentEditable === value2) {
          return true;
        }
        if (node.getAttribute("data-mce-contenteditable") === value2) {
          return true;
        }
      }
      return false;
    };
  };
  const isContentEditableTrue = hasContentEditableState("true");
  const isContentEditableFalse = hasContentEditableState("false");
  const create$12 = (type2, title2, url, level, attach2) => ({
    type: type2,
    title: title2,
    url,
    level,
    attach: attach2
  });
  const isChildOfContentEditableTrue = (node) => {
    let tempNode = node;
    while (tempNode = tempNode.parentNode) {
      const value2 = tempNode.contentEditable;
      if (value2 && value2 !== "inherit") {
        return isContentEditableTrue(tempNode);
      }
    }
    return false;
  };
  const select = (selector, root2) => {
    return map$2(descendants(SugarElement.fromDom(root2), selector), (element2) => {
      return element2.dom;
    });
  };
  const getElementText = (elm) => {
    return elm.innerText || elm.textContent;
  };
  const getOrGenerateId = (elm) => {
    return elm.id ? elm.id : generate$6("h");
  };
  const isAnchor = (elm) => {
    return elm && elm.nodeName === "A" && (elm.id || elm.name) !== void 0;
  };
  const isValidAnchor = (elm) => {
    return isAnchor(elm) && isEditable(elm);
  };
  const isHeader = (elm) => {
    return elm && /^(H[1-6])$/.test(elm.nodeName);
  };
  const isEditable = (elm) => {
    return isChildOfContentEditableTrue(elm) && !isContentEditableFalse(elm);
  };
  const isValidHeader = (elm) => {
    return isHeader(elm) && isEditable(elm);
  };
  const getLevel = (elm) => {
    return isHeader(elm) ? parseInt(elm.nodeName.substr(1), 10) : 0;
  };
  const headerTarget = (elm) => {
    var _a;
    const headerId = getOrGenerateId(elm);
    const attach2 = () => {
      elm.id = headerId;
    };
    return create$12("header", (_a = getElementText(elm)) !== null && _a !== void 0 ? _a : "", "#" + headerId, getLevel(elm), attach2);
  };
  const anchorTarget = (elm) => {
    const anchorId = elm.id || elm.name;
    const anchorText = getElementText(elm);
    return create$12("anchor", anchorText ? anchorText : "#" + anchorId, "#" + anchorId, 0, noop2);
  };
  const getHeaderTargets = (elms) => {
    return map$2(filter$2(elms, isValidHeader), headerTarget);
  };
  const getAnchorTargets = (elms) => {
    return map$2(filter$2(elms, isValidAnchor), anchorTarget);
  };
  const getTargetElements = (elm) => {
    const elms = select("h1,h2,h3,h4,h5,h6,a:not([href])", elm);
    return elms;
  };
  const hasTitle = (target) => {
    return trim2(target.title).length > 0;
  };
  const find2 = (elm) => {
    const elms = getTargetElements(elm);
    return filter$2(getHeaderTargets(elms).concat(getAnchorTargets(elms)), hasTitle);
  };
  const LinkTargets = { find: find2 };
  const STORAGE_KEY = "tinymce-url-history";
  const HISTORY_LENGTH = 5;
  const isHttpUrl = (url) => isString2(url) && /^https?/.test(url);
  const isArrayOfUrl = (a) => isArray2(a) && a.length <= HISTORY_LENGTH && forall(a, isHttpUrl);
  const isRecordOfUrlArray = (r2) => isObject2(r2) && find$4(r2, (value2) => !isArrayOfUrl(value2)).isNone();
  const getAllHistory = () => {
    const unparsedHistory = global$4.getItem(STORAGE_KEY);
    if (unparsedHistory === null) {
      return {};
    }
    let history;
    try {
      history = JSON.parse(unparsedHistory);
    } catch (e) {
      if (e instanceof SyntaxError) {
        console.log("Local storage " + STORAGE_KEY + " was not valid JSON", e);
        return {};
      }
      throw e;
    }
    if (!isRecordOfUrlArray(history)) {
      console.log("Local storage " + STORAGE_KEY + " was not valid format", history);
      return {};
    }
    return history;
  };
  const setAllHistory = (history) => {
    if (!isRecordOfUrlArray(history)) {
      throw new Error("Bad format for history:\n" + JSON.stringify(history));
    }
    global$4.setItem(STORAGE_KEY, JSON.stringify(history));
  };
  const getHistory = (fileType) => {
    const history = getAllHistory();
    return get$g(history, fileType).getOr([]);
  };
  const addToHistory = (url, fileType) => {
    if (!isHttpUrl(url)) {
      return;
    }
    const history = getAllHistory();
    const items = get$g(history, fileType).getOr([]);
    const itemsWithoutUrl = filter$2(items, (item3) => item3 !== url);
    history[fileType] = [url].concat(itemsWithoutUrl).slice(0, HISTORY_LENGTH);
    setAllHistory(history);
  };
  const isTruthy = (value2) => !!value2;
  const makeMap = (value2) => map$1(global$1.makeMap(value2, /[, ]/), isTruthy);
  const getPicker = (editor) => Optional.from(getFilePickerCallback(editor));
  const getPickerTypes = (editor) => {
    const optFileTypes = Optional.from(getFilePickerTypes(editor)).filter(isTruthy).map(makeMap);
    return getPicker(editor).fold(never, (_picker) => optFileTypes.fold(always, (types2) => keys(types2).length > 0 ? types2 : false));
  };
  const getPickerSetting = (editor, filetype) => {
    const pickerTypes = getPickerTypes(editor);
    if (isBoolean2(pickerTypes)) {
      return pickerTypes ? getPicker(editor) : Optional.none();
    } else {
      return pickerTypes[filetype] ? getPicker(editor) : Optional.none();
    }
  };
  const getUrlPicker = (editor, filetype) => getPickerSetting(editor, filetype).map((picker) => (entry) => Future.nu((completer) => {
    const handler = (value2, meta2) => {
      if (!isString2(value2)) {
        throw new Error("Expected value to be string");
      }
      if (meta2 !== void 0 && !isObject2(meta2)) {
        throw new Error("Expected meta to be a object");
      }
      const r2 = {
        value: value2,
        meta: meta2
      };
      completer(r2);
    };
    const meta = {
      filetype,
      fieldname: entry.fieldname,
      ...Optional.from(entry.meta).getOr({})
    };
    picker.call(editor, handler, entry.value, meta);
  }));
  const getTextSetting = (value2) => Optional.from(value2).filter(isString2).getOrUndefined();
  const getLinkInformation = (editor) => {
    if (!useTypeaheadUrls(editor)) {
      return Optional.none();
    }
    return Optional.some({
      targets: LinkTargets.find(editor.getBody()),
      anchorTop: getTextSetting(getAnchorTop(editor)),
      anchorBottom: getTextSetting(getAnchorBottom(editor))
    });
  };
  const getValidationHandler = (editor) => Optional.from(getFilePickerValidatorHandler(editor));
  const UrlInputBackstage = (editor) => ({
    getHistory,
    addToHistory,
    getLinkInformation: () => getLinkInformation(editor),
    getValidationHandler: () => getValidationHandler(editor),
    getUrlPicker: (filetype) => getUrlPicker(editor, filetype)
  });
  const init$6 = (lazySinks, editor, lazyAnchorbar) => {
    const contextMenuState = Cell(false);
    const toolbar = HeaderBackstage(editor);
    const providers = {
      icons: () => editor.ui.registry.getAll().icons,
      menuItems: () => editor.ui.registry.getAll().menuItems,
      translate: global$8.translate,
      isDisabled: () => editor.mode.isReadOnly() || !editor.ui.isEnabled(),
      getOption: editor.options.get
    };
    const urlinput = UrlInputBackstage(editor);
    const styles2 = init$7(editor);
    const colorinput = ColorInputBackstage(editor);
    const dialogSettings = DialogBackstage(editor);
    const isContextMenuOpen = () => contextMenuState.get();
    const setContextMenuState = (state2) => contextMenuState.set(state2);
    const commonBackstage = {
      shared: {
        providers,
        anchors: getAnchors(editor, lazyAnchorbar, toolbar.isPositionedAtTop),
        header: toolbar
      },
      urlinput,
      styles: styles2,
      colorinput,
      dialog: dialogSettings,
      isContextMenuOpen,
      setContextMenuState
    };
    const popupBackstage = {
      ...commonBackstage,
      shared: {
        ...commonBackstage.shared,
        interpreter: (s) => interpretWithoutForm(s, {}, popupBackstage),
        getSink: lazySinks.popup
      }
    };
    const dialogBackstage = {
      ...commonBackstage,
      shared: {
        ...commonBackstage.shared,
        interpreter: (s) => interpretWithoutForm(s, {}, dialogBackstage),
        getSink: lazySinks.dialog
      }
    };
    return {
      popup: popupBackstage,
      dialog: dialogBackstage
    };
  };
  const setup$b = (editor, mothership, uiMotherships) => {
    const broadcastEvent = (name3, evt) => {
      each$1([
        mothership,
        ...uiMotherships
      ], (m) => {
        m.broadcastEvent(name3, evt);
      });
    };
    const broadcastOn = (channel, message) => {
      each$1([
        mothership,
        ...uiMotherships
      ], (m) => {
        m.broadcastOn([channel], message);
      });
    };
    const fireDismissPopups = (evt) => broadcastOn(dismissPopups(), { target: evt.target });
    const doc = getDocument();
    const onTouchstart = bind2(doc, "touchstart", fireDismissPopups);
    const onTouchmove = bind2(doc, "touchmove", (evt) => broadcastEvent(documentTouchmove(), evt));
    const onTouchend = bind2(doc, "touchend", (evt) => broadcastEvent(documentTouchend(), evt));
    const onMousedown = bind2(doc, "mousedown", fireDismissPopups);
    const onMouseup = bind2(doc, "mouseup", (evt) => {
      if (evt.raw.button === 0) {
        broadcastOn(mouseReleased(), { target: evt.target });
      }
    });
    const onContentClick = (raw) => broadcastOn(dismissPopups(), { target: SugarElement.fromDom(raw.target) });
    const onContentMouseup = (raw) => {
      if (raw.button === 0) {
        broadcastOn(mouseReleased(), { target: SugarElement.fromDom(raw.target) });
      }
    };
    const onContentMousedown = () => {
      each$1(editor.editorManager.get(), (loopEditor) => {
        if (editor !== loopEditor) {
          loopEditor.dispatch("DismissPopups", { relatedTarget: editor });
        }
      });
    };
    const onWindowScroll = (evt) => broadcastEvent(windowScroll(), fromRawEvent(evt));
    const onWindowResize = (evt) => {
      broadcastOn(repositionPopups(), {});
      broadcastEvent(windowResize(), fromRawEvent(evt));
    };
    const dos = getRootNode2(SugarElement.fromDom(editor.getElement()));
    const onElementScroll = capture(dos, "scroll", (evt) => {
      requestAnimationFrame(() => {
        const c = editor.getContainer();
        if (c !== void 0 && c !== null) {
          const optScrollingContext = detectWhenSplitUiMode(editor, mothership.element);
          const scrollers = optScrollingContext.map((sc) => [
            sc.element,
            ...sc.others
          ]).getOr([]);
          if (exists(scrollers, (s) => eq(s, evt.target))) {
            editor.dispatch("ElementScroll", { target: evt.target.dom });
            broadcastEvent(externalElementScroll(), evt);
          }
        }
      });
    });
    const onEditorResize = () => broadcastOn(repositionPopups(), {});
    const onEditorProgress = (evt) => {
      if (evt.state) {
        broadcastOn(dismissPopups(), { target: SugarElement.fromDom(editor.getContainer()) });
      }
    };
    const onDismissPopups = (event) => {
      broadcastOn(dismissPopups(), { target: SugarElement.fromDom(event.relatedTarget.getContainer()) });
    };
    editor.on("PostRender", () => {
      editor.on("click", onContentClick);
      editor.on("tap", onContentClick);
      editor.on("mouseup", onContentMouseup);
      editor.on("mousedown", onContentMousedown);
      editor.on("ScrollWindow", onWindowScroll);
      editor.on("ResizeWindow", onWindowResize);
      editor.on("ResizeEditor", onEditorResize);
      editor.on("AfterProgressState", onEditorProgress);
      editor.on("DismissPopups", onDismissPopups);
    });
    editor.on("remove", () => {
      editor.off("click", onContentClick);
      editor.off("tap", onContentClick);
      editor.off("mouseup", onContentMouseup);
      editor.off("mousedown", onContentMousedown);
      editor.off("ScrollWindow", onWindowScroll);
      editor.off("ResizeWindow", onWindowResize);
      editor.off("ResizeEditor", onEditorResize);
      editor.off("AfterProgressState", onEditorProgress);
      editor.off("DismissPopups", onDismissPopups);
      onMousedown.unbind();
      onTouchstart.unbind();
      onTouchmove.unbind();
      onTouchend.unbind();
      onMouseup.unbind();
      onElementScroll.unbind();
    });
    editor.on("detach", () => {
      each$1([
        mothership,
        ...uiMotherships
      ], detachSystem);
      each$1([
        mothership,
        ...uiMotherships
      ], (m) => m.destroy());
    });
  };
  const parts$a = AlloyParts;
  const partType = PartType;
  const schema$f = constant$1([
    defaulted("shell", false),
    required$1("makeItem"),
    defaulted("setupItem", noop2),
    SketchBehaviours.field("listBehaviours", [Replacing])
  ]);
  const customListDetail = () => ({ behaviours: derive$1([Replacing.config({})]) });
  const itemsPart = optional({
    name: "items",
    overrides: customListDetail
  });
  const parts$9 = constant$1([itemsPart]);
  const name2 = constant$1("CustomList");
  const factory$f = (detail, components2, _spec, _external) => {
    const setItems = (list2, items) => {
      getListContainer(list2).fold(() => {
        console.error("Custom List was defined to not be a shell, but no item container was specified in components");
        throw new Error("Custom List was defined to not be a shell, but no item container was specified in components");
      }, (container) => {
        const itemComps = Replacing.contents(container);
        const numListsRequired = items.length;
        const numListsToAdd = numListsRequired - itemComps.length;
        const itemsToAdd = numListsToAdd > 0 ? range$2(numListsToAdd, () => detail.makeItem()) : [];
        const itemsToRemove = itemComps.slice(numListsRequired);
        each$1(itemsToRemove, (item3) => Replacing.remove(container, item3));
        each$1(itemsToAdd, (item3) => Replacing.append(container, item3));
        const builtLists = Replacing.contents(container);
        each$1(builtLists, (item3, i) => {
          detail.setupItem(list2, item3, items[i], i);
        });
      });
    };
    const extra = detail.shell ? {
      behaviours: [Replacing.config({})],
      components: []
    } : {
      behaviours: [],
      components: components2
    };
    const getListContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, "items");
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: extra.components,
      behaviours: augment(detail.listBehaviours, extra.behaviours),
      apis: { setItems }
    };
  };
  const CustomList = composite({
    name: name2(),
    configFields: schema$f(),
    partFields: parts$9(),
    factory: factory$f,
    apis: {
      setItems: (apis2, list2, items) => {
        apis2.setItems(list2, items);
      }
    }
  });
  const schema$e = constant$1([
    required$1("dom"),
    defaulted("shell", true),
    field("toolbarBehaviours", [Replacing])
  ]);
  const enhanceGroups = () => ({ behaviours: derive$1([Replacing.config({})]) });
  const parts$8 = constant$1([optional({
    name: "groups",
    overrides: enhanceGroups
  })]);
  const factory$e = (detail, components2, _spec, _externals) => {
    const setGroups2 = (toolbar, groups) => {
      getGroupContainer(toolbar).fold(() => {
        console.error("Toolbar was defined to not be a shell, but no groups container was specified in components");
        throw new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
      }, (container) => {
        Replacing.set(container, groups);
      });
    };
    const getGroupContainer = (component) => detail.shell ? Optional.some(component) : getPart(component, detail, "groups");
    const extra = detail.shell ? {
      behaviours: [Replacing.config({})],
      components: []
    } : {
      behaviours: [],
      components: components2
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: extra.components,
      behaviours: augment(detail.toolbarBehaviours, extra.behaviours),
      apis: { setGroups: setGroups2 },
      domModification: { attributes: { role: "group" } }
    };
  };
  const Toolbar = composite({
    name: "Toolbar",
    configFields: schema$e(),
    partFields: parts$8(),
    factory: factory$e,
    apis: {
      setGroups: (apis2, toolbar, groups) => {
        apis2.setGroups(toolbar, groups);
      }
    }
  });
  const setup$a = noop2;
  const isDocked$2 = never;
  const getBehaviours$1 = constant$1([]);
  var StaticHeader = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: setup$a,
    isDocked: isDocked$2,
    getBehaviours: getBehaviours$1
  });
  const getOffsetParent2 = (element2) => {
    const isFixed = is$1(getRaw(element2, "position"), "fixed");
    const offsetParent$1 = isFixed ? Optional.none() : offsetParent(element2);
    return offsetParent$1.orThunk(() => {
      const marker = SugarElement.fromTag("span");
      return parent(element2).bind((parent2) => {
        append$2(parent2, marker);
        const offsetParent$12 = offsetParent(marker);
        remove$5(marker);
        return offsetParent$12;
      });
    });
  };
  const getOrigin = (element2) => getOffsetParent2(element2).map(absolute$3).getOrThunk(() => SugarPosition(0, 0));
  const appear = (component, contextualInfo) => {
    const elem = component.element;
    add$2(elem, contextualInfo.transitionClass);
    remove$2(elem, contextualInfo.fadeOutClass);
    add$2(elem, contextualInfo.fadeInClass);
    contextualInfo.onShow(component);
  };
  const disappear = (component, contextualInfo) => {
    const elem = component.element;
    add$2(elem, contextualInfo.transitionClass);
    remove$2(elem, contextualInfo.fadeInClass);
    add$2(elem, contextualInfo.fadeOutClass);
    contextualInfo.onHide(component);
  };
  const isPartiallyVisible = (box2, bounds2) => box2.y < bounds2.bottom && box2.bottom > bounds2.y;
  const isTopCompletelyVisible = (box2, bounds2) => box2.y >= bounds2.y;
  const isBottomCompletelyVisible = (box2, bounds2) => box2.bottom <= bounds2.bottom;
  const forceTopPosition = (winBox, leftX, viewport3) => ({
    location: "top",
    leftX,
    topY: viewport3.bounds.y - winBox.y
  });
  const forceBottomPosition = (winBox, leftX, viewport3) => ({
    location: "bottom",
    leftX,
    bottomY: winBox.bottom - viewport3.bounds.bottom
  });
  const getDockedLeftPosition = (bounds2) => {
    return bounds2.box.x - bounds2.win.x;
  };
  const tryDockingPosition = (modes, bounds2, viewport3) => {
    const winBox = bounds2.win;
    const box2 = bounds2.box;
    const leftX = getDockedLeftPosition(bounds2);
    return findMap(modes, (mode) => {
      switch (mode) {
        case "bottom":
          return !isBottomCompletelyVisible(box2, viewport3.bounds) ? Optional.some(forceBottomPosition(winBox, leftX, viewport3)) : Optional.none();
        case "top":
          return !isTopCompletelyVisible(box2, viewport3.bounds) ? Optional.some(forceTopPosition(winBox, leftX, viewport3)) : Optional.none();
        default:
          return Optional.none();
      }
    }).getOr({ location: "no-dock" });
  };
  const isVisibleForModes = (modes, box2, viewport3) => forall(modes, (mode) => {
    switch (mode) {
      case "bottom":
        return isBottomCompletelyVisible(box2, viewport3.bounds);
      case "top":
        return isTopCompletelyVisible(box2, viewport3.bounds);
    }
  });
  const getXYForRestoring = (pos, viewport3) => {
    const priorY = viewport3.optScrollEnv.fold(constant$1(pos.bounds.y), (scrollEnv) => scrollEnv.scrollElmTop + (pos.bounds.y - scrollEnv.currentScrollTop));
    return SugarPosition(pos.bounds.x, priorY);
  };
  const getXYForSaving = (box2, viewport3) => {
    const priorY = viewport3.optScrollEnv.fold(constant$1(box2.y), (scrollEnv) => box2.y + scrollEnv.currentScrollTop - scrollEnv.scrollElmTop);
    return SugarPosition(box2.x, priorY);
  };
  const getPrior = (elem, viewport3, state2) => state2.getInitialPos().map((pos) => {
    const xy = getXYForRestoring(pos, viewport3);
    return {
      box: bounds(xy.left, xy.top, get$c(elem), get$d(elem)),
      location: pos.location
    };
  });
  const storePrior = (elem, box2, viewport3, state2, decision) => {
    const xy = getXYForSaving(box2, viewport3);
    const bounds$12 = bounds(xy.left, xy.top, box2.width, box2.height);
    state2.setInitialPos({
      style: getAllRaw(elem),
      position: get$e(elem, "position") || "static",
      bounds: bounds$12,
      location: decision.location
    });
  };
  const storePriorIfNone = (elem, box2, viewport3, state2, decision) => {
    state2.getInitialPos().fold(() => storePrior(elem, box2, viewport3, state2, decision), () => noop2);
  };
  const revertToOriginal = (elem, box2, state2) => state2.getInitialPos().bind((position2) => {
    var _a;
    state2.clearInitialPos();
    switch (position2.position) {
      case "static":
        return Optional.some({ morph: "static" });
      case "absolute":
        const offsetParent2 = getOffsetParent2(elem).getOr(body());
        const offsetBox = box$1(offsetParent2);
        const scrollDelta = (_a = offsetParent2.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
        return Optional.some({
          morph: "absolute",
          positionCss: NuPositionCss("absolute", get$g(position2.style, "left").map((_left) => box2.x - offsetBox.x), get$g(position2.style, "top").map((_top) => box2.y - offsetBox.y + scrollDelta), get$g(position2.style, "right").map((_right) => offsetBox.right - box2.right), get$g(position2.style, "bottom").map((_bottom) => offsetBox.bottom - box2.bottom))
        });
      default:
        return Optional.none();
    }
  });
  const tryMorphToOriginal = (elem, viewport3, state2) => getPrior(elem, viewport3, state2).filter(({ box: box2 }) => isVisibleForModes(state2.getModes(), box2, viewport3)).bind(({ box: box2 }) => revertToOriginal(elem, box2, state2));
  const tryDecisionToFixedMorph = (decision) => {
    switch (decision.location) {
      case "top": {
        return Optional.some({
          morph: "fixed",
          positionCss: NuPositionCss("fixed", Optional.some(decision.leftX), Optional.some(decision.topY), Optional.none(), Optional.none())
        });
      }
      case "bottom": {
        return Optional.some({
          morph: "fixed",
          positionCss: NuPositionCss("fixed", Optional.some(decision.leftX), Optional.none(), Optional.none(), Optional.some(decision.bottomY))
        });
      }
      default:
        return Optional.none();
    }
  };
  const tryMorphToFixed = (elem, viewport3, state2) => {
    const box2 = box$1(elem);
    const winBox = win();
    const decision = tryDockingPosition(state2.getModes(), {
      win: winBox,
      box: box2
    }, viewport3);
    if (decision.location === "top" || decision.location === "bottom") {
      storePrior(elem, box2, viewport3, state2, decision);
      return tryDecisionToFixedMorph(decision);
    } else {
      return Optional.none();
    }
  };
  const tryMorphToOriginalOrUpdateFixed = (elem, viewport3, state2) => {
    return tryMorphToOriginal(elem, viewport3, state2).orThunk(() => {
      return viewport3.optScrollEnv.bind((_2) => getPrior(elem, viewport3, state2)).bind(({ box: box2, location: location2 }) => {
        const winBox = win();
        const leftX = getDockedLeftPosition({
          win: winBox,
          box: box2
        });
        const decision = location2 === "top" ? forceTopPosition(winBox, leftX, viewport3) : forceBottomPosition(winBox, leftX, viewport3);
        return tryDecisionToFixedMorph(decision);
      });
    });
  };
  const tryMorph = (component, viewport3, state2) => {
    const elem = component.element;
    const isDocked2 = is$1(getRaw(elem, "position"), "fixed");
    return isDocked2 ? tryMorphToOriginalOrUpdateFixed(elem, viewport3, state2) : tryMorphToFixed(elem, viewport3, state2);
  };
  const calculateMorphToOriginal = (component, viewport3, state2) => {
    const elem = component.element;
    return getPrior(elem, viewport3, state2).bind(({ box: box2 }) => revertToOriginal(elem, box2, state2));
  };
  const forceDockWith = (elem, viewport3, state2, getDecision) => {
    const box2 = box$1(elem);
    const winBox = win();
    const leftX = getDockedLeftPosition({
      win: winBox,
      box: box2
    });
    const decision = getDecision(winBox, leftX, viewport3);
    if (decision.location === "bottom" || decision.location === "top") {
      storePriorIfNone(elem, box2, viewport3, state2, decision);
      return tryDecisionToFixedMorph(decision);
    } else {
      return Optional.none();
    }
  };
  const morphToStatic = (component, config2, state2) => {
    state2.setDocked(false);
    each$1([
      "left",
      "right",
      "top",
      "bottom",
      "position"
    ], (prop) => remove$6(component.element, prop));
    config2.onUndocked(component);
  };
  const morphToCoord = (component, config2, state2, position2) => {
    const isDocked2 = position2.position === "fixed";
    state2.setDocked(isDocked2);
    applyPositionCss(component.element, position2);
    const method = isDocked2 ? config2.onDocked : config2.onUndocked;
    method(component);
  };
  const updateVisibility = (component, config2, state2, viewport3, morphToDocked = false) => {
    config2.contextual.each((contextInfo) => {
      contextInfo.lazyContext(component).each((box2) => {
        const isVisible3 = isPartiallyVisible(box2, viewport3.bounds);
        if (isVisible3 !== state2.isVisible()) {
          state2.setVisible(isVisible3);
          if (morphToDocked && !isVisible3) {
            add$1(component.element, [contextInfo.fadeOutClass]);
            contextInfo.onHide(component);
          } else {
            const method = isVisible3 ? appear : disappear;
            method(component, contextInfo);
          }
        }
      });
    });
  };
  const applyFixedMorph = (component, config2, state2, viewport3, morph) => {
    updateVisibility(component, config2, state2, viewport3, true);
    morphToCoord(component, config2, state2, morph.positionCss);
  };
  const applyMorph = (component, config2, state2, viewport3, morph) => {
    switch (morph.morph) {
      case "static": {
        return morphToStatic(component, config2, state2);
      }
      case "absolute": {
        return morphToCoord(component, config2, state2, morph.positionCss);
      }
      case "fixed": {
        return applyFixedMorph(component, config2, state2, viewport3, morph);
      }
    }
  };
  const refreshInternal = (component, config2, state2) => {
    const viewport3 = config2.lazyViewport(component);
    updateVisibility(component, config2, state2, viewport3);
    tryMorph(component, viewport3, state2).each((morph) => {
      applyMorph(component, config2, state2, viewport3, morph);
    });
  };
  const resetInternal = (component, config2, state2) => {
    const elem = component.element;
    state2.setDocked(false);
    const viewport3 = config2.lazyViewport(component);
    calculateMorphToOriginal(component, viewport3, state2).each((staticOrAbsoluteMorph) => {
      switch (staticOrAbsoluteMorph.morph) {
        case "static": {
          morphToStatic(component, config2, state2);
          break;
        }
        case "absolute": {
          morphToCoord(component, config2, state2, staticOrAbsoluteMorph.positionCss);
          break;
        }
      }
    });
    state2.setVisible(true);
    config2.contextual.each((contextInfo) => {
      remove$1(elem, [
        contextInfo.fadeInClass,
        contextInfo.fadeOutClass,
        contextInfo.transitionClass
      ]);
      contextInfo.onShow(component);
    });
    refresh$3(component, config2, state2);
  };
  const refresh$3 = (component, config2, state2) => {
    if (component.getSystem().isConnected()) {
      refreshInternal(component, config2, state2);
    }
  };
  const reset = (component, config2, state2) => {
    if (state2.isDocked()) {
      resetInternal(component, config2, state2);
    }
  };
  const forceDockWithDecision = (getDecision) => (component, config2, state2) => {
    const viewport3 = config2.lazyViewport(component);
    const optMorph = forceDockWith(component.element, viewport3, state2, getDecision);
    optMorph.each((morph) => {
      applyFixedMorph(component, config2, state2, viewport3, morph);
    });
  };
  const forceDockToTop = forceDockWithDecision(forceTopPosition);
  const forceDockToBottom = forceDockWithDecision(forceBottomPosition);
  const isDocked$1 = (component, config2, state2) => state2.isDocked();
  const setModes = (component, config2, state2, modes) => state2.setModes(modes);
  const getModes = (component, config2, state2) => state2.getModes();
  var DockingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    refresh: refresh$3,
    reset,
    isDocked: isDocked$1,
    getModes,
    setModes,
    forceDockToTop,
    forceDockToBottom
  });
  const events$4 = (dockInfo, dockState) => derive$2([
    runOnSource(transitionend(), (component, simulatedEvent) => {
      dockInfo.contextual.each((contextInfo) => {
        if (has(component.element, contextInfo.transitionClass)) {
          remove$1(component.element, [
            contextInfo.transitionClass,
            contextInfo.fadeInClass
          ]);
          const notify = dockState.isVisible() ? contextInfo.onShown : contextInfo.onHidden;
          notify(component);
        }
        simulatedEvent.stop();
      });
    }),
    run$1(windowScroll(), (component, _2) => {
      refresh$3(component, dockInfo, dockState);
    }),
    run$1(externalElementScroll(), (component, _2) => {
      refresh$3(component, dockInfo, dockState);
    }),
    run$1(windowResize(), (component, _2) => {
      reset(component, dockInfo, dockState);
    })
  ]);
  var ActiveDocking = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events: events$4
  });
  var DockingSchema = [
    optionObjOf("contextual", [
      requiredString("fadeInClass"),
      requiredString("fadeOutClass"),
      requiredString("transitionClass"),
      requiredFunction("lazyContext"),
      onHandler("onShow"),
      onHandler("onShown"),
      onHandler("onHide"),
      onHandler("onHidden")
    ]),
    defaultedFunction("lazyViewport", () => ({
      bounds: win(),
      optScrollEnv: Optional.none()
    })),
    defaultedArrayOf("modes", [
      "top",
      "bottom"
    ], string),
    onHandler("onDocked"),
    onHandler("onUndocked")
  ];
  const init$5 = (spec) => {
    const docked = Cell(false);
    const visible = Cell(true);
    const initialBounds = value$2();
    const modes = Cell(spec.modes);
    const readState = () => `docked:  ${docked.get()}, visible: ${visible.get()}, modes: ${modes.get().join(",")}`;
    return nu$8({
      isDocked: docked.get,
      setDocked: docked.set,
      getInitialPos: initialBounds.get,
      setInitialPos: initialBounds.set,
      clearInitialPos: initialBounds.clear,
      isVisible: visible.get,
      setVisible: visible.set,
      getModes: modes.get,
      setModes: modes.set,
      readState
    });
  };
  var DockingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$5
  });
  const Docking = create$42({
    fields: DockingSchema,
    name: "docking",
    active: ActiveDocking,
    apis: DockingApis,
    state: DockingState
  });
  const toolbarHeightChange = constant$1(generate$6("toolbar-height-change"));
  const visibility = {
    fadeInClass: "tox-editor-dock-fadein",
    fadeOutClass: "tox-editor-dock-fadeout",
    transitionClass: "tox-editor-dock-transition"
  };
  const editorStickyOnClass = "tox-tinymce--toolbar-sticky-on";
  const editorStickyOffClass = "tox-tinymce--toolbar-sticky-off";
  const scrollFromBehindHeader = (e, containerHeader) => {
    const doc = owner$4(containerHeader);
    const win2 = defaultView(containerHeader);
    const viewHeight = win2.dom.innerHeight;
    const scrollPos = get$b(doc);
    const markerElement = SugarElement.fromDom(e.elm);
    const markerPos = absolute$2(markerElement);
    const markerHeight = get$d(markerElement);
    const markerTop = markerPos.y;
    const markerBottom = markerTop + markerHeight;
    const editorHeaderPos = absolute$3(containerHeader);
    const editorHeaderHeight = get$d(containerHeader);
    const editorHeaderTop = editorHeaderPos.top;
    const editorHeaderBottom = editorHeaderTop + editorHeaderHeight;
    const editorHeaderDockedAtTop = Math.abs(editorHeaderTop - scrollPos.top) < 2;
    const editorHeaderDockedAtBottom = Math.abs(editorHeaderBottom - (scrollPos.top + viewHeight)) < 2;
    if (editorHeaderDockedAtTop && markerTop < editorHeaderBottom) {
      to(scrollPos.left, markerTop - editorHeaderHeight, doc);
    } else if (editorHeaderDockedAtBottom && markerBottom > editorHeaderTop) {
      const y = markerTop - viewHeight + markerHeight + editorHeaderHeight;
      to(scrollPos.left, y, doc);
    }
  };
  const isDockedMode = (header, mode) => contains$2(Docking.getModes(header), mode);
  const updateIframeContentFlow = (header) => {
    const getOccupiedHeight = (elm2) => getOuter$2(elm2) + (parseInt(get$e(elm2, "margin-top"), 10) || 0) + (parseInt(get$e(elm2, "margin-bottom"), 10) || 0);
    const elm = header.element;
    parentElement(elm).each((parentElem) => {
      const padding = "padding-" + Docking.getModes(header)[0];
      if (Docking.isDocked(header)) {
        const parentWidth = get$c(parentElem);
        set$8(elm, "width", parentWidth + "px");
        set$8(parentElem, padding, getOccupiedHeight(elm) + "px");
      } else {
        remove$6(elm, "width");
        remove$6(parentElem, padding);
      }
    });
  };
  const updateSinkVisibility = (sinkElem, visible) => {
    if (visible) {
      remove$2(sinkElem, visibility.fadeOutClass);
      add$1(sinkElem, [
        visibility.transitionClass,
        visibility.fadeInClass
      ]);
    } else {
      remove$2(sinkElem, visibility.fadeInClass);
      add$1(sinkElem, [
        visibility.fadeOutClass,
        visibility.transitionClass
      ]);
    }
  };
  const updateEditorClasses = (editor, docked) => {
    const editorContainer = SugarElement.fromDom(editor.getContainer());
    if (docked) {
      add$2(editorContainer, editorStickyOnClass);
      remove$2(editorContainer, editorStickyOffClass);
    } else {
      add$2(editorContainer, editorStickyOffClass);
      remove$2(editorContainer, editorStickyOnClass);
    }
  };
  const restoreFocus = (headerElem, focusedElem) => {
    const ownerDoc = owner$4(focusedElem);
    active$1(ownerDoc).filter((activeElm) => !eq(focusedElem, activeElm)).filter((activeElm) => eq(activeElm, SugarElement.fromDom(ownerDoc.dom.body)) || contains2(headerElem, activeElm)).each(() => focus$3(focusedElem));
  };
  const findFocusedElem = (rootElm, lazySink) => search(rootElm).orThunk(() => lazySink().toOptional().bind((sink) => search(sink.element)));
  const setup$9 = (editor, sharedBackstage, lazyHeader) => {
    if (!editor.inline) {
      if (!sharedBackstage.header.isPositionedAtTop()) {
        editor.on("ResizeEditor", () => {
          lazyHeader().each(Docking.reset);
        });
      }
      editor.on("ResizeWindow ResizeEditor", () => {
        lazyHeader().each(updateIframeContentFlow);
      });
      editor.on("SkinLoaded", () => {
        lazyHeader().each((comp) => {
          Docking.isDocked(comp) ? Docking.reset(comp) : Docking.refresh(comp);
        });
      });
      editor.on("FullscreenStateChanged", () => {
        lazyHeader().each(Docking.reset);
      });
    }
    editor.on("AfterScrollIntoView", (e) => {
      lazyHeader().each((header) => {
        Docking.refresh(header);
        const headerElem = header.element;
        if (isVisible2(headerElem)) {
          scrollFromBehindHeader(e, headerElem);
        }
      });
    });
    editor.on("PostRender", () => {
      updateEditorClasses(editor, false);
    });
  };
  const isDocked = (lazyHeader) => lazyHeader().map(Docking.isDocked).getOr(false);
  const getIframeBehaviours = () => [Receiving.config({ channels: { [toolbarHeightChange()]: { onReceive: updateIframeContentFlow } } })];
  const getBehaviours = (editor, sharedBackstage) => {
    const focusedElm = value$2();
    const lazySink = sharedBackstage.getSink;
    const runOnSinkElement = (f2) => {
      lazySink().each((sink) => f2(sink.element));
    };
    const onDockingSwitch = (comp) => {
      if (!editor.inline) {
        updateIframeContentFlow(comp);
      }
      updateEditorClasses(editor, Docking.isDocked(comp));
      comp.getSystem().broadcastOn([repositionPopups()], {});
      lazySink().each((sink) => sink.getSystem().broadcastOn([repositionPopups()], {}));
    };
    const additionalBehaviours = editor.inline ? [] : getIframeBehaviours();
    return [
      Focusing.config({}),
      Docking.config({
        contextual: {
          lazyContext: (comp) => {
            const headerHeight = getOuter$2(comp.element);
            const container = editor.inline ? editor.getContentAreaContainer() : editor.getContainer();
            return Optional.from(container).map((c) => {
              const box2 = box$1(SugarElement.fromDom(c));
              const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
              return optScrollingContext.fold(() => {
                const boxHeight = box2.height - headerHeight;
                const topBound = box2.y + (isDockedMode(comp, "top") ? 0 : headerHeight);
                return bounds(box2.x, topBound, box2.width, boxHeight);
              }, (scrollEnv) => {
                const constrainedBounds = constrain(box2, getBoundsFrom(scrollEnv));
                return bounds(constrainedBounds.x, constrainedBounds.y, constrainedBounds.width, constrainedBounds.height - headerHeight);
              });
            });
          },
          onShow: () => {
            runOnSinkElement((elem) => updateSinkVisibility(elem, true));
          },
          onShown: (comp) => {
            runOnSinkElement((elem) => remove$1(elem, [
              visibility.transitionClass,
              visibility.fadeInClass
            ]));
            focusedElm.get().each((elem) => {
              restoreFocus(comp.element, elem);
              focusedElm.clear();
            });
          },
          onHide: (comp) => {
            findFocusedElem(comp.element, lazySink).fold(focusedElm.clear, focusedElm.set);
            runOnSinkElement((elem) => updateSinkVisibility(elem, false));
          },
          onHidden: () => {
            runOnSinkElement((elem) => remove$1(elem, [visibility.transitionClass]));
          },
          ...visibility
        },
        lazyViewport: (comp) => {
          const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
          return optScrollingContext.fold(() => {
            const boundsWithoutOffset = win();
            const offset3 = getStickyToolbarOffset(editor);
            const top3 = boundsWithoutOffset.y + (isDockedMode(comp, "top") ? offset3 : 0);
            const height3 = boundsWithoutOffset.height - (isDockedMode(comp, "bottom") ? offset3 : 0);
            return {
              bounds: bounds(boundsWithoutOffset.x, top3, boundsWithoutOffset.width, height3),
              optScrollEnv: Optional.none()
            };
          }, (sc) => {
            const combinedBounds = getBoundsFrom(sc);
            return {
              bounds: combinedBounds,
              optScrollEnv: Optional.some({
                currentScrollTop: sc.element.dom.scrollTop,
                scrollElmTop: absolute$3(sc.element).top
              })
            };
          });
        },
        modes: [sharedBackstage.header.getDockingMode()],
        onDocked: onDockingSwitch,
        onUndocked: onDockingSwitch
      }),
      ...additionalBehaviours
    ];
  };
  var StickyHeader = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    setup: setup$9,
    isDocked,
    getBehaviours
  });
  const renderHeader = (spec) => {
    const editor = spec.editor;
    const getBehaviours$22 = spec.sticky ? getBehaviours : getBehaviours$1;
    return {
      uid: spec.uid,
      dom: spec.dom,
      components: spec.components,
      behaviours: derive$1(getBehaviours$22(editor, spec.sharedBackstage))
    };
  };
  const groupToolbarButtonSchema = objOf([
    type,
    requiredOf("items", oneOf([
      arrOfObj([
        name$1,
        requiredArrayOf("items", string)
      ]),
      string
    ]))
  ].concat(baseToolbarButtonFields));
  const createGroupToolbarButton = (spec) => asRaw("GroupToolbarButton", groupToolbarButtonSchema, spec);
  const baseMenuButtonFields = [
    optionString("text"),
    optionString("tooltip"),
    optionString("icon"),
    defaultedOf("search", false, oneOf([
      boolean,
      objOf([optionString("placeholder")])
    ], (x) => {
      if (isBoolean2(x)) {
        return x ? Optional.some({ placeholder: Optional.none() }) : Optional.none();
      } else {
        return Optional.some(x);
      }
    })),
    requiredFunction("fetch"),
    defaultedFunction("onSetup", () => noop2)
  ];
  const MenuButtonSchema = objOf([
    type,
    ...baseMenuButtonFields
  ]);
  const createMenuButton = (spec) => asRaw("menubutton", MenuButtonSchema, spec);
  const splitButtonSchema = objOf([
    type,
    optionalTooltip,
    optionalIcon,
    optionalText,
    optionalSelect,
    fetch$1,
    onSetup,
    defaultedStringEnum("presets", "normal", [
      "normal",
      "color",
      "listpreview"
    ]),
    defaultedColumns(1),
    onAction,
    onItemAction
  ]);
  const createSplitButton = (spec) => asRaw("SplitButton", splitButtonSchema, spec);
  const factory$d = (detail, spec) => {
    const setMenus = (comp, menus) => {
      const newMenus = map$2(menus, (m) => {
        const buttonSpec = {
          type: "menubutton",
          text: m.text,
          fetch: (callback) => {
            callback(m.getItems());
          }
        };
        const internal = createMenuButton(buttonSpec).mapError((errInfo) => formatError(errInfo)).getOrDie();
        return renderMenuButton(internal, "tox-mbtn", spec.backstage, Optional.some("menuitem"));
      });
      Replacing.set(comp, newMenus);
    };
    const apis2 = {
      focus: Keying.focusIn,
      setMenus
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: [],
      behaviours: derive$1([
        Replacing.config({}),
        config("menubar-events", [
          runOnAttached((component) => {
            detail.onSetup(component);
          }),
          run$1(mouseover(), (comp, se) => {
            descendant(comp.element, ".tox-mbtn--active").each((activeButton) => {
              closest$1(se.event.target, ".tox-mbtn").each((hoveredButton) => {
                if (!eq(activeButton, hoveredButton)) {
                  comp.getSystem().getByDom(activeButton).each((activeComp) => {
                    comp.getSystem().getByDom(hoveredButton).each((hoveredComp) => {
                      Dropdown2.expand(hoveredComp);
                      Dropdown2.close(activeComp);
                      Focusing.focus(hoveredComp);
                    });
                  });
                }
              });
            });
          }),
          run$1(focusShifted(), (comp, se) => {
            se.event.prevFocus.bind((prev) => comp.getSystem().getByDom(prev).toOptional()).each((prev) => {
              se.event.newFocus.bind((nu2) => comp.getSystem().getByDom(nu2).toOptional()).each((nu2) => {
                if (Dropdown2.isOpen(prev)) {
                  Dropdown2.expand(nu2);
                  Dropdown2.close(prev);
                }
              });
            });
          })
        ]),
        Keying.config({
          mode: "flow",
          selector: ".tox-mbtn",
          onEscape: (comp) => {
            detail.onEscape(comp);
            return Optional.some(true);
          }
        }),
        Tabstopping.config({})
      ]),
      apis: apis2,
      domModification: { attributes: { role: "menubar" } }
    };
  };
  var SilverMenubar = single({
    factory: factory$d,
    name: "silver.Menubar",
    configFields: [
      required$1("dom"),
      required$1("uid"),
      required$1("onEscape"),
      required$1("backstage"),
      defaulted("onSetup", noop2)
    ],
    apis: {
      focus: (apis2, comp) => {
        apis2.focus(comp);
      },
      setMenus: (apis2, comp, menus) => {
        apis2.setMenus(comp, menus);
      }
    }
  });
  const promotionMessage = "⚡️Upgrade";
  const promotionLink = "https://www.tiny.cloud/tinymce-self-hosted-premium-features/?utm_source=TinyMCE&utm_medium=SPAP&utm_campaign=SPAP&utm_id=editorreferral";
  const renderPromotion = (spec) => {
    return {
      uid: spec.uid,
      dom: spec.dom,
      components: [{
        dom: {
          tag: "a",
          attributes: {
            "href": promotionLink,
            "rel": "noopener",
            "target": "_blank",
            "aria-hidden": "true"
          },
          classes: ["tox-promotion-link"],
          innerHtml: promotionMessage
        }
      }]
    };
  };
  const owner = "container";
  const schema$d = [field("slotBehaviours", [])];
  const getPartName = (name3) => "<alloy.field." + name3 + ">";
  const sketch = (sSpec) => {
    const parts2 = (() => {
      const record2 = [];
      const slot = (name3, config2) => {
        record2.push(name3);
        return generateOne$1(owner, getPartName(name3), config2);
      };
      return {
        slot,
        record: constant$1(record2)
      };
    })();
    const spec = sSpec(parts2);
    const partNames = parts2.record();
    const fieldParts = map$2(partNames, (n) => required({
      name: n,
      pname: getPartName(n)
    }));
    return composite$1(owner, schema$d, fieldParts, make$1, spec);
  };
  const make$1 = (detail, components2) => {
    const getSlotNames = (_2) => getAllPartNames(detail);
    const getSlot = (container, key) => getPart(container, detail, key);
    const onSlot = (f2, def) => (container, key) => getPart(container, detail, key).map((slot) => f2(slot, key)).getOr(def);
    const onSlots = (f2) => (container, keys2) => {
      each$1(keys2, (key) => f2(container, key));
    };
    const doShowing = (comp, _key) => get$f(comp.element, "aria-hidden") !== "true";
    const doShow = (comp, key) => {
      if (!doShowing(comp)) {
        const element2 = comp.element;
        remove$6(element2, "display");
        remove$7(element2, "aria-hidden");
        emitWith(comp, slotVisibility(), {
          name: key,
          visible: true
        });
      }
    };
    const doHide = (comp, key) => {
      if (doShowing(comp)) {
        const element2 = comp.element;
        set$8(element2, "display", "none");
        set$9(element2, "aria-hidden", "true");
        emitWith(comp, slotVisibility(), {
          name: key,
          visible: false
        });
      }
    };
    const isShowing = onSlot(doShowing, false);
    const hideSlot = onSlot(doHide);
    const hideSlots = onSlots(hideSlot);
    const hideAllSlots = (container) => hideSlots(container, getSlotNames());
    const showSlot = onSlot(doShow);
    const apis2 = {
      getSlotNames,
      getSlot,
      isShowing,
      hideSlot,
      hideAllSlots,
      showSlot
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: get$3(detail.slotBehaviours),
      apis: apis2
    };
  };
  const slotApis = map$1({
    getSlotNames: (apis2, c) => apis2.getSlotNames(c),
    getSlot: (apis2, c, key) => apis2.getSlot(c, key),
    isShowing: (apis2, c, key) => apis2.isShowing(c, key),
    hideSlot: (apis2, c, key) => apis2.hideSlot(c, key),
    hideAllSlots: (apis2, c) => apis2.hideAllSlots(c),
    showSlot: (apis2, c, key) => apis2.showSlot(c, key)
  }, (value2) => makeApi(value2));
  const SlotContainer = {
    ...slotApis,
    ...{ sketch }
  };
  const sidebarSchema = objOf([
    optionalIcon,
    optionalTooltip,
    defaultedFunction("onShow", noop2),
    defaultedFunction("onHide", noop2),
    onSetup
  ]);
  const createSidebar = (spec) => asRaw("sidebar", sidebarSchema, spec);
  const setup$8 = (editor) => {
    const { sidebars } = editor.ui.registry.getAll();
    each$1(keys(sidebars), (name3) => {
      const spec = sidebars[name3];
      const isActive = () => is$1(Optional.from(editor.queryCommandValue("ToggleSidebar")), name3);
      editor.ui.registry.addToggleButton(name3, {
        icon: spec.icon,
        tooltip: spec.tooltip,
        onAction: (buttonApi) => {
          editor.execCommand("ToggleSidebar", false, name3);
          buttonApi.setActive(isActive());
        },
        onSetup: (buttonApi) => {
          buttonApi.setActive(isActive());
          const handleToggle = () => buttonApi.setActive(isActive());
          editor.on("ToggleSidebar", handleToggle);
          return () => {
            editor.off("ToggleSidebar", handleToggle);
          };
        }
      });
    });
  };
  const getApi = (comp) => ({ element: () => comp.element.dom });
  const makePanels = (parts2, panelConfigs) => {
    const specs = map$2(keys(panelConfigs), (name3) => {
      const spec = panelConfigs[name3];
      const bridged = getOrDie(createSidebar(spec));
      return {
        name: name3,
        getApi,
        onSetup: bridged.onSetup,
        onShow: bridged.onShow,
        onHide: bridged.onHide
      };
    });
    return map$2(specs, (spec) => {
      const editorOffCell = Cell(noop2);
      return parts2.slot(spec.name, {
        dom: {
          tag: "div",
          classes: ["tox-sidebar__pane"]
        },
        behaviours: SimpleBehaviours.unnamedEvents([
          onControlAttached(spec, editorOffCell),
          onControlDetached(spec, editorOffCell),
          run$1(slotVisibility(), (sidepanel, se) => {
            const data2 = se.event;
            const optSidePanelSpec = find$5(specs, (config2) => config2.name === data2.name);
            optSidePanelSpec.each((sidePanelSpec) => {
              const handler = data2.visible ? sidePanelSpec.onShow : sidePanelSpec.onHide;
              handler(sidePanelSpec.getApi(sidepanel));
            });
          })
        ])
      });
    });
  };
  const makeSidebar = (panelConfigs) => SlotContainer.sketch((parts2) => ({
    dom: {
      tag: "div",
      classes: ["tox-sidebar__pane-container"]
    },
    components: makePanels(parts2, panelConfigs),
    slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))])
  }));
  const setSidebar = (sidebar, panelConfigs, showSidebar) => {
    const optSlider = Composing.getCurrent(sidebar);
    optSlider.each((slider) => {
      Replacing.set(slider, [makeSidebar(panelConfigs)]);
      const configKey = showSidebar === null || showSidebar === void 0 ? void 0 : showSidebar.toLowerCase();
      if (isString2(configKey) && has$2(panelConfigs, configKey)) {
        Composing.getCurrent(slider).each((slotContainer) => {
          SlotContainer.showSlot(slotContainer, configKey);
          Sliding.immediateGrow(slider);
          remove$6(slider.element, "width");
          updateSidebarRoleOnToggle(sidebar.element, "region");
        });
      }
    });
  };
  const updateSidebarRoleOnToggle = (sidebar, sidebarState) => {
    set$9(sidebar, "role", sidebarState);
  };
  const toggleSidebar = (sidebar, name3) => {
    const optSlider = Composing.getCurrent(sidebar);
    optSlider.each((slider) => {
      const optSlotContainer = Composing.getCurrent(slider);
      optSlotContainer.each((slotContainer) => {
        if (Sliding.hasGrown(slider)) {
          if (SlotContainer.isShowing(slotContainer, name3)) {
            Sliding.shrink(slider);
            updateSidebarRoleOnToggle(sidebar.element, "presentation");
          } else {
            SlotContainer.hideAllSlots(slotContainer);
            SlotContainer.showSlot(slotContainer, name3);
            updateSidebarRoleOnToggle(sidebar.element, "region");
          }
        } else {
          SlotContainer.hideAllSlots(slotContainer);
          SlotContainer.showSlot(slotContainer, name3);
          Sliding.grow(slider);
          updateSidebarRoleOnToggle(sidebar.element, "region");
        }
      });
    });
  };
  const whichSidebar = (sidebar) => {
    const optSlider = Composing.getCurrent(sidebar);
    return optSlider.bind((slider) => {
      const sidebarOpen = Sliding.isGrowing(slider) || Sliding.hasGrown(slider);
      if (sidebarOpen) {
        const optSlotContainer = Composing.getCurrent(slider);
        return optSlotContainer.bind((slotContainer) => find$5(SlotContainer.getSlotNames(slotContainer), (name3) => SlotContainer.isShowing(slotContainer, name3)));
      } else {
        return Optional.none();
      }
    });
  };
  const fixSize = generate$6("FixSizeEvent");
  const autoSize = generate$6("AutoSizeEvent");
  const renderSidebar = (spec) => ({
    uid: spec.uid,
    dom: {
      tag: "div",
      classes: ["tox-sidebar"],
      attributes: { role: "presentation" }
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-sidebar__slider"]
      },
      components: [],
      behaviours: derive$1([
        Tabstopping.config({}),
        Focusing.config({}),
        Sliding.config({
          dimension: { property: "width" },
          closedClass: "tox-sidebar--sliding-closed",
          openClass: "tox-sidebar--sliding-open",
          shrinkingClass: "tox-sidebar--sliding-shrinking",
          growingClass: "tox-sidebar--sliding-growing",
          onShrunk: (slider) => {
            const optSlotContainer = Composing.getCurrent(slider);
            optSlotContainer.each(SlotContainer.hideAllSlots);
            emit(slider, autoSize);
          },
          onGrown: (slider) => {
            emit(slider, autoSize);
          },
          onStartGrow: (slider) => {
            emitWith(slider, fixSize, { width: getRaw(slider.element, "width").getOr("") });
          },
          onStartShrink: (slider) => {
            emitWith(slider, fixSize, { width: get$c(slider.element) + "px" });
          }
        }),
        Replacing.config({}),
        Composing.config({
          find: (comp) => {
            const children2 = Replacing.contents(comp);
            return head(children2);
          }
        })
      ])
    }],
    behaviours: derive$1([
      ComposingConfigs.childAt(0),
      config("sidebar-sliding-events", [
        run$1(fixSize, (comp, se) => {
          set$8(comp.element, "width", se.event.width);
        }),
        run$1(autoSize, (comp, _se) => {
          remove$6(comp.element, "width");
        })
      ])
    ])
  });
  const block = (component, config2, state2, getBusySpec2) => {
    set$9(component.element, "aria-busy", true);
    const root2 = config2.getRoot(component).getOr(component);
    const blockerBehaviours = derive$1([
      Keying.config({
        mode: "special",
        onTab: () => Optional.some(true),
        onShiftTab: () => Optional.some(true)
      }),
      Focusing.config({})
    ]);
    const blockSpec = getBusySpec2(root2, blockerBehaviours);
    const blocker = root2.getSystem().build(blockSpec);
    Replacing.append(root2, premade(blocker));
    if (blocker.hasConfigured(Keying) && config2.focus) {
      Keying.focusIn(blocker);
    }
    if (!state2.isBlocked()) {
      config2.onBlock(component);
    }
    state2.blockWith(() => Replacing.remove(root2, blocker));
  };
  const unblock = (component, config2, state2) => {
    remove$7(component.element, "aria-busy");
    if (state2.isBlocked()) {
      config2.onUnblock(component);
    }
    state2.clear();
  };
  var BlockingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    block,
    unblock
  });
  var BlockingSchema = [
    defaultedFunction("getRoot", Optional.none),
    defaultedBoolean("focus", true),
    onHandler("onBlock"),
    onHandler("onUnblock")
  ];
  const init$4 = () => {
    const blocker = destroyable();
    const blockWith = (destroy2) => {
      blocker.set({ destroy: destroy2 });
    };
    return nu$8({
      readState: blocker.isSet,
      blockWith,
      clear: blocker.clear,
      isBlocked: blocker.isSet
    });
  };
  var BlockingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$4
  });
  const Blocking = create$42({
    fields: BlockingSchema,
    name: "blocking",
    apis: BlockingApis,
    state: BlockingState
  });
  const getAttrs = (elem) => {
    const attributes = elem.dom.attributes !== void 0 ? elem.dom.attributes : [];
    return foldl(attributes, (b2, attr2) => {
      if (attr2.name === "class") {
        return b2;
      } else {
        return {
          ...b2,
          [attr2.name]: attr2.value
        };
      }
    }, {});
  };
  const getClasses = (elem) => Array.prototype.slice.call(elem.dom.classList, 0);
  const fromHtml = (html2) => {
    const elem = SugarElement.fromHtml(html2);
    const children$1 = children(elem);
    const attrs = getAttrs(elem);
    const classes2 = getClasses(elem);
    const contents2 = children$1.length === 0 ? {} : { innerHtml: get$9(elem) };
    return {
      tag: name$3(elem),
      classes: classes2,
      attributes: attrs,
      ...contents2
    };
  };
  const getBusySpec$1 = (providerBackstage) => (_root, _behaviours) => ({
    dom: {
      tag: "div",
      attributes: {
        "aria-label": providerBackstage.translate("Loading..."),
        "tabindex": "0"
      },
      classes: ["tox-throbber__busy-spinner"]
    },
    components: [{ dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  });
  const focusBusyComponent = (throbber) => Composing.getCurrent(throbber).each((comp) => focus$3(comp.element));
  const toggleEditorTabIndex = (editor, state2) => {
    const tabIndexAttr = "tabindex";
    const dataTabIndexAttr = `data-mce-${tabIndexAttr}`;
    Optional.from(editor.iframeElement).map(SugarElement.fromDom).each((iframe2) => {
      if (state2) {
        getOpt(iframe2, tabIndexAttr).each((tabIndex) => set$9(iframe2, dataTabIndexAttr, tabIndex));
        set$9(iframe2, tabIndexAttr, -1);
      } else {
        remove$7(iframe2, tabIndexAttr);
        getOpt(iframe2, dataTabIndexAttr).each((tabIndex) => {
          set$9(iframe2, tabIndexAttr, tabIndex);
          remove$7(iframe2, dataTabIndexAttr);
        });
      }
    });
  };
  const toggleThrobber = (editor, comp, state2, providerBackstage) => {
    const element2 = comp.element;
    toggleEditorTabIndex(editor, state2);
    if (state2) {
      Blocking.block(comp, getBusySpec$1(providerBackstage));
      remove$6(element2, "display");
      remove$7(element2, "aria-hidden");
      if (editor.hasFocus()) {
        focusBusyComponent(comp);
      }
    } else {
      const throbberFocus = Composing.getCurrent(comp).exists((busyComp) => hasFocus(busyComp.element));
      Blocking.unblock(comp);
      set$8(element2, "display", "none");
      set$9(element2, "aria-hidden", "true");
      if (throbberFocus) {
        editor.focus();
      }
    }
  };
  const renderThrobber = (spec) => ({
    uid: spec.uid,
    dom: {
      tag: "div",
      attributes: { "aria-hidden": "true" },
      classes: ["tox-throbber"],
      styles: { display: "none" }
    },
    behaviours: derive$1([
      Replacing.config({}),
      Blocking.config({ focus: false }),
      Composing.config({ find: (comp) => head(comp.components()) })
    ]),
    components: []
  });
  const isFocusEvent = (event) => event.type === "focusin";
  const isPasteBinTarget = (event) => {
    if (isFocusEvent(event)) {
      const node = event.composed ? head(event.composedPath()) : Optional.from(event.target);
      return node.map(SugarElement.fromDom).filter(isElement$12).exists((targetElm) => has(targetElm, "mce-pastebin"));
    } else {
      return false;
    }
  };
  const setup$7 = (editor, lazyThrobber, sharedBackstage) => {
    const throbberState = Cell(false);
    const timer = value$2();
    const stealFocus = (e) => {
      if (throbberState.get() && !isPasteBinTarget(e)) {
        e.preventDefault();
        focusBusyComponent(lazyThrobber());
        editor.editorManager.setActive(editor);
      }
    };
    if (!editor.inline) {
      editor.on("PreInit", () => {
        editor.dom.bind(editor.getWin(), "focusin", stealFocus);
        editor.on("BeforeExecCommand", (e) => {
          if (e.command.toLowerCase() === "mcefocus" && e.value !== true) {
            stealFocus(e);
          }
        });
      });
    }
    const toggle2 = (state2) => {
      if (state2 !== throbberState.get()) {
        throbberState.set(state2);
        toggleThrobber(editor, lazyThrobber(), state2, sharedBackstage.providers);
        fireAfterProgressState(editor, state2);
      }
    };
    editor.on("ProgressState", (e) => {
      timer.on(clearTimeout);
      if (isNumber2(e.time)) {
        const timerId = global$9.setEditorTimeout(editor, () => toggle2(e.state), e.time);
        timer.set(timerId);
      } else {
        toggle2(e.state);
        timer.clear();
      }
    });
  };
  const generate$1 = (xs, f2) => {
    const init2 = {
      len: 0,
      list: []
    };
    const r2 = foldl(xs, (b2, a) => {
      const value2 = f2(a, b2.len);
      return value2.fold(constant$1(b2), (v) => ({
        len: v.finish,
        list: b2.list.concat([v])
      }));
    }, init2);
    return r2.list;
  };
  const output = (within2, extra, withinWidth) => ({
    within: within2,
    extra,
    withinWidth
  });
  const apportion = (units2, total, len) => {
    const parray = generate$1(units2, (unit, current) => {
      const width3 = len(unit);
      return Optional.some({
        element: unit,
        start: current,
        finish: current + width3,
        width: width3
      });
    });
    const within2 = filter$2(parray, (unit) => unit.finish <= total);
    const withinWidth = foldr(within2, (acc, el) => acc + el.width, 0);
    const extra = parray.slice(within2.length);
    return {
      within: within2,
      extra,
      withinWidth
    };
  };
  const toUnit = (parray) => map$2(parray, (unit) => unit.element);
  const fitLast = (within2, extra, withinWidth) => {
    const fits = toUnit(within2.concat(extra));
    return output(fits, [], withinWidth);
  };
  const overflow = (within2, extra, overflower, withinWidth) => {
    const fits = toUnit(within2).concat([overflower]);
    return output(fits, toUnit(extra), withinWidth);
  };
  const fitAll = (within2, extra, withinWidth) => output(toUnit(within2), [], withinWidth);
  const tryFit = (total, units2, len) => {
    const divide = apportion(units2, total, len);
    return divide.extra.length === 0 ? Optional.some(divide) : Optional.none();
  };
  const partition = (total, units2, len, overflower) => {
    const divide = tryFit(total, units2, len).getOrThunk(() => apportion(units2, total - len(overflower), len));
    const within2 = divide.within;
    const extra = divide.extra;
    const withinWidth = divide.withinWidth;
    if (extra.length === 1 && extra[0].width <= len(overflower)) {
      return fitLast(within2, extra, withinWidth);
    } else if (extra.length >= 1) {
      return overflow(within2, extra, overflower, withinWidth);
    } else {
      return fitAll(within2, extra, withinWidth);
    }
  };
  const setGroups$1 = (toolbar, storedGroups) => {
    const bGroups = map$2(storedGroups, (g) => premade(g));
    Toolbar.setGroups(toolbar, bGroups);
  };
  const findFocusedComp = (comps) => findMap(comps, (comp) => search(comp.element).bind((focusedElm) => comp.getSystem().getByDom(focusedElm).toOptional()));
  const refresh$2 = (toolbar, detail, setOverflow) => {
    const builtGroups = detail.builtGroups.get();
    if (builtGroups.length === 0) {
      return;
    }
    const primary2 = getPartOrDie(toolbar, detail, "primary");
    const overflowGroup = Coupling.getCoupled(toolbar, "overflowGroup");
    set$8(primary2.element, "visibility", "hidden");
    const groups = builtGroups.concat([overflowGroup]);
    const focusedComp = findFocusedComp(groups);
    setOverflow([]);
    setGroups$1(primary2, groups);
    const availableWidth = get$c(primary2.element);
    const overflows = partition(availableWidth, detail.builtGroups.get(), (comp) => get$c(comp.element), overflowGroup);
    if (overflows.extra.length === 0) {
      Replacing.remove(primary2, overflowGroup);
      setOverflow([]);
    } else {
      setGroups$1(primary2, overflows.within);
      setOverflow(overflows.extra);
    }
    remove$6(primary2.element, "visibility");
    reflow2(primary2.element);
    focusedComp.each(Focusing.focus);
  };
  const schema$c = constant$1([
    field("splitToolbarBehaviours", [Coupling]),
    customField("builtGroups", () => Cell([]))
  ]);
  const schema$b = constant$1([
    markers$1(["overflowToggledClass"]),
    optionFunction("getOverflowBounds"),
    required$1("lazySink"),
    customField("overflowGroups", () => Cell([])),
    onHandler("onOpened"),
    onHandler("onClosed")
  ].concat(schema$c()));
  const parts$7 = constant$1([
    required({
      factory: Toolbar,
      schema: schema$e(),
      name: "primary"
    }),
    external({
      schema: schema$e(),
      name: "overflow"
    }),
    external({ name: "overflow-button" }),
    external({ name: "overflow-group" })
  ]);
  const expandable = constant$1((element2, available) => {
    setMax(element2, Math.floor(available));
  });
  const schema$a = constant$1([
    markers$1(["toggledClass"]),
    required$1("lazySink"),
    requiredFunction("fetch"),
    optionFunction("getBounds"),
    optionObjOf("fireDismissalEventInstead", [defaulted("event", dismissRequested())]),
    schema$y(),
    onHandler("onToggled")
  ]);
  const parts$6 = constant$1([
    external({
      name: "button",
      overrides: (detail) => ({
        dom: { attributes: { "aria-haspopup": "true" } },
        buttonBehaviours: derive$1([Toggling.config({
          toggleClass: detail.markers.toggledClass,
          aria: { mode: "expanded" },
          toggleOnExecute: false,
          onToggled: detail.onToggled
        })])
      })
    }),
    external({
      factory: Toolbar,
      schema: schema$e(),
      name: "toolbar",
      overrides: (detail) => {
        return {
          toolbarBehaviours: derive$1([Keying.config({
            mode: "cyclic",
            onEscape: (comp) => {
              getPart(comp, detail, "button").each(Focusing.focus);
              return Optional.none();
            }
          })])
        };
      }
    })
  ]);
  const shouldSkipFocus = value$2();
  const toggleWithoutFocusing = (button2, externals) => {
    shouldSkipFocus.set(true);
    toggle(button2, externals);
    shouldSkipFocus.clear();
  };
  const toggle = (button2, externals) => {
    const toolbarSandbox = Coupling.getCoupled(button2, "toolbarSandbox");
    if (Sandboxing.isOpen(toolbarSandbox)) {
      Sandboxing.close(toolbarSandbox);
    } else {
      Sandboxing.open(toolbarSandbox, externals.toolbar());
    }
  };
  const position = (button2, toolbar, detail, layouts2) => {
    const bounds2 = detail.getBounds.map((bounder) => bounder());
    const sink = detail.lazySink(button2).getOrDie();
    Positioning.positionWithinBounds(sink, toolbar, {
      anchor: {
        type: "hotspot",
        hotspot: button2,
        layouts: layouts2,
        overrides: { maxWidthFunction: expandable() }
      }
    }, bounds2);
  };
  const setGroups = (button2, toolbar, detail, layouts2, groups) => {
    Toolbar.setGroups(toolbar, groups);
    position(button2, toolbar, detail, layouts2);
    Toggling.on(button2);
  };
  const makeSandbox = (button2, spec, detail) => {
    const ariaControls = manager();
    const onOpen = (sandbox, toolbar) => {
      const skipFocus = shouldSkipFocus.get().getOr(false);
      detail.fetch().get((groups) => {
        setGroups(button2, toolbar, detail, spec.layouts, groups);
        ariaControls.link(button2.element);
        if (!skipFocus) {
          Keying.focusIn(toolbar);
        }
      });
    };
    const onClose = () => {
      Toggling.off(button2);
      if (!shouldSkipFocus.get().getOr(false)) {
        Focusing.focus(button2);
      }
      ariaControls.unlink(button2.element);
    };
    return {
      dom: {
        tag: "div",
        attributes: { id: ariaControls.id }
      },
      behaviours: derive$1([
        Keying.config({
          mode: "special",
          onEscape: (comp) => {
            Sandboxing.close(comp);
            return Optional.some(true);
          }
        }),
        Sandboxing.config({
          onOpen,
          onClose,
          isPartOf: (container, data2, queryElem) => {
            return isPartOf$1(data2, queryElem) || isPartOf$1(button2, queryElem);
          },
          getAttachPoint: () => {
            return detail.lazySink(button2).getOrDie();
          }
        }),
        Receiving.config({
          channels: {
            ...receivingChannel$1({
              isExtraPart: never,
              ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event } })).getOr({})
            }),
            ...receivingChannel({
              doReposition: () => {
                Sandboxing.getState(Coupling.getCoupled(button2, "toolbarSandbox")).each((toolbar) => {
                  position(button2, toolbar, detail, spec.layouts);
                });
              }
            })
          }
        })
      ])
    };
  };
  const factory$c = (detail, components2, spec, externals) => ({
    ...Button2.sketch({
      ...externals.button(),
      action: (button2) => {
        toggle(button2, externals);
      },
      buttonBehaviours: SketchBehaviours.augment({ dump: externals.button().buttonBehaviours }, [Coupling.config({
        others: {
          toolbarSandbox: (button2) => {
            return makeSandbox(button2, spec, detail);
          }
        }
      })])
    }),
    apis: {
      setGroups: (button2, groups) => {
        Sandboxing.getState(Coupling.getCoupled(button2, "toolbarSandbox")).each((toolbar) => {
          setGroups(button2, toolbar, detail, spec.layouts, groups);
        });
      },
      reposition: (button2) => {
        Sandboxing.getState(Coupling.getCoupled(button2, "toolbarSandbox")).each((toolbar) => {
          position(button2, toolbar, detail, spec.layouts);
        });
      },
      toggle: (button2) => {
        toggle(button2, externals);
      },
      toggleWithoutFocusing: (button2) => {
        toggleWithoutFocusing(button2, externals);
      },
      getToolbar: (button2) => {
        return Sandboxing.getState(Coupling.getCoupled(button2, "toolbarSandbox"));
      },
      isOpen: (button2) => {
        return Sandboxing.isOpen(Coupling.getCoupled(button2, "toolbarSandbox"));
      }
    }
  });
  const FloatingToolbarButton = composite({
    name: "FloatingToolbarButton",
    factory: factory$c,
    configFields: schema$a(),
    partFields: parts$6(),
    apis: {
      setGroups: (apis2, button2, groups) => {
        apis2.setGroups(button2, groups);
      },
      reposition: (apis2, button2) => {
        apis2.reposition(button2);
      },
      toggle: (apis2, button2) => {
        apis2.toggle(button2);
      },
      toggleWithoutFocusing: (apis2, button2) => {
        apis2.toggleWithoutFocusing(button2);
      },
      getToolbar: (apis2, button2) => apis2.getToolbar(button2),
      isOpen: (apis2, button2) => apis2.isOpen(button2)
    }
  });
  const schema$9 = constant$1([
    required$1("items"),
    markers$1(["itemSelector"]),
    field("tgroupBehaviours", [Keying])
  ]);
  const parts$5 = constant$1([group({
    name: "items",
    unit: "item"
  })]);
  const factory$b = (detail, components2, _spec, _externals) => ({
    uid: detail.uid,
    dom: detail.dom,
    components: components2,
    behaviours: augment(detail.tgroupBehaviours, [Keying.config({
      mode: "flow",
      selector: detail.markers.itemSelector
    })]),
    domModification: { attributes: { role: "toolbar" } }
  });
  const ToolbarGroup = composite({
    name: "ToolbarGroup",
    configFields: schema$9(),
    partFields: parts$5(),
    factory: factory$b
  });
  const buildGroups = (comps) => map$2(comps, (g) => premade(g));
  const refresh$1 = (toolbar, memFloatingToolbarButton, detail) => {
    refresh$2(toolbar, detail, (overflowGroups) => {
      detail.overflowGroups.set(overflowGroups);
      memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
        FloatingToolbarButton.setGroups(floatingToolbarButton, buildGroups(overflowGroups));
      });
    });
  };
  const factory$a = (detail, components2, spec, externals) => {
    const memFloatingToolbarButton = record(FloatingToolbarButton.sketch({
      fetch: () => Future.nu((resolve2) => {
        resolve2(buildGroups(detail.overflowGroups.get()));
      }),
      layouts: {
        onLtr: () => [
          southwest$2,
          southeast$2
        ],
        onRtl: () => [
          southeast$2,
          southwest$2
        ],
        onBottomLtr: () => [
          northwest$2,
          northeast$2
        ],
        onBottomRtl: () => [
          northeast$2,
          northwest$2
        ]
      },
      getBounds: spec.getOverflowBounds,
      lazySink: detail.lazySink,
      fireDismissalEventInstead: {},
      markers: { toggledClass: detail.markers.overflowToggledClass },
      parts: {
        button: externals["overflow-button"](),
        toolbar: externals.overflow()
      },
      onToggled: (comp, state2) => detail[state2 ? "onOpened" : "onClosed"](comp)
    }));
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: augment(detail.splitToolbarBehaviours, [Coupling.config({
        others: {
          overflowGroup: () => {
            return ToolbarGroup.sketch({
              ...externals["overflow-group"](),
              items: [memFloatingToolbarButton.asSpec()]
            });
          }
        }
      })]),
      apis: {
        setGroups: (toolbar, groups) => {
          detail.builtGroups.set(map$2(groups, toolbar.getSystem().build));
          refresh$1(toolbar, memFloatingToolbarButton, detail);
        },
        refresh: (toolbar) => refresh$1(toolbar, memFloatingToolbarButton, detail),
        toggle: (toolbar) => {
          memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
            FloatingToolbarButton.toggle(floatingToolbarButton);
          });
        },
        toggleWithoutFocusing: (toolbar) => {
          memFloatingToolbarButton.getOpt(toolbar).each(FloatingToolbarButton.toggleWithoutFocusing);
        },
        isOpen: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).map(FloatingToolbarButton.isOpen).getOr(false),
        reposition: (toolbar) => {
          memFloatingToolbarButton.getOpt(toolbar).each((floatingToolbarButton) => {
            FloatingToolbarButton.reposition(floatingToolbarButton);
          });
        },
        getOverflow: (toolbar) => memFloatingToolbarButton.getOpt(toolbar).bind(FloatingToolbarButton.getToolbar)
      },
      domModification: { attributes: { role: "group" } }
    };
  };
  const SplitFloatingToolbar = composite({
    name: "SplitFloatingToolbar",
    configFields: schema$b(),
    partFields: parts$7(),
    factory: factory$a,
    apis: {
      setGroups: (apis2, toolbar, groups) => {
        apis2.setGroups(toolbar, groups);
      },
      refresh: (apis2, toolbar) => {
        apis2.refresh(toolbar);
      },
      reposition: (apis2, toolbar) => {
        apis2.reposition(toolbar);
      },
      toggle: (apis2, toolbar) => {
        apis2.toggle(toolbar);
      },
      toggleWithoutFocusing: (apis2, toolbar) => {
        apis2.toggle(toolbar);
      },
      isOpen: (apis2, toolbar) => apis2.isOpen(toolbar),
      getOverflow: (apis2, toolbar) => apis2.getOverflow(toolbar)
    }
  });
  const schema$8 = constant$1([
    markers$1([
      "closedClass",
      "openClass",
      "shrinkingClass",
      "growingClass",
      "overflowToggledClass"
    ]),
    onHandler("onOpened"),
    onHandler("onClosed")
  ].concat(schema$c()));
  const parts$4 = constant$1([
    required({
      factory: Toolbar,
      schema: schema$e(),
      name: "primary"
    }),
    required({
      factory: Toolbar,
      schema: schema$e(),
      name: "overflow",
      overrides: (detail) => {
        return {
          toolbarBehaviours: derive$1([
            Sliding.config({
              dimension: { property: "height" },
              closedClass: detail.markers.closedClass,
              openClass: detail.markers.openClass,
              shrinkingClass: detail.markers.shrinkingClass,
              growingClass: detail.markers.growingClass,
              onShrunk: (comp) => {
                getPart(comp, detail, "overflow-button").each((button2) => {
                  Toggling.off(button2);
                  Focusing.focus(button2);
                });
                detail.onClosed(comp);
              },
              onGrown: (comp) => {
                Keying.focusIn(comp);
                detail.onOpened(comp);
              },
              onStartGrow: (comp) => {
                getPart(comp, detail, "overflow-button").each(Toggling.on);
              }
            }),
            Keying.config({
              mode: "acyclic",
              onEscape: (comp) => {
                getPart(comp, detail, "overflow-button").each(Focusing.focus);
                return Optional.some(true);
              }
            })
          ])
        };
      }
    }),
    external({
      name: "overflow-button",
      overrides: (detail) => ({
        buttonBehaviours: derive$1([Toggling.config({
          toggleClass: detail.markers.overflowToggledClass,
          aria: { mode: "pressed" },
          toggleOnExecute: false
        })])
      })
    }),
    external({ name: "overflow-group" })
  ]);
  const isOpen = (toolbar, detail) => getPart(toolbar, detail, "overflow").map(Sliding.hasGrown).getOr(false);
  const toggleToolbar = (toolbar, detail) => {
    getPart(toolbar, detail, "overflow-button").bind(() => getPart(toolbar, detail, "overflow")).each((overf) => {
      refresh(toolbar, detail);
      Sliding.toggleGrow(overf);
    });
  };
  const refresh = (toolbar, detail) => {
    getPart(toolbar, detail, "overflow").each((overflow2) => {
      refresh$2(toolbar, detail, (groups) => {
        const builtGroups = map$2(groups, (g) => premade(g));
        Toolbar.setGroups(overflow2, builtGroups);
      });
      getPart(toolbar, detail, "overflow-button").each((button2) => {
        if (Sliding.hasGrown(overflow2)) {
          Toggling.on(button2);
        }
      });
      Sliding.refresh(overflow2);
    });
  };
  const factory$9 = (detail, components2, spec, externals) => {
    const toolbarToggleEvent = "alloy.toolbar.toggle";
    const doSetGroups = (toolbar, groups) => {
      const built = map$2(groups, toolbar.getSystem().build);
      detail.builtGroups.set(built);
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: augment(detail.splitToolbarBehaviours, [
        Coupling.config({
          others: {
            overflowGroup: (toolbar) => {
              return ToolbarGroup.sketch({
                ...externals["overflow-group"](),
                items: [Button2.sketch({
                  ...externals["overflow-button"](),
                  action: (_button) => {
                    emit(toolbar, toolbarToggleEvent);
                  }
                })]
              });
            }
          }
        }),
        config("toolbar-toggle-events", [run$1(toolbarToggleEvent, (toolbar) => {
          toggleToolbar(toolbar, detail);
        })])
      ]),
      apis: {
        setGroups: (toolbar, groups) => {
          doSetGroups(toolbar, groups);
          refresh(toolbar, detail);
        },
        refresh: (toolbar) => refresh(toolbar, detail),
        toggle: (toolbar) => toggleToolbar(toolbar, detail),
        isOpen: (toolbar) => isOpen(toolbar, detail)
      },
      domModification: { attributes: { role: "group" } }
    };
  };
  const SplitSlidingToolbar = composite({
    name: "SplitSlidingToolbar",
    configFields: schema$8(),
    partFields: parts$4(),
    factory: factory$9,
    apis: {
      setGroups: (apis2, toolbar, groups) => {
        apis2.setGroups(toolbar, groups);
      },
      refresh: (apis2, toolbar) => {
        apis2.refresh(toolbar);
      },
      toggle: (apis2, toolbar) => {
        apis2.toggle(toolbar);
      },
      isOpen: (apis2, toolbar) => apis2.isOpen(toolbar)
    }
  });
  const renderToolbarGroupCommon = (toolbarGroup) => {
    const attributes = toolbarGroup.title.fold(() => ({}), (title2) => ({ attributes: { title: title2 } }));
    return {
      dom: {
        tag: "div",
        classes: ["tox-toolbar__group"],
        ...attributes
      },
      components: [ToolbarGroup.parts.items({})],
      items: toolbarGroup.items,
      markers: { itemSelector: "*:not(.tox-split-button) > .tox-tbtn:not([disabled]), .tox-split-button:not([disabled]), .tox-toolbar-nav-js:not([disabled]), .tox-number-input:not([disabled])" },
      tgroupBehaviours: derive$1([
        Tabstopping.config({}),
        Focusing.config({})
      ])
    };
  };
  const renderToolbarGroup = (toolbarGroup) => ToolbarGroup.sketch(renderToolbarGroupCommon(toolbarGroup));
  const getToolbarBehaviours = (toolbarSpec, modeName) => {
    const onAttached = runOnAttached((component) => {
      const groups = map$2(toolbarSpec.initGroups, renderToolbarGroup);
      Toolbar.setGroups(component, groups);
    });
    return derive$1([
      DisablingConfigs.toolbarButton(toolbarSpec.providers.isDisabled),
      receivingConfig(),
      Keying.config({
        mode: modeName,
        onEscape: toolbarSpec.onEscape,
        selector: ".tox-toolbar__group"
      }),
      config("toolbar-events", [onAttached])
    ]);
  };
  const renderMoreToolbarCommon = (toolbarSpec) => {
    const modeName = toolbarSpec.cyclicKeying ? "cyclic" : "acyclic";
    return {
      uid: toolbarSpec.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar-overlord"]
      },
      parts: {
        "overflow-group": renderToolbarGroupCommon({
          title: Optional.none(),
          items: []
        }),
        "overflow-button": renderIconButtonSpec({
          name: "more",
          icon: Optional.some("more-drawer"),
          enabled: true,
          tooltip: Optional.some("More..."),
          primary: false,
          buttonType: Optional.none(),
          borderless: false
        }, Optional.none(), toolbarSpec.providers)
      },
      splitToolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
    };
  };
  const renderFloatingMoreToolbar = (toolbarSpec) => {
    const baseSpec = renderMoreToolbarCommon(toolbarSpec);
    const overflowXOffset = 4;
    const primary2 = SplitFloatingToolbar.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    return SplitFloatingToolbar.sketch({
      ...baseSpec,
      lazySink: toolbarSpec.getSink,
      getOverflowBounds: () => {
        const headerElem = toolbarSpec.moreDrawerData.lazyHeader().element;
        const headerBounds = absolute$2(headerElem);
        const docElem = documentElement(headerElem);
        const docBounds = absolute$2(docElem);
        const height3 = Math.max(docElem.dom.scrollHeight, docBounds.height);
        return bounds(headerBounds.x + overflowXOffset, docBounds.y, headerBounds.width - overflowXOffset * 2, height3);
      },
      parts: {
        ...baseSpec.parts,
        overflow: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes: toolbarSpec.attributes
          }
        }
      },
      components: [primary2],
      markers: { overflowToggledClass: "tox-tbtn--enabled" },
      onOpened: (comp) => toolbarSpec.onToggled(comp, true),
      onClosed: (comp) => toolbarSpec.onToggled(comp, false)
    });
  };
  const renderSlidingMoreToolbar = (toolbarSpec) => {
    const primary2 = SplitSlidingToolbar.parts.primary({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__primary"]
      }
    });
    const overflow2 = SplitSlidingToolbar.parts.overflow({
      dom: {
        tag: "div",
        classes: ["tox-toolbar__overflow"]
      }
    });
    const baseSpec = renderMoreToolbarCommon(toolbarSpec);
    return SplitSlidingToolbar.sketch({
      ...baseSpec,
      components: [
        primary2,
        overflow2
      ],
      markers: {
        openClass: "tox-toolbar__overflow--open",
        closedClass: "tox-toolbar__overflow--closed",
        growingClass: "tox-toolbar__overflow--growing",
        shrinkingClass: "tox-toolbar__overflow--shrinking",
        overflowToggledClass: "tox-tbtn--enabled"
      },
      onOpened: (comp) => {
        comp.getSystem().broadcastOn([toolbarHeightChange()], { type: "opened" });
        toolbarSpec.onToggled(comp, true);
      },
      onClosed: (comp) => {
        comp.getSystem().broadcastOn([toolbarHeightChange()], { type: "closed" });
        toolbarSpec.onToggled(comp, false);
      }
    });
  };
  const renderToolbar = (toolbarSpec) => {
    const modeName = toolbarSpec.cyclicKeying ? "cyclic" : "acyclic";
    return Toolbar.sketch({
      uid: toolbarSpec.uid,
      dom: {
        tag: "div",
        classes: ["tox-toolbar"].concat(toolbarSpec.type === ToolbarMode$1.scrolling ? ["tox-toolbar--scrolling"] : [])
      },
      components: [Toolbar.parts.groups({})],
      toolbarBehaviours: getToolbarBehaviours(toolbarSpec, modeName)
    });
  };
  const baseButtonFields = [
    optionalText,
    optionalIcon,
    optionString("tooltip"),
    defaultedStringEnum("buttonType", "secondary", [
      "primary",
      "secondary"
    ]),
    defaultedBoolean("borderless", false),
    requiredFunction("onAction")
  ];
  const normalButtonFields = [
    ...baseButtonFields,
    text$12,
    requiredStringEnum("type", ["button"])
  ];
  const toggleButtonFields = [
    ...baseButtonFields,
    defaultedBoolean("active", false),
    requiredStringEnum("type", ["togglebutton"])
  ];
  const schemaWithoutGroupButton = {
    button: normalButtonFields,
    togglebutton: toggleButtonFields
  };
  const groupFields = [
    requiredStringEnum("type", ["group"]),
    defaultedArrayOf("buttons", [], choose$1("type", schemaWithoutGroupButton))
  ];
  const viewButtonSchema = choose$1("type", {
    ...schemaWithoutGroupButton,
    group: groupFields
  });
  const viewSchema = objOf([
    defaultedArrayOf("buttons", [], viewButtonSchema),
    requiredFunction("onShow"),
    requiredFunction("onHide")
  ]);
  const createView2 = (spec) => asRaw("view", viewSchema, spec);
  const renderButton = (spec, providers) => {
    var _a, _b;
    const isToggleButton2 = spec.type === "togglebutton";
    const optMemIcon = spec.icon.map((memIcon) => renderReplaceableIconFromPack(memIcon, providers.icons)).map(record);
    const getAction2 = () => (comp) => {
      const setIcon = (newIcon) => {
        optMemIcon.map((memIcon) => memIcon.getOpt(comp).each((displayIcon) => {
          Replacing.set(displayIcon, [renderReplaceableIconFromPack(newIcon, providers.icons)]);
        }));
      };
      const setActive = (state2) => {
        const elm = comp.element;
        if (state2) {
          add$2(elm, "tox-button--enabled");
          set$9(elm, "aria-pressed", true);
        } else {
          remove$2(elm, "tox-button--enabled");
          remove$7(elm, "aria-pressed");
        }
      };
      const isActive = () => has(comp.element, "tox-button--enabled");
      if (isToggleButton2) {
        return spec.onAction({
          setIcon,
          setActive,
          isActive
        });
      }
      if (spec.type === "button") {
        return spec.onAction({ setIcon });
      }
    };
    const action = getAction2();
    const buttonSpec = {
      ...spec,
      name: isToggleButton2 ? spec.text.getOr(spec.icon.getOr("")) : (_a = spec.text) !== null && _a !== void 0 ? _a : spec.icon.getOr(""),
      primary: spec.buttonType === "primary",
      buttonType: Optional.from(spec.buttonType),
      tooltip: spec.tooltip,
      icon: spec.icon,
      enabled: true,
      borderless: spec.borderless
    };
    const buttonTypeClasses = calculateClassesFromButtonType((_b = spec.buttonType) !== null && _b !== void 0 ? _b : "secondary");
    const optTranslatedText = isToggleButton2 ? spec.text.map(providers.translate) : Optional.some(providers.translate(spec.text));
    const optTranslatedTextComponed = optTranslatedText.map(text$2);
    const tooltipAttributes = buttonSpec.tooltip.or(optTranslatedText).map((tooltip) => ({
      "aria-label": providers.translate(tooltip),
      "title": providers.translate(tooltip)
    })).getOr({});
    const optIconSpec = optMemIcon.map((memIcon) => memIcon.asSpec());
    const components2 = componentRenderPipeline([
      optIconSpec,
      optTranslatedTextComponed
    ]);
    const hasIconAndText = spec.icon.isSome() && optTranslatedTextComponed.isSome();
    const dom2 = {
      tag: "button",
      classes: buttonTypeClasses.concat(...spec.icon.isSome() && !hasIconAndText ? ["tox-button--icon"] : []).concat(...hasIconAndText ? ["tox-button--icon-and-text"] : []).concat(...spec.borderless ? ["tox-button--naked"] : []).concat(...spec.type === "togglebutton" && spec.active ? ["tox-button--enabled"] : []),
      attributes: tooltipAttributes
    };
    const extraBehaviours = [];
    const iconButtonSpec = renderCommonSpec(buttonSpec, Optional.some(action), extraBehaviours, dom2, components2, providers);
    return Button2.sketch(iconButtonSpec);
  };
  const renderViewButton = (spec, providers) => renderButton(spec, providers);
  const renderButtonsGroup = (spec, providers) => {
    return {
      dom: {
        tag: "div",
        classes: ["tox-view__toolbar__group"]
      },
      components: map$2(spec.buttons, (button2) => renderViewButton(button2, providers))
    };
  };
  const deviceDetection = detect$2().deviceType;
  const isPhone = deviceDetection.isPhone();
  const isTablet = deviceDetection.isTablet();
  const renderViewHeader = (spec) => {
    let hasGroups = false;
    const endButtons = map$2(spec.buttons, (btnspec) => {
      if (btnspec.type === "group") {
        hasGroups = true;
        return renderButtonsGroup(btnspec, spec.providers);
      } else {
        return renderViewButton(btnspec, spec.providers);
      }
    });
    return {
      uid: spec.uid,
      dom: {
        tag: "div",
        classes: [
          !hasGroups ? "tox-view__header" : "tox-view__toolbar",
          ...isPhone || isTablet ? [
            "tox-view--mobile",
            "tox-view--scrolling"
          ] : []
        ]
      },
      behaviours: derive$1([
        Focusing.config({}),
        Keying.config({
          mode: "flow",
          selector: "button, .tox-button",
          focusInside: FocusInsideModes.OnEnterOrSpaceMode
        })
      ]),
      components: hasGroups ? endButtons : [
        Container.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-start"]
          },
          components: []
        }),
        Container.sketch({
          dom: {
            tag: "div",
            classes: ["tox-view__header-end"]
          },
          components: endButtons
        })
      ]
    };
  };
  const renderViewPane = (spec) => {
    return {
      uid: spec.uid,
      dom: {
        tag: "div",
        classes: ["tox-view__pane"]
      }
    };
  };
  const factory$8 = (detail, components2, _spec, _externals) => {
    const apis2 = {
      getPane: (comp) => parts$a.getPart(comp, detail, "pane"),
      getOnShow: (_comp) => detail.viewConfig.onShow,
      getOnHide: (_comp) => detail.viewConfig.onHide
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      apis: apis2
    };
  };
  var View = composite({
    name: "silver.View",
    configFields: [required$1("viewConfig")],
    partFields: [
      optional({
        factory: { sketch: renderViewHeader },
        schema: [
          required$1("buttons"),
          required$1("providers")
        ],
        name: "header"
      }),
      optional({
        factory: { sketch: renderViewPane },
        schema: [],
        name: "pane"
      })
    ],
    factory: factory$8,
    apis: {
      getPane: (apis2, comp) => apis2.getPane(comp),
      getOnShow: (apis2, comp) => apis2.getOnShow(comp),
      getOnHide: (apis2, comp) => apis2.getOnHide(comp)
    }
  });
  const makeViews = (parts2, viewConfigs, providers) => {
    return mapToArray(viewConfigs, (config2, name3) => {
      const internalViewConfig = getOrDie(createView2(config2));
      return parts2.slot(name3, View.sketch({
        dom: {
          tag: "div",
          classes: ["tox-view"]
        },
        viewConfig: internalViewConfig,
        components: [
          ...internalViewConfig.buttons.length > 0 ? [View.parts.header({
            buttons: internalViewConfig.buttons,
            providers
          })] : [],
          View.parts.pane({})
        ]
      }));
    });
  };
  const makeSlotContainer = (viewConfigs, providers) => SlotContainer.sketch((parts2) => ({
    dom: {
      tag: "div",
      classes: ["tox-view-wrap__slot-container"]
    },
    components: makeViews(parts2, viewConfigs, providers),
    slotBehaviours: SimpleBehaviours.unnamedEvents([runOnAttached((slotContainer) => SlotContainer.hideAllSlots(slotContainer))])
  }));
  const getCurrentName = (slotContainer) => {
    return find$5(SlotContainer.getSlotNames(slotContainer), (name3) => SlotContainer.isShowing(slotContainer, name3));
  };
  const hideContainer = (comp) => {
    const element2 = comp.element;
    set$8(element2, "display", "none");
    set$9(element2, "aria-hidden", "true");
  };
  const showContainer = (comp) => {
    const element2 = comp.element;
    remove$6(element2, "display");
    remove$7(element2, "aria-hidden");
  };
  const makeViewInstanceApi = (slot) => ({ getContainer: constant$1(slot) });
  const runOnPaneWithInstanceApi = (slotContainer, name3, get2) => {
    SlotContainer.getSlot(slotContainer, name3).each((view2) => {
      View.getPane(view2).each((pane) => {
        const onCallback = get2(view2);
        onCallback(makeViewInstanceApi(pane.element.dom));
      });
    });
  };
  const runOnShow = (slotContainer, name3) => runOnPaneWithInstanceApi(slotContainer, name3, View.getOnShow);
  const runOnHide = (slotContainer, name3) => runOnPaneWithInstanceApi(slotContainer, name3, View.getOnHide);
  const factory$7 = (detail, spec) => {
    const setViews = (comp, viewConfigs) => {
      Replacing.set(comp, [makeSlotContainer(viewConfigs, spec.backstage.shared.providers)]);
    };
    const whichView = (comp) => {
      return Composing.getCurrent(comp).bind(getCurrentName);
    };
    const toggleView = (comp, showMainView, hideMainView, name3) => {
      return Composing.getCurrent(comp).exists((slotContainer) => {
        const optCurrentSlotName = getCurrentName(slotContainer);
        const isTogglingCurrentView = optCurrentSlotName.exists((current) => name3 === current);
        const exists2 = SlotContainer.getSlot(slotContainer, name3).isSome();
        if (exists2) {
          SlotContainer.hideAllSlots(slotContainer);
          if (!isTogglingCurrentView) {
            hideMainView();
            showContainer(comp);
            SlotContainer.showSlot(slotContainer, name3);
            runOnShow(slotContainer, name3);
          } else {
            hideContainer(comp);
            showMainView();
          }
          optCurrentSlotName.each((prevName) => runOnHide(slotContainer, prevName));
        }
        return exists2;
      });
    };
    const apis2 = {
      setViews,
      whichView,
      toggleView
    };
    return {
      uid: detail.uid,
      dom: {
        tag: "div",
        classes: ["tox-view-wrap"],
        attributes: { "aria-hidden": "true" },
        styles: { display: "none" }
      },
      components: [],
      behaviours: derive$1([
        Replacing.config({}),
        Composing.config({
          find: (comp) => {
            const children2 = Replacing.contents(comp);
            return head(children2);
          }
        })
      ]),
      apis: apis2
    };
  };
  var ViewWrapper = single({
    factory: factory$7,
    name: "silver.ViewWrapper",
    configFields: [required$1("backstage")],
    apis: {
      setViews: (apis2, comp, views) => apis2.setViews(comp, views),
      toggleView: (apis2, comp, outerContainer, editorCont, name3) => apis2.toggleView(comp, outerContainer, editorCont, name3),
      whichView: (apis2, comp) => apis2.whichView(comp)
    }
  });
  const factory$6 = (detail, components2, _spec) => {
    let toolbarDrawerOpenState = false;
    const apis2 = {
      getSocket: (comp) => {
        return parts$a.getPart(comp, detail, "socket");
      },
      setSidebar: (comp, panelConfigs, showSidebar) => {
        parts$a.getPart(comp, detail, "sidebar").each((sidebar) => setSidebar(sidebar, panelConfigs, showSidebar));
      },
      toggleSidebar: (comp, name3) => {
        parts$a.getPart(comp, detail, "sidebar").each((sidebar) => toggleSidebar(sidebar, name3));
      },
      whichSidebar: (comp) => {
        return parts$a.getPart(comp, detail, "sidebar").bind(whichSidebar).getOrNull();
      },
      getHeader: (comp) => {
        return parts$a.getPart(comp, detail, "header");
      },
      getToolbar: (comp) => {
        return parts$a.getPart(comp, detail, "toolbar");
      },
      setToolbar: (comp, groups) => {
        parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
          const renderedGroups = map$2(groups, renderToolbarGroup);
          toolbar.getApis().setGroups(toolbar, renderedGroups);
        });
      },
      setToolbars: (comp, toolbars) => {
        parts$a.getPart(comp, detail, "multiple-toolbar").each((mToolbar) => {
          const renderedToolbars = map$2(toolbars, (g) => map$2(g, renderToolbarGroup));
          CustomList.setItems(mToolbar, renderedToolbars);
        });
      },
      refreshToolbar: (comp) => {
        const toolbar = parts$a.getPart(comp, detail, "toolbar");
        toolbar.each((toolbar2) => toolbar2.getApis().refresh(toolbar2));
      },
      toggleToolbarDrawer: (comp) => {
        parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
          mapFrom(toolbar.getApis().toggle, (toggle2) => toggle2(toolbar));
        });
      },
      toggleToolbarDrawerWithoutFocusing: (comp) => {
        parts$a.getPart(comp, detail, "toolbar").each((toolbar) => {
          mapFrom(toolbar.getApis().toggleWithoutFocusing, (toggleWithoutFocusing2) => toggleWithoutFocusing2(toolbar));
        });
      },
      isToolbarDrawerToggled: (comp) => {
        return parts$a.getPart(comp, detail, "toolbar").bind((toolbar) => Optional.from(toolbar.getApis().isOpen).map((isOpen2) => isOpen2(toolbar))).getOr(false);
      },
      getThrobber: (comp) => {
        return parts$a.getPart(comp, detail, "throbber");
      },
      focusToolbar: (comp) => {
        const optToolbar = parts$a.getPart(comp, detail, "toolbar").orThunk(() => parts$a.getPart(comp, detail, "multiple-toolbar"));
        optToolbar.each((toolbar) => {
          Keying.focusIn(toolbar);
        });
      },
      setMenubar: (comp, menus) => {
        parts$a.getPart(comp, detail, "menubar").each((menubar) => {
          SilverMenubar.setMenus(menubar, menus);
        });
      },
      focusMenubar: (comp) => {
        parts$a.getPart(comp, detail, "menubar").each((menubar) => {
          SilverMenubar.focus(menubar);
        });
      },
      setViews: (comp, viewConfigs) => {
        parts$a.getPart(comp, detail, "viewWrapper").each((wrapper) => {
          ViewWrapper.setViews(wrapper, viewConfigs);
        });
      },
      toggleView: (comp, name3) => {
        return parts$a.getPart(comp, detail, "viewWrapper").exists((wrapper) => ViewWrapper.toggleView(wrapper, () => apis2.showMainView(comp), () => apis2.hideMainView(comp), name3));
      },
      whichView: (comp) => {
        return parts$a.getPart(comp, detail, "viewWrapper").bind(ViewWrapper.whichView).getOrNull();
      },
      hideMainView: (comp) => {
        toolbarDrawerOpenState = apis2.isToolbarDrawerToggled(comp);
        if (toolbarDrawerOpenState) {
          apis2.toggleToolbarDrawer(comp);
        }
        parts$a.getPart(comp, detail, "editorContainer").each((editorContainer) => {
          const element2 = editorContainer.element;
          set$8(element2, "display", "none");
          set$9(element2, "aria-hidden", "true");
        });
      },
      showMainView: (comp) => {
        if (toolbarDrawerOpenState) {
          apis2.toggleToolbarDrawer(comp);
        }
        parts$a.getPart(comp, detail, "editorContainer").each((editorContainer) => {
          const element2 = editorContainer.element;
          remove$6(element2, "display");
          remove$7(element2, "aria-hidden");
        });
        apis2.refreshToolbar(comp);
      }
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      apis: apis2,
      behaviours: detail.behaviours
    };
  };
  const partMenubar = partType.optional({
    factory: SilverMenubar,
    name: "menubar",
    schema: [required$1("backstage")]
  });
  const toolbarFactory = (spec) => {
    if (spec.type === ToolbarMode$1.sliding) {
      return renderSlidingMoreToolbar;
    } else if (spec.type === ToolbarMode$1.floating) {
      return renderFloatingMoreToolbar;
    } else {
      return renderToolbar;
    }
  };
  const partMultipleToolbar = partType.optional({
    factory: {
      sketch: (spec) => CustomList.sketch({
        uid: spec.uid,
        dom: spec.dom,
        listBehaviours: derive$1([Keying.config({
          mode: "acyclic",
          selector: ".tox-toolbar"
        })]),
        makeItem: () => renderToolbar({
          type: spec.type,
          uid: generate$6("multiple-toolbar-item"),
          cyclicKeying: false,
          initGroups: [],
          providers: spec.providers,
          onEscape: () => {
            spec.onEscape();
            return Optional.some(true);
          }
        }),
        setupItem: (_mToolbar, tc, data2, _index) => {
          Toolbar.setGroups(tc, data2);
        },
        shell: true
      })
    },
    name: "multiple-toolbar",
    schema: [
      required$1("dom"),
      required$1("onEscape")
    ]
  });
  const partToolbar = partType.optional({
    factory: {
      sketch: (spec) => {
        const renderer = toolbarFactory(spec);
        const toolbarSpec = {
          type: spec.type,
          uid: spec.uid,
          onEscape: () => {
            spec.onEscape();
            return Optional.some(true);
          },
          onToggled: (_comp, state2) => spec.onToolbarToggled(state2),
          cyclicKeying: false,
          initGroups: [],
          getSink: spec.getSink,
          providers: spec.providers,
          moreDrawerData: {
            lazyToolbar: spec.lazyToolbar,
            lazyMoreButton: spec.lazyMoreButton,
            lazyHeader: spec.lazyHeader
          },
          attributes: spec.attributes
        };
        return renderer(toolbarSpec);
      }
    },
    name: "toolbar",
    schema: [
      required$1("dom"),
      required$1("onEscape"),
      required$1("getSink")
    ]
  });
  const partHeader = partType.optional({
    factory: { sketch: renderHeader },
    name: "header",
    schema: [required$1("dom")]
  });
  const partPromotion = partType.optional({
    factory: { sketch: renderPromotion },
    name: "promotion",
    schema: [required$1("dom")]
  });
  const partSocket = partType.optional({
    name: "socket",
    schema: [required$1("dom")]
  });
  const partSidebar = partType.optional({
    factory: { sketch: renderSidebar },
    name: "sidebar",
    schema: [required$1("dom")]
  });
  const partThrobber = partType.optional({
    factory: { sketch: renderThrobber },
    name: "throbber",
    schema: [required$1("dom")]
  });
  const partViewWrapper = partType.optional({
    factory: ViewWrapper,
    name: "viewWrapper",
    schema: [required$1("backstage")]
  });
  const renderEditorContainer = (spec) => ({
    uid: spec.uid,
    dom: {
      tag: "div",
      classes: ["tox-editor-container"]
    },
    components: spec.components
  });
  const partEditorContainer = partType.optional({
    factory: { sketch: renderEditorContainer },
    name: "editorContainer",
    schema: []
  });
  var OuterContainer = composite({
    name: "OuterContainer",
    factory: factory$6,
    configFields: [
      required$1("dom"),
      required$1("behaviours")
    ],
    partFields: [
      partHeader,
      partMenubar,
      partToolbar,
      partMultipleToolbar,
      partSocket,
      partSidebar,
      partPromotion,
      partThrobber,
      partViewWrapper,
      partEditorContainer
    ],
    apis: {
      getSocket: (apis2, comp) => {
        return apis2.getSocket(comp);
      },
      setSidebar: (apis2, comp, panelConfigs, showSidebar) => {
        apis2.setSidebar(comp, panelConfigs, showSidebar);
      },
      toggleSidebar: (apis2, comp, name3) => {
        apis2.toggleSidebar(comp, name3);
      },
      whichSidebar: (apis2, comp) => {
        return apis2.whichSidebar(comp);
      },
      getHeader: (apis2, comp) => {
        return apis2.getHeader(comp);
      },
      getToolbar: (apis2, comp) => {
        return apis2.getToolbar(comp);
      },
      setToolbar: (apis2, comp, groups) => {
        apis2.setToolbar(comp, groups);
      },
      setToolbars: (apis2, comp, toolbars) => {
        apis2.setToolbars(comp, toolbars);
      },
      refreshToolbar: (apis2, comp) => {
        return apis2.refreshToolbar(comp);
      },
      toggleToolbarDrawer: (apis2, comp) => {
        apis2.toggleToolbarDrawer(comp);
      },
      toggleToolbarDrawerWithoutFocusing: (apis2, comp) => {
        apis2.toggleToolbarDrawerWithoutFocusing(comp);
      },
      isToolbarDrawerToggled: (apis2, comp) => {
        return apis2.isToolbarDrawerToggled(comp);
      },
      getThrobber: (apis2, comp) => {
        return apis2.getThrobber(comp);
      },
      setMenubar: (apis2, comp, menus) => {
        apis2.setMenubar(comp, menus);
      },
      focusMenubar: (apis2, comp) => {
        apis2.focusMenubar(comp);
      },
      focusToolbar: (apis2, comp) => {
        apis2.focusToolbar(comp);
      },
      setViews: (apis2, comp, views) => {
        apis2.setViews(comp, views);
      },
      toggleView: (apis2, comp, name3) => {
        return apis2.toggleView(comp, name3);
      },
      whichView: (apis2, comp) => {
        return apis2.whichView(comp);
      }
    }
  });
  const defaultMenubar = "file edit view insert format tools table help";
  const defaultMenus = {
    file: {
      title: "File",
      items: "newdocument restoredraft | preview | export print | deleteallconversations"
    },
    edit: {
      title: "Edit",
      items: "undo redo | cut copy paste pastetext | selectall | searchreplace"
    },
    view: {
      title: "View",
      items: "code | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments"
    },
    insert: {
      title: "Insert",
      items: "image link media addcomment pageembed template inserttemplate codesample inserttable | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime"
    },
    format: {
      title: "Format",
      items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat"
    },
    tools: {
      title: "Tools",
      items: "spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate"
    },
    table: {
      title: "Table",
      items: "inserttable | cell row column | advtablesort | tableprops deletetable"
    },
    help: {
      title: "Help",
      items: "help"
    }
  };
  const make = (menu2, registry, editor) => {
    const removedMenuItems = getRemovedMenuItems(editor).split(/[ ,]/);
    return {
      text: menu2.title,
      getItems: () => bind$3(menu2.items, (i) => {
        const itemName = i.toLowerCase();
        if (itemName.trim().length === 0) {
          return [];
        } else if (exists(removedMenuItems, (removedMenuItem) => removedMenuItem === itemName)) {
          return [];
        } else if (itemName === "separator" || itemName === "|") {
          return [{ type: "separator" }];
        } else if (registry.menuItems[itemName]) {
          return [registry.menuItems[itemName]];
        } else {
          return [];
        }
      })
    };
  };
  const parseItemsString = (items) => {
    return items.split(" ");
  };
  const identifyMenus = (editor, registry) => {
    const rawMenuData = {
      ...defaultMenus,
      ...registry.menus
    };
    const userDefinedMenus = keys(registry.menus).length > 0;
    const menubar = registry.menubar === void 0 || registry.menubar === true ? parseItemsString(defaultMenubar) : parseItemsString(registry.menubar === false ? "" : registry.menubar);
    const validMenus = filter$2(menubar, (menuName) => {
      const isDefaultMenu = has$2(defaultMenus, menuName);
      if (userDefinedMenus) {
        return isDefaultMenu || get$g(registry.menus, menuName).exists((menu2) => has$2(menu2, "items"));
      } else {
        return isDefaultMenu;
      }
    });
    const menus = map$2(validMenus, (menuName) => {
      const menuData = rawMenuData[menuName];
      return make({
        title: menuData.title,
        items: parseItemsString(menuData.items)
      }, registry, editor);
    });
    return filter$2(menus, (menu2) => {
      const isNotSeparator = (item3) => isString2(item3) || item3.type !== "separator";
      return menu2.getItems().length > 0 && exists(menu2.getItems(), isNotSeparator);
    });
  };
  const fireSkinLoaded = (editor) => {
    const done = () => {
      editor._skinLoaded = true;
      fireSkinLoaded$1(editor);
    };
    return () => {
      if (editor.initialized) {
        done();
      } else {
        editor.on("init", done);
      }
    };
  };
  const fireSkinLoadError = (editor, err) => () => fireSkinLoadError$1(editor, { message: err });
  const loadStylesheet = (editor, stylesheetUrl, styleSheetLoader) => {
    editor.on("remove", () => styleSheetLoader.unload(stylesheetUrl));
    return styleSheetLoader.load(stylesheetUrl);
  };
  const loadUiSkins = (editor, skinUrl) => {
    const skinUiCss = skinUrl + "/skin.min.css";
    return loadStylesheet(editor, skinUiCss, editor.ui.styleSheetLoader);
  };
  const loadShadowDomUiSkins = (editor, skinUrl) => {
    const isInShadowRoot$1 = isInShadowRoot(SugarElement.fromDom(editor.getElement()));
    if (isInShadowRoot$1) {
      const shadowDomSkinCss = skinUrl + "/skin.shadowdom.min.css";
      return loadStylesheet(editor, shadowDomSkinCss, global$7.DOM.styleSheetLoader);
    } else {
      return Promise.resolve();
    }
  };
  const loadSkin = (isInline, editor) => {
    const skinUrl = getSkinUrl(editor);
    if (skinUrl) {
      editor.contentCSS.push(skinUrl + (isInline ? "/content.inline" : "/content") + ".min.css");
    }
    if (!isSkinDisabled(editor) && isString2(skinUrl)) {
      return Promise.all([
        loadUiSkins(editor, skinUrl),
        loadShadowDomUiSkins(editor, skinUrl)
      ]).then(fireSkinLoaded(editor), fireSkinLoadError(editor, "Skin could not be loaded"));
    } else {
      return Promise.resolve(fireSkinLoaded(editor)());
    }
  };
  const iframe = curry(loadSkin, false);
  const inline = curry(loadSkin, true);
  const onSetupFormatToggle = (editor, name3) => (api2) => {
    const boundCallback = unbindable();
    const init2 = () => {
      api2.setActive(editor.formatter.match(name3));
      const binding = editor.formatter.formatChanged(name3, api2.setActive);
      boundCallback.set(binding);
    };
    editor.initialized ? init2() : editor.once("init", init2);
    return () => {
      editor.off("init", init2);
      boundCallback.clear();
    };
  };
  const onSetupEvent = (editor, event, f2) => (api2) => {
    const handleEvent = () => f2(api2);
    const init2 = () => {
      f2(api2);
      editor.on(event, handleEvent);
    };
    editor.initialized ? init2() : editor.once("init", init2);
    return () => {
      editor.off("init", init2);
      editor.off(event, handleEvent);
    };
  };
  const onActionToggleFormat$1 = (editor) => (rawItem) => () => {
    editor.undoManager.transact(() => {
      editor.focus();
      editor.execCommand("mceToggleFormat", false, rawItem.format);
    });
  };
  const onActionExecCommand = (editor, command) => () => editor.execCommand(command);
  const generateSelectItems = (_editor, backstage, spec) => {
    const generateItem = (rawItem, response, invalid, value2) => {
      const translatedText = backstage.shared.providers.translate(rawItem.title);
      if (rawItem.type === "separator") {
        return Optional.some({
          type: "separator",
          text: translatedText
        });
      } else if (rawItem.type === "submenu") {
        const items = bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value2));
        if (response === 0 && items.length <= 0) {
          return Optional.none();
        } else {
          return Optional.some({
            type: "nestedmenuitem",
            text: translatedText,
            enabled: items.length > 0,
            getSubmenuItems: () => bind$3(rawItem.getStyleItems(), (si) => validate(si, response, value2))
          });
        }
      } else {
        return Optional.some({
          type: "togglemenuitem",
          text: translatedText,
          icon: rawItem.icon,
          active: rawItem.isSelected(value2),
          enabled: !invalid,
          onAction: spec.onAction(rawItem),
          ...rawItem.getStylePreview().fold(() => ({}), (preview) => ({ meta: { style: preview } }))
        });
      }
    };
    const validate = (item3, response, value2) => {
      const invalid = item3.type === "formatter" && spec.isInvalid(item3);
      if (response === 0) {
        return invalid ? [] : generateItem(item3, response, false, value2).toArray();
      } else {
        return generateItem(item3, response, invalid, value2).toArray();
      }
    };
    const validateItems = (preItems) => {
      const value2 = spec.getCurrentValue();
      const response = spec.shouldHide ? 0 : 1;
      return bind$3(preItems, (item3) => validate(item3, response, value2));
    };
    const getFetch2 = (backstage2, getStyleItems) => (comp, callback) => {
      const preItems = getStyleItems();
      const items = validateItems(preItems);
      const menu2 = build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage2, {
        isHorizontalMenu: false,
        search: Optional.none()
      });
      callback(menu2);
    };
    return {
      validateItems,
      getFetch: getFetch2
    };
  };
  const createMenuItems = (editor, backstage, spec) => {
    const dataset2 = spec.dataset;
    const getStyleItems = dataset2.type === "basic" ? () => map$2(dataset2.data, (d) => processBasic(d, spec.isSelectedFor, spec.getPreviewFor)) : dataset2.getData;
    return {
      items: generateSelectItems(editor, backstage, spec),
      getStyleItems
    };
  };
  const createSelectButton = (editor, backstage, spec) => {
    const { items, getStyleItems } = createMenuItems(editor, backstage, spec);
    const getApi2 = (comp) => ({ getComponent: constant$1(comp) });
    const onSetup2 = onSetupEvent(editor, "NodeChange", (api2) => {
      const comp = api2.getComponent();
      spec.updateText(comp);
    });
    return renderCommonDropdown({
      text: spec.icon.isSome() ? Optional.none() : spec.text,
      icon: spec.icon,
      tooltip: Optional.from(spec.tooltip),
      role: Optional.none(),
      fetch: items.getFetch(backstage, getStyleItems),
      onSetup: onSetup2,
      getApi: getApi2,
      columns: 1,
      presets: "normal",
      classes: spec.icon.isSome() ? [] : ["bespoke"],
      dropdownBehaviours: []
    }, "tox-tbtn", backstage.shared);
  };
  const process = (rawFormats) => map$2(rawFormats, (item3) => {
    let title2 = item3, format = item3;
    const values2 = item3.split("=");
    if (values2.length > 1) {
      title2 = values2[0];
      format = values2[1];
    }
    return {
      title: title2,
      format
    };
  });
  const buildBasicStaticDataset = (data2) => ({
    type: "basic",
    data: data2
  });
  var Delimiter;
  (function(Delimiter2) {
    Delimiter2[Delimiter2["SemiColon"] = 0] = "SemiColon";
    Delimiter2[Delimiter2["Space"] = 1] = "Space";
  })(Delimiter || (Delimiter = {}));
  const split = (rawFormats, delimiter) => {
    if (delimiter === Delimiter.SemiColon) {
      return rawFormats.replace(/;$/, "").split(";");
    } else {
      return rawFormats.split(" ");
    }
  };
  const buildBasicSettingsDataset = (editor, settingName, delimiter) => {
    const rawFormats = editor.options.get(settingName);
    const data2 = process(split(rawFormats, delimiter));
    return {
      type: "basic",
      data: data2
    };
  };
  const alignMenuItems = [
    {
      title: "Left",
      icon: "align-left",
      format: "alignleft",
      command: "JustifyLeft"
    },
    {
      title: "Center",
      icon: "align-center",
      format: "aligncenter",
      command: "JustifyCenter"
    },
    {
      title: "Right",
      icon: "align-right",
      format: "alignright",
      command: "JustifyRight"
    },
    {
      title: "Justify",
      icon: "align-justify",
      format: "alignjustify",
      command: "JustifyFull"
    }
  ];
  const getSpec$4 = (editor) => {
    const getMatchingValue = () => find$5(alignMenuItems, (item3) => editor.formatter.match(item3.format));
    const isSelectedFor = (format) => () => editor.formatter.match(format);
    const getPreviewFor = (_format) => Optional.none;
    const updateSelectMenuIcon = (comp) => {
      const match = getMatchingValue();
      const alignment = match.fold(constant$1("left"), (item3) => item3.title.toLowerCase());
      emitWith(comp, updateMenuIcon, { icon: `align-${alignment}` });
    };
    const dataset2 = buildBasicStaticDataset(alignMenuItems);
    const onAction2 = (rawItem) => () => find$5(alignMenuItems, (item3) => item3.format === rawItem.format).each((item3) => editor.execCommand(item3.command));
    return {
      tooltip: "Align",
      text: Optional.none(),
      icon: Optional.some("align-left"),
      isSelectedFor,
      getCurrentValue: Optional.none,
      getPreviewFor,
      onAction: onAction2,
      updateText: updateSelectMenuIcon,
      dataset: dataset2,
      shouldHide: false,
      isInvalid: (item3) => !editor.formatter.canApply(item3.format)
    };
  };
  const createAlignButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$4(editor));
  const createAlignMenu = (editor, backstage) => {
    const menuItems = createMenuItems(editor, backstage, getSpec$4(editor));
    editor.ui.registry.addNestedMenuItem("align", {
      text: backstage.shared.providers.translate("Align"),
      getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
    });
  };
  const findNearest = (editor, getStyles) => {
    const styles2 = getStyles();
    const formats = map$2(styles2, (style) => style.format);
    return Optional.from(editor.formatter.closest(formats)).bind((fmt) => find$5(styles2, (data2) => data2.format === fmt)).orThunk(() => someIf(editor.formatter.match("p"), {
      title: "Paragraph",
      format: "p"
    }));
  };
  const getSpec$3 = (editor) => {
    const fallbackFormat = "Paragraph";
    const isSelectedFor = (format) => () => editor.formatter.match(format);
    const getPreviewFor = (format) => () => {
      const fmt = editor.formatter.get(format);
      if (fmt) {
        return Optional.some({
          tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
          styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
        });
      } else {
        return Optional.none();
      }
    };
    const updateSelectMenuText = (comp) => {
      const detectedFormat = findNearest(editor, () => dataset2.data);
      const text3 = detectedFormat.fold(constant$1(fallbackFormat), (fmt) => fmt.title);
      emitWith(comp, updateMenuText, { text: text3 });
    };
    const dataset2 = buildBasicSettingsDataset(editor, "block_formats", Delimiter.SemiColon);
    return {
      tooltip: "Blocks",
      text: Optional.some(fallbackFormat),
      icon: Optional.none(),
      isSelectedFor,
      getCurrentValue: Optional.none,
      getPreviewFor,
      onAction: onActionToggleFormat$1(editor),
      updateText: updateSelectMenuText,
      dataset: dataset2,
      shouldHide: false,
      isInvalid: (item3) => !editor.formatter.canApply(item3.format)
    };
  };
  const createBlocksButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$3(editor));
  const createBlocksMenu = (editor, backstage) => {
    const menuItems = createMenuItems(editor, backstage, getSpec$3(editor));
    editor.ui.registry.addNestedMenuItem("blocks", {
      text: "Blocks",
      getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
    });
  };
  const systemStackFonts = [
    "-apple-system",
    "Segoe UI",
    "Roboto",
    "Helvetica Neue",
    "sans-serif"
  ];
  const splitFonts = (fontFamily) => {
    const fonts = fontFamily.split(/\s*,\s*/);
    return map$2(fonts, (font) => font.replace(/^['"]+|['"]+$/g, ""));
  };
  const isSystemFontStack = (fontFamily) => {
    const matchesSystemStack = () => {
      const fonts = splitFonts(fontFamily.toLowerCase());
      return forall(systemStackFonts, (font) => fonts.indexOf(font.toLowerCase()) > -1);
    };
    return fontFamily.indexOf("-apple-system") === 0 && matchesSystemStack();
  };
  const getSpec$2 = (editor) => {
    const systemFont = "System Font";
    const getMatchingValue = () => {
      const getFirstFont = (fontFamily2) => fontFamily2 ? splitFonts(fontFamily2)[0] : "";
      const fontFamily = editor.queryCommandValue("FontName");
      const items = dataset2.data;
      const font = fontFamily ? fontFamily.toLowerCase() : "";
      const matchOpt = find$5(items, (item3) => {
        const format = item3.format;
        return format.toLowerCase() === font || getFirstFont(format).toLowerCase() === getFirstFont(font).toLowerCase();
      }).orThunk(() => {
        return someIf(isSystemFontStack(font), {
          title: systemFont,
          format: font
        });
      });
      return {
        matchOpt,
        font: fontFamily
      };
    };
    const isSelectedFor = (item3) => (valueOpt) => valueOpt.exists((value2) => value2.format === item3);
    const getCurrentValue = () => {
      const { matchOpt } = getMatchingValue();
      return matchOpt;
    };
    const getPreviewFor = (item3) => () => Optional.some({
      tag: "div",
      styles: item3.indexOf("dings") === -1 ? { "font-family": item3 } : {}
    });
    const onAction2 = (rawItem) => () => {
      editor.undoManager.transact(() => {
        editor.focus();
        editor.execCommand("FontName", false, rawItem.format);
      });
    };
    const updateSelectMenuText = (comp) => {
      const { matchOpt, font } = getMatchingValue();
      const text3 = matchOpt.fold(constant$1(font), (item3) => item3.title);
      emitWith(comp, updateMenuText, { text: text3 });
    };
    const dataset2 = buildBasicSettingsDataset(editor, "font_family_formats", Delimiter.SemiColon);
    return {
      tooltip: "Fonts",
      text: Optional.some(systemFont),
      icon: Optional.none(),
      isSelectedFor,
      getCurrentValue,
      getPreviewFor,
      onAction: onAction2,
      updateText: updateSelectMenuText,
      dataset: dataset2,
      shouldHide: false,
      isInvalid: never
    };
  };
  const createFontFamilyButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$2(editor));
  const createFontFamilyMenu = (editor, backstage) => {
    const menuItems = createMenuItems(editor, backstage, getSpec$2(editor));
    editor.ui.registry.addNestedMenuItem("fontfamily", {
      text: backstage.shared.providers.translate("Fonts"),
      getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
    });
  };
  const Keys = {
    tab: constant$1(9),
    escape: constant$1(27),
    enter: constant$1(13),
    backspace: constant$1(8),
    delete: constant$1(46),
    left: constant$1(37),
    up: constant$1(38),
    right: constant$1(39),
    down: constant$1(40),
    space: constant$1(32),
    home: constant$1(36),
    end: constant$1(35),
    pageUp: constant$1(33),
    pageDown: constant$1(34)
  };
  const units = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  };
  const pattern = (() => {
    const decimalDigits = "[0-9]+";
    const signedInteger = "[+-]?" + decimalDigits;
    const exponentPart = "[eE]" + signedInteger;
    const dot = "\\.";
    const opt = (input2) => `(?:${input2})?`;
    const unsignedDecimalLiteral = [
      "Infinity",
      decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
      dot + decimalDigits + opt(exponentPart),
      decimalDigits + opt(exponentPart)
    ].join("|");
    const float = `[+-]?(?:${unsignedDecimalLiteral})`;
    return new RegExp(`^(${float})(.*)$`);
  })();
  const isUnit = (unit, accepted) => exists(accepted, (acc) => exists(units[acc], (check) => unit === check));
  const parse2 = (input2, accepted) => {
    const match = Optional.from(pattern.exec(input2));
    return match.bind((array) => {
      const value2 = Number(array[1]);
      const unitRaw = array[2];
      if (isUnit(unitRaw, accepted)) {
        return Optional.some({
          value: value2,
          unit: unitRaw
        });
      } else {
        return Optional.none();
      }
    });
  };
  const normalise = (input2, accepted) => parse2(input2, accepted).map(({ value: value2, unit }) => value2 + unit);
  const createBespokeNumberInput = (editor, backstage, spec) => {
    let currentComp = Optional.none();
    const getValueFromCurrentComp = (comp) => comp.map((alloyComp) => Representing.getValue(alloyComp)).getOr("");
    const onSetup2 = onSetupEvent(editor, "NodeChange", (api2) => {
      const comp = api2.getComponent();
      currentComp = Optional.some(comp);
      spec.updateInputValue(comp);
    });
    const getApi2 = (comp) => ({ getComponent: constant$1(comp) });
    const editorOffCell = Cell(noop2);
    const customEvents2 = generate$6("custom-number-input-events");
    const isValidValue2 = (value2) => value2 >= 0;
    const changeValue = (f2, fromInput, focusBack) => {
      const text3 = getValueFromCurrentComp(currentComp);
      const parsedText = parse2(text3, [
        "unsupportedLength",
        "empty"
      ]);
      const value2 = parsedText.map((res2) => res2.value).getOr(0);
      const defaultUnit = getFontSizeInputDefaultUnit(editor);
      const unit = parsedText.map((res2) => res2.unit).filter((u) => u !== "").getOr(defaultUnit);
      const newValue = f2(value2, spec.getConfigFromUnit(unit).step);
      const newValueWithUnit = `${isValidValue2(newValue) ? newValue : value2}${unit}`;
      const lenghtDelta = `${value2}${unit}`.length - `${newValueWithUnit}`.length;
      const oldStart = currentComp.map((comp) => comp.element.dom.selectionStart - lenghtDelta);
      const oldEnd = currentComp.map((comp) => comp.element.dom.selectionEnd - lenghtDelta);
      spec.onAction(newValueWithUnit, focusBack);
      currentComp.each((comp) => {
        Representing.setValue(comp, newValueWithUnit);
        if (fromInput) {
          oldStart.each((oldStart2) => comp.element.dom.selectionStart = oldStart2);
          oldEnd.each((oldEnd2) => comp.element.dom.selectionEnd = oldEnd2);
        }
      });
    };
    const decrease = (fromInput, focusBack) => changeValue((n, s) => n - s, fromInput, focusBack);
    const increase = (fromInput, focusBack) => changeValue((n, s) => n + s, fromInput, focusBack);
    const goToParent = (comp) => parentElement(comp.element).fold(Optional.none, (parent2) => {
      focus$3(parent2);
      return Optional.some(true);
    });
    const focusInput = (comp) => {
      if (hasFocus(comp.element)) {
        firstChild(comp.element).each((input2) => focus$3(input2));
        return Optional.some(true);
      } else {
        return Optional.none();
      }
    };
    const makeStepperButton = (action, title2, tooltip, classes2) => {
      const translatedTooltip = backstage.shared.providers.translate(tooltip);
      const altExecuting = generate$6("altExecuting");
      const onClick = () => action(true);
      return Button2.sketch({
        dom: {
          tag: "button",
          attributes: {
            "title": translatedTooltip,
            "aria-label": translatedTooltip
          },
          classes: classes2.concat(title2)
        },
        components: [renderIconFromPack$1(title2, backstage.shared.providers.icons)],
        buttonBehaviours: derive$1([config(altExecuting, [
          run$1(keydown(), (_comp, se) => {
            if (se.event.raw.keyCode === Keys.space() || se.event.raw.keyCode === Keys.enter()) {
              action(false);
            }
          }),
          run$1(click(), onClick),
          run$1(touchend(), onClick)
        ])]),
        eventOrder: {
          [keydown()]: [
            altExecuting,
            "keying"
          ],
          [click()]: [
            altExecuting,
            "alloy.base.behaviour"
          ],
          [touchend()]: [
            altExecuting,
            "alloy.base.behaviour"
          ]
        }
      });
    };
    const memMinus = record(makeStepperButton((focusBack) => decrease(false, focusBack), "minus", "Decrease font size", ["highlight-on-focus"]));
    const memPlus = record(makeStepperButton((focusBack) => increase(false, focusBack), "plus", "Increase font size", ["highlight-on-focus"]));
    const memInput = record({
      dom: {
        tag: "div",
        classes: [
          "tox-input-wrapper",
          "highlight-on-focus"
        ]
      },
      components: [Input.sketch({
        inputBehaviours: derive$1([
          config(customEvents2, [
            onControlAttached({
              onSetup: onSetup2,
              getApi: getApi2
            }, editorOffCell),
            onControlDetached({ getApi: getApi2 }, editorOffCell)
          ]),
          config("input-update-display-text", [
            run$1(updateMenuText, (comp, se) => {
              Representing.setValue(comp, se.event.text);
            }),
            run$1(focusout(), (comp) => {
              spec.onAction(Representing.getValue(comp));
            }),
            run$1(change(), (comp) => {
              spec.onAction(Representing.getValue(comp));
            })
          ]),
          Keying.config({
            mode: "special",
            onEnter: (_comp) => {
              changeValue(identity, true, true);
              return Optional.some(true);
            },
            onEscape: goToParent,
            onUp: (_comp) => {
              increase(true, false);
              return Optional.some(true);
            },
            onDown: (_comp) => {
              decrease(true, false);
              return Optional.some(true);
            },
            onLeft: (_comp, se) => {
              se.cut();
              return Optional.none();
            },
            onRight: (_comp, se) => {
              se.cut();
              return Optional.none();
            }
          })
        ])
      })],
      behaviours: derive$1([
        Focusing.config({}),
        Keying.config({
          mode: "special",
          onEnter: focusInput,
          onSpace: focusInput,
          onEscape: goToParent
        }),
        config("input-wrapper-events", [run$1(mouseover(), (comp) => {
          each$1([
            memMinus,
            memPlus
          ], (button2) => {
            const buttonNode = SugarElement.fromDom(button2.get(comp).element.dom);
            if (hasFocus(buttonNode)) {
              blur$1(buttonNode);
            }
          });
        })])
      ])
    });
    return {
      dom: {
        tag: "div",
        classes: ["tox-number-input"]
      },
      components: [
        memMinus.asSpec(),
        memInput.asSpec(),
        memPlus.asSpec()
      ],
      behaviours: derive$1([
        Focusing.config({}),
        Keying.config({
          mode: "flow",
          focusInside: FocusInsideModes.OnEnterOrSpaceMode,
          cycles: false,
          selector: "button, .tox-input-wrapper",
          onEscape: (wrapperComp) => {
            if (hasFocus(wrapperComp.element)) {
              return Optional.none();
            } else {
              focus$3(wrapperComp.element);
              return Optional.some(true);
            }
          }
        })
      ])
    };
  };
  const legacyFontSizes = {
    "8pt": "1",
    "10pt": "2",
    "12pt": "3",
    "14pt": "4",
    "18pt": "5",
    "24pt": "6",
    "36pt": "7"
  };
  const keywordFontSizes = {
    "xx-small": "7pt",
    "x-small": "8pt",
    "small": "10pt",
    "medium": "12pt",
    "large": "14pt",
    "x-large": "18pt",
    "xx-large": "24pt"
  };
  const round2 = (number2, precision) => {
    const factor = Math.pow(10, precision);
    return Math.round(number2 * factor) / factor;
  };
  const toPt = (fontSize, precision) => {
    if (/[0-9.]+px$/.test(fontSize)) {
      return round2(parseInt(fontSize, 10) * 72 / 96, precision || 0) + "pt";
    } else {
      return get$g(keywordFontSizes, fontSize).getOr(fontSize);
    }
  };
  const toLegacy = (fontSize) => get$g(legacyFontSizes, fontSize).getOr("");
  const getSpec$1 = (editor) => {
    const getMatchingValue = () => {
      let matchOpt = Optional.none();
      const items = dataset2.data;
      const fontSize = editor.queryCommandValue("FontSize");
      if (fontSize) {
        for (let precision = 3; matchOpt.isNone() && precision >= 0; precision--) {
          const pt = toPt(fontSize, precision);
          const legacy = toLegacy(pt);
          matchOpt = find$5(items, (item3) => item3.format === fontSize || item3.format === pt || item3.format === legacy);
        }
      }
      return {
        matchOpt,
        size: fontSize
      };
    };
    const isSelectedFor = (item3) => (valueOpt) => valueOpt.exists((value2) => value2.format === item3);
    const getCurrentValue = () => {
      const { matchOpt } = getMatchingValue();
      return matchOpt;
    };
    const getPreviewFor = constant$1(Optional.none);
    const onAction2 = (rawItem) => () => {
      editor.undoManager.transact(() => {
        editor.focus();
        editor.execCommand("FontSize", false, rawItem.format);
      });
    };
    const updateSelectMenuText = (comp) => {
      const { matchOpt, size } = getMatchingValue();
      const text3 = matchOpt.fold(constant$1(size), (match) => match.title);
      emitWith(comp, updateMenuText, { text: text3 });
    };
    const dataset2 = buildBasicSettingsDataset(editor, "font_size_formats", Delimiter.Space);
    return {
      tooltip: "Font sizes",
      text: Optional.some("12pt"),
      icon: Optional.none(),
      isSelectedFor,
      getPreviewFor,
      getCurrentValue,
      onAction: onAction2,
      updateText: updateSelectMenuText,
      dataset: dataset2,
      shouldHide: false,
      isInvalid: never
    };
  };
  const createFontSizeButton = (editor, backstage) => createSelectButton(editor, backstage, getSpec$1(editor));
  const getConfigFromUnit = (unit) => {
    var _a;
    const baseConfig = { step: 1 };
    const configs = {
      em: { step: 0.1 },
      cm: { step: 0.1 },
      in: { step: 0.1 },
      pc: { step: 0.1 },
      ch: { step: 0.1 },
      rem: { step: 0.1 }
    };
    return (_a = configs[unit]) !== null && _a !== void 0 ? _a : baseConfig;
  };
  const getNumberInputSpec = (editor) => {
    const updateInputValue = (comp) => emitWith(comp, updateMenuText, { text: editor.queryCommandValue("FontSize") });
    return {
      updateInputValue,
      getConfigFromUnit,
      onAction: (format, focusBack) => editor.execCommand("FontSize", false, format, { skip_focus: !focusBack })
    };
  };
  const createFontSizeInputButton = (editor, backstage) => createBespokeNumberInput(editor, backstage, getNumberInputSpec(editor));
  const createFontSizeMenu = (editor, backstage) => {
    const menuItems = createMenuItems(editor, backstage, getSpec$1(editor));
    editor.ui.registry.addNestedMenuItem("fontsize", {
      text: "Font sizes",
      getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
    });
  };
  const getSpec = (editor, dataset2) => {
    const fallbackFormat = "Paragraph";
    const isSelectedFor = (format) => () => editor.formatter.match(format);
    const getPreviewFor = (format) => () => {
      const fmt = editor.formatter.get(format);
      return fmt !== void 0 ? Optional.some({
        tag: fmt.length > 0 ? fmt[0].inline || fmt[0].block || "div" : "div",
        styles: editor.dom.parseStyle(editor.formatter.getCssText(format))
      }) : Optional.none();
    };
    const updateSelectMenuText = (comp) => {
      const getFormatItems = (fmt) => {
        if (isNestedFormat(fmt)) {
          return bind$3(fmt.items, getFormatItems);
        } else if (isFormatReference(fmt)) {
          return [{
            title: fmt.title,
            format: fmt.format
          }];
        } else {
          return [];
        }
      };
      const flattenedItems = bind$3(getStyleFormats(editor), getFormatItems);
      const detectedFormat = findNearest(editor, constant$1(flattenedItems));
      const text3 = detectedFormat.fold(constant$1(fallbackFormat), (fmt) => fmt.title);
      emitWith(comp, updateMenuText, { text: text3 });
    };
    return {
      tooltip: "Formats",
      text: Optional.some(fallbackFormat),
      icon: Optional.none(),
      isSelectedFor,
      getCurrentValue: Optional.none,
      getPreviewFor,
      onAction: onActionToggleFormat$1(editor),
      updateText: updateSelectMenuText,
      shouldHide: shouldAutoHideStyleFormats(editor),
      isInvalid: (item3) => !editor.formatter.canApply(item3.format),
      dataset: dataset2
    };
  };
  const createStylesButton = (editor, backstage) => {
    const dataset2 = {
      type: "advanced",
      ...backstage.styles
    };
    return createSelectButton(editor, backstage, getSpec(editor, dataset2));
  };
  const createStylesMenu = (editor, backstage) => {
    const dataset2 = {
      type: "advanced",
      ...backstage.styles
    };
    const menuItems = createMenuItems(editor, backstage, getSpec(editor, dataset2));
    editor.ui.registry.addNestedMenuItem("styles", {
      text: "Formats",
      getSubmenuItems: () => menuItems.items.validateItems(menuItems.getStyleItems())
    });
  };
  const schema$7 = constant$1([
    required$1("toggleClass"),
    required$1("fetch"),
    onStrictHandler("onExecute"),
    defaulted("getHotspot", Optional.some),
    defaulted("getAnchorOverrides", constant$1({})),
    schema$y(),
    onStrictHandler("onItemExecute"),
    option$3("lazySink"),
    required$1("dom"),
    onHandler("onOpen"),
    field("splitDropdownBehaviours", [
      Coupling,
      Keying,
      Focusing
    ]),
    defaulted("matchWidth", false),
    defaulted("useMinWidth", false),
    defaulted("eventOrder", {}),
    option$3("role")
  ].concat(sandboxFields()));
  const arrowPart = required({
    factory: Button2,
    schema: [required$1("dom")],
    name: "arrow",
    defaults: () => {
      return { buttonBehaviours: derive$1([Focusing.revoke()]) };
    },
    overrides: (detail) => {
      return {
        dom: {
          tag: "span",
          attributes: { role: "presentation" }
        },
        action: (arrow2) => {
          arrow2.getSystem().getByUid(detail.uid).each(emitExecute);
        },
        buttonBehaviours: derive$1([Toggling.config({
          toggleOnExecute: false,
          toggleClass: detail.toggleClass
        })])
      };
    }
  });
  const buttonPart = required({
    factory: Button2,
    schema: [required$1("dom")],
    name: "button",
    defaults: () => {
      return { buttonBehaviours: derive$1([Focusing.revoke()]) };
    },
    overrides: (detail) => {
      return {
        dom: {
          tag: "span",
          attributes: { role: "presentation" }
        },
        action: (btn) => {
          btn.getSystem().getByUid(detail.uid).each((splitDropdown) => {
            detail.onExecute(splitDropdown, btn);
          });
        }
      };
    }
  });
  const parts$3 = constant$1([
    arrowPart,
    buttonPart,
    optional({
      factory: {
        sketch: (spec) => {
          return {
            uid: spec.uid,
            dom: {
              tag: "span",
              styles: { display: "none" },
              attributes: { "aria-hidden": "true" },
              innerHtml: spec.text
            }
          };
        }
      },
      schema: [required$1("text")],
      name: "aria-descriptor"
    }),
    external({
      schema: [tieredMenuMarkers()],
      name: "menu",
      defaults: (detail) => {
        return {
          onExecute: (tmenu, item3) => {
            tmenu.getSystem().getByUid(detail.uid).each((splitDropdown) => {
              detail.onItemExecute(splitDropdown, tmenu, item3);
            });
          }
        };
      }
    }),
    partType$1()
  ]);
  const factory$5 = (detail, components2, spec, externals) => {
    const switchToMenu = (sandbox) => {
      Composing.getCurrent(sandbox).each((current) => {
        Highlighting.highlightFirst(current);
        Keying.focusIn(current);
      });
    };
    const action = (component) => {
      const onOpenSync = switchToMenu;
      togglePopup(detail, identity, component, externals, onOpenSync, HighlightOnOpen.HighlightMenuAndItem).get(noop2);
    };
    const openMenu = (comp) => {
      action(comp);
      return Optional.some(true);
    };
    const executeOnButton = (comp) => {
      const button2 = getPartOrDie(comp, detail, "button");
      emitExecute(button2);
      return Optional.some(true);
    };
    const buttonEvents = {
      ...derive$2([runOnAttached((component, _simulatedEvent) => {
        const ariaDescriptor = getPart(component, detail, "aria-descriptor");
        ariaDescriptor.each((descriptor) => {
          const descriptorId = generate$6("aria");
          set$9(descriptor.element, "id", descriptorId);
          set$9(component.element, "aria-describedby", descriptorId);
        });
      })]),
      ...events$a(Optional.some(action))
    };
    const apis2 = {
      repositionMenus: (comp) => {
        if (Toggling.isOn(comp)) {
          repositionMenus(comp);
        }
      }
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      apis: apis2,
      eventOrder: {
        ...detail.eventOrder,
        [execute$5()]: [
          "disabling",
          "toggling",
          "alloy.base.behaviour"
        ]
      },
      events: buttonEvents,
      behaviours: augment(detail.splitDropdownBehaviours, [
        Coupling.config({
          others: {
            sandbox: (hotspot) => {
              const arrow2 = getPartOrDie(hotspot, detail, "arrow");
              const extras = {
                onOpen: () => {
                  Toggling.on(arrow2);
                  Toggling.on(hotspot);
                },
                onClose: () => {
                  Toggling.off(arrow2);
                  Toggling.off(hotspot);
                }
              };
              return makeSandbox$1(detail, hotspot, extras);
            }
          }
        }),
        Keying.config({
          mode: "special",
          onSpace: executeOnButton,
          onEnter: executeOnButton,
          onDown: openMenu
        }),
        Focusing.config({}),
        Toggling.config({
          toggleOnExecute: false,
          aria: { mode: "expanded" }
        })
      ]),
      domModification: {
        attributes: {
          "role": detail.role.getOr("button"),
          "aria-haspopup": true
        }
      }
    };
  };
  const SplitDropdown = composite({
    name: "SplitDropdown",
    configFields: schema$7(),
    partFields: parts$3(),
    factory: factory$5,
    apis: { repositionMenus: (apis2, comp) => apis2.repositionMenus(comp) }
  });
  const getButtonApi = (component) => ({
    isEnabled: () => !Disabling.isDisabled(component),
    setEnabled: (state2) => Disabling.set(component, !state2),
    setText: (text3) => emitWith(component, updateMenuText, { text: text3 }),
    setIcon: (icon2) => emitWith(component, updateMenuIcon, { icon: icon2 })
  });
  const getToggleApi = (component) => ({
    setActive: (state2) => {
      Toggling.set(component, state2);
    },
    isActive: () => Toggling.isOn(component),
    isEnabled: () => !Disabling.isDisabled(component),
    setEnabled: (state2) => Disabling.set(component, !state2),
    setText: (text3) => emitWith(component, updateMenuText, { text: text3 }),
    setIcon: (icon2) => emitWith(component, updateMenuIcon, { icon: icon2 })
  });
  const getTooltipAttributes = (tooltip, providersBackstage) => tooltip.map((tooltip2) => ({
    "aria-label": providersBackstage.translate(tooltip2),
    "title": providersBackstage.translate(tooltip2)
  })).getOr({});
  const focusButtonEvent = generate$6("focus-button");
  const renderCommonStructure = (optIcon, optText, tooltip, behaviours2, providersBackstage) => {
    const optMemDisplayText = optText.map((text3) => record(renderLabel$1(text3, "tox-tbtn", providersBackstage)));
    const optMemDisplayIcon = optIcon.map((icon2) => record(renderReplaceableIconFromPack(icon2, providersBackstage.icons)));
    return {
      dom: {
        tag: "button",
        classes: ["tox-tbtn"].concat(optText.isSome() ? ["tox-tbtn--select"] : []),
        attributes: getTooltipAttributes(tooltip, providersBackstage)
      },
      components: componentRenderPipeline([
        optMemDisplayIcon.map((mem) => mem.asSpec()),
        optMemDisplayText.map((mem) => mem.asSpec())
      ]),
      eventOrder: {
        [mousedown()]: [
          "focusing",
          "alloy.base.behaviour",
          commonButtonDisplayEvent
        ],
        [attachedToDom()]: [
          commonButtonDisplayEvent,
          "toolbar-group-button-events"
        ]
      },
      buttonBehaviours: derive$1([
        DisablingConfigs.toolbarButton(providersBackstage.isDisabled),
        receivingConfig(),
        config(commonButtonDisplayEvent, [
          runOnAttached((comp, _se) => forceInitialSize(comp)),
          run$1(updateMenuText, (comp, se) => {
            optMemDisplayText.bind((mem) => mem.getOpt(comp)).each((displayText) => {
              Replacing.set(displayText, [text$2(providersBackstage.translate(se.event.text))]);
            });
          }),
          run$1(updateMenuIcon, (comp, se) => {
            optMemDisplayIcon.bind((mem) => mem.getOpt(comp)).each((displayIcon) => {
              Replacing.set(displayIcon, [renderReplaceableIconFromPack(se.event.icon, providersBackstage.icons)]);
            });
          }),
          run$1(mousedown(), (button2, se) => {
            se.event.prevent();
            emit(button2, focusButtonEvent);
          })
        ])
      ].concat(behaviours2.getOr([])))
    };
  };
  const renderFloatingToolbarButton = (spec, backstage, identifyButtons2, attributes) => {
    const sharedBackstage = backstage.shared;
    const editorOffCell = Cell(noop2);
    const specialisation = {
      toolbarButtonBehaviours: [],
      getApi: getButtonApi,
      onSetup: spec.onSetup
    };
    const behaviours2 = [config("toolbar-group-button-events", [
      onControlAttached(specialisation, editorOffCell),
      onControlDetached(specialisation, editorOffCell)
    ])];
    return FloatingToolbarButton.sketch({
      lazySink: sharedBackstage.getSink,
      fetch: () => Future.nu((resolve2) => {
        resolve2(map$2(identifyButtons2(spec.items), renderToolbarGroup));
      }),
      markers: { toggledClass: "tox-tbtn--enabled" },
      parts: {
        button: renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.some(behaviours2), sharedBackstage.providers),
        toolbar: {
          dom: {
            tag: "div",
            classes: ["tox-toolbar__overflow"],
            attributes
          }
        }
      }
    });
  };
  const renderCommonToolbarButton = (spec, specialisation, providersBackstage) => {
    var _d;
    const editorOffCell = Cell(noop2);
    const structure = renderCommonStructure(spec.icon, spec.text, spec.tooltip, Optional.none(), providersBackstage);
    return Button2.sketch({
      dom: structure.dom,
      components: structure.components,
      eventOrder: toolbarButtonEventOrder,
      buttonBehaviours: {
        ...derive$1([
          config("toolbar-button-events", [
            onToolbarButtonExecute({
              onAction: spec.onAction,
              getApi: specialisation.getApi
            }),
            onControlAttached(specialisation, editorOffCell),
            onControlDetached(specialisation, editorOffCell)
          ]),
          DisablingConfigs.toolbarButton(() => !spec.enabled || providersBackstage.isDisabled()),
          receivingConfig()
        ].concat(specialisation.toolbarButtonBehaviours)),
        [commonButtonDisplayEvent]: (_d = structure.buttonBehaviours) === null || _d === void 0 ? void 0 : _d[commonButtonDisplayEvent]
      }
    });
  };
  const renderToolbarButton = (spec, providersBackstage) => renderToolbarButtonWith(spec, providersBackstage, []);
  const renderToolbarButtonWith = (spec, providersBackstage, bonusEvents) => renderCommonToolbarButton(spec, {
    toolbarButtonBehaviours: bonusEvents.length > 0 ? [config("toolbarButtonWith", bonusEvents)] : [],
    getApi: getButtonApi,
    onSetup: spec.onSetup
  }, providersBackstage);
  const renderToolbarToggleButton = (spec, providersBackstage) => renderToolbarToggleButtonWith(spec, providersBackstage, []);
  const renderToolbarToggleButtonWith = (spec, providersBackstage, bonusEvents) => renderCommonToolbarButton(spec, {
    toolbarButtonBehaviours: [
      Replacing.config({}),
      Toggling.config({
        toggleClass: "tox-tbtn--enabled",
        aria: { mode: "pressed" },
        toggleOnExecute: false
      })
    ].concat(bonusEvents.length > 0 ? [config("toolbarToggleButtonWith", bonusEvents)] : []),
    getApi: getToggleApi,
    onSetup: spec.onSetup
  }, providersBackstage);
  const fetchChoices = (getApi2, spec, providersBackstage) => (comp) => Future.nu((callback) => spec.fetch(callback)).map((items) => Optional.from(createTieredDataFrom(deepMerge(createPartialChoiceMenu(generate$6("menu-value"), items, (value2) => {
    spec.onItemAction(getApi2(comp), value2);
  }, spec.columns, spec.presets, ItemResponse$1.CLOSE_ON_EXECUTE, spec.select.getOr(never), providersBackstage), {
    movement: deriveMenuMovement(spec.columns, spec.presets),
    menuBehaviours: SimpleBehaviours.unnamedEvents(spec.columns !== "auto" ? [] : [runOnAttached((comp2, _se) => {
      detectSize(comp2, 4, classForPreset(spec.presets)).each(({ numRows, numColumns }) => {
        Keying.setGridSize(comp2, numRows, numColumns);
      });
    })])
  }))));
  const renderSplitButton = (spec, sharedBackstage) => {
    const getApi2 = (comp) => ({
      isEnabled: () => !Disabling.isDisabled(comp),
      setEnabled: (state2) => Disabling.set(comp, !state2),
      setIconFill: (id, value2) => {
        descendant(comp.element, `svg path[id="${id}"], rect[id="${id}"]`).each((underlinePath) => {
          set$9(underlinePath, "fill", value2);
        });
      },
      setActive: (state2) => {
        set$9(comp.element, "aria-pressed", state2);
        descendant(comp.element, "span").each((button2) => {
          comp.getSystem().getByDom(button2).each((buttonComp) => Toggling.set(buttonComp, state2));
        });
      },
      isActive: () => descendant(comp.element, "span").exists((button2) => comp.getSystem().getByDom(button2).exists(Toggling.isOn)),
      setText: (text3) => descendant(comp.element, "span").each((button2) => comp.getSystem().getByDom(button2).each((buttonComp) => emitWith(buttonComp, updateMenuText, { text: text3 }))),
      setIcon: (icon2) => descendant(comp.element, "span").each((button2) => comp.getSystem().getByDom(button2).each((buttonComp) => emitWith(buttonComp, updateMenuIcon, { icon: icon2 })))
    });
    const editorOffCell = Cell(noop2);
    const specialisation = {
      getApi: getApi2,
      onSetup: spec.onSetup
    };
    return SplitDropdown.sketch({
      dom: {
        tag: "div",
        classes: ["tox-split-button"],
        attributes: {
          "aria-pressed": false,
          ...getTooltipAttributes(spec.tooltip, sharedBackstage.providers)
        }
      },
      onExecute: (button2) => {
        const api2 = getApi2(button2);
        if (api2.isEnabled()) {
          spec.onAction(api2);
        }
      },
      onItemExecute: (_a, _b, _c) => {
      },
      splitDropdownBehaviours: derive$1([
        DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
        receivingConfig(),
        config("split-dropdown-events", [
          runOnAttached((comp, _se) => forceInitialSize(comp)),
          run$1(focusButtonEvent, Focusing.focus),
          onControlAttached(specialisation, editorOffCell),
          onControlDetached(specialisation, editorOffCell)
        ]),
        Unselecting.config({})
      ]),
      eventOrder: {
        [attachedToDom()]: [
          "alloy.base.behaviour",
          "split-dropdown-events"
        ]
      },
      toggleClass: "tox-tbtn--enabled",
      lazySink: sharedBackstage.getSink,
      fetch: fetchChoices(getApi2, spec, sharedBackstage.providers),
      parts: { menu: part(false, spec.columns, spec.presets) },
      components: [
        SplitDropdown.parts.button(renderCommonStructure(spec.icon, spec.text, Optional.none(), Optional.some([Toggling.config({
          toggleClass: "tox-tbtn--enabled",
          toggleOnExecute: false
        })]), sharedBackstage.providers)),
        SplitDropdown.parts.arrow({
          dom: {
            tag: "button",
            classes: [
              "tox-tbtn",
              "tox-split-button__chevron"
            ],
            innerHtml: get$2("chevron-down", sharedBackstage.providers.icons)
          },
          buttonBehaviours: derive$1([
            DisablingConfigs.splitButton(sharedBackstage.providers.isDisabled),
            receivingConfig(),
            addFocusableBehaviour()
          ])
        }),
        SplitDropdown.parts["aria-descriptor"]({ text: sharedBackstage.providers.translate("To open the popup, press Shift+Enter") })
      ]
    });
  };
  const defaultToolbar = [
    {
      name: "history",
      items: [
        "undo",
        "redo"
      ]
    },
    {
      name: "styles",
      items: ["styles"]
    },
    {
      name: "formatting",
      items: [
        "bold",
        "italic"
      ]
    },
    {
      name: "alignment",
      items: [
        "alignleft",
        "aligncenter",
        "alignright",
        "alignjustify"
      ]
    },
    {
      name: "indentation",
      items: [
        "outdent",
        "indent"
      ]
    },
    {
      name: "permanent pen",
      items: ["permanentpen"]
    },
    {
      name: "comments",
      items: ["addcomment"]
    }
  ];
  const renderFromBridge = (bridgeBuilder, render2) => (spec, backstage, editor) => {
    const internal = bridgeBuilder(spec).mapError((errInfo) => formatError(errInfo)).getOrDie();
    return render2(internal, backstage, editor);
  };
  const types = {
    button: renderFromBridge(createToolbarButton, (s, backstage) => renderToolbarButton(s, backstage.shared.providers)),
    togglebutton: renderFromBridge(createToggleButton, (s, backstage) => renderToolbarToggleButton(s, backstage.shared.providers)),
    menubutton: renderFromBridge(createMenuButton, (s, backstage) => renderMenuButton(s, "tox-tbtn", backstage, Optional.none())),
    splitbutton: renderFromBridge(createSplitButton, (s, backstage) => renderSplitButton(s, backstage.shared)),
    grouptoolbarbutton: renderFromBridge(createGroupToolbarButton, (s, backstage, editor) => {
      const buttons = editor.ui.registry.getAll().buttons;
      const identify = (toolbar) => identifyButtons(editor, {
        buttons,
        toolbar,
        allowToolbarGroups: false
      }, backstage, Optional.none());
      const attributes = { [Attribute]: backstage.shared.header.isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop };
      switch (getToolbarMode(editor)) {
        case ToolbarMode$1.floating:
          return renderFloatingToolbarButton(s, backstage, identify, attributes);
        default:
          throw new Error("Toolbar groups are only supported when using floating toolbar mode");
      }
    })
  };
  const extractFrom = (spec, backstage, editor) => get$g(types, spec.type).fold(() => {
    console.error("skipping button defined by", spec);
    return Optional.none();
  }, (render2) => Optional.some(render2(spec, backstage, editor)));
  const bespokeButtons = {
    styles: createStylesButton,
    fontsize: createFontSizeButton,
    fontsizeinput: createFontSizeInputButton,
    fontfamily: createFontFamilyButton,
    blocks: createBlocksButton,
    align: createAlignButton
  };
  const removeUnusedDefaults = (buttons) => {
    const filteredItemGroups = map$2(defaultToolbar, (group2) => {
      const items = filter$2(group2.items, (subItem) => has$2(buttons, subItem) || has$2(bespokeButtons, subItem));
      return {
        name: group2.name,
        items
      };
    });
    return filter$2(filteredItemGroups, (group2) => group2.items.length > 0);
  };
  const convertStringToolbar = (strToolbar) => {
    const groupsStrings = strToolbar.split("|");
    return map$2(groupsStrings, (g) => ({ items: g.trim().split(" ") }));
  };
  const isToolbarGroupSettingArray = (toolbar) => isArrayOf(toolbar, (t2) => has$2(t2, "name") && has$2(t2, "items"));
  const createToolbar = (toolbarConfig) => {
    const toolbar = toolbarConfig.toolbar;
    const buttons = toolbarConfig.buttons;
    if (toolbar === false) {
      return [];
    } else if (toolbar === void 0 || toolbar === true) {
      return removeUnusedDefaults(buttons);
    } else if (isString2(toolbar)) {
      return convertStringToolbar(toolbar);
    } else if (isToolbarGroupSettingArray(toolbar)) {
      return toolbar;
    } else {
      console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]");
      return [];
    }
  };
  const lookupButton = (editor, buttons, toolbarItem, allowToolbarGroups, backstage, prefixes) => get$g(buttons, toolbarItem.toLowerCase()).orThunk(() => prefixes.bind((ps) => findMap(ps, (prefix2) => get$g(buttons, prefix2 + toolbarItem.toLowerCase())))).fold(() => get$g(bespokeButtons, toolbarItem.toLowerCase()).map((r2) => r2(editor, backstage)), (spec) => {
    if (spec.type === "grouptoolbarbutton" && !allowToolbarGroups) {
      console.warn(`Ignoring the '${toolbarItem}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`);
      return Optional.none();
    } else {
      return extractFrom(spec, backstage, editor);
    }
  });
  const identifyButtons = (editor, toolbarConfig, backstage, prefixes) => {
    const toolbarGroups = createToolbar(toolbarConfig);
    const groups = map$2(toolbarGroups, (group2) => {
      const items = bind$3(group2.items, (toolbarItem) => {
        return toolbarItem.trim().length === 0 ? [] : lookupButton(editor, toolbarConfig.buttons, toolbarItem, toolbarConfig.allowToolbarGroups, backstage, prefixes).toArray();
      });
      return {
        title: Optional.from(editor.translate(group2.name)),
        items
      };
    });
    return filter$2(groups, (group2) => group2.items.length > 0);
  };
  const setToolbar = (editor, uiRefs, rawUiConfig, backstage) => {
    const outerContainer = uiRefs.mainUi.outerContainer;
    const toolbarConfig = rawUiConfig.toolbar;
    const toolbarButtonsConfig = rawUiConfig.buttons;
    if (isArrayOf(toolbarConfig, isString2)) {
      const toolbars = toolbarConfig.map((t2) => {
        const config2 = {
          toolbar: t2,
          buttons: toolbarButtonsConfig,
          allowToolbarGroups: rawUiConfig.allowToolbarGroups
        };
        return identifyButtons(editor, config2, backstage, Optional.none());
      });
      OuterContainer.setToolbars(outerContainer, toolbars);
    } else {
      OuterContainer.setToolbar(outerContainer, identifyButtons(editor, rawUiConfig, backstage, Optional.none()));
    }
  };
  const detection = detect$2();
  const isiOS12 = detection.os.isiOS() && detection.os.version.major <= 12;
  const setupEvents$1 = (editor, uiRefs) => {
    const { uiMotherships } = uiRefs;
    const dom2 = editor.dom;
    let contentWindow = editor.getWin();
    const initialDocEle = editor.getDoc().documentElement;
    const lastWindowDimensions = Cell(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
    const lastDocumentDimensions = Cell(SugarPosition(initialDocEle.offsetWidth, initialDocEle.offsetHeight));
    const resizeWindow = () => {
      const outer = lastWindowDimensions.get();
      if (outer.left !== contentWindow.innerWidth || outer.top !== contentWindow.innerHeight) {
        lastWindowDimensions.set(SugarPosition(contentWindow.innerWidth, contentWindow.innerHeight));
        fireResizeContent(editor);
      }
    };
    const resizeDocument = () => {
      const docEle = editor.getDoc().documentElement;
      const inner = lastDocumentDimensions.get();
      if (inner.left !== docEle.offsetWidth || inner.top !== docEle.offsetHeight) {
        lastDocumentDimensions.set(SugarPosition(docEle.offsetWidth, docEle.offsetHeight));
        fireResizeContent(editor);
      }
    };
    const scroll = (e) => {
      fireScrollContent(editor, e);
    };
    dom2.bind(contentWindow, "resize", resizeWindow);
    dom2.bind(contentWindow, "scroll", scroll);
    const elementLoad = capture(SugarElement.fromDom(editor.getBody()), "load", resizeDocument);
    editor.on("hide", () => {
      each$1(uiMotherships, (m) => {
        set$8(m.element, "display", "none");
      });
    });
    editor.on("show", () => {
      each$1(uiMotherships, (m) => {
        remove$6(m.element, "display");
      });
    });
    editor.on("NodeChange", resizeDocument);
    editor.on("remove", () => {
      elementLoad.unbind();
      dom2.unbind(contentWindow, "resize", resizeWindow);
      dom2.unbind(contentWindow, "scroll", scroll);
      contentWindow = null;
    });
  };
  const attachUiMotherships = (editor, uiRoot, uiRefs) => {
    if (isSplitUiMode(editor)) {
      attachSystemAfter(uiRefs.mainUi.mothership.element, uiRefs.popupUi.mothership);
    }
    attachSystem(uiRoot, uiRefs.dialogUi.mothership);
  };
  const render$1 = async (editor, uiRefs, rawUiConfig, backstage, args) => {
    const { mainUi, uiMotherships } = uiRefs;
    const lastToolbarWidth = Cell(0);
    const outerContainer = mainUi.outerContainer;
    await iframe(editor);
    const eTargetNode = SugarElement.fromDom(args.targetNode);
    const uiRoot = getContentContainer(getRootNode2(eTargetNode));
    attachSystemAfter(eTargetNode, mainUi.mothership);
    attachUiMotherships(editor, uiRoot, uiRefs);
    editor.on("PostRender", () => {
      OuterContainer.setSidebar(outerContainer, rawUiConfig.sidebar, getSidebarShow(editor));
      setToolbar(editor, uiRefs, rawUiConfig, backstage);
      lastToolbarWidth.set(editor.getWin().innerWidth);
      OuterContainer.setMenubar(outerContainer, identifyMenus(editor, rawUiConfig));
      OuterContainer.setViews(outerContainer, rawUiConfig.views);
      setupEvents$1(editor, uiRefs);
    });
    const socket = OuterContainer.getSocket(outerContainer).getOrDie("Could not find expected socket element");
    if (isiOS12) {
      setAll(socket.element, {
        "overflow": "scroll",
        "-webkit-overflow-scrolling": "touch"
      });
      const limit2 = first(() => {
        editor.dispatch("ScrollContent");
      }, 20);
      const unbinder = bind2(socket.element, "scroll", limit2.throttle);
      editor.on("remove", unbinder.unbind);
    }
    setupReadonlyModeSwitch(editor, uiRefs);
    editor.addCommand("ToggleSidebar", (_ui, value2) => {
      OuterContainer.toggleSidebar(outerContainer, value2);
      editor.dispatch("ToggleSidebar");
    });
    editor.addQueryValueHandler("ToggleSidebar", () => {
      var _a;
      return (_a = OuterContainer.whichSidebar(outerContainer)) !== null && _a !== void 0 ? _a : "";
    });
    editor.addCommand("ToggleView", (_ui, value2) => {
      if (OuterContainer.toggleView(outerContainer, value2)) {
        const target = outerContainer.element;
        mainUi.mothership.broadcastOn([dismissPopups()], { target });
        each$1(uiMotherships, (m) => {
          m.broadcastOn([dismissPopups()], { target });
        });
        if (isNull2(OuterContainer.whichView(outerContainer))) {
          editor.focus();
          editor.nodeChanged();
        }
      }
    });
    editor.addQueryValueHandler("ToggleView", () => {
      var _a;
      return (_a = OuterContainer.whichView(outerContainer)) !== null && _a !== void 0 ? _a : "";
    });
    const toolbarMode = getToolbarMode(editor);
    const refreshDrawer = () => {
      OuterContainer.refreshToolbar(uiRefs.mainUi.outerContainer);
    };
    if (toolbarMode === ToolbarMode$1.sliding || toolbarMode === ToolbarMode$1.floating) {
      editor.on("ResizeWindow ResizeEditor ResizeContent", () => {
        const width3 = editor.getWin().innerWidth;
        if (width3 !== lastToolbarWidth.get()) {
          refreshDrawer();
          lastToolbarWidth.set(width3);
        }
      });
    }
    const api2 = {
      setEnabled: (state2) => {
        broadcastReadonly(uiRefs, !state2);
      },
      isEnabled: () => !Disabling.isDisabled(outerContainer)
    };
    return {
      iframeContainer: socket.element.dom,
      editorContainer: outerContainer.element.dom,
      api: api2
    };
  };
  var Iframe = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render: render$1
  });
  const parseToInt = (val) => {
    const re = /^[0-9\.]+(|px)$/i;
    if (re.test("" + val)) {
      return Optional.some(parseInt("" + val, 10));
    }
    return Optional.none();
  };
  const numToPx = (val) => isNumber2(val) ? val + "px" : val;
  const calcCappedSize = (size, minSize, maxSize) => {
    const minOverride = minSize.filter((min3) => size < min3);
    const maxOverride = maxSize.filter((max3) => size > max3);
    return minOverride.or(maxOverride).getOr(size);
  };
  const getHeight = (editor) => {
    const baseHeight = getHeightOption(editor);
    const minHeight = getMinHeightOption(editor);
    const maxHeight = getMaxHeightOption(editor);
    return parseToInt(baseHeight).map((height3) => calcCappedSize(height3, minHeight, maxHeight));
  };
  const getHeightWithFallback = (editor) => {
    const height3 = getHeight(editor);
    return height3.getOr(getHeightOption(editor));
  };
  const getWidth = (editor) => {
    const baseWidth = getWidthOption(editor);
    const minWidth = getMinWidthOption(editor);
    const maxWidth = getMaxWidthOption(editor);
    return parseToInt(baseWidth).map((width3) => calcCappedSize(width3, minWidth, maxWidth));
  };
  const getWidthWithFallback = (editor) => {
    const width3 = getWidth(editor);
    return width3.getOr(getWidthOption(editor));
  };
  const { ToolbarLocation, ToolbarMode } = Options;
  const maximumDistanceToEdge = 40;
  const InlineHeader = (editor, targetElm, uiRefs, backstage, floatContainer) => {
    const { mainUi, uiMotherships } = uiRefs;
    const DOM = global$7.DOM;
    const useFixedToolbarContainer = useFixedContainer(editor);
    const isSticky = isStickyToolbar(editor);
    const editorMaxWidthOpt = getMaxWidthOption(editor).or(getWidth(editor));
    const headerBackstage = backstage.shared.header;
    const isPositionedAtTop = headerBackstage.isPositionedAtTop;
    const toolbarMode = getToolbarMode(editor);
    const isSplitToolbar = toolbarMode === ToolbarMode.sliding || toolbarMode === ToolbarMode.floating;
    const visible = Cell(false);
    const isVisible3 = () => visible.get() && !editor.removed;
    const calcToolbarOffset = (toolbar) => isSplitToolbar ? toolbar.fold(constant$1(0), (tbar) => tbar.components().length > 1 ? get$d(tbar.components()[1].element) : 0) : 0;
    const calcMode = (container) => {
      switch (getToolbarLocation(editor)) {
        case ToolbarLocation.auto:
          const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);
          const offset3 = calcToolbarOffset(toolbar);
          const toolbarHeight = get$d(container.element) - offset3;
          const targetBounds = box$1(targetElm);
          const roomAtTop = targetBounds.y > toolbarHeight;
          if (roomAtTop) {
            return "top";
          } else {
            const doc = documentElement(targetElm);
            const docHeight = Math.max(doc.dom.scrollHeight, get$d(doc));
            const roomAtBottom = targetBounds.bottom < docHeight - toolbarHeight;
            if (roomAtBottom) {
              return "bottom";
            } else {
              const winBounds = win();
              const isRoomAtBottomViewport = winBounds.bottom < targetBounds.bottom - toolbarHeight;
              return isRoomAtBottomViewport ? "bottom" : "top";
            }
          }
        case ToolbarLocation.bottom:
          return "bottom";
        case ToolbarLocation.top:
        default:
          return "top";
      }
    };
    const setupMode = (mode) => {
      floatContainer.on((container) => {
        Docking.setModes(container, [mode]);
        headerBackstage.setDockingMode(mode);
        const verticalDir = isPositionedAtTop() ? AttributeValue.TopToBottom : AttributeValue.BottomToTop;
        set$9(container.element, Attribute, verticalDir);
      });
    };
    const updateChromeWidth = () => {
      floatContainer.on((container) => {
        const maxWidth = editorMaxWidthOpt.getOrThunk(() => {
          const bodyMargin = parseToInt(get$e(body(), "margin-left")).getOr(0);
          return get$c(body()) - absolute$3(targetElm).left + bodyMargin;
        });
        set$8(container.element, "max-width", maxWidth + "px");
      });
    };
    const updateChromePosition = (optToolbarWidth) => {
      floatContainer.on((container) => {
        const toolbar = OuterContainer.getToolbar(mainUi.outerContainer);
        const offset3 = calcToolbarOffset(toolbar);
        const targetBounds = box$1(targetElm);
        const { top: top3, left: left3 } = getOffsetParent$1(editor, mainUi.outerContainer.element).fold(() => {
          return {
            top: isPositionedAtTop() ? Math.max(targetBounds.y - get$d(container.element) + offset3, 0) : targetBounds.bottom,
            left: targetBounds.x
          };
        }, (offsetParent2) => {
          var _a;
          const offsetBox = box$1(offsetParent2);
          const scrollDelta = (_a = offsetParent2.dom.scrollTop) !== null && _a !== void 0 ? _a : 0;
          const isOffsetParentBody = eq(offsetParent2, body());
          const topValue = isOffsetParentBody ? Math.max(targetBounds.y - get$d(container.element) + offset3, 0) : targetBounds.y - offsetBox.y + scrollDelta - get$d(container.element) + offset3;
          return {
            top: isPositionedAtTop() ? topValue : targetBounds.bottom,
            left: isOffsetParentBody ? targetBounds.x : targetBounds.x - offsetBox.x
          };
        });
        const baseProperties = {
          position: "absolute",
          left: Math.round(left3) + "px",
          top: Math.round(top3) + "px"
        };
        const widthProperties = optToolbarWidth.map((toolbarWidth) => {
          const scroll = get$b();
          const minimumToolbarWidth = 150;
          const availableWidth = window.innerWidth - (left3 - scroll.left);
          const width3 = Math.max(Math.min(toolbarWidth, availableWidth), minimumToolbarWidth);
          return { width: width3 + "px" };
        }).getOr({});
        setAll(mainUi.outerContainer.element, {
          ...baseProperties,
          ...widthProperties
        });
      });
    };
    const getOffsetParent$1 = (editor2, element2) => isSplitUiMode(editor2) ? getOffsetParent2(element2) : Optional.none();
    const repositionPopups$1 = () => {
      each$1(uiMotherships, (m) => {
        m.broadcastOn([repositionPopups()], {});
      });
    };
    const restoreAndGetCompleteOuterContainerWidth = () => {
      if (!useFixedToolbarContainer) {
        const toolbarCurrentRightsidePosition = absolute$3(mainUi.outerContainer.element).left + getOuter$1(mainUi.outerContainer.element);
        if (toolbarCurrentRightsidePosition >= window.innerWidth - maximumDistanceToEdge || getRaw(mainUi.outerContainer.element, "width").isSome()) {
          set$8(mainUi.outerContainer.element, "position", "absolute");
          set$8(mainUi.outerContainer.element, "left", "0px");
          remove$6(mainUi.outerContainer.element, "width");
          const w = getOuter$1(mainUi.outerContainer.element);
          return Optional.some(w);
        } else {
          return Optional.none();
        }
      } else {
        return Optional.none();
      }
    };
    const update = (stickyAction) => {
      if (!isVisible3()) {
        return;
      }
      if (!useFixedToolbarContainer) {
        updateChromeWidth();
      }
      const optToolbarWidth = useFixedToolbarContainer ? Optional.none() : restoreAndGetCompleteOuterContainerWidth();
      if (isSplitToolbar) {
        OuterContainer.refreshToolbar(mainUi.outerContainer);
      }
      if (!useFixedToolbarContainer) {
        updateChromePosition(optToolbarWidth);
      }
      if (isSticky) {
        floatContainer.on(stickyAction);
      }
      repositionPopups$1();
    };
    const doUpdateMode = () => {
      if (useFixedToolbarContainer || !isSticky || !isVisible3()) {
        return false;
      }
      return floatContainer.get().exists((fc) => {
        const currentMode = headerBackstage.getDockingMode();
        const newMode = calcMode(fc);
        if (newMode !== currentMode) {
          setupMode(newMode);
          return true;
        } else {
          return false;
        }
      });
    };
    const show2 = () => {
      visible.set(true);
      set$8(mainUi.outerContainer.element, "display", "flex");
      DOM.addClass(editor.getBody(), "mce-edit-focus");
      each$1(uiMotherships, (m) => {
        remove$6(m.element, "display");
      });
      doUpdateMode();
      if (isSplitUiMode(editor)) {
        update((elem) => Docking.isDocked(elem) ? Docking.reset(elem) : Docking.refresh(elem));
      } else {
        update(Docking.refresh);
      }
    };
    const hide2 = () => {
      visible.set(false);
      set$8(mainUi.outerContainer.element, "display", "none");
      DOM.removeClass(editor.getBody(), "mce-edit-focus");
      each$1(uiMotherships, (m) => {
        set$8(m.element, "display", "none");
      });
    };
    const updateMode = () => {
      const changedMode = doUpdateMode();
      if (changedMode) {
        update(Docking.reset);
      }
    };
    return {
      isVisible: isVisible3,
      isPositionedAtTop,
      show: show2,
      hide: hide2,
      update,
      updateMode,
      repositionPopups: repositionPopups$1
    };
  };
  const getTargetPosAndBounds = (targetElm, isToolbarTop) => {
    const bounds2 = box$1(targetElm);
    return {
      pos: isToolbarTop ? bounds2.y : bounds2.bottom,
      bounds: bounds2
    };
  };
  const setupEvents = (editor, targetElm, ui, toolbarPersist) => {
    const prevPosAndBounds = Cell(getTargetPosAndBounds(targetElm, ui.isPositionedAtTop()));
    const resizeContent = (e) => {
      const { pos, bounds: bounds2 } = getTargetPosAndBounds(targetElm, ui.isPositionedAtTop());
      const {
        pos: prevPos,
        bounds: prevBounds
      } = prevPosAndBounds.get();
      const hasResized = bounds2.height !== prevBounds.height || bounds2.width !== prevBounds.width;
      prevPosAndBounds.set({
        pos,
        bounds: bounds2
      });
      if (hasResized) {
        fireResizeContent(editor, e);
      }
      if (ui.isVisible()) {
        if (prevPos !== pos) {
          ui.update(Docking.reset);
        } else if (hasResized) {
          ui.updateMode();
          ui.repositionPopups();
        }
      }
    };
    if (!toolbarPersist) {
      editor.on("activate", ui.show);
      editor.on("deactivate", ui.hide);
    }
    editor.on("SkinLoaded ResizeWindow", () => ui.update(Docking.reset));
    editor.on("NodeChange keydown", (e) => {
      requestAnimationFrame(() => resizeContent(e));
    });
    let lastScrollX = 0;
    const updateUi = last(() => ui.update(Docking.refresh), 33);
    editor.on("ScrollWindow", () => {
      const newScrollX = get$b().left;
      if (newScrollX !== lastScrollX) {
        lastScrollX = newScrollX;
        updateUi.throttle();
      }
      ui.updateMode();
    });
    if (isSplitUiMode(editor)) {
      editor.on("ElementScroll", (_args) => {
        ui.update(Docking.refresh);
      });
    }
    const elementLoad = unbindable();
    elementLoad.set(capture(SugarElement.fromDom(editor.getBody()), "load", (e) => resizeContent(e.raw)));
    editor.on("remove", () => {
      elementLoad.clear();
    });
  };
  const render = async (editor, uiRefs, rawUiConfig, backstage, args) => {
    const { mainUi } = uiRefs;
    const floatContainer = value$2();
    const targetElm = SugarElement.fromDom(args.targetNode);
    const ui = InlineHeader(editor, targetElm, uiRefs, backstage, floatContainer);
    const toolbarPersist = isToolbarPersist(editor);
    await inline(editor);
    const render2 = () => {
      if (floatContainer.isSet()) {
        ui.show();
        return;
      }
      floatContainer.set(OuterContainer.getHeader(mainUi.outerContainer).getOrDie());
      const uiContainer = getUiContainer(editor);
      if (isSplitUiMode(editor)) {
        attachSystemAfter(targetElm, mainUi.mothership);
        attachSystemAfter(targetElm, uiRefs.popupUi.mothership);
      } else {
        attachSystem(uiContainer, mainUi.mothership);
      }
      attachSystem(uiContainer, uiRefs.dialogUi.mothership);
      setToolbar(editor, uiRefs, rawUiConfig, backstage);
      OuterContainer.setMenubar(mainUi.outerContainer, identifyMenus(editor, rawUiConfig));
      ui.show();
      setupEvents(editor, targetElm, ui, toolbarPersist);
      editor.nodeChanged();
    };
    editor.on("show", render2);
    editor.on("hide", ui.hide);
    if (!toolbarPersist) {
      editor.on("focus", render2);
      editor.on("blur", ui.hide);
    }
    editor.on("init", () => {
      if (editor.hasFocus() || toolbarPersist) {
        render2();
      }
    });
    setupReadonlyModeSwitch(editor, uiRefs);
    const api2 = {
      show: render2,
      hide: ui.hide,
      setEnabled: (state2) => {
        broadcastReadonly(uiRefs, !state2);
      },
      isEnabled: () => !Disabling.isDisabled(mainUi.outerContainer)
    };
    return {
      editorContainer: mainUi.outerContainer.element.dom,
      api: api2
    };
  };
  var Inline = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    render
  });
  const LazyUiReferences = () => {
    const dialogUi = value$2();
    const popupUi = value$2();
    const mainUi = value$2();
    const lazyGetInOuterOrDie = (label2, f2) => () => mainUi.get().bind((oc) => f2(oc.outerContainer)).getOrDie(`Could not find ${label2} element in OuterContainer`);
    const getUiMotherships = () => {
      const optDialogMothership = dialogUi.get().map((ui) => ui.mothership);
      const optPopupMothership = popupUi.get().map((ui) => ui.mothership);
      return optDialogMothership.fold(() => optPopupMothership.toArray(), (dm) => optPopupMothership.fold(() => [dm], (pm) => eq(dm.element, pm.element) ? [dm] : [
        dm,
        pm
      ]));
    };
    return {
      dialogUi,
      popupUi,
      mainUi,
      getUiMotherships,
      lazyGetInOuterOrDie
    };
  };
  const showContextToolbarEvent = "contexttoolbar-show";
  const hideContextToolbarEvent = "contexttoolbar-hide";
  const getFormApi = (input2) => ({
    hide: () => emit(input2, sandboxClose()),
    getValue: () => Representing.getValue(input2)
  });
  const runOnExecute = (memInput, original2) => run$1(internalToolbarButtonExecute, (comp, se) => {
    const input2 = memInput.get(comp);
    const formApi = getFormApi(input2);
    original2.onAction(formApi, se.event.buttonApi);
  });
  const renderContextButton = (memInput, button2, providers) => {
    const { primary: primary2, ...rest } = button2.original;
    const bridged = getOrDie(createToolbarButton({
      ...rest,
      type: "button",
      onAction: noop2
    }));
    return renderToolbarButtonWith(bridged, providers, [runOnExecute(memInput, button2)]);
  };
  const renderContextToggleButton = (memInput, button2, providers) => {
    const { primary: primary2, ...rest } = button2.original;
    const bridged = getOrDie(createToggleButton({
      ...rest,
      type: "togglebutton",
      onAction: noop2
    }));
    return renderToolbarToggleButtonWith(bridged, providers, [runOnExecute(memInput, button2)]);
  };
  const isToggleButton = (button2) => button2.type === "contextformtogglebutton";
  const generateOne = (memInput, button2, providersBackstage) => {
    if (isToggleButton(button2)) {
      return renderContextToggleButton(memInput, button2, providersBackstage);
    } else {
      return renderContextButton(memInput, button2, providersBackstage);
    }
  };
  const generate = (memInput, buttons, providersBackstage) => {
    const mementos = map$2(buttons, (button2) => record(generateOne(memInput, button2, providersBackstage)));
    const asSpecs = () => map$2(mementos, (mem) => mem.asSpec());
    const findPrimary = (compInSystem) => findMap(buttons, (button2, i) => {
      if (button2.primary) {
        return Optional.from(mementos[i]).bind((mem) => mem.getOpt(compInSystem)).filter(not(Disabling.isDisabled));
      } else {
        return Optional.none();
      }
    });
    return {
      asSpecs,
      findPrimary
    };
  };
  const buildInitGroups = (ctx, providers) => {
    const inputAttributes = ctx.label.fold(() => ({}), (label2) => ({ "aria-label": label2 }));
    const memInput = record(Input.sketch({
      inputClasses: [
        "tox-toolbar-textfield",
        "tox-toolbar-nav-js"
      ],
      data: ctx.initValue(),
      inputAttributes,
      selectOnFocus: true,
      inputBehaviours: derive$1([Keying.config({
        mode: "special",
        onEnter: (input2) => commands.findPrimary(input2).map((primary2) => {
          emitExecute(primary2);
          return true;
        }),
        onLeft: (comp, se) => {
          se.cut();
          return Optional.none();
        },
        onRight: (comp, se) => {
          se.cut();
          return Optional.none();
        }
      })])
    }));
    const commands = generate(memInput, ctx.commands, providers);
    return [
      {
        title: Optional.none(),
        items: [memInput.asSpec()]
      },
      {
        title: Optional.none(),
        items: commands.asSpecs()
      }
    ];
  };
  const renderContextForm = (toolbarType, ctx, providers) => renderToolbar({
    type: toolbarType,
    uid: generate$6("context-toolbar"),
    initGroups: buildInitGroups(ctx, providers),
    onEscape: Optional.none,
    cyclicKeying: true,
    providers
  });
  const ContextForm = {
    renderContextForm,
    buildInitGroups
  };
  const isVerticalOverlap = (a, b2, threshold) => b2.bottom - a.y >= threshold && a.bottom - b2.y >= threshold;
  const getRangeRect = (rng) => {
    const rect2 = rng.getBoundingClientRect();
    if (rect2.height <= 0 && rect2.width <= 0) {
      const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset).element;
      const elm = isText(leaf$1) ? parent(leaf$1) : Optional.some(leaf$1);
      return elm.filter(isElement$12).map((e) => e.dom.getBoundingClientRect()).getOr(rect2);
    } else {
      return rect2;
    }
  };
  const getSelectionBounds = (editor) => {
    const rng = editor.selection.getRng();
    const rect2 = getRangeRect(rng);
    if (editor.inline) {
      const scroll = get$b();
      return bounds(scroll.left + rect2.left, scroll.top + rect2.top, rect2.width, rect2.height);
    } else {
      const bodyPos = absolute$2(SugarElement.fromDom(editor.getBody()));
      return bounds(bodyPos.x + rect2.left, bodyPos.y + rect2.top, rect2.width, rect2.height);
    }
  };
  const getAnchorElementBounds = (editor, lastElement) => lastElement.filter((elem) => inBody(elem) && isHTMLElement2(elem)).map(absolute$2).getOrThunk(() => getSelectionBounds(editor));
  const getHorizontalBounds = (contentAreaBox, viewportBounds, margin) => {
    const x = Math.max(contentAreaBox.x + margin, viewportBounds.x);
    const right3 = Math.min(contentAreaBox.right - margin, viewportBounds.right);
    return {
      x,
      width: right3 - x
    };
  };
  const getVerticalBounds = (editor, contentAreaBox, viewportBounds, isToolbarLocationTop, toolbarType, margin) => {
    const container = SugarElement.fromDom(editor.getContainer());
    const header = descendant(container, ".tox-editor-header").getOr(container);
    const headerBox = box$1(header);
    const isToolbarBelowContentArea = headerBox.y >= contentAreaBox.bottom;
    const isToolbarAbove = isToolbarLocationTop && !isToolbarBelowContentArea;
    if (editor.inline && isToolbarAbove) {
      return {
        y: Math.max(headerBox.bottom + margin, viewportBounds.y),
        bottom: viewportBounds.bottom
      };
    }
    if (editor.inline && !isToolbarAbove) {
      return {
        y: viewportBounds.y,
        bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
      };
    }
    const containerBounds = toolbarType === "line" ? box$1(container) : contentAreaBox;
    if (isToolbarAbove) {
      return {
        y: Math.max(headerBox.bottom + margin, viewportBounds.y),
        bottom: Math.min(containerBounds.bottom - margin, viewportBounds.bottom)
      };
    }
    return {
      y: Math.max(containerBounds.y + margin, viewportBounds.y),
      bottom: Math.min(headerBox.y - margin, viewportBounds.bottom)
    };
  };
  const getContextToolbarBounds = (editor, sharedBackstage, toolbarType, margin = 0) => {
    const viewportBounds = getBounds$3(window);
    const contentAreaBox = box$1(SugarElement.fromDom(editor.getContentAreaContainer()));
    const toolbarOrMenubarEnabled = isMenubarEnabled(editor) || isToolbarEnabled(editor) || isMultipleToolbars(editor);
    const { x, width: width3 } = getHorizontalBounds(contentAreaBox, viewportBounds, margin);
    if (editor.inline && !toolbarOrMenubarEnabled) {
      return bounds(x, viewportBounds.y, width3, viewportBounds.height);
    } else {
      const isToolbarTop = sharedBackstage.header.isPositionedAtTop();
      const { y, bottom: bottom3 } = getVerticalBounds(editor, contentAreaBox, viewportBounds, isToolbarTop, toolbarType, margin);
      return bounds(x, y, width3, bottom3 - y);
    }
  };
  const bubbleSize$1 = 12;
  const bubbleAlignments$1 = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"],
    inset: ["tox-pop--inset"]
  };
  const anchorOverrides = {
    maxHeightFunction: expandable$1(),
    maxWidthFunction: expandable()
  };
  const isEntireElementSelected = (editor, elem) => {
    const rng = editor.selection.getRng();
    const leaf$1 = leaf(SugarElement.fromDom(rng.startContainer), rng.startOffset);
    return rng.startContainer === rng.endContainer && rng.startOffset === rng.endOffset - 1 && eq(leaf$1.element, elem);
  };
  const preservePosition = (elem, position2, f2) => {
    const currentPosition = getRaw(elem, "position");
    set$8(elem, "position", position2);
    const result = f2(elem);
    currentPosition.each((pos) => set$8(elem, "position", pos));
    return result;
  };
  const shouldUseInsetLayouts = (position2) => position2 === "node";
  const determineInsetLayout = (editor, contextbar, elem, data2, bounds2) => {
    const selectionBounds = getSelectionBounds(editor);
    const isSameAnchorElement = data2.lastElement().exists((prev) => eq(elem, prev));
    if (isEntireElementSelected(editor, elem)) {
      return isSameAnchorElement ? preserve : north;
    } else if (isSameAnchorElement) {
      return preservePosition(contextbar, data2.getMode(), () => {
        const isOverlapping = isVerticalOverlap(selectionBounds, box$1(contextbar), -20);
        return isOverlapping && !data2.isReposition() ? flip2 : preserve;
      });
    } else {
      const yBounds = data2.getMode() === "fixed" ? bounds2.y + get$b().top : bounds2.y;
      const contextbarHeight = get$d(contextbar) + bubbleSize$1;
      return yBounds + contextbarHeight <= selectionBounds.y ? north : south;
    }
  };
  const getAnchorSpec$2 = (editor, mobile, data2, position2) => {
    const smartInsetLayout = (elem) => (anchor2, element2, bubbles, placee, bounds2) => {
      const layout2 = determineInsetLayout(editor, placee, elem, data2, bounds2);
      const newAnchor = {
        ...anchor2,
        y: bounds2.y,
        height: bounds2.height
      };
      return {
        ...layout2(newAnchor, element2, bubbles, placee, bounds2),
        alwaysFit: true
      };
    };
    const getInsetLayouts = (elem) => shouldUseInsetLayouts(position2) ? [smartInsetLayout(elem)] : [];
    const desktopAnchorSpecLayouts = {
      onLtr: (elem) => [
        north$2,
        south$2,
        northeast$2,
        southeast$2,
        northwest$2,
        southwest$2
      ].concat(getInsetLayouts(elem)),
      onRtl: (elem) => [
        north$2,
        south$2,
        northwest$2,
        southwest$2,
        northeast$2,
        southeast$2
      ].concat(getInsetLayouts(elem))
    };
    const mobileAnchorSpecLayouts = {
      onLtr: (elem) => [
        south$2,
        southeast$2,
        southwest$2,
        northeast$2,
        northwest$2,
        north$2
      ].concat(getInsetLayouts(elem)),
      onRtl: (elem) => [
        south$2,
        southwest$2,
        southeast$2,
        northwest$2,
        northeast$2,
        north$2
      ].concat(getInsetLayouts(elem))
    };
    return mobile ? mobileAnchorSpecLayouts : desktopAnchorSpecLayouts;
  };
  const getAnchorLayout = (editor, position2, isTouch2, data2) => {
    if (position2 === "line") {
      return {
        bubble: nu$5(bubbleSize$1, 0, bubbleAlignments$1),
        layouts: {
          onLtr: () => [east$2],
          onRtl: () => [west$2]
        },
        overrides: anchorOverrides
      };
    } else {
      return {
        bubble: nu$5(0, bubbleSize$1, bubbleAlignments$1, 1 / bubbleSize$1),
        layouts: getAnchorSpec$2(editor, isTouch2, data2, position2),
        overrides: anchorOverrides
      };
    }
  };
  const matchTargetWith = (elem, candidates) => {
    const ctxs = filter$2(candidates, (toolbarApi) => toolbarApi.predicate(elem.dom));
    const { pass, fail } = partition$3(ctxs, (t2) => t2.type === "contexttoolbar");
    return {
      contextToolbars: pass,
      contextForms: fail
    };
  };
  const filterByPositionForStartNode = (toolbars) => {
    if (toolbars.length <= 1) {
      return toolbars;
    } else {
      const doesPositionExist = (value2) => exists(toolbars, (t2) => t2.position === value2);
      const filterToolbarsByPosition = (value2) => filter$2(toolbars, (t2) => t2.position === value2);
      const hasSelectionToolbars = doesPositionExist("selection");
      const hasNodeToolbars = doesPositionExist("node");
      if (hasSelectionToolbars || hasNodeToolbars) {
        if (hasNodeToolbars && hasSelectionToolbars) {
          const nodeToolbars = filterToolbarsByPosition("node");
          const selectionToolbars = map$2(filterToolbarsByPosition("selection"), (t2) => ({
            ...t2,
            position: "node"
          }));
          return nodeToolbars.concat(selectionToolbars);
        } else {
          return hasSelectionToolbars ? filterToolbarsByPosition("selection") : filterToolbarsByPosition("node");
        }
      } else {
        return filterToolbarsByPosition("line");
      }
    }
  };
  const filterByPositionForAncestorNode = (toolbars) => {
    if (toolbars.length <= 1) {
      return toolbars;
    } else {
      const findPosition = (value2) => find$5(toolbars, (t2) => t2.position === value2);
      const basePosition = findPosition("selection").orThunk(() => findPosition("node")).orThunk(() => findPosition("line")).map((t2) => t2.position);
      return basePosition.fold(() => [], (pos) => filter$2(toolbars, (t2) => t2.position === pos));
    }
  };
  const matchStartNode = (elem, nodeCandidates, editorCandidates) => {
    const nodeMatches = matchTargetWith(elem, nodeCandidates);
    if (nodeMatches.contextForms.length > 0) {
      return Optional.some({
        elem,
        toolbars: [nodeMatches.contextForms[0]]
      });
    } else {
      const editorMatches = matchTargetWith(elem, editorCandidates);
      if (editorMatches.contextForms.length > 0) {
        return Optional.some({
          elem,
          toolbars: [editorMatches.contextForms[0]]
        });
      } else if (nodeMatches.contextToolbars.length > 0 || editorMatches.contextToolbars.length > 0) {
        const toolbars = filterByPositionForStartNode(nodeMatches.contextToolbars.concat(editorMatches.contextToolbars));
        return Optional.some({
          elem,
          toolbars
        });
      } else {
        return Optional.none();
      }
    }
  };
  const matchAncestor = (isRoot, startNode, scopes) => {
    if (isRoot(startNode)) {
      return Optional.none();
    } else {
      return ancestor$2(startNode, (ancestorElem) => {
        if (isElement$12(ancestorElem)) {
          const { contextToolbars, contextForms } = matchTargetWith(ancestorElem, scopes.inNodeScope);
          const toolbars = contextForms.length > 0 ? contextForms : filterByPositionForAncestorNode(contextToolbars);
          return toolbars.length > 0 ? Optional.some({
            elem: ancestorElem,
            toolbars
          }) : Optional.none();
        } else {
          return Optional.none();
        }
      }, isRoot);
    }
  };
  const lookup$1 = (scopes, editor) => {
    const rootElem = SugarElement.fromDom(editor.getBody());
    const isRoot = (elem) => eq(elem, rootElem);
    const isOutsideRoot = (startNode2) => !isRoot(startNode2) && !contains2(rootElem, startNode2);
    const startNode = SugarElement.fromDom(editor.selection.getNode());
    if (isOutsideRoot(startNode)) {
      return Optional.none();
    }
    return matchStartNode(startNode, scopes.inNodeScope, scopes.inEditorScope).orThunk(() => matchAncestor(isRoot, startNode, scopes));
  };
  const categorise = (contextToolbars, navigate) => {
    const forms = {};
    const inNodeScope = [];
    const inEditorScope = [];
    const formNavigators = {};
    const lookupTable = {};
    const registerForm = (key, toolbarSpec) => {
      const contextForm = getOrDie(createContextForm(toolbarSpec));
      forms[key] = contextForm;
      contextForm.launch.map((launch) => {
        formNavigators["form:" + key] = {
          ...toolbarSpec.launch,
          type: launch.type === "contextformtogglebutton" ? "togglebutton" : "button",
          onAction: () => {
            navigate(contextForm);
          }
        };
      });
      if (contextForm.scope === "editor") {
        inEditorScope.push(contextForm);
      } else {
        inNodeScope.push(contextForm);
      }
      lookupTable[key] = contextForm;
    };
    const registerToolbar = (key, toolbarSpec) => {
      createContextToolbar(toolbarSpec).each((contextToolbar) => {
        if (toolbarSpec.scope === "editor") {
          inEditorScope.push(contextToolbar);
        } else {
          inNodeScope.push(contextToolbar);
        }
        lookupTable[key] = contextToolbar;
      });
    };
    const keys$1 = keys(contextToolbars);
    each$1(keys$1, (key) => {
      const toolbarApi = contextToolbars[key];
      if (toolbarApi.type === "contextform") {
        registerForm(key, toolbarApi);
      } else if (toolbarApi.type === "contexttoolbar") {
        registerToolbar(key, toolbarApi);
      }
    });
    return {
      forms,
      inNodeScope,
      inEditorScope,
      lookupTable,
      formNavigators
    };
  };
  const forwardSlideEvent = generate$6("forward-slide");
  const backSlideEvent = generate$6("backward-slide");
  const changeSlideEvent = generate$6("change-slide-event");
  const resizingClass = "tox-pop--resizing";
  const renderContextToolbar = (spec) => {
    const stack = Cell([]);
    return InlineView.sketch({
      dom: {
        tag: "div",
        classes: ["tox-pop"]
      },
      fireDismissalEventInstead: { event: "doNotDismissYet" },
      onShow: (comp) => {
        stack.set([]);
        InlineView.getContent(comp).each((c) => {
          remove$6(c.element, "visibility");
        });
        remove$2(comp.element, resizingClass);
        remove$6(comp.element, "width");
      },
      inlineBehaviours: derive$1([
        config("context-toolbar-events", [
          runOnSource(transitionend(), (comp, se) => {
            if (se.event.raw.propertyName === "width") {
              remove$2(comp.element, resizingClass);
              remove$6(comp.element, "width");
            }
          }),
          run$1(changeSlideEvent, (comp, se) => {
            const elem = comp.element;
            remove$6(elem, "width");
            const currentWidth = get$c(elem);
            InlineView.setContent(comp, se.event.contents);
            add$2(elem, resizingClass);
            const newWidth = get$c(elem);
            set$8(elem, "width", currentWidth + "px");
            InlineView.getContent(comp).each((newContents) => {
              se.event.focus.bind((f2) => {
                focus$3(f2);
                return search(elem);
              }).orThunk(() => {
                Keying.focusIn(newContents);
                return active$1(getRootNode2(elem));
              });
            });
            setTimeout(() => {
              set$8(comp.element, "width", newWidth + "px");
            }, 0);
          }),
          run$1(forwardSlideEvent, (comp, se) => {
            InlineView.getContent(comp).each((oldContents) => {
              stack.set(stack.get().concat([{
                bar: oldContents,
                focus: active$1(getRootNode2(comp.element))
              }]));
            });
            emitWith(comp, changeSlideEvent, {
              contents: se.event.forwardContents,
              focus: Optional.none()
            });
          }),
          run$1(backSlideEvent, (comp, _se) => {
            last$1(stack.get()).each((last2) => {
              stack.set(stack.get().slice(0, stack.get().length - 1));
              emitWith(comp, changeSlideEvent, {
                contents: premade(last2.bar),
                focus: last2.focus
              });
            });
          })
        ]),
        Keying.config({
          mode: "special",
          onEscape: (comp) => last$1(stack.get()).fold(() => spec.onEscape(), (_2) => {
            emit(comp, backSlideEvent);
            return Optional.some(true);
          })
        })
      ]),
      lazySink: () => Result.value(spec.sink)
    });
  };
  const transitionClass = "tox-pop--transition";
  const register$9 = (editor, registryContextToolbars, sink, extras) => {
    const backstage = extras.backstage;
    const sharedBackstage = backstage.shared;
    const isTouch2 = detect$2().deviceType.isTouch;
    const lastElement = value$2();
    const lastTrigger = value$2();
    const lastContextPosition = value$2();
    const contextbar = build$1(renderContextToolbar({
      sink,
      onEscape: () => {
        editor.focus();
        return Optional.some(true);
      }
    }));
    const getBounds2 = () => {
      const position2 = lastContextPosition.get().getOr("node");
      const margin = shouldUseInsetLayouts(position2) ? 1 : 0;
      return getContextToolbarBounds(editor, sharedBackstage, position2, margin);
    };
    const canLaunchToolbar = () => {
      return !editor.removed && !(isTouch2() && backstage.isContextMenuOpen());
    };
    const isSameLaunchElement = (elem) => is$1(lift2(elem, lastElement.get(), eq), true);
    const shouldContextToolbarHide = () => {
      if (!canLaunchToolbar()) {
        return true;
      } else {
        const contextToolbarBounds = getBounds2();
        const anchorBounds = is$1(lastContextPosition.get(), "node") ? getAnchorElementBounds(editor, lastElement.get()) : getSelectionBounds(editor);
        return contextToolbarBounds.height <= 0 || !isVerticalOverlap(anchorBounds, contextToolbarBounds, 0.01);
      }
    };
    const close2 = () => {
      lastElement.clear();
      lastTrigger.clear();
      lastContextPosition.clear();
      InlineView.hide(contextbar);
    };
    const hideOrRepositionIfNecessary = () => {
      if (InlineView.isOpen(contextbar)) {
        const contextBarEle = contextbar.element;
        remove$6(contextBarEle, "display");
        if (shouldContextToolbarHide()) {
          set$8(contextBarEle, "display", "none");
        } else {
          lastTrigger.set(0);
          InlineView.reposition(contextbar);
        }
      }
    };
    const wrapInPopDialog = (toolbarSpec) => ({
      dom: {
        tag: "div",
        classes: ["tox-pop__dialog"]
      },
      components: [toolbarSpec],
      behaviours: derive$1([
        Keying.config({ mode: "acyclic" }),
        config("pop-dialog-wrap-events", [
          runOnAttached((comp) => {
            editor.shortcuts.add("ctrl+F9", "focus statusbar", () => Keying.focusIn(comp));
          }),
          runOnDetached((_comp) => {
            editor.shortcuts.remove("ctrl+F9");
          })
        ])
      ])
    });
    const getScopes = cached(() => categorise(registryContextToolbars, (toolbarApi) => {
      const alloySpec = buildToolbar([toolbarApi]);
      emitWith(contextbar, forwardSlideEvent, { forwardContents: wrapInPopDialog(alloySpec) });
    }));
    const buildContextToolbarGroups = (allButtons, ctx) => identifyButtons(editor, {
      buttons: allButtons,
      toolbar: ctx.items,
      allowToolbarGroups: false
    }, extras.backstage, Optional.some(["form:"]));
    const buildContextFormGroups = (ctx, providers) => ContextForm.buildInitGroups(ctx, providers);
    const buildToolbar = (toolbars) => {
      const { buttons } = editor.ui.registry.getAll();
      const scopes = getScopes();
      const allButtons = {
        ...buttons,
        ...scopes.formNavigators
      };
      const toolbarType = getToolbarMode(editor) === ToolbarMode$1.scrolling ? ToolbarMode$1.scrolling : ToolbarMode$1.default;
      const initGroups = flatten(map$2(toolbars, (ctx) => ctx.type === "contexttoolbar" ? buildContextToolbarGroups(allButtons, ctx) : buildContextFormGroups(ctx, sharedBackstage.providers)));
      return renderToolbar({
        type: toolbarType,
        uid: generate$6("context-toolbar"),
        initGroups,
        onEscape: Optional.none,
        cyclicKeying: true,
        providers: sharedBackstage.providers
      });
    };
    const getAnchor2 = (position2, element2) => {
      const anchorage = position2 === "node" ? sharedBackstage.anchors.node(element2) : sharedBackstage.anchors.cursor();
      const anchorLayout = getAnchorLayout(editor, position2, isTouch2(), {
        lastElement: lastElement.get,
        isReposition: () => is$1(lastTrigger.get(), 0),
        getMode: () => Positioning.getMode(sink)
      });
      return deepMerge(anchorage, anchorLayout);
    };
    const launchContext = (toolbarApi, elem) => {
      launchContextToolbar.cancel();
      if (!canLaunchToolbar()) {
        return;
      }
      const toolbarSpec = buildToolbar(toolbarApi);
      const position2 = toolbarApi[0].position;
      const anchor2 = getAnchor2(position2, elem);
      lastContextPosition.set(position2);
      lastTrigger.set(1);
      const contextBarEle = contextbar.element;
      remove$6(contextBarEle, "display");
      if (!isSameLaunchElement(elem)) {
        remove$2(contextBarEle, transitionClass);
        Positioning.reset(sink, contextbar);
      }
      InlineView.showWithinBounds(contextbar, wrapInPopDialog(toolbarSpec), {
        anchor: anchor2,
        transition: {
          classes: [transitionClass],
          mode: "placement"
        }
      }, () => Optional.some(getBounds2()));
      elem.fold(lastElement.clear, lastElement.set);
      if (shouldContextToolbarHide()) {
        set$8(contextBarEle, "display", "none");
      }
    };
    let isDragging = false;
    const launchContextToolbar = last(() => {
      if (!editor.hasFocus() || editor.removed || isDragging) {
        return;
      }
      if (has(contextbar.element, transitionClass)) {
        launchContextToolbar.throttle();
      } else {
        const scopes = getScopes();
        lookup$1(scopes, editor).fold(close2, (info) => {
          launchContext(info.toolbars, Optional.some(info.elem));
        });
      }
    }, 17);
    editor.on("init", () => {
      editor.on("remove", close2);
      editor.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", hideOrRepositionIfNecessary);
      editor.on("click keyup focus SetContent", launchContextToolbar.throttle);
      editor.on(hideContextToolbarEvent, close2);
      editor.on(showContextToolbarEvent, (e) => {
        const scopes = getScopes();
        get$g(scopes.lookupTable, e.toolbarKey).each((ctx) => {
          launchContext([ctx], someIf(e.target !== editor, e.target));
          InlineView.getContent(contextbar).each(Keying.focusIn);
        });
      });
      editor.on("focusout", (_e) => {
        global$9.setEditorTimeout(editor, () => {
          if (search(sink.element).isNone() && search(contextbar.element).isNone()) {
            close2();
          }
        }, 0);
      });
      editor.on("SwitchMode", () => {
        if (editor.mode.isReadOnly()) {
          close2();
        }
      });
      editor.on("AfterProgressState", (event) => {
        if (event.state) {
          close2();
        } else if (editor.hasFocus()) {
          launchContextToolbar.throttle();
        }
      });
      editor.on("dragstart", () => {
        isDragging = true;
      });
      editor.on("dragend drop", () => {
        isDragging = false;
      });
      editor.on("NodeChange", (_e) => {
        search(contextbar.element).fold(launchContextToolbar.throttle, noop2);
      });
    });
  };
  const register$8 = (editor) => {
    const alignToolbarButtons = [
      {
        name: "alignleft",
        text: "Align left",
        cmd: "JustifyLeft",
        icon: "align-left"
      },
      {
        name: "aligncenter",
        text: "Align center",
        cmd: "JustifyCenter",
        icon: "align-center"
      },
      {
        name: "alignright",
        text: "Align right",
        cmd: "JustifyRight",
        icon: "align-right"
      },
      {
        name: "alignjustify",
        text: "Justify",
        cmd: "JustifyFull",
        icon: "align-justify"
      }
    ];
    each$1(alignToolbarButtons, (item3) => {
      editor.ui.registry.addToggleButton(item3.name, {
        tooltip: item3.text,
        icon: item3.icon,
        onAction: onActionExecCommand(editor, item3.cmd),
        onSetup: onSetupFormatToggle(editor, item3.name)
      });
    });
    editor.ui.registry.addButton("alignnone", {
      tooltip: "No alignment",
      icon: "align-none",
      onAction: onActionExecCommand(editor, "JustifyNone")
    });
  };
  const registerController = (editor, spec) => {
    const getMenuItems = () => {
      const options = spec.getOptions(editor);
      const initial = spec.getCurrent(editor).map(spec.hash);
      const current = value$2();
      return map$2(options, (value2) => ({
        type: "togglemenuitem",
        text: spec.display(value2),
        onSetup: (api2) => {
          const setActive = (active2) => {
            if (active2) {
              current.on((oldApi) => oldApi.setActive(false));
              current.set(api2);
            }
            api2.setActive(active2);
          };
          setActive(is$1(initial, spec.hash(value2)));
          const unbindWatcher = spec.watcher(editor, value2, setActive);
          return () => {
            current.clear();
            unbindWatcher();
          };
        },
        onAction: () => spec.setCurrent(editor, value2)
      }));
    };
    editor.ui.registry.addMenuButton(spec.name, {
      tooltip: spec.text,
      icon: spec.icon,
      fetch: (callback) => callback(getMenuItems()),
      onSetup: spec.onToolbarSetup
    });
    editor.ui.registry.addNestedMenuItem(spec.name, {
      type: "nestedmenuitem",
      text: spec.text,
      getSubmenuItems: getMenuItems,
      onSetup: spec.onMenuSetup
    });
  };
  const lineHeightSpec = {
    name: "lineheight",
    text: "Line height",
    icon: "line-height",
    getOptions: getLineHeightFormats,
    hash: (input2) => normalise(input2, [
      "fixed",
      "relative",
      "empty"
    ]).getOr(input2),
    display: identity,
    watcher: (editor, value2, callback) => editor.formatter.formatChanged("lineheight", callback, false, { value: value2 }).unbind,
    getCurrent: (editor) => Optional.from(editor.queryCommandValue("LineHeight")),
    setCurrent: (editor, value2) => editor.execCommand("LineHeight", false, value2)
  };
  const languageSpec = (editor) => {
    const settingsOpt = Optional.from(getContentLanguages(editor));
    return settingsOpt.map((settings) => ({
      name: "language",
      text: "Language",
      icon: "language",
      getOptions: constant$1(settings),
      hash: (input2) => isUndefined2(input2.customCode) ? input2.code : `${input2.code}/${input2.customCode}`,
      display: (input2) => input2.title,
      watcher: (editor2, value2, callback) => {
        var _a;
        return editor2.formatter.formatChanged("lang", callback, false, {
          value: value2.code,
          customValue: (_a = value2.customCode) !== null && _a !== void 0 ? _a : null
        }).unbind;
      },
      getCurrent: (editor2) => {
        const node = SugarElement.fromDom(editor2.selection.getNode());
        return closest$4(node, (n) => Optional.some(n).filter(isElement$12).bind((ele) => {
          const codeOpt = getOpt(ele, "lang");
          return codeOpt.map((code) => {
            const customCode = getOpt(ele, "data-mce-lang").getOrUndefined();
            return {
              code,
              customCode,
              title: ""
            };
          });
        }));
      },
      setCurrent: (editor2, lang) => editor2.execCommand("Lang", false, lang),
      onToolbarSetup: (api2) => {
        const unbinder = unbindable();
        api2.setActive(editor.formatter.match("lang", {}, void 0, true));
        unbinder.set(editor.formatter.formatChanged("lang", api2.setActive, true));
        return unbinder.clear;
      }
    }));
  };
  const register$7 = (editor) => {
    registerController(editor, lineHeightSpec);
    languageSpec(editor).each((spec) => registerController(editor, spec));
  };
  const register$6 = (editor, backstage) => {
    createAlignMenu(editor, backstage);
    createFontFamilyMenu(editor, backstage);
    createStylesMenu(editor, backstage);
    createBlocksMenu(editor, backstage);
    createFontSizeMenu(editor, backstage);
  };
  const onSetupOutdentState = (editor) => onSetupEvent(editor, "NodeChange", (api2) => {
    api2.setEnabled(editor.queryCommandState("outdent"));
  });
  const registerButtons$2 = (editor) => {
    editor.ui.registry.addButton("outdent", {
      tooltip: "Decrease indent",
      icon: "outdent",
      onSetup: onSetupOutdentState(editor),
      onAction: onActionExecCommand(editor, "outdent")
    });
    editor.ui.registry.addButton("indent", {
      tooltip: "Increase indent",
      icon: "indent",
      onAction: onActionExecCommand(editor, "indent")
    });
  };
  const register$5 = (editor) => {
    registerButtons$2(editor);
  };
  const makeSetupHandler = (editor, pasteAsText) => (api2) => {
    api2.setActive(pasteAsText.get());
    const pastePlainTextToggleHandler = (e) => {
      pasteAsText.set(e.state);
      api2.setActive(e.state);
    };
    editor.on("PastePlainTextToggle", pastePlainTextToggleHandler);
    return () => editor.off("PastePlainTextToggle", pastePlainTextToggleHandler);
  };
  const register$4 = (editor) => {
    const pasteAsText = Cell(getPasteAsText(editor));
    const onAction2 = () => editor.execCommand("mceTogglePlainTextPaste");
    editor.ui.registry.addToggleButton("pastetext", {
      active: false,
      icon: "paste-text",
      tooltip: "Paste as text",
      onAction: onAction2,
      onSetup: makeSetupHandler(editor, pasteAsText)
    });
    editor.ui.registry.addToggleMenuItem("pastetext", {
      text: "Paste as text",
      icon: "paste-text",
      onAction: onAction2,
      onSetup: makeSetupHandler(editor, pasteAsText)
    });
  };
  const onActionToggleFormat = (editor, fmt) => () => {
    editor.execCommand("mceToggleFormat", false, fmt);
  };
  const registerFormatButtons = (editor) => {
    global$1.each([
      {
        name: "bold",
        text: "Bold",
        icon: "bold"
      },
      {
        name: "italic",
        text: "Italic",
        icon: "italic"
      },
      {
        name: "underline",
        text: "Underline",
        icon: "underline"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        icon: "superscript"
      }
    ], (btn, _idx) => {
      editor.ui.registry.addToggleButton(btn.name, {
        tooltip: btn.text,
        icon: btn.icon,
        onSetup: onSetupFormatToggle(editor, btn.name),
        onAction: onActionToggleFormat(editor, btn.name)
      });
    });
    for (let i = 1; i <= 6; i++) {
      const name3 = "h" + i;
      editor.ui.registry.addToggleButton(name3, {
        text: name3.toUpperCase(),
        tooltip: "Heading " + i,
        onSetup: onSetupFormatToggle(editor, name3),
        onAction: onActionToggleFormat(editor, name3)
      });
    }
  };
  const registerCommandButtons = (editor) => {
    global$1.each([
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste"
      },
      {
        name: "help",
        text: "Help",
        action: "mceHelp",
        icon: "help"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "remove",
        text: "Remove",
        action: "Delete",
        icon: "remove"
      },
      {
        name: "print",
        text: "Print",
        action: "mcePrint",
        icon: "print"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (btn) => {
      editor.ui.registry.addButton(btn.name, {
        tooltip: btn.text,
        icon: btn.icon,
        onAction: onActionExecCommand(editor, btn.action)
      });
    });
  };
  const registerCommandToggleButtons = (editor) => {
    global$1.each([{
      name: "blockquote",
      text: "Blockquote",
      action: "mceBlockQuote",
      icon: "quote"
    }], (btn) => {
      editor.ui.registry.addToggleButton(btn.name, {
        tooltip: btn.text,
        icon: btn.icon,
        onAction: onActionExecCommand(editor, btn.action),
        onSetup: onSetupFormatToggle(editor, btn.name)
      });
    });
  };
  const registerButtons$1 = (editor) => {
    registerFormatButtons(editor);
    registerCommandButtons(editor);
    registerCommandToggleButtons(editor);
  };
  const registerMenuItems$2 = (editor) => {
    global$1.each([
      {
        name: "bold",
        text: "Bold",
        action: "Bold",
        icon: "bold",
        shortcut: "Meta+B"
      },
      {
        name: "italic",
        text: "Italic",
        action: "Italic",
        icon: "italic",
        shortcut: "Meta+I"
      },
      {
        name: "underline",
        text: "Underline",
        action: "Underline",
        icon: "underline",
        shortcut: "Meta+U"
      },
      {
        name: "strikethrough",
        text: "Strikethrough",
        action: "Strikethrough",
        icon: "strike-through"
      },
      {
        name: "subscript",
        text: "Subscript",
        action: "Subscript",
        icon: "subscript"
      },
      {
        name: "superscript",
        text: "Superscript",
        action: "Superscript",
        icon: "superscript"
      },
      {
        name: "removeformat",
        text: "Clear formatting",
        action: "RemoveFormat",
        icon: "remove-formatting"
      },
      {
        name: "newdocument",
        text: "New document",
        action: "mceNewDocument",
        icon: "new-document"
      },
      {
        name: "cut",
        text: "Cut",
        action: "Cut",
        icon: "cut",
        shortcut: "Meta+X"
      },
      {
        name: "copy",
        text: "Copy",
        action: "Copy",
        icon: "copy",
        shortcut: "Meta+C"
      },
      {
        name: "paste",
        text: "Paste",
        action: "Paste",
        icon: "paste",
        shortcut: "Meta+V"
      },
      {
        name: "selectall",
        text: "Select all",
        action: "SelectAll",
        icon: "select-all",
        shortcut: "Meta+A"
      },
      {
        name: "print",
        text: "Print...",
        action: "mcePrint",
        icon: "print",
        shortcut: "Meta+P"
      },
      {
        name: "hr",
        text: "Horizontal line",
        action: "InsertHorizontalRule",
        icon: "horizontal-rule"
      }
    ], (menuitem) => {
      editor.ui.registry.addMenuItem(menuitem.name, {
        text: menuitem.text,
        icon: menuitem.icon,
        shortcut: menuitem.shortcut,
        onAction: onActionExecCommand(editor, menuitem.action)
      });
    });
    editor.ui.registry.addMenuItem("codeformat", {
      text: "Code",
      icon: "sourcecode",
      onAction: onActionToggleFormat(editor, "code")
    });
  };
  const register$3 = (editor) => {
    registerButtons$1(editor);
    registerMenuItems$2(editor);
  };
  const onSetupUndoRedoState = (editor, type2) => onSetupEvent(editor, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (api2) => {
    api2.setEnabled(!editor.mode.isReadOnly() && editor.undoManager[type2]());
  });
  const registerMenuItems$1 = (editor) => {
    editor.ui.registry.addMenuItem("undo", {
      text: "Undo",
      icon: "undo",
      shortcut: "Meta+Z",
      onSetup: onSetupUndoRedoState(editor, "hasUndo"),
      onAction: onActionExecCommand(editor, "undo")
    });
    editor.ui.registry.addMenuItem("redo", {
      text: "Redo",
      icon: "redo",
      shortcut: "Meta+Y",
      onSetup: onSetupUndoRedoState(editor, "hasRedo"),
      onAction: onActionExecCommand(editor, "redo")
    });
  };
  const registerButtons = (editor) => {
    editor.ui.registry.addButton("undo", {
      tooltip: "Undo",
      icon: "undo",
      enabled: false,
      onSetup: onSetupUndoRedoState(editor, "hasUndo"),
      onAction: onActionExecCommand(editor, "undo")
    });
    editor.ui.registry.addButton("redo", {
      tooltip: "Redo",
      icon: "redo",
      enabled: false,
      onSetup: onSetupUndoRedoState(editor, "hasRedo"),
      onAction: onActionExecCommand(editor, "redo")
    });
  };
  const register$2 = (editor) => {
    registerMenuItems$1(editor);
    registerButtons(editor);
  };
  const onSetupVisualAidState = (editor) => onSetupEvent(editor, "VisualAid", (api2) => {
    api2.setActive(editor.hasVisual);
  });
  const registerMenuItems = (editor) => {
    editor.ui.registry.addToggleMenuItem("visualaid", {
      text: "Visual aids",
      onSetup: onSetupVisualAidState(editor),
      onAction: onActionExecCommand(editor, "mceToggleVisualAid")
    });
  };
  const registerToolbarButton = (editor) => {
    editor.ui.registry.addButton("visualaid", {
      tooltip: "Visual aids",
      text: "Visual aids",
      onAction: onActionExecCommand(editor, "mceToggleVisualAid")
    });
  };
  const register$1 = (editor) => {
    registerToolbarButton(editor);
    registerMenuItems(editor);
  };
  const setup$6 = (editor, backstage) => {
    register$8(editor);
    register$3(editor);
    register$6(editor, backstage);
    register$2(editor);
    register$c(editor);
    register$1(editor);
    register$5(editor);
    register$7(editor);
    register$4(editor);
  };
  const patchPipeConfig = (config2) => isString2(config2) ? config2.split(/[ ,]/) : config2;
  const option2 = (name3) => (editor) => editor.options.get(name3);
  const register = (editor) => {
    const registerOption = editor.options.register;
    registerOption("contextmenu_avoid_overlap", {
      processor: "string",
      default: ""
    });
    registerOption("contextmenu_never_use_native", {
      processor: "boolean",
      default: false
    });
    registerOption("contextmenu", {
      processor: (value2) => {
        if (value2 === false) {
          return {
            value: [],
            valid: true
          };
        } else if (isString2(value2) || isArrayOf(value2, isString2)) {
          return {
            value: patchPipeConfig(value2),
            valid: true
          };
        } else {
          return {
            valid: false,
            message: "Must be false or a string."
          };
        }
      },
      default: "link linkchecker image editimage table spellchecker configurepermanentpen"
    });
  };
  const shouldNeverUseNative = option2("contextmenu_never_use_native");
  const getAvoidOverlapSelector = option2("contextmenu_avoid_overlap");
  const isContextMenuDisabled = (editor) => getContextMenu(editor).length === 0;
  const getContextMenu = (editor) => {
    const contextMenus = editor.ui.registry.getAll().contextMenus;
    const contextMenu = editor.options.get("contextmenu");
    if (editor.options.isSet("contextmenu")) {
      return contextMenu;
    } else {
      return filter$2(contextMenu, (item3) => has$2(contextMenus, item3));
    }
  };
  const nu = (x, y) => ({
    type: "makeshift",
    x,
    y
  });
  const transpose = (pos, dx, dy) => {
    return nu(pos.x + dx, pos.y + dy);
  };
  const isTouchEvent$1 = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0;
  const fromPageXY = (e) => {
    if (isTouchEvent$1(e)) {
      const touch2 = e.touches[0];
      return nu(touch2.pageX, touch2.pageY);
    } else {
      return nu(e.pageX, e.pageY);
    }
  };
  const fromClientXY = (e) => {
    if (isTouchEvent$1(e)) {
      const touch2 = e.touches[0];
      return nu(touch2.clientX, touch2.clientY);
    } else {
      return nu(e.clientX, e.clientY);
    }
  };
  const transposeContentAreaContainer = (element2, pos) => {
    const containerPos = global$7.DOM.getPos(element2);
    return transpose(pos, containerPos.x, containerPos.y);
  };
  const getPointAnchor = (editor, e) => {
    if (e.type === "contextmenu" || e.type === "longpress") {
      if (editor.inline) {
        return fromPageXY(e);
      } else {
        return transposeContentAreaContainer(editor.getContentAreaContainer(), fromClientXY(e));
      }
    } else {
      return getSelectionAnchor(editor);
    }
  };
  const getSelectionAnchor = (editor) => {
    return {
      type: "selection",
      root: SugarElement.fromDom(editor.selection.getNode())
    };
  };
  const getNodeAnchor = (editor) => ({
    type: "node",
    node: Optional.some(SugarElement.fromDom(editor.selection.getNode())),
    root: SugarElement.fromDom(editor.getBody())
  });
  const getAnchorSpec$1 = (editor, e, anchorType) => {
    switch (anchorType) {
      case "node":
        return getNodeAnchor(editor);
      case "point":
        return getPointAnchor(editor, e);
      case "selection":
        return getSelectionAnchor(editor);
    }
  };
  const initAndShow$1 = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
    const items = buildMenu();
    const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
    build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
      isHorizontalMenu: false,
      search: Optional.none()
    }).map((menuData) => {
      e.preventDefault();
      InlineView.showMenuAt(contextmenu, { anchor: anchorSpec }, {
        menu: { markers: markers("normal") },
        data: menuData
      });
    });
  };
  const layouts = {
    onLtr: () => [
      south$2,
      southeast$2,
      southwest$2,
      northeast$2,
      northwest$2,
      north$2,
      north,
      south,
      northeast,
      southeast,
      northwest,
      southwest
    ],
    onRtl: () => [
      south$2,
      southwest$2,
      southeast$2,
      northwest$2,
      northeast$2,
      north$2,
      north,
      south,
      northwest,
      southwest,
      northeast,
      southeast
    ]
  };
  const bubbleSize = 12;
  const bubbleAlignments = {
    valignCentre: [],
    alignCentre: [],
    alignLeft: ["tox-pop--align-left"],
    alignRight: ["tox-pop--align-right"],
    right: ["tox-pop--right"],
    left: ["tox-pop--left"],
    bottom: ["tox-pop--bottom"],
    top: ["tox-pop--top"]
  };
  const isTouchWithinSelection = (editor, e) => {
    const selection = editor.selection;
    if (selection.isCollapsed() || e.touches.length < 1) {
      return false;
    } else {
      const touch2 = e.touches[0];
      const rng = selection.getRng();
      const rngRectOpt = getFirstRect(editor.getWin(), SimSelection.domRange(rng));
      return rngRectOpt.exists((rngRect) => rngRect.left <= touch2.clientX && rngRect.right >= touch2.clientX && rngRect.top <= touch2.clientY && rngRect.bottom >= touch2.clientY);
    }
  };
  const setupiOSOverrides = (editor) => {
    const originalSelection = editor.selection.getRng();
    const selectionReset = () => {
      global$9.setEditorTimeout(editor, () => {
        editor.selection.setRng(originalSelection);
      }, 10);
      unbindEventListeners();
    };
    editor.once("touchend", selectionReset);
    const preventMousedown = (e) => {
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    editor.on("mousedown", preventMousedown, true);
    const clearSelectionReset = () => unbindEventListeners();
    editor.once("longpresscancel", clearSelectionReset);
    const unbindEventListeners = () => {
      editor.off("touchend", selectionReset);
      editor.off("longpresscancel", clearSelectionReset);
      editor.off("mousedown", preventMousedown);
    };
  };
  const getAnchorSpec = (editor, e, anchorType) => {
    const anchorSpec = getAnchorSpec$1(editor, e, anchorType);
    const bubbleYOffset = anchorType === "point" ? bubbleSize : 0;
    return {
      bubble: nu$5(0, bubbleYOffset, bubbleAlignments),
      layouts,
      overrides: {
        maxWidthFunction: expandable(),
        maxHeightFunction: expandable$1()
      },
      ...anchorSpec
    };
  };
  const show = (editor, e, items, backstage, contextmenu, anchorType, highlightImmediately) => {
    const anchorSpec = getAnchorSpec(editor, e, anchorType);
    build(items, ItemResponse$1.CLOSE_ON_EXECUTE, backstage, {
      isHorizontalMenu: true,
      search: Optional.none()
    }).map((menuData) => {
      e.preventDefault();
      const highlightOnOpen = highlightImmediately ? HighlightOnOpen.HighlightMenuAndItem : HighlightOnOpen.HighlightNone;
      InlineView.showMenuWithinBounds(contextmenu, { anchor: anchorSpec }, {
        menu: {
          markers: markers("normal"),
          highlightOnOpen
        },
        data: menuData,
        type: "horizontal"
      }, () => Optional.some(getContextToolbarBounds(editor, backstage.shared, anchorType === "node" ? "node" : "selection")));
      editor.dispatch(hideContextToolbarEvent);
    });
  };
  const initAndShow = (editor, e, buildMenu, backstage, contextmenu, anchorType) => {
    const detection2 = detect$2();
    const isiOS = detection2.os.isiOS();
    const isMacOS = detection2.os.isMacOS();
    const isAndroid = detection2.os.isAndroid();
    const isTouch2 = detection2.deviceType.isTouch();
    const shouldHighlightImmediately = () => !(isAndroid || isiOS || isMacOS && isTouch2);
    const open2 = () => {
      const items = buildMenu();
      show(editor, e, items, backstage, contextmenu, anchorType, shouldHighlightImmediately());
    };
    if ((isMacOS || isiOS) && anchorType !== "node") {
      const openiOS = () => {
        setupiOSOverrides(editor);
        open2();
      };
      if (isTouchWithinSelection(editor, e)) {
        openiOS();
      } else {
        editor.once("selectionchange", openiOS);
        editor.once("touchend", () => editor.off("selectionchange", openiOS));
      }
    } else {
      open2();
    }
  };
  const isSeparator = (item3) => isString2(item3) ? item3 === "|" : item3.type === "separator";
  const separator = { type: "separator" };
  const makeContextItem = (item3) => {
    const commonMenuItem = (item4) => ({
      text: item4.text,
      icon: item4.icon,
      enabled: item4.enabled,
      shortcut: item4.shortcut
    });
    if (isString2(item3)) {
      return item3;
    } else {
      switch (item3.type) {
        case "separator":
          return separator;
        case "submenu":
          return {
            type: "nestedmenuitem",
            ...commonMenuItem(item3),
            getSubmenuItems: () => {
              const items = item3.getSubmenuItems();
              if (isString2(items)) {
                return items;
              } else {
                return map$2(items, makeContextItem);
              }
            }
          };
        default:
          const commonItem = item3;
          return {
            type: "menuitem",
            ...commonMenuItem(commonItem),
            onAction: noarg(commonItem.onAction)
          };
      }
    }
  };
  const addContextMenuGroup = (xs, groupItems) => {
    if (groupItems.length === 0) {
      return xs;
    }
    const lastMenuItem = last$1(xs).filter((item3) => !isSeparator(item3));
    const before2 = lastMenuItem.fold(() => [], (_2) => [separator]);
    return xs.concat(before2).concat(groupItems).concat([separator]);
  };
  const generateContextMenu = (contextMenus, menuConfig, selectedElement) => {
    const sections = foldl(menuConfig, (acc, name3) => {
      return get$g(contextMenus, name3.toLowerCase()).map((menu2) => {
        const items = menu2.update(selectedElement);
        if (isString2(items)) {
          return addContextMenuGroup(acc, items.split(" "));
        } else if (items.length > 0) {
          const allItems = map$2(items, makeContextItem);
          return addContextMenuGroup(acc, allItems);
        } else {
          return acc;
        }
      }).getOrThunk(() => acc.concat([name3]));
    }, []);
    if (sections.length > 0 && isSeparator(sections[sections.length - 1])) {
      sections.pop();
    }
    return sections;
  };
  const isNativeOverrideKeyEvent = (editor, e) => e.ctrlKey && !shouldNeverUseNative(editor);
  const isTouchEvent = (e) => e.type === "longpress" || has$2(e, "touches");
  const isTriggeredByKeyboard = (editor, e) => !isTouchEvent(e) && (e.button !== 2 || e.target === editor.getBody() && e.pointerType === "");
  const getSelectedElement = (editor, e) => isTriggeredByKeyboard(editor, e) ? editor.selection.getStart(true) : e.target;
  const getAnchorType = (editor, e) => {
    const selector = getAvoidOverlapSelector(editor);
    const anchorType = isTriggeredByKeyboard(editor, e) ? "selection" : "point";
    if (isNotEmpty(selector)) {
      const target = getSelectedElement(editor, e);
      const selectorExists = closest(SugarElement.fromDom(target), selector);
      return selectorExists ? "node" : anchorType;
    } else {
      return anchorType;
    }
  };
  const setup$5 = (editor, lazySink, backstage) => {
    const detection2 = detect$2();
    const isTouch2 = detection2.deviceType.isTouch;
    const contextmenu = build$1(InlineView.sketch({
      dom: { tag: "div" },
      lazySink,
      onEscape: () => editor.focus(),
      onShow: () => backstage.setContextMenuState(true),
      onHide: () => backstage.setContextMenuState(false),
      fireDismissalEventInstead: {},
      inlineBehaviours: derive$1([config("dismissContextMenu", [run$1(dismissRequested(), (comp, _se) => {
        Sandboxing.close(comp);
        editor.focus();
      })])])
    }));
    const hideContextMenu = () => InlineView.hide(contextmenu);
    const showContextMenu = (e) => {
      if (shouldNeverUseNative(editor)) {
        e.preventDefault();
      }
      if (isNativeOverrideKeyEvent(editor, e) || isContextMenuDisabled(editor)) {
        return;
      }
      const anchorType = getAnchorType(editor, e);
      const buildMenu = () => {
        const selectedElement = getSelectedElement(editor, e);
        const registry = editor.ui.registry.getAll();
        const menuConfig = getContextMenu(editor);
        return generateContextMenu(registry.contextMenus, menuConfig, selectedElement);
      };
      const initAndShow$2 = isTouch2() ? initAndShow : initAndShow$1;
      initAndShow$2(editor, e, buildMenu, backstage, contextmenu, anchorType);
    };
    editor.on("init", () => {
      const hideEvents = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (isTouch2() ? "" : " ResizeWindow");
      editor.on(hideEvents, hideContextMenu);
      editor.on("longpress contextmenu", showContextMenu);
    });
  };
  const adt = Adt.generate([
    {
      offset: [
        "x",
        "y"
      ]
    },
    {
      absolute: [
        "x",
        "y"
      ]
    },
    {
      fixed: [
        "x",
        "y"
      ]
    }
  ]);
  const subtract = (change2) => (point2) => point2.translate(-change2.left, -change2.top);
  const add = (change2) => (point2) => point2.translate(change2.left, change2.top);
  const transform = (changes) => (x, y) => foldl(changes, (rest, f2) => f2(rest), SugarPosition(x, y));
  const asFixed = (coord, scroll, origin) => coord.fold(transform([
    add(origin),
    subtract(scroll)
  ]), transform([subtract(scroll)]), transform([]));
  const asAbsolute = (coord, scroll, origin) => coord.fold(transform([add(origin)]), transform([]), transform([add(scroll)]));
  const asOffset = (coord, scroll, origin) => coord.fold(transform([]), transform([subtract(origin)]), transform([
    add(scroll),
    subtract(origin)
  ]));
  const withinRange = (coord1, coord2, xRange2, yRange2, scroll, origin) => {
    const a1 = asAbsolute(coord1, scroll, origin);
    const a2 = asAbsolute(coord2, scroll, origin);
    return Math.abs(a1.left - a2.left) <= xRange2 && Math.abs(a1.top - a2.top) <= yRange2;
  };
  const getDeltas = (coord1, coord2, xRange2, yRange2, scroll, origin) => {
    const a1 = asAbsolute(coord1, scroll, origin);
    const a2 = asAbsolute(coord2, scroll, origin);
    const left3 = Math.abs(a1.left - a2.left);
    const top3 = Math.abs(a1.top - a2.top);
    return SugarPosition(left3, top3);
  };
  const toStyles = (coord, scroll, origin) => {
    const stylesOpt = coord.fold((x, y) => ({
      position: Optional.some("absolute"),
      left: Optional.some(x + "px"),
      top: Optional.some(y + "px")
    }), (x, y) => ({
      position: Optional.some("absolute"),
      left: Optional.some(x - origin.left + "px"),
      top: Optional.some(y - origin.top + "px")
    }), (x, y) => ({
      position: Optional.some("fixed"),
      left: Optional.some(x + "px"),
      top: Optional.some(y + "px")
    }));
    return {
      right: Optional.none(),
      bottom: Optional.none(),
      ...stylesOpt
    };
  };
  const translate = (coord, deltaX, deltaY) => coord.fold((x, y) => offset2(x + deltaX, y + deltaY), (x, y) => absolute(x + deltaX, y + deltaY), (x, y) => fixed(x + deltaX, y + deltaY));
  const absorb = (partialCoord, originalCoord, scroll, origin) => {
    const absorbOne = (stencil, nu2) => (optX, optY) => {
      const original2 = stencil(originalCoord, scroll, origin);
      return nu2(optX.getOr(original2.left), optY.getOr(original2.top));
    };
    return partialCoord.fold(absorbOne(asOffset, offset2), absorbOne(asAbsolute, absolute), absorbOne(asFixed, fixed));
  };
  const offset2 = adt.offset;
  const absolute = adt.absolute;
  const fixed = adt.fixed;
  const parseAttrToInt = (element2, name3) => {
    const value2 = get$f(element2, name3);
    return isUndefined2(value2) ? NaN : parseInt(value2, 10);
  };
  const get = (component, snapsInfo) => {
    const element2 = component.element;
    const x = parseAttrToInt(element2, snapsInfo.leftAttr);
    const y = parseAttrToInt(element2, snapsInfo.topAttr);
    return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(SugarPosition(x, y));
  };
  const set = (component, snapsInfo, pt) => {
    const element2 = component.element;
    set$9(element2, snapsInfo.leftAttr, pt.left + "px");
    set$9(element2, snapsInfo.topAttr, pt.top + "px");
  };
  const clear2 = (component, snapsInfo) => {
    const element2 = component.element;
    remove$7(element2, snapsInfo.leftAttr);
    remove$7(element2, snapsInfo.topAttr);
  };
  const getCoords = (component, snapInfo, coord, delta) => get(component, snapInfo).fold(() => coord, (fixed$12) => fixed(fixed$12.left + delta.left, fixed$12.top + delta.top));
  const moveOrSnap = (component, snapInfo, coord, delta, scroll, origin) => {
    const newCoord = getCoords(component, snapInfo, coord, delta);
    const snap2 = snapInfo.mustSnap ? findClosestSnap(component, snapInfo, newCoord, scroll, origin) : findSnap(component, snapInfo, newCoord, scroll, origin);
    const fixedCoord = asFixed(newCoord, scroll, origin);
    set(component, snapInfo, fixedCoord);
    return snap2.fold(() => ({
      coord: fixed(fixedCoord.left, fixedCoord.top),
      extra: Optional.none()
    }), (spanned) => ({
      coord: spanned.output,
      extra: spanned.extra
    }));
  };
  const stopDrag = (component, snapInfo) => {
    clear2(component, snapInfo);
  };
  const findMatchingSnap = (snaps, newCoord, scroll, origin) => findMap(snaps, (snap2) => {
    const sensor = snap2.sensor;
    const inRange = withinRange(newCoord, sensor, snap2.range.left, snap2.range.top, scroll, origin);
    return inRange ? Optional.some({
      output: absorb(snap2.output, newCoord, scroll, origin),
      extra: snap2.extra
    }) : Optional.none();
  });
  const findClosestSnap = (component, snapInfo, newCoord, scroll, origin) => {
    const snaps = snapInfo.getSnapPoints(component);
    const matchSnap = findMatchingSnap(snaps, newCoord, scroll, origin);
    return matchSnap.orThunk(() => {
      const bestSnap = foldl(snaps, (acc, snap2) => {
        const sensor = snap2.sensor;
        const deltas = getDeltas(newCoord, sensor, snap2.range.left, snap2.range.top, scroll, origin);
        return acc.deltas.fold(() => ({
          deltas: Optional.some(deltas),
          snap: Optional.some(snap2)
        }), (bestDeltas) => {
          const currAvg = (deltas.left + deltas.top) / 2;
          const bestAvg = (bestDeltas.left + bestDeltas.top) / 2;
          if (currAvg <= bestAvg) {
            return {
              deltas: Optional.some(deltas),
              snap: Optional.some(snap2)
            };
          } else {
            return acc;
          }
        });
      }, {
        deltas: Optional.none(),
        snap: Optional.none()
      });
      return bestSnap.snap.map((snap2) => ({
        output: absorb(snap2.output, newCoord, scroll, origin),
        extra: snap2.extra
      }));
    });
  };
  const findSnap = (component, snapInfo, newCoord, scroll, origin) => {
    const snaps = snapInfo.getSnapPoints(component);
    return findMatchingSnap(snaps, newCoord, scroll, origin);
  };
  const snapTo$1 = (snap2, scroll, origin) => ({
    coord: absorb(snap2.output, snap2.output, scroll, origin),
    extra: snap2.extra
  });
  const snapTo = (component, dragConfig, _state, snap2) => {
    const target = dragConfig.getTarget(component.element);
    if (dragConfig.repositionTarget) {
      const doc = owner$4(component.element);
      const scroll = get$b(doc);
      const origin = getOrigin(target);
      const snapPin = snapTo$1(snap2, scroll, origin);
      const styles2 = toStyles(snapPin.coord, scroll, origin);
      setOptions2(target, styles2);
    }
  };
  var DraggingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    snapTo
  });
  const initialAttribute = "data-initial-z-index";
  const resetZIndex = (blocker) => {
    parent(blocker.element).filter(isElement$12).each((root2) => {
      getOpt(root2, initialAttribute).fold(() => remove$6(root2, "z-index"), (zIndex) => set$8(root2, "z-index", zIndex));
      remove$7(root2, initialAttribute);
    });
  };
  const changeZIndex = (blocker) => {
    parent(blocker.element).filter(isElement$12).each((root2) => {
      getRaw(root2, "z-index").each((zindex) => {
        set$9(root2, initialAttribute, zindex);
      });
      set$8(root2, "z-index", get$e(blocker.element, "z-index"));
    });
  };
  const instigate = (anyComponent, blocker) => {
    anyComponent.getSystem().addToGui(blocker);
    changeZIndex(blocker);
  };
  const discard = (blocker) => {
    resetZIndex(blocker);
    blocker.getSystem().removeFromGui(blocker);
  };
  const createComponent = (component, blockerClass, blockerEvents) => component.getSystem().build(Container.sketch({
    dom: {
      styles: {
        "left": "0px",
        "top": "0px",
        "width": "100%",
        "height": "100%",
        "position": "fixed",
        "z-index": "1000000000000000"
      },
      classes: [blockerClass]
    },
    events: blockerEvents
  }));
  var SnapSchema = optionObjOf("snaps", [
    required$1("getSnapPoints"),
    onHandler("onSensor"),
    required$1("leftAttr"),
    required$1("topAttr"),
    defaulted("lazyViewport", win),
    defaulted("mustSnap", false)
  ]);
  const schema$6 = [
    defaulted("useFixed", never),
    required$1("blockerClass"),
    defaulted("getTarget", identity),
    defaulted("onDrag", noop2),
    defaulted("repositionTarget", true),
    defaulted("onDrop", noop2),
    defaultedFunction("getBounds", win),
    SnapSchema
  ];
  const getCurrentCoord = (target) => lift3(getRaw(target, "left"), getRaw(target, "top"), getRaw(target, "position"), (left3, top3, position2) => {
    const nu2 = position2 === "fixed" ? fixed : offset2;
    return nu2(parseInt(left3, 10), parseInt(top3, 10));
  }).getOrThunk(() => {
    const location2 = absolute$3(target);
    return absolute(location2.left, location2.top);
  });
  const clampCoords = (component, coords, scroll, origin, startData) => {
    const bounds2 = startData.bounds;
    const absoluteCoord = asAbsolute(coords, scroll, origin);
    const newX = clamp(absoluteCoord.left, bounds2.x, bounds2.x + bounds2.width - startData.width);
    const newY = clamp(absoluteCoord.top, bounds2.y, bounds2.y + bounds2.height - startData.height);
    const newCoords = absolute(newX, newY);
    return coords.fold(() => {
      const offset$12 = asOffset(newCoords, scroll, origin);
      return offset2(offset$12.left, offset$12.top);
    }, constant$1(newCoords), () => {
      const fixed$12 = asFixed(newCoords, scroll, origin);
      return fixed(fixed$12.left, fixed$12.top);
    });
  };
  const calcNewCoord = (component, optSnaps, currentCoord, scroll, origin, delta, startData) => {
    const newCoord = optSnaps.fold(() => {
      const translated = translate(currentCoord, delta.left, delta.top);
      const fixedCoord = asFixed(translated, scroll, origin);
      return fixed(fixedCoord.left, fixedCoord.top);
    }, (snapInfo) => {
      const snapping = moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
      snapping.extra.each((extra) => {
        snapInfo.onSensor(component, extra);
      });
      return snapping.coord;
    });
    return clampCoords(component, newCoord, scroll, origin, startData);
  };
  const dragBy = (component, dragConfig, startData, delta) => {
    const target = dragConfig.getTarget(component.element);
    if (dragConfig.repositionTarget) {
      const doc = owner$4(component.element);
      const scroll = get$b(doc);
      const origin = getOrigin(target);
      const currentCoord = getCurrentCoord(target);
      const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
      const styles2 = toStyles(newCoord, scroll, origin);
      setOptions2(target, styles2);
    }
    dragConfig.onDrag(component, target, delta);
  };
  const calcStartData = (dragConfig, comp) => ({
    bounds: dragConfig.getBounds(),
    height: getOuter$2(comp.element),
    width: getOuter$1(comp.element)
  });
  const move = (component, dragConfig, dragState, dragMode, event) => {
    const delta = dragState.update(dragMode, event);
    const dragStartData = dragState.getStartData().getOrThunk(() => calcStartData(dragConfig, component));
    delta.each((dlt) => {
      dragBy(component, dragConfig, dragStartData, dlt);
    });
  };
  const stop = (component, blocker, dragConfig, dragState) => {
    blocker.each(discard);
    dragConfig.snaps.each((snapInfo) => {
      stopDrag(component, snapInfo);
    });
    const target = dragConfig.getTarget(component.element);
    dragState.reset();
    dragConfig.onDrop(component, target);
  };
  const handlers = (events2) => (dragConfig, dragState) => {
    const updateStartState = (comp) => {
      dragState.setStartData(calcStartData(dragConfig, comp));
    };
    return derive$2([
      run$1(windowScroll(), (comp) => {
        dragState.getStartData().each(() => updateStartState(comp));
      }),
      ...events2(dragConfig, dragState, updateStartState)
    ]);
  };
  const init$3 = (dragApi) => derive$2([
    run$1(mousedown(), dragApi.forceDrop),
    run$1(mouseup(), dragApi.drop),
    run$1(mousemove(), (comp, simulatedEvent) => {
      dragApi.move(simulatedEvent.event);
    }),
    run$1(mouseout(), dragApi.delayDrop)
  ]);
  const getData$1 = (event) => Optional.from(SugarPosition(event.x, event.y));
  const getDelta$1 = (old, nu2) => SugarPosition(nu2.left - old.left, nu2.top - old.top);
  var MouseData = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData: getData$1,
    getDelta: getDelta$1
  });
  const events$3 = (dragConfig, dragState, updateStartState) => [run$1(mousedown(), (component, simulatedEvent) => {
    const raw = simulatedEvent.event.raw;
    if (raw.button !== 0) {
      return;
    }
    simulatedEvent.stop();
    const stop$1 = () => stop(component, Optional.some(blocker), dragConfig, dragState);
    const delayDrop = DelayedFunction(stop$1, 200);
    const dragApi = {
      drop: stop$1,
      delayDrop: delayDrop.schedule,
      forceDrop: stop$1,
      move: (event) => {
        delayDrop.cancel();
        move(component, dragConfig, dragState, MouseData, event);
      }
    };
    const blocker = createComponent(component, dragConfig.blockerClass, init$3(dragApi));
    const start2 = () => {
      updateStartState(component);
      instigate(component, blocker);
    };
    start2();
  })];
  const schema$5 = [
    ...schema$6,
    output$1("dragger", { handlers: handlers(events$3) })
  ];
  const init$2 = (dragApi) => derive$2([
    run$1(touchstart(), dragApi.forceDrop),
    run$1(touchend(), dragApi.drop),
    run$1(touchcancel(), dragApi.drop),
    run$1(touchmove(), (comp, simulatedEvent) => {
      dragApi.move(simulatedEvent.event);
    })
  ]);
  const getDataFrom = (touches) => {
    const touch2 = touches[0];
    return Optional.some(SugarPosition(touch2.clientX, touch2.clientY));
  };
  const getData = (event) => {
    const raw = event.raw;
    const touches = raw.touches;
    return touches.length === 1 ? getDataFrom(touches) : Optional.none();
  };
  const getDelta = (old, nu2) => SugarPosition(nu2.left - old.left, nu2.top - old.top);
  var TouchData = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getData,
    getDelta
  });
  const events$2 = (dragConfig, dragState, updateStartState) => {
    const blockerSingleton = value$2();
    const stopBlocking = (component) => {
      stop(component, blockerSingleton.get(), dragConfig, dragState);
      blockerSingleton.clear();
    };
    return [
      run$1(touchstart(), (component, simulatedEvent) => {
        simulatedEvent.stop();
        const stop2 = () => stopBlocking(component);
        const dragApi = {
          drop: stop2,
          delayDrop: noop2,
          forceDrop: stop2,
          move: (event) => {
            move(component, dragConfig, dragState, TouchData, event);
          }
        };
        const blocker = createComponent(component, dragConfig.blockerClass, init$2(dragApi));
        blockerSingleton.set(blocker);
        const start2 = () => {
          updateStartState(component);
          instigate(component, blocker);
        };
        start2();
      }),
      run$1(touchmove(), (component, simulatedEvent) => {
        simulatedEvent.stop();
        move(component, dragConfig, dragState, TouchData, simulatedEvent.event);
      }),
      run$1(touchend(), (component, simulatedEvent) => {
        simulatedEvent.stop();
        stopBlocking(component);
      }),
      run$1(touchcancel(), stopBlocking)
    ];
  };
  const schema$4 = [
    ...schema$6,
    output$1("dragger", { handlers: handlers(events$2) })
  ];
  const events$1 = (dragConfig, dragState, updateStartState) => [
    ...events$3(dragConfig, dragState, updateStartState),
    ...events$2(dragConfig, dragState, updateStartState)
  ];
  const schema$3 = [
    ...schema$6,
    output$1("dragger", { handlers: handlers(events$1) })
  ];
  const mouse = schema$5;
  const touch = schema$4;
  const mouseOrTouch = schema$3;
  var DraggingBranches = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    mouse,
    touch,
    mouseOrTouch
  });
  const init$1 = () => {
    let previous = Optional.none();
    let startData = Optional.none();
    const reset2 = () => {
      previous = Optional.none();
      startData = Optional.none();
    };
    const calculateDelta = (mode, nu2) => {
      const result = previous.map((old) => mode.getDelta(old, nu2));
      previous = Optional.some(nu2);
      return result;
    };
    const update = (mode, dragEvent) => mode.getData(dragEvent).bind((nuData) => calculateDelta(mode, nuData));
    const setStartData = (data2) => {
      startData = Optional.some(data2);
    };
    const getStartData = () => startData;
    const readState = constant$1({});
    return nu$8({
      readState,
      reset: reset2,
      update,
      getStartData,
      setStartData
    });
  };
  var DragState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init: init$1
  });
  const Dragging = createModes({
    branchKey: "mode",
    branches: DraggingBranches,
    name: "dragging",
    active: {
      events: (dragConfig, dragState) => {
        const dragger = dragConfig.dragger;
        return dragger.handlers(dragConfig, dragState);
      }
    },
    extra: {
      snap: (sConfig) => ({
        sensor: sConfig.sensor,
        range: sConfig.range,
        output: sConfig.output,
        extra: Optional.from(sConfig.extra)
      })
    },
    state: DragState,
    apis: DraggingApis
  });
  const snapWidth = 40;
  const snapOffset = snapWidth / 2;
  const calcSnap = (selectorOpt, td, x, y, width3, height3) => selectorOpt.fold(() => Dragging.snap({
    sensor: absolute(x - snapOffset, y - snapOffset),
    range: SugarPosition(width3, height3),
    output: absolute(Optional.some(x), Optional.some(y)),
    extra: { td }
  }), (selectorHandle) => {
    const sensorLeft = x - snapOffset;
    const sensorTop = y - snapOffset;
    const sensorWidth = snapWidth;
    const sensorHeight = snapWidth;
    const rect2 = selectorHandle.element.dom.getBoundingClientRect();
    return Dragging.snap({
      sensor: absolute(sensorLeft, sensorTop),
      range: SugarPosition(sensorWidth, sensorHeight),
      output: absolute(Optional.some(x - rect2.width / 2), Optional.some(y - rect2.height / 2)),
      extra: { td }
    });
  });
  const getSnapsConfig = (getSnapPoints, cell, onChange) => {
    const isSameCell = (cellOpt, td) => cellOpt.exists((currentTd) => eq(currentTd, td));
    return {
      getSnapPoints,
      leftAttr: "data-drag-left",
      topAttr: "data-drag-top",
      onSensor: (component, extra) => {
        const td = extra.td;
        if (!isSameCell(cell.get(), td)) {
          cell.set(td);
          onChange(td);
        }
      },
      mustSnap: true
    };
  };
  const createSelector = (snaps) => record(Button2.sketch({
    dom: {
      tag: "div",
      classes: ["tox-selector"]
    },
    buttonBehaviours: derive$1([
      Dragging.config({
        mode: "mouseOrTouch",
        blockerClass: "blocker",
        snaps
      }),
      Unselecting.config({})
    ]),
    eventOrder: {
      mousedown: [
        "dragging",
        "alloy.base.behaviour"
      ],
      touchstart: [
        "dragging",
        "alloy.base.behaviour"
      ]
    }
  }));
  const setup$4 = (editor, sink) => {
    const tlTds = Cell([]);
    const brTds = Cell([]);
    const isVisible3 = Cell(false);
    const startCell = value$2();
    const finishCell = value$2();
    const getTopLeftSnap = (td) => {
      const box2 = absolute$2(td);
      return calcSnap(memTopLeft.getOpt(sink), td, box2.x, box2.y, box2.width, box2.height);
    };
    const getTopLeftSnaps = () => map$2(tlTds.get(), (td) => getTopLeftSnap(td));
    const getBottomRightSnap = (td) => {
      const box2 = absolute$2(td);
      return calcSnap(memBottomRight.getOpt(sink), td, box2.right, box2.bottom, box2.width, box2.height);
    };
    const getBottomRightSnaps = () => map$2(brTds.get(), (td) => getBottomRightSnap(td));
    const topLeftSnaps = getSnapsConfig(getTopLeftSnaps, startCell, (start2) => {
      finishCell.get().each((finish) => {
        editor.dispatch("TableSelectorChange", {
          start: start2,
          finish
        });
      });
    });
    const bottomRightSnaps = getSnapsConfig(getBottomRightSnaps, finishCell, (finish) => {
      startCell.get().each((start2) => {
        editor.dispatch("TableSelectorChange", {
          start: start2,
          finish
        });
      });
    });
    const memTopLeft = createSelector(topLeftSnaps);
    const memBottomRight = createSelector(bottomRightSnaps);
    const topLeft = build$1(memTopLeft.asSpec());
    const bottomRight = build$1(memBottomRight.asSpec());
    const showOrHideHandle = (selector, cell, isAbove, isBelow) => {
      const cellRect = cell.dom.getBoundingClientRect();
      remove$6(selector.element, "display");
      const viewportHeight = defaultView(SugarElement.fromDom(editor.getBody())).dom.innerHeight;
      const aboveViewport = isAbove(cellRect);
      const belowViewport = isBelow(cellRect, viewportHeight);
      if (aboveViewport || belowViewport) {
        set$8(selector.element, "display", "none");
      }
    };
    const snapTo2 = (selector, cell, getSnapConfig, pos) => {
      const snap2 = getSnapConfig(cell);
      Dragging.snapTo(selector, snap2);
      const isAbove = (rect2) => rect2[pos] < 0;
      const isBelow = (rect2, viewportHeight) => rect2[pos] > viewportHeight;
      showOrHideHandle(selector, cell, isAbove, isBelow);
    };
    const snapTopLeft = (cell) => snapTo2(topLeft, cell, getTopLeftSnap, "top");
    const snapLastTopLeft = () => startCell.get().each(snapTopLeft);
    const snapBottomRight = (cell) => snapTo2(bottomRight, cell, getBottomRightSnap, "bottom");
    const snapLastBottomRight = () => finishCell.get().each(snapBottomRight);
    if (detect$2().deviceType.isTouch()) {
      editor.on("TableSelectionChange", (e) => {
        if (!isVisible3.get()) {
          attach(sink, topLeft);
          attach(sink, bottomRight);
          isVisible3.set(true);
        }
        startCell.set(e.start);
        finishCell.set(e.finish);
        e.otherCells.each((otherCells) => {
          tlTds.set(otherCells.upOrLeftCells);
          brTds.set(otherCells.downOrRightCells);
          snapTopLeft(e.start);
          snapBottomRight(e.finish);
        });
      });
      editor.on("ResizeEditor ResizeWindow ScrollContent", () => {
        snapLastTopLeft();
        snapLastBottomRight();
      });
      editor.on("TableSelectionClear", () => {
        if (isVisible3.get()) {
          detach(topLeft);
          detach(bottomRight);
          isVisible3.set(false);
        }
        startCell.clear();
        finishCell.clear();
      });
    }
  };
  var Logo = '<svg width="50px" height="16px" viewBox="0 0 50 16" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M10.143 0c2.608.015 5.186 2.178 5.186 5.331 0 0 .077 3.812-.084 4.87-.361 2.41-2.164 4.074-4.65 4.496-1.453.284-2.523.49-3.212.623-.373.071-.634.122-.785.152-.184.038-.997.145-1.35.145-2.732 0-5.21-2.04-5.248-5.33 0 0 0-3.514.03-4.442.093-2.4 1.758-4.342 4.926-4.963 0 0 3.875-.752 4.036-.782.368-.07.775-.1 1.15-.1Zm1.826 2.8L5.83 3.989v2.393l-2.455.475v5.968l6.137-1.189V9.243l2.456-.476V2.8ZM5.83 6.382l3.682-.713v3.574l-3.682.713V6.382Zm27.173-1.64-.084-1.066h-2.226v9.132h2.456V7.743c-.008-1.151.998-2.064 2.149-2.072 1.15-.008 1.987.92 1.995 2.072v5.065h2.455V7.359c-.015-2.18-1.657-3.929-3.837-3.913a3.993 3.993 0 0 0-2.908 1.296Zm-6.3-4.266L29.16 0v2.387l-2.456.475V.476Zm0 3.2v9.132h2.456V3.676h-2.456Zm18.179 11.787L49.11 3.676H46.58l-1.612 4.527-.46 1.382-.384-1.382-1.611-4.527H39.98l3.3 9.132L42.15 16l2.732-.537ZM22.867 9.738c0 .752.568 1.075.921 1.075.353 0 .668-.047.998-.154l.537 1.765c-.23.154-.92.537-2.225.537-1.305 0-2.655-.997-2.686-2.686a136.877 136.877 0 0 1 0-4.374H18.8V3.676h1.612v-1.98l2.455-.476v2.456h2.302V5.9h-2.302v3.837Z"/>\n</svg>\n';
  const isHidden = (elm) => elm.nodeName === "BR" || !!elm.getAttribute("data-mce-bogus") || elm.getAttribute("data-mce-type") === "bookmark";
  const renderElementPath = (editor, settings, providersBackstage) => {
    var _a;
    const delimiter = (_a = settings.delimiter) !== null && _a !== void 0 ? _a : "›";
    const renderElement = (name3, element2, index) => Button2.sketch({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-item"],
        attributes: {
          "data-index": index,
          "aria-level": index + 1
        }
      },
      components: [text$2(name3)],
      action: (_btn) => {
        editor.focus();
        editor.selection.select(element2);
        editor.nodeChanged();
      },
      buttonBehaviours: derive$1([
        DisablingConfigs.button(providersBackstage.isDisabled),
        receivingConfig()
      ])
    });
    const renderDivider = () => ({
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path-divider"],
        attributes: { "aria-hidden": true }
      },
      components: [text$2(` ${delimiter} `)]
    });
    const renderPathData = (data2) => foldl(data2, (acc, path2, index) => {
      const element2 = renderElement(path2.name, path2.element, index);
      if (index === 0) {
        return acc.concat([element2]);
      } else {
        return acc.concat([
          renderDivider(),
          element2
        ]);
      }
    }, []);
    const updatePath2 = (parents2) => {
      const newPath = [];
      let i = parents2.length;
      while (i-- > 0) {
        const parent2 = parents2[i];
        if (parent2.nodeType === 1 && !isHidden(parent2)) {
          const args = fireResolveName(editor, parent2);
          if (!args.isDefaultPrevented()) {
            newPath.push({
              name: args.name,
              element: parent2
            });
          }
          if (args.isPropagationStopped()) {
            break;
          }
        }
      }
      return newPath;
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar__path"],
        attributes: { role: "navigation" }
      },
      behaviours: derive$1([
        Keying.config({
          mode: "flow",
          selector: "div[role=button]"
        }),
        Disabling.config({ disabled: providersBackstage.isDisabled }),
        receivingConfig(),
        Tabstopping.config({}),
        Replacing.config({}),
        config("elementPathEvents", [runOnAttached((comp, _e) => {
          editor.shortcuts.add("alt+F11", "focus statusbar elementpath", () => Keying.focusIn(comp));
          editor.on("NodeChange", (e) => {
            const newPath = updatePath2(e.parents);
            const newChildren = newPath.length > 0 ? renderPathData(newPath) : [];
            Replacing.set(comp, newChildren);
          });
        })])
      ]),
      components: []
    };
  };
  var ResizeTypes;
  (function(ResizeTypes2) {
    ResizeTypes2[ResizeTypes2["None"] = 0] = "None";
    ResizeTypes2[ResizeTypes2["Both"] = 1] = "Both";
    ResizeTypes2[ResizeTypes2["Vertical"] = 2] = "Vertical";
  })(ResizeTypes || (ResizeTypes = {}));
  const getDimensions = (editor, deltas, resizeType, originalHeight, originalWidth) => {
    const dimensions = { height: calcCappedSize(originalHeight + deltas.top, getMinHeightOption(editor), getMaxHeightOption(editor)) };
    if (resizeType === ResizeTypes.Both) {
      dimensions.width = calcCappedSize(originalWidth + deltas.left, getMinWidthOption(editor), getMaxWidthOption(editor));
    }
    return dimensions;
  };
  const resize = (editor, deltas, resizeType) => {
    const container = SugarElement.fromDom(editor.getContainer());
    const dimensions = getDimensions(editor, deltas, resizeType, get$d(container), get$c(container));
    each(dimensions, (val, dim) => {
      if (isNumber2(val)) {
        set$8(container, dim, numToPx(val));
      }
    });
    fireResizeEditor(editor);
  };
  const getResizeType = (editor) => {
    const resize2 = getResize(editor);
    if (resize2 === false) {
      return ResizeTypes.None;
    } else if (resize2 === "both") {
      return ResizeTypes.Both;
    } else {
      return ResizeTypes.Vertical;
    }
  };
  const keyboardHandler = (editor, resizeType, x, y) => {
    const scale = 20;
    const delta = SugarPosition(x * scale, y * scale);
    resize(editor, delta, resizeType);
    return Optional.some(true);
  };
  const renderResizeHandler = (editor, providersBackstage) => {
    const resizeType = getResizeType(editor);
    if (resizeType === ResizeTypes.None) {
      return Optional.none();
    }
    return Optional.some(render$3("resize-handle", {
      tag: "div",
      classes: ["tox-statusbar__resize-handle"],
      attributes: { title: providersBackstage.translate("Resize") },
      behaviours: [
        Dragging.config({
          mode: "mouse",
          repositionTarget: false,
          onDrag: (_comp, _target, delta) => resize(editor, delta, resizeType),
          blockerClass: "tox-blocker"
        }),
        Keying.config({
          mode: "special",
          onLeft: () => keyboardHandler(editor, resizeType, -1, 0),
          onRight: () => keyboardHandler(editor, resizeType, 1, 0),
          onUp: () => keyboardHandler(editor, resizeType, 0, -1),
          onDown: () => keyboardHandler(editor, resizeType, 0, 1)
        }),
        Tabstopping.config({}),
        Focusing.config({})
      ]
    }, providersBackstage.icons));
  };
  const renderWordCount = (editor, providersBackstage) => {
    const replaceCountText = (comp, count, mode) => Replacing.set(comp, [text$2(providersBackstage.translate([
      "{0} " + mode,
      count[mode]
    ]))]);
    return Button2.sketch({
      dom: {
        tag: "button",
        classes: ["tox-statusbar__wordcount"]
      },
      components: [],
      buttonBehaviours: derive$1([
        DisablingConfigs.button(providersBackstage.isDisabled),
        receivingConfig(),
        Tabstopping.config({}),
        Replacing.config({}),
        Representing.config({
          store: {
            mode: "memory",
            initialValue: {
              mode: "words",
              count: {
                words: 0,
                characters: 0
              }
            }
          }
        }),
        config("wordcount-events", [
          runOnExecute$1((comp) => {
            const currentVal = Representing.getValue(comp);
            const newMode = currentVal.mode === "words" ? "characters" : "words";
            Representing.setValue(comp, {
              mode: newMode,
              count: currentVal.count
            });
            replaceCountText(comp, currentVal.count, newMode);
          }),
          runOnAttached((comp) => {
            editor.on("wordCountUpdate", (e) => {
              const { mode } = Representing.getValue(comp);
              Representing.setValue(comp, {
                mode,
                count: e.wordCount
              });
              replaceCountText(comp, e.wordCount, mode);
            });
          })
        ])
      ]),
      eventOrder: {
        [execute$5()]: [
          "disabling",
          "alloy.base.behaviour",
          "wordcount-events"
        ]
      }
    });
  };
  const renderStatusbar = (editor, providersBackstage) => {
    const renderBranding = () => {
      return {
        dom: {
          tag: "span",
          classes: ["tox-statusbar__branding"]
        },
        components: [{
          dom: {
            tag: "a",
            attributes: {
              "href": "https://www.tiny.cloud/powered-by-tiny?utm_campaign=editor_referral&utm_medium=poweredby&utm_source=tinymce&utm_content=v6",
              "rel": "noopener",
              "target": "_blank",
              "aria-label": global$8.translate([
                "Powered by {0}",
                "Tiny"
              ])
            },
            innerHtml: Logo.trim()
          },
          behaviours: derive$1([Focusing.config({})])
        }]
      };
    };
    const getTextComponents = () => {
      const components2 = [];
      if (useElementPath(editor)) {
        components2.push(renderElementPath(editor, {}, providersBackstage));
      }
      if (editor.hasPlugin("wordcount")) {
        components2.push(renderWordCount(editor, providersBackstage));
      }
      if (useBranding(editor)) {
        components2.push(renderBranding());
      }
      if (components2.length > 0) {
        return [{
          dom: {
            tag: "div",
            classes: ["tox-statusbar__text-container"]
          },
          components: components2
        }];
      }
      return [];
    };
    const getComponents = () => {
      const components2 = getTextComponents();
      const resizeHandler = renderResizeHandler(editor, providersBackstage);
      return components2.concat(resizeHandler.toArray());
    };
    return {
      dom: {
        tag: "div",
        classes: ["tox-statusbar"]
      },
      components: getComponents()
    };
  };
  const getLazyMothership = (label2, singleton2) => singleton2.get().getOrDie(`UI for ${label2} has not been rendered`);
  const setup$3 = (editor, setupForTheme) => {
    const isInline = editor.inline;
    const mode = isInline ? Inline : Iframe;
    const header = isStickyToolbar(editor) ? StickyHeader : StaticHeader;
    const lazyUiRefs = LazyUiReferences();
    const lazyMothership = value$2();
    const lazyDialogMothership = value$2();
    const lazyPopupMothership = value$2();
    const platform3 = detect$2();
    const isTouch2 = platform3.deviceType.isTouch();
    const touchPlatformClass = "tox-platform-touch";
    const deviceClasses = isTouch2 ? [touchPlatformClass] : [];
    const isToolbarBottom = isToolbarLocationBottom(editor);
    const toolbarMode = getToolbarMode(editor);
    const memAnchorBar = record({
      dom: {
        tag: "div",
        classes: ["tox-anchorbar"]
      }
    });
    const lazyHeader = () => lazyUiRefs.mainUi.get().map((ui) => ui.outerContainer).bind(OuterContainer.getHeader);
    const lazyDialogSinkResult = () => Result.fromOption(lazyUiRefs.dialogUi.get().map((ui) => ui.sink), "UI has not been rendered");
    const lazyPopupSinkResult = () => Result.fromOption(lazyUiRefs.popupUi.get().map((ui) => ui.sink), "(popup) UI has not been rendered");
    const lazyAnchorBar = lazyUiRefs.lazyGetInOuterOrDie("anchor bar", memAnchorBar.getOpt);
    const lazyToolbar = lazyUiRefs.lazyGetInOuterOrDie("toolbar", OuterContainer.getToolbar);
    const lazyThrobber = lazyUiRefs.lazyGetInOuterOrDie("throbber", OuterContainer.getThrobber);
    const backstages = init$6({
      popup: lazyPopupSinkResult,
      dialog: lazyDialogSinkResult
    }, editor, lazyAnchorBar);
    const makeHeaderPart = () => {
      const verticalDirAttributes = { attributes: { [Attribute]: isToolbarBottom ? AttributeValue.BottomToTop : AttributeValue.TopToBottom } };
      const partMenubar2 = OuterContainer.parts.menubar({
        dom: {
          tag: "div",
          classes: ["tox-menubar"]
        },
        backstage: backstages.popup,
        onEscape: () => {
          editor.focus();
        }
      });
      const partToolbar2 = OuterContainer.parts.toolbar({
        dom: {
          tag: "div",
          classes: ["tox-toolbar"]
        },
        getSink: backstages.popup.shared.getSink,
        providers: backstages.popup.shared.providers,
        onEscape: () => {
          editor.focus();
        },
        onToolbarToggled: (state2) => {
          fireToggleToolbarDrawer(editor, state2);
        },
        type: toolbarMode,
        lazyToolbar,
        lazyHeader: () => lazyHeader().getOrDie("Could not find header element"),
        ...verticalDirAttributes
      });
      const partMultipleToolbar2 = OuterContainer.parts["multiple-toolbar"]({
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        providers: backstages.popup.shared.providers,
        onEscape: () => {
          editor.focus();
        },
        type: toolbarMode
      });
      const hasMultipleToolbar = isMultipleToolbars(editor);
      const hasToolbar = isToolbarEnabled(editor);
      const hasMenubar = isMenubarEnabled(editor);
      const shouldHavePromotion = promotionEnabled(editor);
      const partPromotion2 = makePromotion();
      const hasAnyContents = hasMultipleToolbar || hasToolbar || hasMenubar;
      const getPartToolbar = () => {
        if (hasMultipleToolbar) {
          return [partMultipleToolbar2];
        } else if (hasToolbar) {
          return [partToolbar2];
        } else {
          return [];
        }
      };
      const menubarCollection = shouldHavePromotion ? [
        partPromotion2,
        partMenubar2
      ] : [partMenubar2];
      return OuterContainer.parts.header({
        dom: {
          tag: "div",
          classes: ["tox-editor-header"].concat(hasAnyContents ? [] : ["tox-editor-header--empty"]),
          ...verticalDirAttributes
        },
        components: flatten([
          hasMenubar ? menubarCollection : [],
          getPartToolbar(),
          useFixedContainer(editor) ? [] : [memAnchorBar.asSpec()]
        ]),
        sticky: isStickyToolbar(editor),
        editor,
        sharedBackstage: backstages.popup.shared
      });
    };
    const makePromotion = () => {
      return OuterContainer.parts.promotion({
        dom: {
          tag: "div",
          classes: ["tox-promotion"]
        }
      });
    };
    const makeSidebarDefinition = () => {
      const partSocket2 = OuterContainer.parts.socket({
        dom: {
          tag: "div",
          classes: ["tox-edit-area"]
        }
      });
      const partSidebar2 = OuterContainer.parts.sidebar({
        dom: {
          tag: "div",
          classes: ["tox-sidebar"]
        }
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-sidebar-wrap"]
        },
        components: [
          partSocket2,
          partSidebar2
        ]
      };
    };
    const renderDialogUi = () => {
      const uiContainer = getUiContainer(editor);
      const isGridUiContainer = eq(body(), uiContainer) && get$e(uiContainer, "display") === "grid";
      const sinkSpec = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-tinymce-aux"
          ].concat(deviceClasses),
          attributes: { ...global$8.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: derive$1([Positioning.config({ useFixed: () => header.isDocked(lazyHeader) })])
      };
      const reactiveWidthSpec = {
        dom: { styles: { width: document.body.clientWidth + "px" } },
        events: derive$2([run$1(windowResize(), (comp) => {
          set$8(comp.element, "width", document.body.clientWidth + "px");
        })])
      };
      const sink = build$1(deepMerge(sinkSpec, isGridUiContainer ? reactiveWidthSpec : {}));
      const uiMothership = takeover(sink);
      lazyDialogMothership.set(uiMothership);
      return {
        sink,
        mothership: uiMothership
      };
    };
    const renderPopupUi = () => {
      const sinkSpec = {
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-silver-sink",
            "tox-silver-popup-sink",
            "tox-tinymce-aux"
          ].concat(deviceClasses),
          attributes: { ...global$8.isRtl() ? { dir: "rtl" } : {} }
        },
        behaviours: derive$1([Positioning.config({
          useFixed: () => header.isDocked(lazyHeader),
          getBounds: () => setupForTheme.getPopupSinkBounds()
        })])
      };
      const sink = build$1(sinkSpec);
      const uiMothership = takeover(sink);
      lazyPopupMothership.set(uiMothership);
      return {
        sink,
        mothership: uiMothership
      };
    };
    const renderMainUi = () => {
      const partHeader2 = makeHeaderPart();
      const sidebarContainer = makeSidebarDefinition();
      const partThrobber2 = OuterContainer.parts.throbber({
        dom: {
          tag: "div",
          classes: ["tox-throbber"]
        },
        backstage: backstages.popup
      });
      const partViewWrapper2 = OuterContainer.parts.viewWrapper({ backstage: backstages.popup });
      const statusbar = useStatusBar(editor) && !isInline ? Optional.some(renderStatusbar(editor, backstages.popup.shared.providers)) : Optional.none();
      const editorComponents = flatten([
        isToolbarBottom ? [] : [partHeader2],
        isInline ? [] : [sidebarContainer],
        isToolbarBottom ? [partHeader2] : []
      ]);
      const editorContainer = OuterContainer.parts.editorContainer({
        components: flatten([
          editorComponents,
          isInline ? [] : statusbar.toArray()
        ])
      });
      const isHidden2 = isDistractionFree(editor);
      const attributes = {
        role: "application",
        ...global$8.isRtl() ? { dir: "rtl" } : {},
        ...isHidden2 ? { "aria-hidden": "true" } : {}
      };
      const outerContainer = build$1(OuterContainer.sketch({
        dom: {
          tag: "div",
          classes: [
            "tox",
            "tox-tinymce"
          ].concat(isInline ? ["tox-tinymce-inline"] : []).concat(isToolbarBottom ? ["tox-tinymce--toolbar-bottom"] : []).concat(deviceClasses),
          styles: {
            visibility: "hidden",
            ...isHidden2 ? {
              opacity: "0",
              border: "0"
            } : {}
          },
          attributes
        },
        components: [
          editorContainer,
          ...isInline ? [] : [partViewWrapper2],
          partThrobber2
        ],
        behaviours: derive$1([
          receivingConfig(),
          Disabling.config({ disableClass: "tox-tinymce--disabled" }),
          Keying.config({
            mode: "cyclic",
            selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
          })
        ])
      }));
      const mothership = takeover(outerContainer);
      lazyMothership.set(mothership);
      return {
        mothership,
        outerContainer
      };
    };
    const setEditorSize = (outerContainer) => {
      const parsedHeight = numToPx(getHeightWithFallback(editor));
      const parsedWidth = numToPx(getWidthWithFallback(editor));
      if (!editor.inline) {
        if (isValidValue("div", "width", parsedWidth)) {
          set$8(outerContainer.element, "width", parsedWidth);
        }
        if (isValidValue("div", "height", parsedHeight)) {
          set$8(outerContainer.element, "height", parsedHeight);
        } else {
          set$8(outerContainer.element, "height", "400px");
        }
      }
      return parsedHeight;
    };
    const setupShortcutsAndCommands = (outerContainer) => {
      editor.addShortcut("alt+F9", "focus menubar", () => {
        OuterContainer.focusMenubar(outerContainer);
      });
      editor.addShortcut("alt+F10", "focus toolbar", () => {
        OuterContainer.focusToolbar(outerContainer);
      });
      editor.addCommand("ToggleToolbarDrawer", (_ui, options) => {
        if (options === null || options === void 0 ? void 0 : options.skipFocus) {
          OuterContainer.toggleToolbarDrawerWithoutFocusing(outerContainer);
        } else {
          OuterContainer.toggleToolbarDrawer(outerContainer);
        }
      });
      editor.addQueryStateHandler("ToggleToolbarDrawer", () => OuterContainer.isToolbarDrawerToggled(outerContainer));
    };
    const renderUIWithRefs = (uiRefs) => {
      const { mainUi, popupUi, uiMotherships } = uiRefs;
      map$1(getToolbarGroups(editor), (toolbarGroupButtonConfig, name3) => {
        editor.ui.registry.addGroupToolbarButton(name3, toolbarGroupButtonConfig);
      });
      const { buttons, menuItems, contextToolbars, sidebars, views } = editor.ui.registry.getAll();
      const toolbarOpt = getMultipleToolbarsOption(editor);
      const rawUiConfig = {
        menuItems,
        menus: getMenus(editor),
        menubar: getMenubar(editor),
        toolbar: toolbarOpt.getOrThunk(() => getToolbar(editor)),
        allowToolbarGroups: toolbarMode === ToolbarMode$1.floating,
        buttons,
        sidebar: sidebars,
        views
      };
      setupShortcutsAndCommands(mainUi.outerContainer);
      setup$b(editor, mainUi.mothership, uiMotherships);
      header.setup(editor, backstages.popup.shared, lazyHeader);
      setup$6(editor, backstages.popup);
      setup$5(editor, backstages.popup.shared.getSink, backstages.popup);
      setup$8(editor);
      setup$7(editor, lazyThrobber, backstages.popup.shared);
      register$9(editor, contextToolbars, popupUi.sink, { backstage: backstages.popup });
      setup$4(editor, popupUi.sink);
      const elm = editor.getElement();
      const height3 = setEditorSize(mainUi.outerContainer);
      const args = {
        targetNode: elm,
        height: height3
      };
      return mode.render(editor, uiRefs, rawUiConfig, backstages.popup, args);
    };
    const reuseDialogUiForPopuUi = (dialogUi) => {
      lazyPopupMothership.set(dialogUi.mothership);
      return dialogUi;
    };
    const renderUI = () => {
      const mainUi = renderMainUi();
      const dialogUi = renderDialogUi();
      const popupUi = isSplitUiMode(editor) ? renderPopupUi() : reuseDialogUiForPopuUi(dialogUi);
      lazyUiRefs.dialogUi.set(dialogUi);
      lazyUiRefs.popupUi.set(popupUi);
      lazyUiRefs.mainUi.set(mainUi);
      const uiRefs = {
        popupUi,
        dialogUi,
        mainUi,
        uiMotherships: lazyUiRefs.getUiMotherships()
      };
      return renderUIWithRefs(uiRefs);
    };
    return {
      popups: {
        backstage: backstages.popup,
        getMothership: () => getLazyMothership("popups", lazyPopupMothership)
      },
      dialogs: {
        backstage: backstages.dialog,
        getMothership: () => getLazyMothership("dialogs", lazyDialogMothership)
      },
      renderUI
    };
  };
  const describedBy = (describedElement, describeElement) => {
    const describeId = Optional.from(get$f(describedElement, "id")).fold(() => {
      const id = generate$6("dialog-describe");
      set$9(describeElement, "id", id);
      return id;
    }, identity);
    set$9(describedElement, "aria-describedby", describeId);
  };
  const labelledBy = (labelledElement, labelElement) => {
    const labelId = getOpt(labelledElement, "id").fold(() => {
      const id = generate$6("dialog-label");
      set$9(labelElement, "id", id);
      return id;
    }, identity);
    set$9(labelledElement, "aria-labelledby", labelId);
  };
  const schema$2 = constant$1([
    required$1("lazySink"),
    option$3("dragBlockClass"),
    defaultedFunction("getBounds", win),
    defaulted("useTabstopAt", always),
    defaulted("firstTabstop", 0),
    defaulted("eventOrder", {}),
    field("modalBehaviours", [Keying]),
    onKeyboardHandler("onExecute"),
    onStrictKeyboardHandler("onEscape")
  ]);
  const basic = { sketch: identity };
  const parts$2 = constant$1([
    optional({
      name: "draghandle",
      overrides: (detail, spec) => {
        return {
          behaviours: derive$1([Dragging.config({
            mode: "mouse",
            getTarget: (handle2) => {
              return ancestor(handle2, '[role="dialog"]').getOr(handle2);
            },
            blockerClass: detail.dragBlockClass.getOrDie(new Error("The drag blocker class was not specified for a dialog with a drag handle: \n" + JSON.stringify(spec, null, 2)).message),
            getBounds: detail.getDragBounds
          })])
        };
      }
    }),
    required({
      schema: [required$1("dom")],
      name: "title"
    }),
    required({
      factory: basic,
      schema: [required$1("dom")],
      name: "close"
    }),
    required({
      factory: basic,
      schema: [required$1("dom")],
      name: "body"
    }),
    optional({
      factory: basic,
      schema: [required$1("dom")],
      name: "footer"
    }),
    external({
      factory: {
        sketch: (spec, detail) => ({
          ...spec,
          dom: detail.dom,
          components: detail.components
        })
      },
      schema: [
        defaulted("dom", {
          tag: "div",
          styles: {
            position: "fixed",
            left: "0px",
            top: "0px",
            right: "0px",
            bottom: "0px"
          }
        }),
        defaulted("components", [])
      ],
      name: "blocker"
    })
  ]);
  const factory$4 = (detail, components2, spec, externals) => {
    const dialogComp = value$2();
    const showDialog = (dialog) => {
      dialogComp.set(dialog);
      const sink = detail.lazySink(dialog).getOrDie();
      const externalBlocker = externals.blocker();
      const blocker = sink.getSystem().build({
        ...externalBlocker,
        components: externalBlocker.components.concat([premade(dialog)]),
        behaviours: derive$1([
          Focusing.config({}),
          config("dialog-blocker-events", [runOnSource(focusin(), () => {
            Keying.focusIn(dialog);
          })])
        ])
      });
      attach(sink, blocker);
      Keying.focusIn(dialog);
    };
    const hideDialog = (dialog) => {
      dialogComp.clear();
      parent(dialog.element).each((blockerDom) => {
        dialog.getSystem().getByDom(blockerDom).each((blocker) => {
          detach(blocker);
        });
      });
    };
    const getDialogBody = (dialog) => getPartOrDie(dialog, detail, "body");
    const getDialogFooter = (dialog) => getPartOrDie(dialog, detail, "footer");
    const setBusy = (dialog, getBusySpec2) => {
      Blocking.block(dialog, getBusySpec2);
    };
    const setIdle = (dialog) => {
      Blocking.unblock(dialog);
    };
    const modalEventsId = generate$6("modal-events");
    const eventOrder = {
      ...detail.eventOrder,
      [attachedToDom()]: [modalEventsId].concat(detail.eventOrder["alloy.system.attached"] || [])
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      apis: {
        show: showDialog,
        hide: hideDialog,
        getBody: getDialogBody,
        getFooter: getDialogFooter,
        setIdle,
        setBusy
      },
      eventOrder,
      domModification: {
        attributes: {
          "role": "dialog",
          "aria-modal": "true"
        }
      },
      behaviours: augment(detail.modalBehaviours, [
        Replacing.config({}),
        Keying.config({
          mode: "cyclic",
          onEnter: detail.onExecute,
          onEscape: detail.onEscape,
          useTabstopAt: detail.useTabstopAt,
          firstTabstop: detail.firstTabstop
        }),
        Blocking.config({ getRoot: dialogComp.get }),
        config(modalEventsId, [runOnAttached((c) => {
          labelledBy(c.element, getPartOrDie(c, detail, "title").element);
          describedBy(c.element, getPartOrDie(c, detail, "body").element);
        })])
      ])
    };
  };
  const ModalDialog = composite({
    name: "ModalDialog",
    configFields: schema$2(),
    partFields: parts$2(),
    factory: factory$4,
    apis: {
      show: (apis2, dialog) => {
        apis2.show(dialog);
      },
      hide: (apis2, dialog) => {
        apis2.hide(dialog);
      },
      getBody: (apis2, dialog) => apis2.getBody(dialog),
      getFooter: (apis2, dialog) => apis2.getFooter(dialog),
      setBusy: (apis2, dialog, getBusySpec2) => {
        apis2.setBusy(dialog, getBusySpec2);
      },
      setIdle: (apis2, dialog) => {
        apis2.setIdle(dialog);
      }
    }
  });
  const dialogToggleMenuItemSchema = objOf([
    type,
    name$1
  ].concat(commonMenuItemFields));
  const dialogToggleMenuItemDataProcessor = boolean;
  const baseFooterButtonFields = [
    generatedName("button"),
    optionalIcon,
    defaultedStringEnum("align", "end", [
      "start",
      "end"
    ]),
    primary,
    enabled,
    optionStringEnum("buttonType", [
      "primary",
      "secondary"
    ])
  ];
  const dialogFooterButtonFields = [
    ...baseFooterButtonFields,
    text$12
  ];
  const normalFooterButtonFields = [
    requiredStringEnum("type", [
      "submit",
      "cancel",
      "custom"
    ]),
    ...dialogFooterButtonFields
  ];
  const menuFooterButtonFields = [
    requiredStringEnum("type", ["menu"]),
    optionalText,
    optionalTooltip,
    optionalIcon,
    requiredArrayOf("items", dialogToggleMenuItemSchema),
    ...baseFooterButtonFields
  ];
  const toggleButtonSpecFields = [
    ...baseFooterButtonFields,
    requiredStringEnum("type", ["togglebutton"]),
    requiredString("tooltip"),
    icon,
    optionalText,
    defaultedBoolean("active", false)
  ];
  const dialogFooterButtonSchema = choose$1("type", {
    submit: normalFooterButtonFields,
    cancel: normalFooterButtonFields,
    custom: normalFooterButtonFields,
    menu: menuFooterButtonFields,
    togglebutton: toggleButtonSpecFields
  });
  const alertBannerFields = [
    type,
    text$12,
    requiredStringEnum("level", [
      "info",
      "warn",
      "error",
      "success"
    ]),
    icon,
    defaulted("url", "")
  ];
  const alertBannerSchema = objOf(alertBannerFields);
  const createBarFields = (itemsField) => [
    type,
    itemsField
  ];
  const buttonFields = [
    type,
    text$12,
    enabled,
    generatedName("button"),
    optionalIcon,
    borderless,
    optionStringEnum("buttonType", [
      "primary",
      "secondary",
      "toolbar"
    ]),
    primary
  ];
  const buttonSchema = objOf(buttonFields);
  const formComponentFields = [
    type,
    name$1
  ];
  const formComponentWithLabelFields = formComponentFields.concat([optionalLabel]);
  const checkboxFields = formComponentFields.concat([
    label,
    enabled
  ]);
  const checkboxSchema = objOf(checkboxFields);
  const checkboxDataProcessor = boolean;
  const collectionFields = formComponentWithLabelFields.concat([defaultedColumns("auto")]);
  const collectionSchema = objOf(collectionFields);
  const collectionDataProcessor = arrOfObj([
    value$1,
    text$12,
    icon
  ]);
  const colorInputFields = formComponentWithLabelFields.concat([defaultedString("storageKey", "default")]);
  const colorInputSchema = objOf(colorInputFields);
  const colorInputDataProcessor = string;
  const colorPickerFields = formComponentWithLabelFields;
  const colorPickerSchema = objOf(colorPickerFields);
  const colorPickerDataProcessor = string;
  const customEditorFields = formComponentFields.concat([
    defaultedString("tag", "textarea"),
    requiredString("scriptId"),
    requiredString("scriptUrl"),
    defaultedPostMsg("settings", void 0)
  ]);
  const customEditorFieldsOld = formComponentFields.concat([
    defaultedString("tag", "textarea"),
    requiredFunction("init")
  ]);
  const customEditorSchema = valueOf((v) => asRaw("customeditor.old", objOfOnly(customEditorFieldsOld), v).orThunk(() => asRaw("customeditor.new", objOfOnly(customEditorFields), v)));
  const customEditorDataProcessor = string;
  const dropZoneFields = formComponentWithLabelFields;
  const dropZoneSchema = objOf(dropZoneFields);
  const dropZoneDataProcessor = arrOfVal();
  const createGridFields = (itemsField) => [
    type,
    requiredNumber("columns"),
    itemsField
  ];
  const htmlPanelFields = [
    type,
    requiredString("html"),
    defaultedStringEnum("presets", "presentation", [
      "presentation",
      "document"
    ])
  ];
  const htmlPanelSchema = objOf(htmlPanelFields);
  const iframeFields = formComponentWithLabelFields.concat([
    defaultedBoolean("sandboxed", true),
    defaultedBoolean("transparent", true)
  ]);
  const iframeSchema = objOf(iframeFields);
  const iframeDataProcessor = string;
  const imagePreviewSchema = objOf(formComponentFields.concat([optionString("height")]));
  const imagePreviewDataProcessor = objOf([
    requiredString("url"),
    optionNumber("zoom"),
    optionNumber("cachedWidth"),
    optionNumber("cachedHeight")
  ]);
  const inputFields = formComponentWithLabelFields.concat([
    optionString("inputMode"),
    optionString("placeholder"),
    defaultedBoolean("maximized", false),
    enabled
  ]);
  const inputSchema = objOf(inputFields);
  const inputDataProcessor = string;
  const createLabelFields = (itemsField) => [
    type,
    label,
    itemsField
  ];
  const listBoxSingleItemFields = [
    text$12,
    value$1
  ];
  const listBoxNestedItemFields = [
    text$12,
    requiredArrayOf("items", thunkOf("items", () => listBoxItemSchema))
  ];
  const listBoxItemSchema = oneOf([
    objOf(listBoxSingleItemFields),
    objOf(listBoxNestedItemFields)
  ]);
  const listBoxFields = formComponentWithLabelFields.concat([
    requiredArrayOf("items", listBoxItemSchema),
    enabled
  ]);
  const listBoxSchema = objOf(listBoxFields);
  const listBoxDataProcessor = string;
  const selectBoxFields = formComponentWithLabelFields.concat([
    requiredArrayOfObj("items", [
      text$12,
      value$1
    ]),
    defaultedNumber("size", 1),
    enabled
  ]);
  const selectBoxSchema = objOf(selectBoxFields);
  const selectBoxDataProcessor = string;
  const sizeInputFields = formComponentWithLabelFields.concat([
    defaultedBoolean("constrain", true),
    enabled
  ]);
  const sizeInputSchema = objOf(sizeInputFields);
  const sizeInputDataProcessor = objOf([
    requiredString("width"),
    requiredString("height")
  ]);
  const sliderFields = formComponentFields.concat([
    label,
    defaultedNumber("min", 0),
    defaultedNumber("max", 0)
  ]);
  const sliderSchema = objOf(sliderFields);
  const sliderInputDataProcessor = number;
  const tableFields = [
    type,
    requiredArrayOf("header", string),
    requiredArrayOf("cells", arrOf(string))
  ];
  const tableSchema = objOf(tableFields);
  const textAreaFields = formComponentWithLabelFields.concat([
    optionString("placeholder"),
    defaultedBoolean("maximized", false),
    enabled
  ]);
  const textAreaSchema = objOf(textAreaFields);
  const textAreaDataProcessor = string;
  const baseTreeItemFields = [
    requiredStringEnum("type", [
      "directory",
      "leaf"
    ]),
    title,
    requiredString("id"),
    optionOf("menu", MenuButtonSchema)
  ];
  const treeItemLeafFields = baseTreeItemFields;
  const treeItemLeafSchema = objOf(treeItemLeafFields);
  const treeItemDirectoryFields = baseTreeItemFields.concat([requiredArrayOf("children", thunkOf("children", () => {
    return choose$2("type", {
      directory: treeItemDirectorySchema,
      leaf: treeItemLeafSchema
    });
  }))]);
  const treeItemDirectorySchema = objOf(treeItemDirectoryFields);
  const treeItemSchema = choose$2("type", {
    directory: treeItemDirectorySchema,
    leaf: treeItemLeafSchema
  });
  const treeFields = [
    type,
    requiredArrayOf("items", treeItemSchema),
    optionFunction("onLeafAction")
  ];
  const treeSchema = objOf(treeFields);
  const urlInputFields = formComponentWithLabelFields.concat([
    defaultedStringEnum("filetype", "file", [
      "image",
      "media",
      "file"
    ]),
    enabled
  ]);
  const urlInputSchema = objOf(urlInputFields);
  const urlInputDataProcessor = objOf([
    value$1,
    defaultedMeta
  ]);
  const createItemsField = (name3) => field$1("items", "items", required$2(), arrOf(valueOf((v) => asRaw(`Checking item of ${name3}`, itemSchema, v).fold((sErr) => Result.error(formatError(sErr)), (passValue) => Result.value(passValue)))));
  const itemSchema = valueThunk(() => choose$2("type", {
    alertbanner: alertBannerSchema,
    bar: objOf(createBarFields(createItemsField("bar"))),
    button: buttonSchema,
    checkbox: checkboxSchema,
    colorinput: colorInputSchema,
    colorpicker: colorPickerSchema,
    dropzone: dropZoneSchema,
    grid: objOf(createGridFields(createItemsField("grid"))),
    iframe: iframeSchema,
    input: inputSchema,
    listbox: listBoxSchema,
    selectbox: selectBoxSchema,
    sizeinput: sizeInputSchema,
    slider: sliderSchema,
    textarea: textAreaSchema,
    urlinput: urlInputSchema,
    customeditor: customEditorSchema,
    htmlpanel: htmlPanelSchema,
    imagepreview: imagePreviewSchema,
    collection: collectionSchema,
    label: objOf(createLabelFields(createItemsField("label"))),
    table: tableSchema,
    tree: treeSchema,
    panel: panelSchema
  }));
  const panelFields = [
    type,
    defaulted("classes", []),
    requiredArrayOf("items", itemSchema)
  ];
  const panelSchema = objOf(panelFields);
  const tabFields = [
    generatedName("tab"),
    title,
    requiredArrayOf("items", itemSchema)
  ];
  const tabPanelFields = [
    type,
    requiredArrayOfObj("tabs", tabFields)
  ];
  const tabPanelSchema = objOf(tabPanelFields);
  const dialogButtonFields = dialogFooterButtonFields;
  const dialogButtonSchema = dialogFooterButtonSchema;
  const dialogSchema = objOf([
    requiredString("title"),
    requiredOf("body", choose$2("type", {
      panel: panelSchema,
      tabpanel: tabPanelSchema
    })),
    defaultedString("size", "normal"),
    requiredArrayOf("buttons", dialogButtonSchema),
    defaulted("initialData", {}),
    defaultedFunction("onAction", noop2),
    defaultedFunction("onChange", noop2),
    defaultedFunction("onSubmit", noop2),
    defaultedFunction("onClose", noop2),
    defaultedFunction("onCancel", noop2),
    defaultedFunction("onTabChange", noop2)
  ]);
  const createDialog = (spec) => asRaw("dialog", dialogSchema, spec);
  const urlDialogButtonSchema = objOf([
    requiredStringEnum("type", [
      "cancel",
      "custom"
    ]),
    ...dialogButtonFields
  ]);
  const urlDialogSchema = objOf([
    requiredString("title"),
    requiredString("url"),
    optionNumber("height"),
    optionNumber("width"),
    optionArrayOf("buttons", urlDialogButtonSchema),
    defaultedFunction("onAction", noop2),
    defaultedFunction("onCancel", noop2),
    defaultedFunction("onClose", noop2),
    defaultedFunction("onMessage", noop2)
  ]);
  const createUrlDialog = (spec) => asRaw("dialog", urlDialogSchema, spec);
  const getAllObjects = (obj) => {
    if (isObject2(obj)) {
      return [obj].concat(bind$3(values(obj), getAllObjects));
    } else if (isArray2(obj)) {
      return bind$3(obj, getAllObjects);
    } else {
      return [];
    }
  };
  const isNamedItem = (obj) => isString2(obj.type) && isString2(obj.name);
  const dataProcessors = {
    checkbox: checkboxDataProcessor,
    colorinput: colorInputDataProcessor,
    colorpicker: colorPickerDataProcessor,
    dropzone: dropZoneDataProcessor,
    input: inputDataProcessor,
    iframe: iframeDataProcessor,
    imagepreview: imagePreviewDataProcessor,
    selectbox: selectBoxDataProcessor,
    sizeinput: sizeInputDataProcessor,
    slider: sliderInputDataProcessor,
    listbox: listBoxDataProcessor,
    size: sizeInputDataProcessor,
    textarea: textAreaDataProcessor,
    urlinput: urlInputDataProcessor,
    customeditor: customEditorDataProcessor,
    collection: collectionDataProcessor,
    togglemenuitem: dialogToggleMenuItemDataProcessor
  };
  const getDataProcessor = (item3) => Optional.from(dataProcessors[item3.type]);
  const getNamedItems = (structure) => filter$2(getAllObjects(structure), isNamedItem);
  const createDataValidator = (structure) => {
    const namedItems = getNamedItems(structure);
    const fields = bind$3(namedItems, (item3) => getDataProcessor(item3).fold(() => [], (schema2) => [requiredOf(item3.name, schema2)]));
    return objOf(fields);
  };
  const extract = (structure) => {
    var _a;
    const internalDialog = getOrDie(createDialog(structure));
    const dataValidator = createDataValidator(structure);
    const initialData = (_a = structure.initialData) !== null && _a !== void 0 ? _a : {};
    return {
      internalDialog,
      dataValidator,
      initialData
    };
  };
  const DialogManager = {
    open: (factory2, structure) => {
      const extraction = extract(structure);
      return factory2(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
    },
    openUrl: (factory2, structure) => {
      const internalDialog = getOrDie(createUrlDialog(structure));
      return factory2(internalDialog);
    },
    redial: (structure) => extract(structure)
  };
  const events = (reflectingConfig, reflectingState) => {
    const update = (component, data2) => {
      reflectingConfig.updateState.each((updateState) => {
        const newState = updateState(component, data2);
        reflectingState.set(newState);
      });
      reflectingConfig.renderComponents.each((renderComponents2) => {
        const newComponents = renderComponents2(data2, reflectingState.get());
        const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;
        replacer(component, newComponents);
      });
    };
    return derive$2([
      run$1(receive(), (component, message) => {
        const receivingData = message;
        if (!receivingData.universal) {
          const channel = reflectingConfig.channel;
          if (contains$2(receivingData.channels, channel)) {
            update(component, receivingData.data);
          }
        }
      }),
      runOnAttached((comp, _se) => {
        reflectingConfig.initialData.each((rawData) => {
          update(comp, rawData);
        });
      })
    ]);
  };
  var ActiveReflecting = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    events
  });
  const getState = (component, replaceConfig, reflectState) => reflectState;
  var ReflectingApis = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    getState
  });
  var ReflectingSchema = [
    required$1("channel"),
    option$3("renderComponents"),
    option$3("updateState"),
    option$3("initialData"),
    defaultedBoolean("reuseDom", true)
  ];
  const init = () => {
    const cell = Cell(Optional.none());
    const clear3 = () => cell.set(Optional.none());
    const readState = () => cell.get().getOr("none");
    return {
      readState,
      get: cell.get,
      set: cell.set,
      clear: clear3
    };
  };
  var ReflectingState = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    init
  });
  const Reflecting = create$42({
    fields: ReflectingSchema,
    name: "reflecting",
    active: ActiveReflecting,
    apis: ReflectingApis,
    state: ReflectingState
  });
  const toValidValues = (values2) => {
    const errors = [];
    const result = {};
    each(values2, (value2, name3) => {
      value2.fold(() => {
        errors.push(name3);
      }, (v) => {
        result[name3] = v;
      });
    });
    return errors.length > 0 ? Result.error(errors) : Result.value(result);
  };
  const renderBodyPanel = (spec, dialogData, backstage) => {
    const memForm = record(Form.sketch((parts2) => ({
      dom: {
        tag: "div",
        classes: ["tox-form"].concat(spec.classes)
      },
      components: map$2(spec.items, (item3) => interpretInForm(parts2, item3, dialogData, backstage))
    })));
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-content"]
        },
        components: [memForm.asSpec()]
      }],
      behaviours: derive$1([
        Keying.config({
          mode: "acyclic",
          useTabstopAt: not(isPseudoStop)
        }),
        ComposingConfigs.memento(memForm),
        RepresentingConfigs.memento(memForm, {
          postprocess: (formValue) => toValidValues(formValue).fold((err) => {
            console.error(err);
            return {};
          }, identity)
        })
      ])
    };
  };
  const factory$3 = (detail, _spec) => ({
    uid: detail.uid,
    dom: detail.dom,
    components: detail.components,
    events: events$a(detail.action),
    behaviours: augment(detail.tabButtonBehaviours, [
      Focusing.config({}),
      Keying.config({
        mode: "execution",
        useSpace: true,
        useEnter: true
      }),
      Representing.config({
        store: {
          mode: "memory",
          initialValue: detail.value
        }
      })
    ]),
    domModification: detail.domModification
  });
  const TabButton = single({
    name: "TabButton",
    configFields: [
      defaulted("uid", void 0),
      required$1("value"),
      field$1("dom", "dom", mergeWithThunk(() => ({
        attributes: {
          "role": "tab",
          "id": generate$6("aria"),
          "aria-selected": "false"
        }
      })), anyValue()),
      option$3("action"),
      defaulted("domModification", {}),
      field("tabButtonBehaviours", [
        Focusing,
        Keying,
        Representing
      ]),
      required$1("view")
    ],
    factory: factory$3
  });
  const schema$1 = constant$1([
    required$1("tabs"),
    required$1("dom"),
    defaulted("clickToDismiss", false),
    field("tabbarBehaviours", [
      Highlighting,
      Keying
    ]),
    markers$1([
      "tabClass",
      "selectedClass"
    ])
  ]);
  const tabsPart = group({
    factory: TabButton,
    name: "tabs",
    unit: "tab",
    overrides: (barDetail) => {
      const dismissTab$1 = (tabbar, button2) => {
        Highlighting.dehighlight(tabbar, button2);
        emitWith(tabbar, dismissTab(), {
          tabbar,
          button: button2
        });
      };
      const changeTab$1 = (tabbar, button2) => {
        Highlighting.highlight(tabbar, button2);
        emitWith(tabbar, changeTab(), {
          tabbar,
          button: button2
        });
      };
      return {
        action: (button2) => {
          const tabbar = button2.getSystem().getByUid(barDetail.uid).getOrDie();
          const activeButton = Highlighting.isHighlighted(tabbar, button2);
          const response = (() => {
            if (activeButton && barDetail.clickToDismiss) {
              return dismissTab$1;
            } else if (!activeButton) {
              return changeTab$1;
            } else {
              return noop2;
            }
          })();
          response(tabbar, button2);
        },
        domModification: { classes: [barDetail.markers.tabClass] }
      };
    }
  });
  const parts$1 = constant$1([tabsPart]);
  const factory$2 = (detail, components2, _spec, _externals) => ({
    "uid": detail.uid,
    "dom": detail.dom,
    components: components2,
    "debug.sketcher": "Tabbar",
    "domModification": { attributes: { role: "tablist" } },
    "behaviours": augment(detail.tabbarBehaviours, [
      Highlighting.config({
        highlightClass: detail.markers.selectedClass,
        itemClass: detail.markers.tabClass,
        onHighlight: (tabbar, tab) => {
          set$9(tab.element, "aria-selected", "true");
        },
        onDehighlight: (tabbar, tab) => {
          set$9(tab.element, "aria-selected", "false");
        }
      }),
      Keying.config({
        mode: "flow",
        getInitial: (tabbar) => {
          return Highlighting.getHighlighted(tabbar).map((tab) => tab.element);
        },
        selector: "." + detail.markers.tabClass,
        executeOnMove: true
      })
    ])
  });
  const Tabbar = composite({
    name: "Tabbar",
    configFields: schema$1(),
    partFields: parts$1(),
    factory: factory$2
  });
  const factory$1 = (detail, _spec) => ({
    uid: detail.uid,
    dom: detail.dom,
    behaviours: augment(detail.tabviewBehaviours, [Replacing.config({})]),
    domModification: { attributes: { role: "tabpanel" } }
  });
  const Tabview = single({
    name: "Tabview",
    configFields: [field("tabviewBehaviours", [Replacing])],
    factory: factory$1
  });
  const schema = constant$1([
    defaulted("selectFirst", true),
    onHandler("onChangeTab"),
    onHandler("onDismissTab"),
    defaulted("tabs", []),
    field("tabSectionBehaviours", [])
  ]);
  const barPart = required({
    factory: Tabbar,
    schema: [
      required$1("dom"),
      requiredObjOf("markers", [
        required$1("tabClass"),
        required$1("selectedClass")
      ])
    ],
    name: "tabbar",
    defaults: (detail) => {
      return { tabs: detail.tabs };
    }
  });
  const viewPart = required({
    factory: Tabview,
    name: "tabview"
  });
  const parts = constant$1([
    barPart,
    viewPart
  ]);
  const factory = (detail, components2, _spec, _externals) => {
    const changeTab$1 = (button2) => {
      const tabValue = Representing.getValue(button2);
      getPart(button2, detail, "tabview").each((tabview) => {
        const tabWithValue = find$5(detail.tabs, (t2) => t2.value === tabValue);
        tabWithValue.each((tabData) => {
          const panel2 = tabData.view();
          getOpt(button2.element, "id").each((id) => {
            set$9(tabview.element, "aria-labelledby", id);
          });
          Replacing.set(tabview, panel2);
          detail.onChangeTab(tabview, button2, panel2);
        });
      });
    };
    const changeTabBy = (section, byPred) => {
      getPart(section, detail, "tabbar").each((tabbar) => {
        byPred(tabbar).each(emitExecute);
      });
    };
    return {
      uid: detail.uid,
      dom: detail.dom,
      components: components2,
      behaviours: get$3(detail.tabSectionBehaviours),
      events: derive$2(flatten([
        detail.selectFirst ? [runOnAttached((section, _simulatedEvent) => {
          changeTabBy(section, Highlighting.getFirst);
        })] : [],
        [
          run$1(changeTab(), (section, simulatedEvent) => {
            const button2 = simulatedEvent.event.button;
            changeTab$1(button2);
          }),
          run$1(dismissTab(), (section, simulatedEvent) => {
            const button2 = simulatedEvent.event.button;
            detail.onDismissTab(section, button2);
          })
        ]
      ])),
      apis: {
        getViewItems: (section) => {
          return getPart(section, detail, "tabview").map((tabview) => Replacing.contents(tabview)).getOr([]);
        },
        showTab: (section, tabKey) => {
          const getTabIfNotActive = (tabbar) => {
            const candidates = Highlighting.getCandidates(tabbar);
            const optTab = find$5(candidates, (c) => Representing.getValue(c) === tabKey);
            return optTab.filter((tab) => !Highlighting.isHighlighted(tabbar, tab));
          };
          changeTabBy(section, getTabIfNotActive);
        }
      }
    };
  };
  const TabSection = composite({
    name: "TabSection",
    configFields: schema(),
    partFields: parts(),
    factory,
    apis: {
      getViewItems: (apis2, component) => apis2.getViewItems(component),
      showTab: (apis2, component, tabKey) => {
        apis2.showTab(component, tabKey);
      }
    }
  });
  const measureHeights = (allTabs, tabview, tabviewComp) => map$2(allTabs, (_tab, i) => {
    Replacing.set(tabviewComp, allTabs[i].view());
    const rect2 = tabview.dom.getBoundingClientRect();
    Replacing.set(tabviewComp, []);
    return rect2.height;
  });
  const getMaxHeight = (heights) => head(sort(heights, (a, b2) => {
    if (a > b2) {
      return -1;
    } else if (a < b2) {
      return 1;
    } else {
      return 0;
    }
  }));
  const getMaxTabviewHeight = (dialog, tabview, tablist) => {
    const documentElement$1 = documentElement(dialog).dom;
    const rootElm = ancestor(dialog, ".tox-dialog-wrap").getOr(dialog);
    const isFixed = get$e(rootElm, "position") === "fixed";
    let maxHeight;
    if (isFixed) {
      maxHeight = Math.max(documentElement$1.clientHeight, window.innerHeight);
    } else {
      maxHeight = Math.max(documentElement$1.offsetHeight, documentElement$1.scrollHeight);
    }
    const tabviewHeight = get$d(tabview);
    const isTabListBeside = tabview.dom.offsetLeft >= tablist.dom.offsetLeft + get$c(tablist);
    const currentTabHeight = isTabListBeside ? Math.max(get$d(tablist), tabviewHeight) : tabviewHeight;
    const dialogTopMargin = parseInt(get$e(dialog, "margin-top"), 10) || 0;
    const dialogBottomMargin = parseInt(get$e(dialog, "margin-bottom"), 10) || 0;
    const dialogHeight = get$d(dialog) + dialogTopMargin + dialogBottomMargin;
    const chromeHeight = dialogHeight - currentTabHeight;
    return maxHeight - chromeHeight;
  };
  const showTab = (allTabs, comp) => {
    head(allTabs).each((tab) => TabSection.showTab(comp, tab.value));
  };
  const setTabviewHeight = (tabview, height3) => {
    set$8(tabview, "height", height3 + "px");
    set$8(tabview, "flex-basis", height3 + "px");
  };
  const updateTabviewHeight = (dialogBody, tabview, maxTabHeight) => {
    ancestor(dialogBody, '[role="dialog"]').each((dialog) => {
      descendant(dialog, '[role="tablist"]').each((tablist) => {
        maxTabHeight.get().map((height3) => {
          set$8(tabview, "height", "0");
          set$8(tabview, "flex-basis", "0");
          return Math.min(height3, getMaxTabviewHeight(dialog, tabview, tablist));
        }).each((height3) => {
          setTabviewHeight(tabview, height3);
        });
      });
    });
  };
  const getTabview = (dialog) => descendant(dialog, '[role="tabpanel"]');
  const smartMode = (allTabs) => {
    const maxTabHeight = value$2();
    const extraEvents = [
      runOnAttached((comp) => {
        const dialog = comp.element;
        getTabview(dialog).each((tabview) => {
          set$8(tabview, "visibility", "hidden");
          comp.getSystem().getByDom(tabview).toOptional().each((tabviewComp) => {
            const heights = measureHeights(allTabs, tabview, tabviewComp);
            const maxTabHeightOpt = getMaxHeight(heights);
            maxTabHeightOpt.fold(maxTabHeight.clear, maxTabHeight.set);
          });
          updateTabviewHeight(dialog, tabview, maxTabHeight);
          remove$6(tabview, "visibility");
          showTab(allTabs, comp);
          requestAnimationFrame(() => {
            updateTabviewHeight(dialog, tabview, maxTabHeight);
          });
        });
      }),
      run$1(windowResize(), (comp) => {
        const dialog = comp.element;
        getTabview(dialog).each((tabview) => {
          updateTabviewHeight(dialog, tabview, maxTabHeight);
        });
      }),
      run$1(formResizeEvent, (comp, _se) => {
        const dialog = comp.element;
        getTabview(dialog).each((tabview) => {
          const oldFocus = active$1(getRootNode2(tabview));
          set$8(tabview, "visibility", "hidden");
          const oldHeight = getRaw(tabview, "height").map((h) => parseInt(h, 10));
          remove$6(tabview, "height");
          remove$6(tabview, "flex-basis");
          const newHeight = tabview.dom.getBoundingClientRect().height;
          const hasGrown2 = oldHeight.forall((h) => newHeight > h);
          if (hasGrown2) {
            maxTabHeight.set(newHeight);
            updateTabviewHeight(dialog, tabview, maxTabHeight);
          } else {
            oldHeight.each((h) => {
              setTabviewHeight(tabview, h);
            });
          }
          remove$6(tabview, "visibility");
          oldFocus.each(focus$3);
        });
      })
    ];
    const selectFirst = false;
    return {
      extraEvents,
      selectFirst
    };
  };
  const SendDataToSectionChannel = "send-data-to-section";
  const SendDataToViewChannel = "send-data-to-view";
  const renderTabPanel = (spec, dialogData, backstage) => {
    const storedValue = Cell({});
    const updateDataWithForm = (form) => {
      const formData = Representing.getValue(form);
      const validData = toValidValues(formData).getOr({});
      const currentData = storedValue.get();
      const newData = deepMerge(currentData, validData);
      storedValue.set(newData);
    };
    const setDataOnForm = (form) => {
      const tabData = storedValue.get();
      Representing.setValue(form, tabData);
    };
    const oldTab = Cell(null);
    const allTabs = map$2(spec.tabs, (tab) => {
      return {
        value: tab.name,
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-nav-item"]
        },
        components: [text$2(backstage.shared.providers.translate(tab.title))],
        view: () => {
          return [Form.sketch((parts2) => ({
            dom: {
              tag: "div",
              classes: ["tox-form"]
            },
            components: map$2(tab.items, (item3) => interpretInForm(parts2, item3, dialogData, backstage)),
            formBehaviours: derive$1([
              Keying.config({
                mode: "acyclic",
                useTabstopAt: not(isPseudoStop)
              }),
              config("TabView.form.events", [
                runOnAttached(setDataOnForm),
                runOnDetached(updateDataWithForm)
              ]),
              Receiving.config({
                channels: wrapAll([
                  {
                    key: SendDataToSectionChannel,
                    value: { onReceive: updateDataWithForm }
                  },
                  {
                    key: SendDataToViewChannel,
                    value: { onReceive: setDataOnForm }
                  }
                ])
              })
            ])
          }))];
        }
      };
    });
    const tabMode = smartMode(allTabs);
    return TabSection.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      onChangeTab: (section, button2, _viewItems) => {
        const name3 = Representing.getValue(button2);
        emitWith(section, formTabChangeEvent, {
          name: name3,
          oldName: oldTab.get()
        });
        oldTab.set(name3);
      },
      tabs: allTabs,
      components: [
        TabSection.parts.tabbar({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-nav"]
          },
          components: [Tabbar.parts.tabs({})],
          markers: {
            tabClass: "tox-tab",
            selectedClass: "tox-dialog__body-nav-item--active"
          },
          tabbarBehaviours: derive$1([Tabstopping.config({})])
        }),
        TabSection.parts.tabview({
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          }
        })
      ],
      selectFirst: tabMode.selectFirst,
      tabSectionBehaviours: derive$1([
        config("tabpanel", tabMode.extraEvents),
        Keying.config({ mode: "acyclic" }),
        Composing.config({ find: (comp) => head(TabSection.getViewItems(comp)) }),
        RepresentingConfigs.withComp(Optional.none(), (tsection) => {
          tsection.getSystem().broadcastOn([SendDataToSectionChannel], {});
          return storedValue.get();
        }, (tsection, value2) => {
          storedValue.set(value2);
          tsection.getSystem().broadcastOn([SendDataToViewChannel], {});
        })
      ])
    });
  };
  const dialogChannel = generate$6("update-dialog");
  const titleChannel = generate$6("update-title");
  const bodyChannel = generate$6("update-body");
  const footerChannel = generate$6("update-footer");
  const bodySendMessageChannel = generate$6("body-send-message");
  const renderBody = (spec, dialogId, contentId, backstage, ariaAttrs) => {
    const renderComponents2 = (incoming) => {
      const body2 = incoming.body;
      switch (body2.type) {
        case "tabpanel": {
          return [renderTabPanel(body2, incoming.initialData, backstage)];
        }
        default: {
          return [renderBodyPanel(body2, incoming.initialData, backstage)];
        }
      }
    };
    const updateState = (_comp, incoming) => Optional.some({ isTabPanel: () => incoming.body.type === "tabpanel" });
    const ariaAttributes = { "aria-live": "polite" };
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"],
        attributes: {
          ...contentId.map((x) => ({ id: x })).getOr({}),
          ...ariaAttrs ? ariaAttributes : {}
        }
      },
      components: [],
      behaviours: derive$1([
        ComposingConfigs.childAt(0),
        Reflecting.config({
          channel: `${bodyChannel}-${dialogId}`,
          updateState,
          renderComponents: renderComponents2,
          initialData: spec
        })
      ])
    };
  };
  const renderInlineBody = (spec, dialogId, contentId, backstage, ariaAttrs) => renderBody(spec, dialogId, Optional.some(contentId), backstage, ariaAttrs);
  const renderModalBody = (spec, dialogId, backstage) => {
    const bodySpec = renderBody(spec, dialogId, Optional.none(), backstage, false);
    return ModalDialog.parts.body(bodySpec);
  };
  const renderIframeBody = (spec) => {
    const bodySpec = {
      dom: {
        tag: "div",
        classes: ["tox-dialog__content-js"]
      },
      components: [{
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-iframe"]
        },
        components: [craft({
          dom: {
            tag: "iframe",
            attributes: { src: spec.url }
          },
          behaviours: derive$1([
            Tabstopping.config({}),
            Focusing.config({})
          ])
        })]
      }],
      behaviours: derive$1([Keying.config({
        mode: "acyclic",
        useTabstopAt: not(isPseudoStop)
      })])
    };
    return ModalDialog.parts.body(bodySpec);
  };
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf2 = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze, seal = Object.seal, create2 = Object.create;
  var _ref = typeof Reflect !== "undefined" && Reflect, apply = _ref.apply, construct = _ref.construct;
  if (!apply) {
    apply = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!freeze) {
    freeze = function freeze2(x) {
      return x;
    };
  }
  if (!seal) {
    seal = function seal2(x) {
      return x;
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array) {
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    var l2 = array.length;
    while (l2--) {
      var element2 = array[l2];
      if (typeof element2 === "string") {
        var lcElement = stringToLowerCase(element2);
        if (lcElement !== element2) {
          if (!isFrozen(array)) {
            array[l2] = lcElement;
          }
          element2 = lcElement;
        }
      }
      set2[element2] = true;
    }
    return set2;
  }
  function clone(object) {
    var newObject = create2(null);
    var property;
    for (property in object) {
      if (apply(hasOwnProperty2, object, [property])) {
        newObject[property] = object[property];
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf2(object);
    }
    function fallbackValue(element2) {
      console.warn("fallback value for", element2);
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze([
    "a",
    "abbr",
    "acronym",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "bdi",
    "bdo",
    "big",
    "blink",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "center",
    "cite",
    "code",
    "col",
    "colgroup",
    "content",
    "data",
    "datalist",
    "dd",
    "decorator",
    "del",
    "details",
    "dfn",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "element",
    "em",
    "fieldset",
    "figcaption",
    "figure",
    "font",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "img",
    "input",
    "ins",
    "kbd",
    "label",
    "legend",
    "li",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meter",
    "nav",
    "nobr",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "section",
    "select",
    "shadow",
    "small",
    "source",
    "spacer",
    "span",
    "strike",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "template",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "tr",
    "track",
    "tt",
    "u",
    "ul",
    "var",
    "video",
    "wbr"
  ]);
  var svg$12 = freeze([
    "svg",
    "a",
    "altglyph",
    "altglyphdef",
    "altglyphitem",
    "animatecolor",
    "animatemotion",
    "animatetransform",
    "circle",
    "clippath",
    "defs",
    "desc",
    "ellipse",
    "filter",
    "font",
    "g",
    "glyph",
    "glyphref",
    "hkern",
    "image",
    "line",
    "lineargradient",
    "marker",
    "mask",
    "metadata",
    "mpath",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialgradient",
    "rect",
    "stop",
    "style",
    "switch",
    "symbol",
    "text",
    "textpath",
    "title",
    "tref",
    "tspan",
    "view",
    "vkern"
  ]);
  var svgFilters = freeze([
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDistantLight",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence"
  ]);
  var svgDisallowed = freeze([
    "animate",
    "color-profile",
    "cursor",
    "discard",
    "fedropshadow",
    "font-face",
    "font-face-format",
    "font-face-name",
    "font-face-src",
    "font-face-uri",
    "foreignobject",
    "hatch",
    "hatchpath",
    "mesh",
    "meshgradient",
    "meshpatch",
    "meshrow",
    "missing-glyph",
    "script",
    "set",
    "solidcolor",
    "unknown",
    "use"
  ]);
  var mathMl$1 = freeze([
    "math",
    "menclose",
    "merror",
    "mfenced",
    "mfrac",
    "mglyph",
    "mi",
    "mlabeledtr",
    "mmultiscripts",
    "mn",
    "mo",
    "mover",
    "mpadded",
    "mphantom",
    "mroot",
    "mrow",
    "ms",
    "mspace",
    "msqrt",
    "mstyle",
    "msub",
    "msup",
    "msubsup",
    "mtable",
    "mtd",
    "mtext",
    "mtr",
    "munder",
    "munderover"
  ]);
  var mathMlDisallowed = freeze([
    "maction",
    "maligngroup",
    "malignmark",
    "mlongdiv",
    "mscarries",
    "mscarry",
    "msgroup",
    "mstack",
    "msline",
    "msrow",
    "semantics",
    "annotation",
    "annotation-xml",
    "mprescripts",
    "none"
  ]);
  var text2 = freeze(["#text"]);
  var html = freeze([
    "accept",
    "action",
    "align",
    "alt",
    "autocapitalize",
    "autocomplete",
    "autopictureinpicture",
    "autoplay",
    "background",
    "bgcolor",
    "border",
    "capture",
    "cellpadding",
    "cellspacing",
    "checked",
    "cite",
    "class",
    "clear",
    "color",
    "cols",
    "colspan",
    "controls",
    "controlslist",
    "coords",
    "crossorigin",
    "datetime",
    "decoding",
    "default",
    "dir",
    "disabled",
    "disablepictureinpicture",
    "disableremoteplayback",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "face",
    "for",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "id",
    "inputmode",
    "integrity",
    "ismap",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "loop",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "multiple",
    "muted",
    "name",
    "nonce",
    "noshade",
    "novalidate",
    "nowrap",
    "open",
    "optimum",
    "pattern",
    "placeholder",
    "playsinline",
    "poster",
    "preload",
    "pubdate",
    "radiogroup",
    "readonly",
    "rel",
    "required",
    "rev",
    "reversed",
    "role",
    "rows",
    "rowspan",
    "spellcheck",
    "scope",
    "selected",
    "shape",
    "size",
    "sizes",
    "span",
    "srclang",
    "start",
    "src",
    "srcset",
    "step",
    "style",
    "summary",
    "tabindex",
    "title",
    "translate",
    "type",
    "usemap",
    "valign",
    "value",
    "width",
    "xmlns",
    "slot"
  ]);
  var svg2 = freeze([
    "accent-height",
    "accumulate",
    "additive",
    "alignment-baseline",
    "ascent",
    "attributename",
    "attributetype",
    "azimuth",
    "basefrequency",
    "baseline-shift",
    "begin",
    "bias",
    "by",
    "class",
    "clip",
    "clippathunits",
    "clip-path",
    "clip-rule",
    "color",
    "color-interpolation",
    "color-interpolation-filters",
    "color-profile",
    "color-rendering",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "diffuseconstant",
    "direction",
    "display",
    "divisor",
    "dur",
    "edgemode",
    "elevation",
    "end",
    "fill",
    "fill-opacity",
    "fill-rule",
    "filter",
    "filterunits",
    "flood-color",
    "flood-opacity",
    "font-family",
    "font-size",
    "font-size-adjust",
    "font-stretch",
    "font-style",
    "font-variant",
    "font-weight",
    "fx",
    "fy",
    "g1",
    "g2",
    "glyph-name",
    "glyphref",
    "gradientunits",
    "gradienttransform",
    "height",
    "href",
    "id",
    "image-rendering",
    "in",
    "in2",
    "k",
    "k1",
    "k2",
    "k3",
    "k4",
    "kerning",
    "keypoints",
    "keysplines",
    "keytimes",
    "lang",
    "lengthadjust",
    "letter-spacing",
    "kernelmatrix",
    "kernelunitlength",
    "lighting-color",
    "local",
    "marker-end",
    "marker-mid",
    "marker-start",
    "markerheight",
    "markerunits",
    "markerwidth",
    "maskcontentunits",
    "maskunits",
    "max",
    "mask",
    "media",
    "method",
    "mode",
    "min",
    "name",
    "numoctaves",
    "offset",
    "operator",
    "opacity",
    "order",
    "orient",
    "orientation",
    "origin",
    "overflow",
    "paint-order",
    "path",
    "pathlength",
    "patterncontentunits",
    "patterntransform",
    "patternunits",
    "points",
    "preservealpha",
    "preserveaspectratio",
    "primitiveunits",
    "r",
    "rx",
    "ry",
    "radius",
    "refx",
    "refy",
    "repeatcount",
    "repeatdur",
    "restart",
    "result",
    "rotate",
    "scale",
    "seed",
    "shape-rendering",
    "specularconstant",
    "specularexponent",
    "spreadmethod",
    "startoffset",
    "stddeviation",
    "stitchtiles",
    "stop-color",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-linecap",
    "stroke-linejoin",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke",
    "stroke-width",
    "style",
    "surfacescale",
    "systemlanguage",
    "tabindex",
    "targetx",
    "targety",
    "transform",
    "transform-origin",
    "text-anchor",
    "text-decoration",
    "text-rendering",
    "textlength",
    "type",
    "u1",
    "u2",
    "unicode",
    "values",
    "viewbox",
    "visibility",
    "version",
    "vert-adv-y",
    "vert-origin-x",
    "vert-origin-y",
    "width",
    "word-spacing",
    "wrap",
    "writing-mode",
    "xchannelselector",
    "ychannelselector",
    "x",
    "x1",
    "x2",
    "xmlns",
    "y",
    "y1",
    "y2",
    "z",
    "zoomandpan"
  ]);
  var mathMl = freeze([
    "accent",
    "accentunder",
    "align",
    "bevelled",
    "close",
    "columnsalign",
    "columnlines",
    "columnspan",
    "denomalign",
    "depth",
    "dir",
    "display",
    "displaystyle",
    "encoding",
    "fence",
    "frame",
    "height",
    "href",
    "id",
    "largeop",
    "length",
    "linethickness",
    "lspace",
    "lquote",
    "mathbackground",
    "mathcolor",
    "mathsize",
    "mathvariant",
    "maxsize",
    "minsize",
    "movablelimits",
    "notation",
    "numalign",
    "open",
    "rowalign",
    "rowlines",
    "rowspacing",
    "rowspan",
    "rspace",
    "rquote",
    "scriptlevel",
    "scriptminsize",
    "scriptsizemultiplier",
    "selection",
    "separator",
    "separators",
    "stretchy",
    "subscriptshift",
    "supscriptshift",
    "symmetric",
    "voffset",
    "width",
    "xmlns"
  ]);
  var xml = freeze([
    "xlink:href",
    "xml:id",
    "xlink:title",
    "xml:space",
    "xmlns:xlink"
  ]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
  var DOCTYPE_NAME = seal(/^html$/i);
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
    if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    var suffix2 = null;
    var ATTR_NAME = "data-tt-policy-suffix";
    if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
      suffix2 = document2.currentScript.getAttribute(ATTR_NAME);
    }
    var policyName = "dompurify" + (suffix2 ? "#" + suffix2 : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html2) {
          return html2;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  function createDOMPurify() {
    var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    var DOMPurify = function DOMPurify2(root2) {
      return createDOMPurify(root2);
    };
    DOMPurify.version = "2.3.8";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    var originalDocument = window2.document;
    var document2 = window2.document;
    var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter2 = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
    var ElementPrototype = Element2.prototype;
    var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    var getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      var template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
    var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var documentMode = {};
    try {
      documentMode = clone(document2).documentMode ? document2.documentMode : {};
    } catch (_2) {
    }
    var hooks = {};
    DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$12), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text2)));
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg2), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    var FORBID_TAGS = null;
    var FORBID_ATTR = null;
    var ALLOW_ARIA_ATTR = true;
    var ALLOW_DATA_ATTR = true;
    var ALLOW_UNKNOWN_PROTOCOLS = false;
    var SAFE_FOR_TEMPLATES = false;
    var WHOLE_DOCUMENT = false;
    var SET_CONFIG = false;
    var FORCE_BODY = false;
    var RETURN_DOM = false;
    var RETURN_DOM_FRAGMENT = false;
    var RETURN_TRUSTED_TYPE = false;
    var SANITIZE_DOM = true;
    var KEEP_CONTENT = true;
    var IN_PLACE = false;
    var USE_PROFILES = {};
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, [
      "annotation-xml",
      "audio",
      "colgroup",
      "desc",
      "foreignobject",
      "head",
      "iframe",
      "math",
      "mi",
      "mn",
      "mo",
      "ms",
      "mtext",
      "noembed",
      "noframes",
      "noscript",
      "plaintext",
      "script",
      "style",
      "svg",
      "template",
      "thead",
      "title",
      "video",
      "xmp"
    ]);
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, [
      "audio",
      "video",
      "img",
      "source",
      "image",
      "track"
    ]);
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [
      "alt",
      "class",
      "for",
      "id",
      "label",
      "name",
      "pattern",
      "placeholder",
      "role",
      "summary",
      "title",
      "value",
      "style",
      "xmlns"
    ]);
    var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = [
      "application/xhtml+xml",
      "text/html"
    ];
    var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    var transformCaseFunc;
    var CONFIG = null;
    var formElement = document2.createElement("form");
    var isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    var _parseConfig = function _parseConfig2(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || _typeof(cfg) !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
        return x;
      } : stringToLowerCase;
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text2));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$12);
          addToSet(ALLOWED_ATTR, svg2);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg2);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, [
          "html",
          "head",
          "body"
        ]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext"
    ]);
    var HTML_INTEGRATION_POINTS = addToSet({}, [
      "foreignobject",
      "desc",
      "title",
      "annotation-xml"
    ]);
    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [
      "title",
      "style",
      "font",
      "a",
      "script"
    ]);
    var ALL_SVG_TAGS = addToSet({}, svg$12);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    var _checkValidNamespace = function _checkValidNamespace2(element2) {
      var parent2 = getParentNode2(element2);
      if (!parent2 || !parent2.tagName) {
        parent2 = {
          namespaceURI: HTML_NAMESPACE,
          tagName: "template"
        };
      }
      var tagName = stringToLowerCase(element2.tagName);
      var parentTagName = stringToLowerCase(parent2.tagName);
      if (element2.namespaceURI === SVG_NAMESPACE) {
        if (parent2.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent2.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element2.namespaceURI === MATHML_NAMESPACE) {
        if (parent2.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent2.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element2.namespaceURI === HTML_NAMESPACE) {
        if (parent2.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent2.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      return false;
    };
    var _forceRemove = function _forceRemove2(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        node.parentNode.removeChild(node);
      } catch (_2) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_3) {
          node.remove();
        }
      }
    };
    var _removeAttribute = function _removeAttribute2(name3, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name3),
          from: node
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }
      node.removeAttribute(name3);
      if (name3 === "is" && !ALLOWED_ATTR[name3]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_2) {
          }
        } else {
          try {
            node.setAttribute(name3, "");
          } catch (_2) {
          }
        }
      }
    };
    var _initDocument = function _initDocument2(dirty) {
      var doc;
      var leadingWhitespace;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
        } catch (_2) {
        }
      }
      var body2 = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body2.insertBefore(document2.createTextNode(leadingWhitespace), body2.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body2;
    };
    var _createIterator = function _createIterator2(root2) {
      return createNodeIterator.call(root2.ownerDocument || root2, root2, NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT, null, false);
    };
    var _isClobbered = function _isClobbered2(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
    };
    var _isNode = function _isNode2(object) {
      return _typeof(Node2) === "object" ? object instanceof Node2 : object && _typeof(object) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
    };
    var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], function(hook) {
        hook.call(DOMPurify, currentNode, data2, CONFIG);
      });
    };
    var _sanitizeElements = function _sanitizeElements2(currentNode) {
      var content;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
        _forceRemove(currentNode);
        return true;
      }
      var tagName = transformCaseFunc(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
            return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
            return false;
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode2(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            var childCount = childNodes.length;
            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, " ");
        content = stringReplace(content, ERB_EXPR$1, " ");
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    };
    var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value2) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value2 in document2 || value2 in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
        ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
        ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value2) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value2)))
          ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName])
        ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
        ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value2, "data:") === 0 && DATA_URI_TAGS[lcTag])
        ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value2, ATTR_WHITESPACE$1, "")))
        ;
      else if (!value2)
        ;
      else {
        return false;
      }
      return true;
    };
    var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
      return tagName.indexOf("-") > 0;
    };
    var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      var attr2;
      var value2;
      var lcName;
      var l2;
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      var attributes = currentNode.attributes;
      if (!attributes) {
        return;
      }
      var hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l2 = attributes.length;
      while (l2--) {
        attr2 = attributes[l2];
        var _attr = attr2, name3 = _attr.name, namespaceURI = _attr.namespaceURI;
        value2 = name3 === "value" ? attr2.value : stringTrim(attr2.value);
        lcName = transformCaseFunc(name3);
        var initValue = value2;
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value2;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value2 = hookEvent.attrValue;
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        if (!hookEvent.keepAttr) {
          _removeAttribute(name3, currentNode);
          continue;
        }
        if (regExpTest(/\/>/i, value2)) {
          _removeAttribute(name3, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          value2 = stringReplace(value2, MUSTACHE_EXPR$1, " ");
          value2 = stringReplace(value2, ERB_EXPR$1, " ");
        }
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value2)) {
          _removeAttribute(name3, currentNode);
          continue;
        }
        if (value2 !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name3, value2);
            } else {
              currentNode.setAttribute(name3, value2);
            }
          } catch (_2) {
            _removeAttribute(name3, currentNode);
          }
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    };
    var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      var shadowNode;
      var shadowIterator = _createIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    };
    DOMPurify.sanitize = function(dirty, cfg) {
      var body2;
      var importedNode;
      var currentNode;
      var oldNode;
      var returnNode;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString !== "function") {
          throw typeErrorCreate("toString is not a function");
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        }
      }
      if (!DOMPurify.isSupported) {
        if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
          if (typeof dirty === "string") {
            return window2.toStaticHTML(dirty);
          }
          if (_isNode(dirty)) {
            return window2.toStaticHTML(dirty.outerHTML);
          }
        }
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body2 = _initDocument("<!---->");
        importedNode = body2.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
          body2 = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body2 = importedNode;
        } else {
          body2.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body2 = _initDocument(dirty);
        if (!body2) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body2 && FORCE_BODY) {
        _forceRemove(body2.firstChild);
      }
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body2);
      while (currentNode = nodeIterator.nextNode()) {
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
        oldNode = currentNode;
      }
      oldNode = null;
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body2.ownerDocument);
          while (body2.firstChild) {
            returnNode.appendChild(body2.firstChild);
          }
        } else {
          returnNode = body2;
        }
        if (ALLOWED_ATTR.shadowroot) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      var serializedHTML = WHOLE_DOCUMENT ? body2.outerHTML : body2.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body2.ownerDocument && body2.ownerDocument.doctype && body2.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body2.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body2.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function(cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr2, value2) {
      if (!CONFIG) {
        _parseConfig({});
      }
      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr2);
      return _isValidAttribute(lcTag, lcName, value2);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  const sanitizeHtmlString = (html2) => purify().sanitize(html2);
  const isTouch = global$5.deviceType.isTouch();
  const hiddenHeader = (title2, close2) => ({
    dom: {
      tag: "div",
      styles: { display: "none" },
      classes: ["tox-dialog__header"]
    },
    components: [
      title2,
      close2
    ]
  });
  const pClose = (onClose, providersBackstage) => ModalDialog.parts.close(Button2.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        "type": "button",
        "aria-label": providersBackstage.translate("Close")
      }
    },
    action: onClose,
    buttonBehaviours: derive$1([Tabstopping.config({})])
  }));
  const pUntitled = () => ModalDialog.parts.title({
    dom: {
      tag: "div",
      classes: ["tox-dialog__title"],
      innerHtml: "",
      styles: { display: "none" }
    }
  });
  const pBodyMessage = (message, providersBackstage) => ModalDialog.parts.body({
    dom: {
      tag: "div",
      classes: ["tox-dialog__body"]
    },
    components: [{
      dom: {
        tag: "div",
        classes: ["tox-dialog__body-content"]
      },
      components: [{ dom: fromHtml(`<p>${sanitizeHtmlString(providersBackstage.translate(message))}</p>`) }]
    }]
  });
  const pFooter = (buttons) => ModalDialog.parts.footer({
    dom: {
      tag: "div",
      classes: ["tox-dialog__footer"]
    },
    components: buttons
  });
  const pFooterGroup = (startButtons, endButtons) => [
    Container.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-start"]
      },
      components: startButtons
    }),
    Container.sketch({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer-end"]
      },
      components: endButtons
    })
  ];
  const renderDialog$1 = (spec) => {
    const dialogClass = "tox-dialog";
    const blockerClass = dialogClass + "-wrap";
    const blockerBackdropClass = blockerClass + "__backdrop";
    const scrollLockClass = dialogClass + "__disable-scroll";
    return ModalDialog.sketch({
      lazySink: spec.lazySink,
      onEscape: (comp) => {
        spec.onEscape(comp);
        return Optional.some(true);
      },
      useTabstopAt: (elem) => !isPseudoStop(elem),
      firstTabstop: spec.firstTabstop,
      dom: {
        tag: "div",
        classes: [dialogClass].concat(spec.extraClasses),
        styles: {
          position: "relative",
          ...spec.extraStyles
        }
      },
      components: [
        spec.header,
        spec.body,
        ...spec.footer.toArray()
      ],
      parts: {
        blocker: {
          dom: fromHtml(`<div class="${blockerClass}"></div>`),
          components: [{
            dom: {
              tag: "div",
              classes: isTouch ? [
                blockerBackdropClass,
                blockerBackdropClass + "--opaque"
              ] : [blockerBackdropClass]
            }
          }]
        }
      },
      dragBlockClass: blockerClass,
      modalBehaviours: derive$1([
        Focusing.config({}),
        config("dialog-events", spec.dialogEvents.concat([runOnSource(focusin(), (comp, _se) => {
          Keying.focusIn(comp);
        })])),
        config("scroll-lock", [
          runOnAttached(() => {
            add$2(body(), scrollLockClass);
          }),
          runOnDetached(() => {
            remove$2(body(), scrollLockClass);
          })
        ]),
        ...spec.extraBehaviours
      ]),
      eventOrder: {
        [execute$5()]: ["dialog-events"],
        [attachedToDom()]: [
          "scroll-lock",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [detachedFromDom()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "scroll-lock"
        ],
        ...spec.eventOrder
      }
    });
  };
  const renderClose = (providersBackstage) => Button2.sketch({
    dom: {
      tag: "button",
      classes: [
        "tox-button",
        "tox-button--icon",
        "tox-button--naked"
      ],
      attributes: {
        "type": "button",
        "aria-label": providersBackstage.translate("Close"),
        "title": providersBackstage.translate("Close")
      }
    },
    buttonBehaviours: derive$1([Tabstopping.config({})]),
    components: [render$3("close", {
      tag: "div",
      classes: ["tox-icon"]
    }, providersBackstage.icons)],
    action: (comp) => {
      emit(comp, formCancelEvent);
    }
  });
  const renderTitle = (spec, dialogId, titleId, providersBackstage) => {
    const renderComponents2 = (data2) => [text$2(providersBackstage.translate(data2.title))];
    return {
      dom: {
        tag: "div",
        classes: ["tox-dialog__title"],
        attributes: { ...titleId.map((x) => ({ id: x })).getOr({}) }
      },
      components: [],
      behaviours: derive$1([Reflecting.config({
        channel: `${titleChannel}-${dialogId}`,
        initialData: spec,
        renderComponents: renderComponents2
      })])
    };
  };
  const renderDragHandle = () => ({ dom: fromHtml('<div class="tox-dialog__draghandle"></div>') });
  const renderInlineHeader = (spec, dialogId, titleId, providersBackstage) => Container.sketch({
    dom: fromHtml('<div class="tox-dialog__header"></div>'),
    components: [
      renderTitle(spec, dialogId, Optional.some(titleId), providersBackstage),
      renderDragHandle(),
      renderClose(providersBackstage)
    ],
    containerBehaviours: derive$1([Dragging.config({
      mode: "mouse",
      blockerClass: "blocker",
      getTarget: (handle2) => {
        return closest$1(handle2, '[role="dialog"]').getOrDie();
      },
      snaps: {
        getSnapPoints: () => [],
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top"
      }
    })])
  });
  const renderModalHeader = (spec, dialogId, providersBackstage) => {
    const pTitle = ModalDialog.parts.title(renderTitle(spec, dialogId, Optional.none(), providersBackstage));
    const pHandle = ModalDialog.parts.draghandle(renderDragHandle());
    const pClose2 = ModalDialog.parts.close(renderClose(providersBackstage));
    const components2 = [pTitle].concat(spec.draggable ? [pHandle] : []).concat([pClose2]);
    return Container.sketch({
      dom: fromHtml('<div class="tox-dialog__header"></div>'),
      components: components2
    });
  };
  const getHeader = (title2, dialogId, backstage) => renderModalHeader({
    title: backstage.shared.providers.translate(title2),
    draggable: backstage.dialog.isDraggableModal()
  }, dialogId, backstage.shared.providers);
  const getBusySpec = (message, bs, providers) => ({
    dom: {
      tag: "div",
      classes: ["tox-dialog__busy-spinner"],
      attributes: { "aria-label": providers.translate(message) },
      styles: {
        left: "0px",
        right: "0px",
        bottom: "0px",
        top: "0px",
        position: "absolute"
      }
    },
    behaviours: bs,
    components: [{ dom: fromHtml('<div class="tox-spinner"><div></div><div></div><div></div></div>') }]
  });
  const getEventExtras = (lazyDialog, providers, extra) => ({
    onClose: () => extra.closeWindow(),
    onBlock: (blockEvent) => {
      ModalDialog.setBusy(lazyDialog(), (_comp, bs) => getBusySpec(blockEvent.message, bs, providers));
    },
    onUnblock: () => {
      ModalDialog.setIdle(lazyDialog());
    }
  });
  const renderModalDialog = (spec, initialData, dialogEvents, backstage) => {
    const updateState = (_comp, incoming) => Optional.some(incoming);
    return build$1(renderDialog$1({
      ...spec,
      firstTabstop: 1,
      lazySink: backstage.shared.getSink,
      extraBehaviours: [
        Reflecting.config({
          channel: `${dialogChannel}-${spec.id}`,
          updateState,
          initialData
        }),
        RepresentingConfigs.memory({}),
        ...spec.extraBehaviours
      ],
      onEscape: (comp) => {
        emit(comp, formCancelEvent);
      },
      dialogEvents,
      eventOrder: {
        [receive()]: [
          Reflecting.name(),
          Receiving.name()
        ],
        [attachedToDom()]: [
          "scroll-lock",
          Reflecting.name(),
          "messages",
          "dialog-events",
          "alloy.base.behaviour"
        ],
        [detachedFromDom()]: [
          "alloy.base.behaviour",
          "dialog-events",
          "messages",
          Reflecting.name(),
          "scroll-lock"
        ]
      }
    }));
  };
  const mapMenuButtons = (buttons, menuItemStates = {}) => {
    const mapItems = (button2) => {
      const items = map$2(button2.items, (item3) => {
        const cell = get$g(menuItemStates, item3.name).getOr(Cell(false));
        return {
          ...item3,
          storage: cell
        };
      });
      return {
        ...button2,
        items
      };
    };
    return map$2(buttons, (button2) => {
      return button2.type === "menu" ? mapItems(button2) : button2;
    });
  };
  const extractCellsToObject = (buttons) => foldl(buttons, (acc, button2) => {
    if (button2.type === "menu") {
      const menuButton = button2;
      return foldl(menuButton.items, (innerAcc, item3) => {
        innerAcc[item3.name] = item3.storage;
        return innerAcc;
      }, acc);
    }
    return acc;
  }, {});
  const initCommonEvents = (fireApiEvent, extras) => [
    runWithTarget(focusin(), onFocus),
    fireApiEvent(formCloseEvent, (_api, spec, _event, self3) => {
      active$1(getRootNode2(self3.element)).fold(noop2, blur$1);
      extras.onClose();
      spec.onClose();
    }),
    fireApiEvent(formCancelEvent, (api2, spec, _event, self3) => {
      spec.onCancel(api2);
      emit(self3, formCloseEvent);
    }),
    run$1(formUnblockEvent, (_c, _se) => extras.onUnblock()),
    run$1(formBlockEvent, (_c, se) => extras.onBlock(se.event))
  ];
  const initUrlDialog = (getInstanceApi, extras) => {
    const fireApiEvent = (eventName, f2) => run$1(eventName, (c, se) => {
      withSpec(c, (spec, _c) => {
        f2(getInstanceApi(), spec, se.event, c);
      });
    });
    const withSpec = (c, f2) => {
      Reflecting.getState(c).get().each((currentDialog) => {
        f2(currentDialog, c);
      });
    };
    return [
      ...initCommonEvents(fireApiEvent, extras),
      fireApiEvent(formActionEvent, (api2, spec, event) => {
        spec.onAction(api2, { name: event.name });
      })
    ];
  };
  const initDialog = (getInstanceApi, extras, getSink2) => {
    const fireApiEvent = (eventName, f2) => run$1(eventName, (c, se) => {
      withSpec(c, (spec, _c) => {
        f2(getInstanceApi(), spec, se.event, c);
      });
    });
    const withSpec = (c, f2) => {
      Reflecting.getState(c).get().each((currentDialogInit) => {
        f2(currentDialogInit.internalDialog, c);
      });
    };
    return [
      ...initCommonEvents(fireApiEvent, extras),
      fireApiEvent(formSubmitEvent, (api2, spec) => spec.onSubmit(api2)),
      fireApiEvent(formChangeEvent, (api2, spec, event) => {
        spec.onChange(api2, { name: event.name });
      }),
      fireApiEvent(formActionEvent, (api2, spec, event, component) => {
        const focusIn2 = () => Keying.focusIn(component);
        const isDisabled3 = (focused) => has$1(focused, "disabled") || getOpt(focused, "aria-disabled").exists((val) => val === "true");
        const rootNode = getRootNode2(component.element);
        const current = active$1(rootNode);
        spec.onAction(api2, {
          name: event.name,
          value: event.value
        });
        active$1(rootNode).fold(focusIn2, (focused) => {
          if (isDisabled3(focused)) {
            focusIn2();
          } else if (current.exists((cur) => contains2(focused, cur) && isDisabled3(cur))) {
            focusIn2();
          } else {
            getSink2().toOptional().filter((sink) => !contains2(sink.element, focused)).each(focusIn2);
          }
        });
      }),
      fireApiEvent(formTabChangeEvent, (api2, spec, event) => {
        spec.onTabChange(api2, {
          newTabName: event.name,
          oldTabName: event.oldName
        });
      }),
      runOnDetached((component) => {
        const api2 = getInstanceApi();
        Representing.setValue(component, api2.getData());
      })
    ];
  };
  const SilverDialogEvents = {
    initUrlDialog,
    initDialog
  };
  const makeButton = (button2, backstage) => renderFooterButton(button2, button2.type, backstage);
  const lookup = (compInSystem, footerButtons, buttonName) => find$5(footerButtons, (button2) => button2.name === buttonName).bind((memButton) => memButton.memento.getOpt(compInSystem));
  const renderComponents = (_data, state2) => {
    const footerButtons = state2.map((s) => s.footerButtons).getOr([]);
    const buttonGroups = partition$3(footerButtons, (button2) => button2.align === "start");
    const makeGroup = (edge2, buttons) => Container.sketch({
      dom: {
        tag: "div",
        classes: [`tox-dialog__footer-${edge2}`]
      },
      components: map$2(buttons, (button2) => button2.memento.asSpec())
    });
    const startButtons = makeGroup("start", buttonGroups.pass);
    const endButtons = makeGroup("end", buttonGroups.fail);
    return [
      startButtons,
      endButtons
    ];
  };
  const renderFooter = (initSpec, dialogId, backstage) => {
    const updateState = (comp, data2) => {
      const footerButtons = map$2(data2.buttons, (button2) => {
        const memButton = record(makeButton(button2, backstage));
        return {
          name: button2.name,
          align: button2.align,
          memento: memButton
        };
      });
      const lookupByName = (buttonName) => lookup(comp, footerButtons, buttonName);
      return Optional.some({
        lookupByName,
        footerButtons
      });
    };
    return {
      dom: fromHtml('<div class="tox-dialog__footer"></div>'),
      components: [],
      behaviours: derive$1([Reflecting.config({
        channel: `${footerChannel}-${dialogId}`,
        initialData: initSpec,
        updateState,
        renderComponents
      })])
    };
  };
  const renderInlineFooter = (initSpec, dialogId, backstage) => renderFooter(initSpec, dialogId, backstage);
  const renderModalFooter = (initSpec, dialogId, backstage) => ModalDialog.parts.footer(renderFooter(initSpec, dialogId, backstage));
  const getCompByName = (access, name3) => {
    const root2 = access.getRoot();
    if (root2.getSystem().isConnected()) {
      const form = Composing.getCurrent(access.getFormWrapper()).getOr(access.getFormWrapper());
      return Form.getField(form, name3).orThunk(() => {
        const footer = access.getFooter();
        const footerState = Reflecting.getState(footer).get();
        return footerState.bind((f2) => f2.lookupByName(name3));
      });
    } else {
      return Optional.none();
    }
  };
  const validateData$1 = (access, data2) => {
    const root2 = access.getRoot();
    return Reflecting.getState(root2).get().map((dialogState) => getOrDie(asRaw("data", dialogState.dataValidator, data2))).getOr(data2);
  };
  const getDialogApi = (access, doRedial, menuItemStates) => {
    const withRoot = (f2) => {
      const root2 = access.getRoot();
      if (root2.getSystem().isConnected()) {
        f2(root2);
      }
    };
    const getData2 = () => {
      const root2 = access.getRoot();
      const valueComp = root2.getSystem().isConnected() ? access.getFormWrapper() : root2;
      const representedValues = Representing.getValue(valueComp);
      const menuItemCurrentState = map$1(menuItemStates, (cell) => cell.get());
      return {
        ...representedValues,
        ...menuItemCurrentState
      };
    };
    const setData = (newData) => {
      withRoot((_2) => {
        const prevData = instanceApi.getData();
        const mergedData = deepMerge(prevData, newData);
        const newInternalData = validateData$1(access, mergedData);
        const form = access.getFormWrapper();
        Representing.setValue(form, newInternalData);
        each(menuItemStates, (v, k) => {
          if (has$2(mergedData, k)) {
            v.set(mergedData[k]);
          }
        });
      });
    };
    const setEnabled = (name3, state2) => {
      getCompByName(access, name3).each(state2 ? Disabling.enable : Disabling.disable);
    };
    const focus2 = (name3) => {
      getCompByName(access, name3).each(Focusing.focus);
    };
    const block2 = (message) => {
      if (!isString2(message)) {
        throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
      }
      withRoot((root2) => {
        emitWith(root2, formBlockEvent, { message });
      });
    };
    const unblock2 = () => {
      withRoot((root2) => {
        emit(root2, formUnblockEvent);
      });
    };
    const showTab2 = (name3) => {
      withRoot((_2) => {
        const body2 = access.getBody();
        const bodyState = Reflecting.getState(body2);
        if (bodyState.get().exists((b2) => b2.isTabPanel())) {
          Composing.getCurrent(body2).each((tabSection) => {
            TabSection.showTab(tabSection, name3);
          });
        }
      });
    };
    const redial = (d) => {
      withRoot((root2) => {
        const id = access.getId();
        const dialogInit = doRedial(d);
        const storedMenuButtons = mapMenuButtons(dialogInit.internalDialog.buttons, menuItemStates);
        root2.getSystem().broadcastOn([`${dialogChannel}-${id}`], dialogInit);
        root2.getSystem().broadcastOn([`${titleChannel}-${id}`], dialogInit.internalDialog);
        root2.getSystem().broadcastOn([`${bodyChannel}-${id}`], dialogInit.internalDialog);
        root2.getSystem().broadcastOn([`${footerChannel}-${id}`], {
          ...dialogInit.internalDialog,
          buttons: storedMenuButtons
        });
        instanceApi.setData(dialogInit.initialData);
      });
    };
    const close2 = () => {
      withRoot((root2) => {
        emit(root2, formCloseEvent);
      });
    };
    const instanceApi = {
      getData: getData2,
      setData,
      setEnabled,
      focus: focus2,
      block: block2,
      unblock: unblock2,
      showTab: showTab2,
      redial,
      close: close2,
      toggleFullscreen: access.toggleFullscreen
    };
    return instanceApi;
  };
  const getDialogSizeClasses = (size) => {
    switch (size) {
      case "large":
        return ["tox-dialog--width-lg"];
      case "medium":
        return ["tox-dialog--width-md"];
      default:
        return [];
    }
  };
  const renderDialog = (dialogInit, extra, backstage) => {
    const dialogId = generate$6("dialog");
    const internalDialog = dialogInit.internalDialog;
    const header = getHeader(internalDialog.title, dialogId, backstage);
    const body2 = renderModalBody({
      body: internalDialog.body,
      initialData: internalDialog.initialData
    }, dialogId, backstage);
    const storedMenuButtons = mapMenuButtons(internalDialog.buttons);
    const objOfCells = extractCellsToObject(storedMenuButtons);
    const footer = renderModalFooter({ buttons: storedMenuButtons }, dialogId, backstage);
    const dialogEvents = SilverDialogEvents.initDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra), backstage.shared.getSink);
    const dialogSize = getDialogSizeClasses(internalDialog.size);
    const spec = {
      id: dialogId,
      header,
      body: body2,
      footer: Optional.some(footer),
      extraClasses: dialogSize,
      extraBehaviours: [],
      extraStyles: {}
    };
    const dialog = renderModalDialog(spec, dialogInit, dialogEvents, backstage);
    const modalAccess = (() => {
      const getForm = () => {
        const outerForm = ModalDialog.getBody(dialog);
        return Composing.getCurrent(outerForm).getOr(outerForm);
      };
      const toggleFullscreen = () => {
        const fullscreenClass = "tox-dialog--fullscreen";
        const sugarBody = SugarElement.fromDom(dialog.element.dom);
        if (!has(sugarBody, fullscreenClass)) {
          remove$1(sugarBody, dialogSize);
          add$2(sugarBody, fullscreenClass);
        } else {
          remove$2(sugarBody, fullscreenClass);
          add$1(sugarBody, dialogSize);
        }
      };
      return {
        getId: constant$1(dialogId),
        getRoot: constant$1(dialog),
        getBody: () => ModalDialog.getBody(dialog),
        getFooter: () => ModalDialog.getFooter(dialog),
        getFormWrapper: getForm,
        toggleFullscreen
      };
    })();
    const instanceApi = getDialogApi(modalAccess, extra.redial, objOfCells);
    return {
      dialog,
      instanceApi
    };
  };
  const renderInlineDialog = (dialogInit, extra, backstage, ariaAttrs) => {
    const dialogId = generate$6("dialog");
    const dialogLabelId = generate$6("dialog-label");
    const dialogContentId = generate$6("dialog-content");
    const internalDialog = dialogInit.internalDialog;
    const updateState = (_comp, incoming) => Optional.some(incoming);
    const memHeader = record(renderInlineHeader({
      title: internalDialog.title,
      draggable: true
    }, dialogId, dialogLabelId, backstage.shared.providers));
    const memBody = record(renderInlineBody({
      body: internalDialog.body,
      initialData: internalDialog.initialData
    }, dialogId, dialogContentId, backstage, ariaAttrs));
    const storagedMenuButtons = mapMenuButtons(internalDialog.buttons);
    const objOfCells = extractCellsToObject(storagedMenuButtons);
    const memFooter = record(renderInlineFooter({ buttons: storagedMenuButtons }, dialogId, backstage));
    const dialogEvents = SilverDialogEvents.initDialog(() => instanceApi, {
      onBlock: (event) => {
        Blocking.block(dialog, (_comp, bs) => getBusySpec(event.message, bs, backstage.shared.providers));
      },
      onUnblock: () => {
        Blocking.unblock(dialog);
      },
      onClose: () => extra.closeWindow()
    }, backstage.shared.getSink);
    const inlineClass = "tox-dialog-inline";
    const dialog = build$1({
      dom: {
        tag: "div",
        classes: [
          "tox-dialog",
          inlineClass
        ],
        attributes: {
          role: "dialog",
          ["aria-labelledby"]: dialogLabelId,
          ["aria-describedby"]: dialogContentId
        }
      },
      eventOrder: {
        [receive()]: [
          Reflecting.name(),
          Receiving.name()
        ],
        [execute$5()]: ["execute-on-form"],
        [attachedToDom()]: [
          "reflecting",
          "execute-on-form"
        ]
      },
      behaviours: derive$1([
        Keying.config({
          mode: "cyclic",
          onEscape: (c) => {
            emit(c, formCloseEvent);
            return Optional.some(true);
          },
          useTabstopAt: (elem) => !isPseudoStop(elem) && (name$3(elem) !== "button" || get$f(elem, "disabled") !== "disabled"),
          firstTabstop: 1
        }),
        Reflecting.config({
          channel: `${dialogChannel}-${dialogId}`,
          updateState,
          initialData: dialogInit
        }),
        Focusing.config({}),
        config("execute-on-form", dialogEvents.concat([runOnSource(focusin(), (comp, _se) => {
          Keying.focusIn(comp);
        })])),
        Blocking.config({ getRoot: () => Optional.some(dialog) }),
        Replacing.config({}),
        RepresentingConfigs.memory({})
      ]),
      components: [
        memHeader.asSpec(),
        memBody.asSpec(),
        memFooter.asSpec()
      ]
    });
    const toggleFullscreen = () => {
      const fullscreenClass = "tox-dialog--fullscreen";
      const sugarBody = SugarElement.fromDom(dialog.element.dom);
      if (!hasAll(sugarBody, [fullscreenClass])) {
        remove$1(sugarBody, [inlineClass]);
        add$1(sugarBody, [fullscreenClass]);
      } else {
        remove$1(sugarBody, [fullscreenClass]);
        add$1(sugarBody, [inlineClass]);
      }
    };
    const instanceApi = getDialogApi({
      getId: constant$1(dialogId),
      getRoot: constant$1(dialog),
      getFooter: () => memFooter.get(dialog),
      getBody: () => memBody.get(dialog),
      getFormWrapper: () => {
        const body2 = memBody.get(dialog);
        return Composing.getCurrent(body2).getOr(body2);
      },
      toggleFullscreen
    }, extra.redial, objOfCells);
    return {
      dialog,
      instanceApi
    };
  };
  var global2 = tinymce.util.Tools.resolve("tinymce.util.URI");
  const getUrlDialogApi = (root2) => {
    const withRoot = (f2) => {
      if (root2.getSystem().isConnected()) {
        f2(root2);
      }
    };
    const block2 = (message) => {
      if (!isString2(message)) {
        throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
      }
      withRoot((root3) => {
        emitWith(root3, formBlockEvent, { message });
      });
    };
    const unblock2 = () => {
      withRoot((root3) => {
        emit(root3, formUnblockEvent);
      });
    };
    const close2 = () => {
      withRoot((root3) => {
        emit(root3, formCloseEvent);
      });
    };
    const sendMessage = (data2) => {
      withRoot((root3) => {
        root3.getSystem().broadcastOn([bodySendMessageChannel], data2);
      });
    };
    return {
      block: block2,
      unblock: unblock2,
      close: close2,
      sendMessage
    };
  };
  const SUPPORTED_MESSAGE_ACTIONS = [
    "insertContent",
    "setContent",
    "execCommand",
    "close",
    "block",
    "unblock"
  ];
  const isSupportedMessage = (data2) => isObject2(data2) && SUPPORTED_MESSAGE_ACTIONS.indexOf(data2.mceAction) !== -1;
  const isCustomMessage = (data2) => !isSupportedMessage(data2) && isObject2(data2) && has$2(data2, "mceAction");
  const handleMessage = (editor, api2, data2) => {
    switch (data2.mceAction) {
      case "insertContent":
        editor.insertContent(data2.content);
        break;
      case "setContent":
        editor.setContent(data2.content);
        break;
      case "execCommand":
        const ui = isBoolean2(data2.ui) ? data2.ui : false;
        editor.execCommand(data2.cmd, ui, data2.value);
        break;
      case "close":
        api2.close();
        break;
      case "block":
        api2.block(data2.message);
        break;
      case "unblock":
        api2.unblock();
        break;
    }
  };
  const renderUrlDialog = (internalDialog, extra, editor, backstage) => {
    const dialogId = generate$6("dialog");
    const header = getHeader(internalDialog.title, dialogId, backstage);
    const body2 = renderIframeBody(internalDialog);
    const footer = internalDialog.buttons.bind((buttons) => {
      if (buttons.length === 0) {
        return Optional.none();
      } else {
        return Optional.some(renderModalFooter({ buttons }, dialogId, backstage));
      }
    });
    const dialogEvents = SilverDialogEvents.initUrlDialog(() => instanceApi, getEventExtras(() => dialog, backstage.shared.providers, extra));
    const styles2 = {
      ...internalDialog.height.fold(() => ({}), (height3) => ({
        "height": height3 + "px",
        "max-height": height3 + "px"
      })),
      ...internalDialog.width.fold(() => ({}), (width3) => ({
        "width": width3 + "px",
        "max-width": width3 + "px"
      }))
    };
    const classes2 = internalDialog.width.isNone() && internalDialog.height.isNone() ? ["tox-dialog--width-lg"] : [];
    const iframeUri = new global2(internalDialog.url, { base_uri: new global2(window.location.href) });
    const iframeDomain = `${iframeUri.protocol}://${iframeUri.host}${iframeUri.port ? ":" + iframeUri.port : ""}`;
    const messageHandlerUnbinder = unbindable();
    const extraBehaviours = [
      config("messages", [
        runOnAttached(() => {
          const unbind2 = bind2(SugarElement.fromDom(window), "message", (e) => {
            if (iframeUri.isSameOrigin(new global2(e.raw.origin))) {
              const data2 = e.raw.data;
              if (isSupportedMessage(data2)) {
                handleMessage(editor, instanceApi, data2);
              } else if (isCustomMessage(data2)) {
                internalDialog.onMessage(instanceApi, data2);
              }
            }
          });
          messageHandlerUnbinder.set(unbind2);
        }),
        runOnDetached(messageHandlerUnbinder.clear)
      ]),
      Receiving.config({
        channels: {
          [bodySendMessageChannel]: {
            onReceive: (comp, data2) => {
              descendant(comp.element, "iframe").each((iframeEle) => {
                const iframeWin = iframeEle.dom.contentWindow;
                if (isNonNullable(iframeWin)) {
                  iframeWin.postMessage(data2, iframeDomain);
                }
              });
            }
          }
        }
      })
    ];
    const spec = {
      id: dialogId,
      header,
      body: body2,
      footer,
      extraClasses: classes2,
      extraBehaviours,
      extraStyles: styles2
    };
    const dialog = renderModalDialog(spec, internalDialog, dialogEvents, backstage);
    const instanceApi = getUrlDialogApi(dialog);
    return {
      dialog,
      instanceApi
    };
  };
  const setup$2 = (backstage) => {
    const sharedBackstage = backstage.shared;
    const open2 = (message, callback) => {
      const closeDialog = () => {
        ModalDialog.hide(alertDialog);
        callback();
      };
      const memFooterClose = record(renderFooterButton({
        name: "close-alert",
        text: "OK",
        primary: true,
        buttonType: Optional.some("primary"),
        align: "end",
        enabled: true,
        icon: Optional.none()
      }, "cancel", backstage));
      const titleSpec = pUntitled();
      const closeSpec = pClose(closeDialog, sharedBackstage.providers);
      const alertDialog = build$1(renderDialog$1({
        lazySink: () => sharedBackstage.getSink(),
        header: hiddenHeader(titleSpec, closeSpec),
        body: pBodyMessage(message, sharedBackstage.providers),
        footer: Optional.some(pFooter(pFooterGroup([], [memFooterClose.asSpec()]))),
        onEscape: closeDialog,
        extraClasses: ["tox-alert-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [run$1(formCancelEvent, closeDialog)],
        eventOrder: {}
      }));
      ModalDialog.show(alertDialog);
      const footerCloseButton = memFooterClose.get(alertDialog);
      Focusing.focus(footerCloseButton);
    };
    return { open: open2 };
  };
  const setup$1 = (backstage) => {
    const sharedBackstage = backstage.shared;
    const open2 = (message, callback) => {
      const closeDialog = (state2) => {
        ModalDialog.hide(confirmDialog);
        callback(state2);
      };
      const memFooterYes = record(renderFooterButton({
        name: "yes",
        text: "Yes",
        primary: true,
        buttonType: Optional.some("primary"),
        align: "end",
        enabled: true,
        icon: Optional.none()
      }, "submit", backstage));
      const footerNo = renderFooterButton({
        name: "no",
        text: "No",
        primary: false,
        buttonType: Optional.some("secondary"),
        align: "end",
        enabled: true,
        icon: Optional.none()
      }, "cancel", backstage);
      const titleSpec = pUntitled();
      const closeSpec = pClose(() => closeDialog(false), sharedBackstage.providers);
      const confirmDialog = build$1(renderDialog$1({
        lazySink: () => sharedBackstage.getSink(),
        header: hiddenHeader(titleSpec, closeSpec),
        body: pBodyMessage(message, sharedBackstage.providers),
        footer: Optional.some(pFooter(pFooterGroup([], [
          footerNo,
          memFooterYes.asSpec()
        ]))),
        onEscape: () => closeDialog(false),
        extraClasses: ["tox-confirm-dialog"],
        extraBehaviours: [],
        extraStyles: {},
        dialogEvents: [
          run$1(formCancelEvent, () => closeDialog(false)),
          run$1(formSubmitEvent, () => closeDialog(true))
        ],
        eventOrder: {}
      }));
      ModalDialog.show(confirmDialog);
      const footerYesButton = memFooterYes.get(confirmDialog);
      Focusing.focus(footerYesButton);
    };
    return { open: open2 };
  };
  const validateData = (data2, validator2) => getOrDie(asRaw("data", validator2, data2));
  const isAlertOrConfirmDialog = (target) => closest(target, ".tox-alert-dialog") || closest(target, ".tox-confirm-dialog");
  const inlineAdditionalBehaviours = (editor, isStickyToolbar2, isToolbarLocationTop) => {
    if (isStickyToolbar2 && isToolbarLocationTop) {
      return [];
    } else {
      return [Docking.config({
        contextual: {
          lazyContext: () => Optional.some(box$1(SugarElement.fromDom(editor.getContentAreaContainer()))),
          fadeInClass: "tox-dialog-dock-fadein",
          fadeOutClass: "tox-dialog-dock-fadeout",
          transitionClass: "tox-dialog-dock-transition"
        },
        modes: ["top"],
        lazyViewport: (comp) => {
          const optScrollingContext = detectWhenSplitUiMode(editor, comp.element);
          return optScrollingContext.map((sc) => {
            const combinedBounds = getBoundsFrom(sc);
            return {
              bounds: combinedBounds,
              optScrollEnv: Optional.some({
                currentScrollTop: sc.element.dom.scrollTop,
                scrollElmTop: absolute$3(sc.element).top
              })
            };
          }).getOrThunk(() => ({
            bounds: win(),
            optScrollEnv: Optional.none()
          }));
        }
      })];
    }
  };
  const setup = (extras) => {
    const editor = extras.editor;
    const isStickyToolbar$1 = isStickyToolbar(editor);
    const alertDialog = setup$2(extras.backstages.dialog);
    const confirmDialog = setup$1(extras.backstages.dialog);
    const open2 = (config2, params, closeWindow) => {
      if (params !== void 0 && params.inline === "toolbar") {
        return openInlineDialog(config2, extras.backstages.popup.shared.anchors.inlineDialog(), closeWindow, params.ariaAttrs);
      } else if (params !== void 0 && params.inline === "cursor") {
        return openInlineDialog(config2, extras.backstages.popup.shared.anchors.cursor(), closeWindow, params.ariaAttrs);
      } else {
        return openModalDialog(config2, closeWindow);
      }
    };
    const openUrl = (config2, closeWindow) => openModalUrlDialog(config2, closeWindow);
    const openModalUrlDialog = (config2, closeWindow) => {
      const factory2 = (contents2) => {
        const dialog = renderUrlDialog(contents2, {
          closeWindow: () => {
            ModalDialog.hide(dialog.dialog);
            closeWindow(dialog.instanceApi);
          }
        }, editor, extras.backstages.dialog);
        ModalDialog.show(dialog.dialog);
        return dialog.instanceApi;
      };
      return DialogManager.openUrl(factory2, config2);
    };
    const openModalDialog = (config2, closeWindow) => {
      const factory2 = (contents2, internalInitialData, dataValidator) => {
        const initialData = internalInitialData;
        const dialogInit = {
          dataValidator,
          initialData,
          internalDialog: contents2
        };
        const dialog = renderDialog(dialogInit, {
          redial: DialogManager.redial,
          closeWindow: () => {
            ModalDialog.hide(dialog.dialog);
            closeWindow(dialog.instanceApi);
          }
        }, extras.backstages.dialog);
        ModalDialog.show(dialog.dialog);
        dialog.instanceApi.setData(initialData);
        return dialog.instanceApi;
      };
      return DialogManager.open(factory2, config2);
    };
    const openInlineDialog = (config$1, anchor2, closeWindow, ariaAttrs = false) => {
      const factory2 = (contents2, internalInitialData, dataValidator) => {
        const initialData = validateData(internalInitialData, dataValidator);
        const inlineDialog = value$2();
        const isToolbarLocationTop = extras.backstages.popup.shared.header.isPositionedAtTop();
        const dialogInit = {
          dataValidator,
          initialData,
          internalDialog: contents2
        };
        const refreshDocking = () => inlineDialog.on((dialog) => {
          InlineView.reposition(dialog);
          Docking.refresh(dialog);
        });
        const dialogUi = renderInlineDialog(dialogInit, {
          redial: DialogManager.redial,
          closeWindow: () => {
            inlineDialog.on(InlineView.hide);
            editor.off("ResizeEditor", refreshDocking);
            inlineDialog.clear();
            closeWindow(dialogUi.instanceApi);
          }
        }, extras.backstages.popup, ariaAttrs);
        const inlineDialogComp = build$1(InlineView.sketch({
          lazySink: extras.backstages.popup.shared.getSink,
          dom: {
            tag: "div",
            classes: []
          },
          fireDismissalEventInstead: {},
          ...isToolbarLocationTop ? {} : { fireRepositionEventInstead: {} },
          inlineBehaviours: derive$1([
            config("window-manager-inline-events", [run$1(dismissRequested(), (_comp, _se) => {
              emit(dialogUi.dialog, formCancelEvent);
            })]),
            ...inlineAdditionalBehaviours(editor, isStickyToolbar$1, isToolbarLocationTop)
          ]),
          isExtraPart: (_comp, target) => isAlertOrConfirmDialog(target)
        }));
        inlineDialog.set(inlineDialogComp);
        const getInlineDialogBounds = () => {
          const elem = editor.inline ? body() : SugarElement.fromDom(editor.getContainer());
          const bounds2 = box$1(elem);
          return Optional.some(bounds2);
        };
        InlineView.showWithinBounds(inlineDialogComp, premade(dialogUi.dialog), { anchor: anchor2 }, getInlineDialogBounds);
        if (!isStickyToolbar$1 || !isToolbarLocationTop) {
          Docking.refresh(inlineDialogComp);
          editor.on("ResizeEditor", refreshDocking);
        }
        dialogUi.instanceApi.setData(initialData);
        Keying.focusIn(dialogUi.dialog);
        return dialogUi.instanceApi;
      };
      return DialogManager.open(factory2, config$1);
    };
    const confirm = (message, callback) => {
      confirmDialog.open(message, callback);
    };
    const alert = (message, callback) => {
      alertDialog.open(message, callback);
    };
    const close2 = (instanceApi) => {
      instanceApi.close();
    };
    return {
      open: open2,
      openUrl,
      alert,
      close: close2,
      confirm
    };
  };
  const registerOptions = (editor) => {
    register$e(editor);
    register$d(editor);
    register(editor);
  };
  var Theme = () => {
    global$a.add("silver", (editor) => {
      registerOptions(editor);
      let popupSinkBounds = () => win();
      const {
        dialogs,
        popups,
        renderUI: renderModeUI
      } = setup$3(editor, { getPopupSinkBounds: () => popupSinkBounds() });
      const renderUI = async () => {
        const renderResult = await renderModeUI();
        const optScrollingContext = detectWhenSplitUiMode(editor, popups.getMothership().element);
        optScrollingContext.each((sc) => {
          popupSinkBounds = () => {
            return getBoundsFrom(sc);
          };
        });
        return renderResult;
      };
      Autocompleter.register(editor, popups.backstage.shared);
      const windowMgr = setup({
        editor,
        backstages: {
          popup: popups.backstage,
          dialog: dialogs.backstage
        }
      });
      const getNotificationManagerImpl = () => NotificationManagerImpl(editor, { backstage: popups.backstage }, popups.getMothership());
      return {
        renderUI,
        getWindowManagerImpl: constant$1(windowMgr),
        getNotificationManagerImpl
      };
    });
  };
  Theme();
})();
(function() {
  var global$1 = tinymce.util.Tools.resolve("tinymce.ModelManager");
  const hasProto = (v, constructor, predicate) => {
    var _a;
    if (predicate(v, constructor.prototype)) {
      return true;
    } else {
      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;
    }
  };
  const typeOf = (x) => {
    const t = typeof x;
    if (x === null) {
      return "null";
    } else if (t === "object" && Array.isArray(x)) {
      return "array";
    } else if (t === "object" && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {
      return "string";
    } else {
      return t;
    }
  };
  const isType$1 = (type2) => (value2) => typeOf(value2) === type2;
  const isSimpleType = (type2) => (value2) => typeof value2 === type2;
  const eq$2 = (t) => (a) => t === a;
  const isString2 = isType$1("string");
  const isObject2 = isType$1("object");
  const isArray2 = isType$1("array");
  const isNull2 = eq$2(null);
  const isBoolean2 = isSimpleType("boolean");
  const isUndefined2 = eq$2(void 0);
  const isNullable = (a) => a === null || a === void 0;
  const isNonNullable = (a) => !isNullable(a);
  const isFunction2 = isSimpleType("function");
  const isNumber2 = isSimpleType("number");
  const noop2 = () => {
  };
  const compose = (fa, fb) => {
    return (...args) => {
      return fa(fb.apply(null, args));
    };
  };
  const compose1 = (fbc, fab) => (a) => fbc(fab(a));
  const constant = (value2) => {
    return () => {
      return value2;
    };
  };
  const identity = (x) => {
    return x;
  };
  const tripleEquals = (a, b) => {
    return a === b;
  };
  function curry(fn3, ...initialArgs) {
    return (...restArgs) => {
      const all3 = initialArgs.concat(restArgs);
      return fn3.apply(null, all3);
    };
  }
  const not = (f) => (t) => !f(t);
  const die = (msg) => {
    return () => {
      throw new Error(msg);
    };
  };
  const apply = (f) => {
    return f();
  };
  const never = constant(false);
  const always = constant(true);
  class Optional {
    constructor(tag, value2) {
      this.tag = tag;
      this.value = value2;
    }
    static some(value2) {
      return new Optional(true, value2);
    }
    static none() {
      return Optional.singletonNone;
    }
    fold(onNone, onSome) {
      if (this.tag) {
        return onSome(this.value);
      } else {
        return onNone();
      }
    }
    isSome() {
      return this.tag;
    }
    isNone() {
      return !this.tag;
    }
    map(mapper) {
      if (this.tag) {
        return Optional.some(mapper(this.value));
      } else {
        return Optional.none();
      }
    }
    bind(binder2) {
      if (this.tag) {
        return binder2(this.value);
      } else {
        return Optional.none();
      }
    }
    exists(predicate) {
      return this.tag && predicate(this.value);
    }
    forall(predicate) {
      return !this.tag || predicate(this.value);
    }
    filter(predicate) {
      if (!this.tag || predicate(this.value)) {
        return this;
      } else {
        return Optional.none();
      }
    }
    getOr(replacement) {
      return this.tag ? this.value : replacement;
    }
    or(replacement) {
      return this.tag ? this : replacement;
    }
    getOrThunk(thunk) {
      return this.tag ? this.value : thunk();
    }
    orThunk(thunk) {
      return this.tag ? this : thunk();
    }
    getOrDie(message) {
      if (!this.tag) {
        throw new Error(message !== null && message !== void 0 ? message : "Called getOrDie on None");
      } else {
        return this.value;
      }
    }
    static from(value2) {
      return isNonNullable(value2) ? Optional.some(value2) : Optional.none();
    }
    getOrNull() {
      return this.tag ? this.value : null;
    }
    getOrUndefined() {
      return this.value;
    }
    each(worker) {
      if (this.tag) {
        worker(this.value);
      }
    }
    toArray() {
      return this.tag ? [this.value] : [];
    }
    toString() {
      return this.tag ? `some(${this.value})` : "none()";
    }
  }
  Optional.singletonNone = new Optional(false);
  const nativeSlice = Array.prototype.slice;
  const nativeIndexOf = Array.prototype.indexOf;
  const nativePush = Array.prototype.push;
  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);
  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;
  const exists = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return true;
      }
    }
    return false;
  };
  const range$1 = (num, f) => {
    const r2 = [];
    for (let i = 0; i < num; i++) {
      r2.push(f(i));
    }
    return r2;
  };
  const map$1 = (xs, f) => {
    const len = xs.length;
    const r2 = new Array(len);
    for (let i = 0; i < len; i++) {
      const x = xs[i];
      r2[i] = f(x, i);
    }
    return r2;
  };
  const each$2 = (xs, f) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      f(x, i);
    }
  };
  const eachr = (xs, f) => {
    for (let i = xs.length - 1; i >= 0; i--) {
      const x = xs[i];
      f(x, i);
    }
  };
  const partition = (xs, pred) => {
    const pass = [];
    const fail = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      const arr = pred(x, i) ? pass : fail;
      arr.push(x);
    }
    return {
      pass,
      fail
    };
  };
  const filter$2 = (xs, pred) => {
    const r2 = [];
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        r2.push(x);
      }
    }
    return r2;
  };
  const foldr = (xs, f, acc) => {
    eachr(xs, (x, i) => {
      acc = f(acc, x, i);
    });
    return acc;
  };
  const foldl = (xs, f, acc) => {
    each$2(xs, (x, i) => {
      acc = f(acc, x, i);
    });
    return acc;
  };
  const findUntil = (xs, pred, until) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(x);
      } else if (until(x, i)) {
        break;
      }
    }
    return Optional.none();
  };
  const find$1 = (xs, pred) => {
    return findUntil(xs, pred, never);
  };
  const findIndex = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      if (pred(x, i)) {
        return Optional.some(i);
      }
    }
    return Optional.none();
  };
  const flatten = (xs) => {
    const r2 = [];
    for (let i = 0, len = xs.length; i < len; ++i) {
      if (!isArray2(xs[i])) {
        throw new Error("Arr.flatten item " + i + " was not an array, input: " + xs);
      }
      nativePush.apply(r2, xs[i]);
    }
    return r2;
  };
  const bind$2 = (xs, f) => flatten(map$1(xs, f));
  const forall = (xs, pred) => {
    for (let i = 0, len = xs.length; i < len; ++i) {
      const x = xs[i];
      if (pred(x, i) !== true) {
        return false;
      }
    }
    return true;
  };
  const reverse = (xs) => {
    const r2 = nativeSlice.call(xs, 0);
    r2.reverse();
    return r2;
  };
  const mapToObject = (xs, f) => {
    const r2 = {};
    for (let i = 0, len = xs.length; i < len; i++) {
      const x = xs[i];
      r2[String(x)] = f(x, i);
    }
    return r2;
  };
  const sort$1 = (xs, comparator) => {
    const copy2 = nativeSlice.call(xs, 0);
    copy2.sort(comparator);
    return copy2;
  };
  const get$d = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();
  const head = (xs) => get$d(xs, 0);
  const last$2 = (xs) => get$d(xs, xs.length - 1);
  const findMap = (arr, f) => {
    for (let i = 0; i < arr.length; i++) {
      const r2 = f(arr[i], i);
      if (r2.isSome()) {
        return r2;
      }
    }
    return Optional.none();
  };
  const keys = Object.keys;
  const hasOwnProperty2 = Object.hasOwnProperty;
  const each$1 = (obj, f) => {
    const props = keys(obj);
    for (let k = 0, len = props.length; k < len; k++) {
      const i = props[k];
      const x = obj[i];
      f(x, i);
    }
  };
  const map2 = (obj, f) => {
    return tupleMap(obj, (x, i) => ({
      k: i,
      v: f(x, i)
    }));
  };
  const tupleMap = (obj, f) => {
    const r2 = {};
    each$1(obj, (x, i) => {
      const tuple = f(x, i);
      r2[tuple.k] = tuple.v;
    });
    return r2;
  };
  const objAcc = (r2) => (x, i) => {
    r2[i] = x;
  };
  const internalFilter = (obj, pred, onTrue, onFalse) => {
    each$1(obj, (x, i) => {
      (pred(x, i) ? onTrue : onFalse)(x, i);
    });
  };
  const filter$1 = (obj, pred) => {
    const t = {};
    internalFilter(obj, pred, objAcc(t), noop2);
    return t;
  };
  const mapToArray = (obj, f) => {
    const r2 = [];
    each$1(obj, (value2, name3) => {
      r2.push(f(value2, name3));
    });
    return r2;
  };
  const values = (obj) => {
    return mapToArray(obj, identity);
  };
  const get$c = (obj, key2) => {
    return has$1(obj, key2) ? Optional.from(obj[key2]) : Optional.none();
  };
  const has$1 = (obj, key2) => hasOwnProperty2.call(obj, key2);
  const hasNonNullableKey = (obj, key2) => has$1(obj, key2) && obj[key2] !== void 0 && obj[key2] !== null;
  const isEmpty2 = (r2) => {
    for (const x in r2) {
      if (hasOwnProperty2.call(r2, x)) {
        return false;
      }
    }
    return true;
  };
  const Global = typeof window !== "undefined" ? window : Function("return this;")();
  const path = (parts, scope) => {
    let o = scope !== void 0 && scope !== null ? scope : Global;
    for (let i = 0; i < parts.length && o !== void 0 && o !== null; ++i) {
      o = o[parts[i]];
    }
    return o;
  };
  const resolve$2 = (p, scope) => {
    const parts = p.split(".");
    return path(parts, scope);
  };
  const unsafe = (name3, scope) => {
    return resolve$2(name3, scope);
  };
  const getOrDie = (name3, scope) => {
    const actual = unsafe(name3, scope);
    if (actual === void 0 || actual === null) {
      throw new Error(name3 + " not available on this browser");
    }
    return actual;
  };
  const getPrototypeOf2 = Object.getPrototypeOf;
  const sandHTMLElement = (scope) => {
    return getOrDie("HTMLElement", scope);
  };
  const isPrototypeOf = (x) => {
    const scope = resolve$2("ownerDocument.defaultView", x);
    return isObject2(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\w*Element$/.test(getPrototypeOf2(x).constructor.name));
  };
  const COMMENT = 8;
  const DOCUMENT = 9;
  const DOCUMENT_FRAGMENT = 11;
  const ELEMENT = 1;
  const TEXT = 3;
  const name2 = (element) => {
    const r2 = element.dom.nodeName;
    return r2.toLowerCase();
  };
  const type = (element) => element.dom.nodeType;
  const isType = (t) => (element) => type(element) === t;
  const isComment = (element) => type(element) === COMMENT || name2(element) === "#comment";
  const isHTMLElement2 = (element) => isElement2(element) && isPrototypeOf(element.dom);
  const isElement2 = isType(ELEMENT);
  const isText = isType(TEXT);
  const isDocument = isType(DOCUMENT);
  const isDocumentFragment = isType(DOCUMENT_FRAGMENT);
  const isTag = (tag) => (e) => isElement2(e) && name2(e) === tag;
  const rawSet = (dom, key2, value2) => {
    if (isString2(value2) || isBoolean2(value2) || isNumber2(value2)) {
      dom.setAttribute(key2, value2 + "");
    } else {
      console.error("Invalid call to Attribute.set. Key ", key2, ":: Value ", value2, ":: Element ", dom);
      throw new Error("Attribute value was not simple");
    }
  };
  const set$2 = (element, key2, value2) => {
    rawSet(element.dom, key2, value2);
  };
  const setAll$1 = (element, attrs) => {
    const dom = element.dom;
    each$1(attrs, (v, k) => {
      rawSet(dom, k, v);
    });
  };
  const setOptions2 = (element, attrs) => {
    each$1(attrs, (v, k) => {
      v.fold(() => {
        remove$7(element, k);
      }, (value2) => {
        rawSet(element.dom, k, value2);
      });
    });
  };
  const get$b = (element, key2) => {
    const v = element.dom.getAttribute(key2);
    return v === null ? void 0 : v;
  };
  const getOpt = (element, key2) => Optional.from(get$b(element, key2));
  const remove$7 = (element, key2) => {
    element.dom.removeAttribute(key2);
  };
  const clone$2 = (element) => foldl(element.dom.attributes, (acc, attr2) => {
    acc[attr2.name] = attr2.value;
    return acc;
  }, {});
  const fromHtml$1 = (html, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html;
    if (!div.hasChildNodes() || div.childNodes.length > 1) {
      const message = "HTML does not have a single root node";
      console.error(message, html);
      throw new Error(message);
    }
    return fromDom$1(div.childNodes[0]);
  };
  const fromTag = (tag, scope) => {
    const doc = scope || document;
    const node = doc.createElement(tag);
    return fromDom$1(node);
  };
  const fromText = (text2, scope) => {
    const doc = scope || document;
    const node = doc.createTextNode(text2);
    return fromDom$1(node);
  };
  const fromDom$1 = (node) => {
    if (node === null || node === void 0) {
      throw new Error("Node cannot be null or undefined");
    }
    return { dom: node };
  };
  const fromPoint$1 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$1);
  const SugarElement = {
    fromHtml: fromHtml$1,
    fromTag,
    fromText,
    fromDom: fromDom$1,
    fromPoint: fromPoint$1
  };
  const is$2 = (element, selector) => {
    const dom = element.dom;
    if (dom.nodeType !== ELEMENT) {
      return false;
    } else {
      const elem = dom;
      if (elem.matches !== void 0) {
        return elem.matches(selector);
      } else if (elem.msMatchesSelector !== void 0) {
        return elem.msMatchesSelector(selector);
      } else if (elem.webkitMatchesSelector !== void 0) {
        return elem.webkitMatchesSelector(selector);
      } else if (elem.mozMatchesSelector !== void 0) {
        return elem.mozMatchesSelector(selector);
      } else {
        throw new Error("Browser lacks native selectors");
      }
    }
  };
  const bypassSelector = (dom) => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;
  const all$1 = (selector, scope) => {
    const base2 = scope === void 0 ? document : scope.dom;
    return bypassSelector(base2) ? [] : map$1(base2.querySelectorAll(selector), SugarElement.fromDom);
  };
  const one = (selector, scope) => {
    const base2 = scope === void 0 ? document : scope.dom;
    return bypassSelector(base2) ? Optional.none() : Optional.from(base2.querySelector(selector)).map(SugarElement.fromDom);
  };
  const eq$1 = (e1, e2) => e1.dom === e2.dom;
  const contains$1 = (e1, e2) => {
    const d1 = e1.dom;
    const d2 = e2.dom;
    return d1 === d2 ? false : d1.contains(d2);
  };
  const is$1 = is$2;
  const owner = (element) => SugarElement.fromDom(element.dom.ownerDocument);
  const documentOrOwner = (dos) => isDocument(dos) ? dos : owner(dos);
  const documentElement = (element) => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);
  const defaultView = (element) => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);
  const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);
  const parentElement = (element) => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);
  const parents = (element, isRoot) => {
    const stop = isFunction2(isRoot) ? isRoot : never;
    let dom = element.dom;
    const ret = [];
    while (dom.parentNode !== null && dom.parentNode !== void 0) {
      const rawParent = dom.parentNode;
      const p = SugarElement.fromDom(rawParent);
      ret.push(p);
      if (stop(p) === true) {
        break;
      } else {
        dom = rawParent;
      }
    }
    return ret;
  };
  const prevSibling = (element) => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);
  const nextSibling = (element) => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);
  const children$2 = (element) => map$1(element.dom.childNodes, SugarElement.fromDom);
  const child$2 = (element, index) => {
    const cs = element.dom.childNodes;
    return Optional.from(cs[index]).map(SugarElement.fromDom);
  };
  const firstChild = (element) => child$2(element, 0);
  const before$3 = (marker, element) => {
    const parent$1 = parent(marker);
    parent$1.each((v) => {
      v.dom.insertBefore(element.dom, marker.dom);
    });
  };
  const after$5 = (marker, element) => {
    const sibling = nextSibling(marker);
    sibling.fold(() => {
      const parent$1 = parent(marker);
      parent$1.each((v) => {
        append$1(v, element);
      });
    }, (v) => {
      before$3(v, element);
    });
  };
  const prepend = (parent2, element) => {
    const firstChild$1 = firstChild(parent2);
    firstChild$1.fold(() => {
      append$1(parent2, element);
    }, (v) => {
      parent2.dom.insertBefore(element.dom, v.dom);
    });
  };
  const append$1 = (parent2, element) => {
    parent2.dom.appendChild(element.dom);
  };
  const appendAt = (parent2, element, index) => {
    child$2(parent2, index).fold(() => {
      append$1(parent2, element);
    }, (v) => {
      before$3(v, element);
    });
  };
  const wrap = (element, wrapper) => {
    before$3(element, wrapper);
    append$1(wrapper, element);
  };
  const after$4 = (marker, elements) => {
    each$2(elements, (x, i) => {
      const e = i === 0 ? marker : elements[i - 1];
      after$5(e, x);
    });
  };
  const append2 = (parent2, elements) => {
    each$2(elements, (x) => {
      append$1(parent2, x);
    });
  };
  const empty = (element) => {
    element.dom.textContent = "";
    each$2(children$2(element), (rogue) => {
      remove$6(rogue);
    });
  };
  const remove$6 = (element) => {
    const dom = element.dom;
    if (dom.parentNode !== null) {
      dom.parentNode.removeChild(dom);
    }
  };
  const unwrap = (wrapper) => {
    const children2 = children$2(wrapper);
    if (children2.length > 0) {
      after$4(wrapper, children2);
    }
    remove$6(wrapper);
  };
  const clone$1 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));
  const shallow = (original) => clone$1(original, false);
  const deep = (original) => clone$1(original, true);
  const shallowAs = (original, tag) => {
    const nu2 = SugarElement.fromTag(tag);
    const attributes = clone$2(original);
    setAll$1(nu2, attributes);
    return nu2;
  };
  const copy$2 = (original, tag) => {
    const nu2 = shallowAs(original, tag);
    const cloneChildren = children$2(deep(original));
    append2(nu2, cloneChildren);
    return nu2;
  };
  const mutate$1 = (original, tag) => {
    const nu2 = shallowAs(original, tag);
    after$5(original, nu2);
    const children2 = children$2(original);
    append2(nu2, children2);
    remove$6(original);
    return nu2;
  };
  const validSectionList = [
    "tfoot",
    "thead",
    "tbody",
    "colgroup"
  ];
  const isValidSection = (parentName) => contains$2(validSectionList, parentName);
  const grid = (rows2, columns2) => ({
    rows: rows2,
    columns: columns2
  });
  const address = (row2, column) => ({
    row: row2,
    column
  });
  const detail = (element, rowspan, colspan) => ({
    element,
    rowspan,
    colspan
  });
  const detailnew = (element, rowspan, colspan, isNew) => ({
    element,
    rowspan,
    colspan,
    isNew
  });
  const extended = (element, rowspan, colspan, row2, column, isLocked) => ({
    element,
    rowspan,
    colspan,
    row: row2,
    column,
    isLocked
  });
  const rowdetail = (element, cells2, section2) => ({
    element,
    cells: cells2,
    section: section2
  });
  const rowdetailnew = (element, cells2, section2, isNew) => ({
    element,
    cells: cells2,
    section: section2,
    isNew
  });
  const elementnew = (element, isNew, isLocked) => ({
    element,
    isNew,
    isLocked
  });
  const rowcells = (element, cells2, section2, isNew) => ({
    element,
    cells: cells2,
    section: section2,
    isNew
  });
  const bounds = (startRow, startCol, finishRow, finishCol) => ({
    startRow,
    startCol,
    finishRow,
    finishCol
  });
  const columnext = (element, colspan, column) => ({
    element,
    colspan,
    column
  });
  const colgroup = (element, columns2) => ({
    element,
    columns: columns2
  });
  const isShadowRoot2 = (dos) => isDocumentFragment(dos) && isNonNullable(dos.dom.host);
  const supported2 = isFunction2(Element.prototype.attachShadow) && isFunction2(Node.prototype.getRootNode);
  const isSupported$1 = constant(supported2);
  const getRootNode2 = supported2 ? (e) => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;
  const getShadowRoot = (e) => {
    const r2 = getRootNode2(e);
    return isShadowRoot2(r2) ? Optional.some(r2) : Optional.none();
  };
  const getShadowHost = (e) => SugarElement.fromDom(e.dom.host);
  const getOriginalEventTarget = (event) => {
    if (isSupported$1() && isNonNullable(event.target)) {
      const el = SugarElement.fromDom(event.target);
      if (isElement2(el) && isOpenShadowHost(el)) {
        if (event.composed && event.composedPath) {
          const composedPath = event.composedPath();
          if (composedPath) {
            return head(composedPath);
          }
        }
      }
    }
    return Optional.from(event.target);
  };
  const isOpenShadowHost = (element) => isNonNullable(element.dom.shadowRoot);
  const inBody = (element) => {
    const dom = isText(element) ? element.dom.parentNode : element.dom;
    if (dom === void 0 || dom === null || dom.ownerDocument === null) {
      return false;
    }
    const doc = dom.ownerDocument;
    return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));
  };
  const body$1 = () => getBody$1(SugarElement.fromDom(document));
  const getBody$1 = (doc) => {
    const b = doc.dom.body;
    if (b === null || b === void 0) {
      throw new Error("Body is not available yet");
    }
    return SugarElement.fromDom(b);
  };
  const ancestors$4 = (scope, predicate, isRoot) => filter$2(parents(scope, isRoot), predicate);
  const children$1 = (scope, predicate) => filter$2(children$2(scope), predicate);
  const descendants$1 = (scope, predicate) => {
    let result = [];
    each$2(children$2(scope), (x) => {
      if (predicate(x)) {
        result = result.concat([x]);
      }
      result = result.concat(descendants$1(x, predicate));
    });
    return result;
  };
  const ancestors$3 = (scope, selector, isRoot) => ancestors$4(scope, (e) => is$2(e, selector), isRoot);
  const children = (scope, selector) => children$1(scope, (e) => is$2(e, selector));
  const descendants = (scope, selector) => all$1(selector, scope);
  var ClosestOrAncestor = (is2, ancestor2, scope, a, isRoot) => {
    if (is2(scope, a)) {
      return Optional.some(scope);
    } else if (isFunction2(isRoot) && isRoot(scope)) {
      return Optional.none();
    } else {
      return ancestor2(scope, a, isRoot);
    }
  };
  const ancestor$2 = (scope, predicate, isRoot) => {
    let element = scope.dom;
    const stop = isFunction2(isRoot) ? isRoot : never;
    while (element.parentNode) {
      element = element.parentNode;
      const el = SugarElement.fromDom(element);
      if (predicate(el)) {
        return Optional.some(el);
      } else if (stop(el)) {
        break;
      }
    }
    return Optional.none();
  };
  const closest$2 = (scope, predicate, isRoot) => {
    const is2 = (s, test) => test(s);
    return ClosestOrAncestor(is2, ancestor$2, scope, predicate, isRoot);
  };
  const child$1 = (scope, predicate) => {
    const pred = (node) => predicate(SugarElement.fromDom(node));
    const result = find$1(scope.dom.childNodes, pred);
    return result.map(SugarElement.fromDom);
  };
  const descendant$1 = (scope, predicate) => {
    const descend = (node) => {
      for (let i = 0; i < node.childNodes.length; i++) {
        const child2 = SugarElement.fromDom(node.childNodes[i]);
        if (predicate(child2)) {
          return Optional.some(child2);
        }
        const res2 = descend(node.childNodes[i]);
        if (res2.isSome()) {
          return res2;
        }
      }
      return Optional.none();
    };
    return descend(scope.dom);
  };
  const ancestor$1 = (scope, selector, isRoot) => ancestor$2(scope, (e) => is$2(e, selector), isRoot);
  const child = (scope, selector) => child$1(scope, (e) => is$2(e, selector));
  const descendant = (scope, selector) => one(selector, scope);
  const closest$1 = (scope, selector, isRoot) => {
    const is2 = (element, selector2) => is$2(element, selector2);
    return ClosestOrAncestor(is2, ancestor$1, scope, selector, isRoot);
  };
  const is = (lhs, rhs, comparator = tripleEquals) => lhs.exists((left3) => comparator(left3, rhs));
  const cat = (arr) => {
    const r2 = [];
    const push = (x) => {
      r2.push(x);
    };
    for (let i = 0; i < arr.length; i++) {
      arr[i].each(push);
    }
    return r2;
  };
  const bindFrom = (a, f) => a !== void 0 && a !== null ? f(a) : Optional.none();
  const someIf = (b, a) => b ? Optional.some(a) : Optional.none();
  const checkRange = (str, substr, start2) => substr === "" || str.length >= substr.length && str.substr(start2, start2 + substr.length) === substr;
  const contains2 = (str, substr, start2 = 0, end2) => {
    const idx = str.indexOf(substr, start2);
    if (idx !== -1) {
      return isUndefined2(end2) ? true : idx + substr.length <= end2;
    } else {
      return false;
    }
  };
  const startsWith = (str, prefix) => {
    return checkRange(str, prefix, 0);
  };
  const endsWith2 = (str, suffix) => {
    return checkRange(str, suffix, str.length - suffix.length);
  };
  const blank = (r2) => (s) => s.replace(r2, "");
  const trim2 = blank(/^\s+|\s+$/g);
  const isNotEmpty = (s) => s.length > 0;
  const toFloat2 = (value2) => {
    const num = parseFloat(value2);
    return isNaN(num) ? Optional.none() : Optional.some(num);
  };
  const isSupported = (dom) => dom.style !== void 0 && isFunction2(dom.style.getPropertyValue);
  const internalSet = (dom, property, value2) => {
    if (!isString2(value2)) {
      console.error("Invalid call to CSS.set. Property ", property, ":: Value ", value2, ":: Element ", dom);
      throw new Error("CSS value must be a string: " + value2);
    }
    if (isSupported(dom)) {
      dom.style.setProperty(property, value2);
    }
  };
  const internalRemove = (dom, property) => {
    if (isSupported(dom)) {
      dom.style.removeProperty(property);
    }
  };
  const set$1 = (element, property, value2) => {
    const dom = element.dom;
    internalSet(dom, property, value2);
  };
  const setAll = (element, css2) => {
    const dom = element.dom;
    each$1(css2, (v, k) => {
      internalSet(dom, k, v);
    });
  };
  const get$a = (element, property) => {
    const dom = element.dom;
    const styles3 = window.getComputedStyle(dom);
    const r2 = styles3.getPropertyValue(property);
    return r2 === "" && !inBody(element) ? getUnsafeProperty(dom, property) : r2;
  };
  const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : "";
  const getRaw$2 = (element, property) => {
    const dom = element.dom;
    const raw = getUnsafeProperty(dom, property);
    return Optional.from(raw).filter((r2) => r2.length > 0);
  };
  const remove$5 = (element, property) => {
    const dom = element.dom;
    internalRemove(dom, property);
    if (is(getOpt(element, "style").map(trim2), "")) {
      remove$7(element, "style");
    }
  };
  const copy$1 = (source, target) => {
    const sourceDom = source.dom;
    const targetDom = target.dom;
    if (isSupported(sourceDom) && isSupported(targetDom)) {
      targetDom.style.cssText = sourceDom.style.cssText;
    }
  };
  const getAttrValue = (cell2, name3, fallback2 = 0) => getOpt(cell2, name3).map((value2) => parseInt(value2, 10)).getOr(fallback2);
  const getSpan = (cell2, type2) => getAttrValue(cell2, type2, 1);
  const hasColspan = (cellOrCol) => {
    if (isTag("col")(cellOrCol)) {
      return getAttrValue(cellOrCol, "span", 1) > 1;
    } else {
      return getSpan(cellOrCol, "colspan") > 1;
    }
  };
  const hasRowspan = (cell2) => getSpan(cell2, "rowspan") > 1;
  const getCssValue = (element, property) => parseInt(get$a(element, property), 10);
  const minWidth = constant(10);
  const minHeight = constant(10);
  const firstLayer = (scope, selector) => {
    return filterFirstLayer(scope, selector, always);
  };
  const filterFirstLayer = (scope, selector, predicate) => {
    return bind$2(children$2(scope), (x) => {
      if (is$2(x, selector)) {
        return predicate(x) ? [x] : [];
      } else {
        return filterFirstLayer(x, selector, predicate);
      }
    });
  };
  const lookup = (tags, element, isRoot = never) => {
    if (isRoot(element)) {
      return Optional.none();
    }
    if (contains$2(tags, name2(element))) {
      return Optional.some(element);
    }
    const isRootOrUpperTable = (elm) => is$2(elm, "table") || isRoot(elm);
    return ancestor$1(element, tags.join(","), isRootOrUpperTable);
  };
  const cell = (element, isRoot) => lookup([
    "td",
    "th"
  ], element, isRoot);
  const cells$1 = (ancestor2) => firstLayer(ancestor2, "th,td");
  const columns$1 = (ancestor2) => {
    if (is$2(ancestor2, "colgroup")) {
      return children(ancestor2, "col");
    } else {
      return bind$2(columnGroups(ancestor2), (columnGroup) => children(columnGroup, "col"));
    }
  };
  const table = (element, isRoot) => closest$1(element, "table", isRoot);
  const rows$1 = (ancestor2) => firstLayer(ancestor2, "tr");
  const columnGroups = (ancestor2) => table(ancestor2).fold(constant([]), (table2) => children(table2, "colgroup"));
  const fromRowsOrColGroups = (elems, getSection) => map$1(elems, (row2) => {
    if (name2(row2) === "colgroup") {
      const cells2 = map$1(columns$1(row2), (column) => {
        const colspan = getAttrValue(column, "span", 1);
        return detail(column, 1, colspan);
      });
      return rowdetail(row2, cells2, "colgroup");
    } else {
      const cells2 = map$1(cells$1(row2), (cell2) => {
        const rowspan = getAttrValue(cell2, "rowspan", 1);
        const colspan = getAttrValue(cell2, "colspan", 1);
        return detail(cell2, rowspan, colspan);
      });
      return rowdetail(row2, cells2, getSection(row2));
    }
  });
  const getParentSection = (group) => parent(group).map((parent2) => {
    const parentName = name2(parent2);
    return isValidSection(parentName) ? parentName : "tbody";
  }).getOr("tbody");
  const fromTable$1 = (table2) => {
    const rows2 = rows$1(table2);
    const columnGroups$1 = columnGroups(table2);
    const elems = [
      ...columnGroups$1,
      ...rows2
    ];
    return fromRowsOrColGroups(elems, getParentSection);
  };
  const fromPastedRows = (elems, section2) => fromRowsOrColGroups(elems, () => section2);
  const cached = (f) => {
    let called = false;
    let r2;
    return (...args) => {
      if (!called) {
        called = true;
        r2 = f.apply(null, args);
      }
      return r2;
    };
  };
  const DeviceType = (os, browser2, userAgent, mediaMatch2) => {
    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;
    const isiPhone = os.isiOS() && !isiPad;
    const isMobile = os.isiOS() || os.isAndroid();
    const isTouch = isMobile || mediaMatch2("(pointer:coarse)");
    const isTablet = isiPad || !isiPhone && isMobile && mediaMatch2("(min-device-width:768px)");
    const isPhone = isiPhone || isMobile && !isTablet;
    const iOSwebview = browser2.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;
    const isDesktop = !isPhone && !isTablet && !iOSwebview;
    return {
      isiPad: constant(isiPad),
      isiPhone: constant(isiPhone),
      isTablet: constant(isTablet),
      isPhone: constant(isPhone),
      isTouch: constant(isTouch),
      isAndroid: os.isAndroid,
      isiOS: os.isiOS,
      isWebView: constant(iOSwebview),
      isDesktop: constant(isDesktop)
    };
  };
  const firstMatch = (regexes, s) => {
    for (let i = 0; i < regexes.length; i++) {
      const x = regexes[i];
      if (x.test(s)) {
        return x;
      }
    }
    return void 0;
  };
  const find2 = (regexes, agent) => {
    const r2 = firstMatch(regexes, agent);
    if (!r2) {
      return {
        major: 0,
        minor: 0
      };
    }
    const group = (i) => {
      return Number(agent.replace(r2, "$" + i));
    };
    return nu$2(group(1), group(2));
  };
  const detect$5 = (versionRegexes, agent) => {
    const cleanedAgent = String(agent).toLowerCase();
    if (versionRegexes.length === 0) {
      return unknown$2();
    }
    return find2(versionRegexes, cleanedAgent);
  };
  const unknown$2 = () => {
    return nu$2(0, 0);
  };
  const nu$2 = (major, minor) => {
    return {
      major,
      minor
    };
  };
  const Version = {
    nu: nu$2,
    detect: detect$5,
    unknown: unknown$2
  };
  const detectBrowser$1 = (browsers2, userAgentData) => {
    return findMap(userAgentData.brands, (uaBrand) => {
      const lcBrand = uaBrand.brand.toLowerCase();
      return find$1(browsers2, (browser2) => {
        var _a;
        return lcBrand === ((_a = browser2.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());
      }).map((info) => ({
        current: info.name,
        version: Version.nu(parseInt(uaBrand.version, 10), 0)
      }));
    });
  };
  const detect$4 = (candidates, userAgent) => {
    const agent = String(userAgent).toLowerCase();
    return find$1(candidates, (candidate) => {
      return candidate.search(agent);
    });
  };
  const detectBrowser = (browsers2, userAgent) => {
    return detect$4(browsers2, userAgent).map((browser2) => {
      const version = Version.detect(browser2.versionRegexes, userAgent);
      return {
        current: browser2.name,
        version
      };
    });
  };
  const detectOs = (oses2, userAgent) => {
    return detect$4(oses2, userAgent).map((os) => {
      const version = Version.detect(os.versionRegexes, userAgent);
      return {
        current: os.name,
        version
      };
    });
  };
  const normalVersionRegex = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/;
  const checkContains = (target) => {
    return (uastring) => {
      return contains2(uastring, target);
    };
  };
  const browsers = [
    {
      name: "Edge",
      versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
      search: (uastring) => {
        return contains2(uastring, "edge/") && contains2(uastring, "chrome") && contains2(uastring, "safari") && contains2(uastring, "applewebkit");
      }
    },
    {
      name: "Chromium",
      brand: "Chromium",
      versionRegexes: [
        /.*?chrome\/([0-9]+)\.([0-9]+).*/,
        normalVersionRegex
      ],
      search: (uastring) => {
        return contains2(uastring, "chrome") && !contains2(uastring, "chromeframe");
      }
    },
    {
      name: "IE",
      versionRegexes: [
        /.*?msie\ ?([0-9]+)\.([0-9]+).*/,
        /.*?rv:([0-9]+)\.([0-9]+).*/
      ],
      search: (uastring) => {
        return contains2(uastring, "msie") || contains2(uastring, "trident");
      }
    },
    {
      name: "Opera",
      versionRegexes: [
        normalVersionRegex,
        /.*?opera\/([0-9]+)\.([0-9]+).*/
      ],
      search: checkContains("opera")
    },
    {
      name: "Firefox",
      versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
      search: checkContains("firefox")
    },
    {
      name: "Safari",
      versionRegexes: [
        normalVersionRegex,
        /.*?cpu os ([0-9]+)_([0-9]+).*/
      ],
      search: (uastring) => {
        return (contains2(uastring, "safari") || contains2(uastring, "mobile/")) && contains2(uastring, "applewebkit");
      }
    }
  ];
  const oses = [
    {
      name: "Windows",
      search: checkContains("win"),
      versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "iOS",
      search: (uastring) => {
        return contains2(uastring, "iphone") || contains2(uastring, "ipad");
      },
      versionRegexes: [
        /.*?version\/\ ?([0-9]+)\.([0-9]+).*/,
        /.*cpu os ([0-9]+)_([0-9]+).*/,
        /.*cpu iphone os ([0-9]+)_([0-9]+).*/
      ]
    },
    {
      name: "Android",
      search: checkContains("android"),
      versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
    },
    {
      name: "macOS",
      search: checkContains("mac os x"),
      versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
    },
    {
      name: "Linux",
      search: checkContains("linux"),
      versionRegexes: []
    },
    {
      name: "Solaris",
      search: checkContains("sunos"),
      versionRegexes: []
    },
    {
      name: "FreeBSD",
      search: checkContains("freebsd"),
      versionRegexes: []
    },
    {
      name: "ChromeOS",
      search: checkContains("cros"),
      versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
    }
  ];
  const PlatformInfo = {
    browsers: constant(browsers),
    oses: constant(oses)
  };
  const edge = "Edge";
  const chromium = "Chromium";
  const ie = "IE";
  const opera = "Opera";
  const firefox = "Firefox";
  const safari = "Safari";
  const unknown$1 = () => {
    return nu$1({
      current: void 0,
      version: Version.unknown()
    });
  };
  const nu$1 = (info) => {
    const current = info.current;
    const version = info.version;
    const isBrowser2 = (name3) => () => current === name3;
    return {
      current,
      version,
      isEdge: isBrowser2(edge),
      isChromium: isBrowser2(chromium),
      isIE: isBrowser2(ie),
      isOpera: isBrowser2(opera),
      isFirefox: isBrowser2(firefox),
      isSafari: isBrowser2(safari)
    };
  };
  const Browser = {
    unknown: unknown$1,
    nu: nu$1,
    edge: constant(edge),
    chromium: constant(chromium),
    ie: constant(ie),
    opera: constant(opera),
    firefox: constant(firefox),
    safari: constant(safari)
  };
  const windows = "Windows";
  const ios = "iOS";
  const android = "Android";
  const linux = "Linux";
  const macos = "macOS";
  const solaris = "Solaris";
  const freebsd = "FreeBSD";
  const chromeos = "ChromeOS";
  const unknown = () => {
    return nu({
      current: void 0,
      version: Version.unknown()
    });
  };
  const nu = (info) => {
    const current = info.current;
    const version = info.version;
    const isOS = (name3) => () => current === name3;
    return {
      current,
      version,
      isWindows: isOS(windows),
      isiOS: isOS(ios),
      isAndroid: isOS(android),
      isMacOS: isOS(macos),
      isLinux: isOS(linux),
      isSolaris: isOS(solaris),
      isFreeBSD: isOS(freebsd),
      isChromeOS: isOS(chromeos)
    };
  };
  const OperatingSystem = {
    unknown,
    nu,
    windows: constant(windows),
    ios: constant(ios),
    android: constant(android),
    linux: constant(linux),
    macos: constant(macos),
    solaris: constant(solaris),
    freebsd: constant(freebsd),
    chromeos: constant(chromeos)
  };
  const detect$3 = (userAgent, userAgentDataOpt, mediaMatch2) => {
    const browsers2 = PlatformInfo.browsers();
    const oses2 = PlatformInfo.oses();
    const browser2 = userAgentDataOpt.bind((userAgentData) => detectBrowser$1(browsers2, userAgentData)).orThunk(() => detectBrowser(browsers2, userAgent)).fold(Browser.unknown, Browser.nu);
    const os = detectOs(oses2, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);
    const deviceType = DeviceType(os, browser2, userAgent, mediaMatch2);
    return {
      browser: browser2,
      os,
      deviceType
    };
  };
  const PlatformDetection = { detect: detect$3 };
  const mediaMatch = (query) => window.matchMedia(query).matches;
  let platform2 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));
  const detect$2 = () => platform2();
  const Dimension = (name3, getOffset) => {
    const set2 = (element, h) => {
      if (!isNumber2(h) && !h.match(/^[0-9]+$/)) {
        throw new Error(name3 + ".set accepts only positive integer values. Value was " + h);
      }
      const dom = element.dom;
      if (isSupported(dom)) {
        dom.style[name3] = h + "px";
      }
    };
    const get2 = (element) => {
      const r2 = getOffset(element);
      if (r2 <= 0 || r2 === null) {
        const css2 = get$a(element, name3);
        return parseFloat(css2) || 0;
      }
      return r2;
    };
    const getOuter2 = get2;
    const aggregate = (element, properties) => foldl(properties, (acc, property) => {
      const val = get$a(element, property);
      const value2 = val === void 0 ? 0 : parseInt(val, 10);
      return isNaN(value2) ? acc : acc + value2;
    }, 0);
    const max2 = (element, value2, properties) => {
      const cumulativeInclusions = aggregate(element, properties);
      const absoluteMax = value2 > cumulativeInclusions ? value2 - cumulativeInclusions : 0;
      return absoluteMax;
    };
    return {
      set: set2,
      get: get2,
      getOuter: getOuter2,
      aggregate,
      max: max2
    };
  };
  const toNumber2 = (px, fallback2) => toFloat2(px).getOr(fallback2);
  const getProp = (element, name3, fallback2) => toNumber2(get$a(element, name3), fallback2);
  const calcContentBoxSize = (element, size, upper, lower) => {
    const paddingUpper = getProp(element, `padding-${upper}`, 0);
    const paddingLower = getProp(element, `padding-${lower}`, 0);
    const borderUpper = getProp(element, `border-${upper}-width`, 0);
    const borderLower = getProp(element, `border-${lower}-width`, 0);
    return size - paddingUpper - paddingLower - borderUpper - borderLower;
  };
  const getCalculatedWidth = (element, boxSizing) => {
    const dom = element.dom;
    const width3 = dom.getBoundingClientRect().width || dom.offsetWidth;
    return boxSizing === "border-box" ? width3 : calcContentBoxSize(element, width3, "left", "right");
  };
  const getHeight$1 = (element) => getProp(element, "height", element.dom.offsetHeight);
  const getWidth = (element) => getProp(element, "width", element.dom.offsetWidth);
  const getInnerWidth = (element) => getCalculatedWidth(element, "content-box");
  const api$2 = Dimension("width", (element) => element.dom.offsetWidth);
  const get$9 = (element) => api$2.get(element);
  const getOuter$2 = (element) => api$2.getOuter(element);
  const getInner = getInnerWidth;
  const getRuntime$1 = getWidth;
  const addCells = (gridRow, index, cells2) => {
    const existingCells = gridRow.cells;
    const before2 = existingCells.slice(0, index);
    const after2 = existingCells.slice(index);
    const newCells = before2.concat(cells2).concat(after2);
    return setCells(gridRow, newCells);
  };
  const addCell = (gridRow, index, cell2) => addCells(gridRow, index, [cell2]);
  const mutateCell = (gridRow, index, cell2) => {
    const cells2 = gridRow.cells;
    cells2[index] = cell2;
  };
  const setCells = (gridRow, cells2) => rowcells(gridRow.element, cells2, gridRow.section, gridRow.isNew);
  const mapCells = (gridRow, f) => {
    const cells2 = gridRow.cells;
    const r2 = map$1(cells2, f);
    return rowcells(gridRow.element, r2, gridRow.section, gridRow.isNew);
  };
  const getCell = (gridRow, index) => gridRow.cells[index];
  const getCellElement = (gridRow, index) => getCell(gridRow, index).element;
  const cellLength = (gridRow) => gridRow.cells.length;
  const extractGridDetails = (grid2) => {
    const result = partition(grid2, (row2) => row2.section === "colgroup");
    return {
      rows: result.fail,
      cols: result.pass
    };
  };
  const clone = (gridRow, cloneRow2, cloneCell) => {
    const newCells = map$1(gridRow.cells, cloneCell);
    return rowcells(cloneRow2(gridRow.element), newCells, gridRow.section, true);
  };
  const LOCKED_COL_ATTR = "data-snooker-locked-cols";
  const getLockedColumnsFromTable = (table2) => getOpt(table2, LOCKED_COL_ATTR).bind((lockedColStr) => Optional.from(lockedColStr.match(/\d+/g))).map((lockedCols) => mapToObject(lockedCols, always));
  const getLockedColumnsFromGrid = (grid2) => {
    const locked = foldl(extractGridDetails(grid2).rows, (acc, row2) => {
      each$2(row2.cells, (cell2, idx) => {
        if (cell2.isLocked) {
          acc[idx] = true;
        }
      });
      return acc;
    }, {});
    const lockedArr = mapToArray(locked, (_val, key2) => parseInt(key2, 10));
    return sort$1(lockedArr);
  };
  const key = (row2, column) => {
    return row2 + "," + column;
  };
  const getAt = (warehouse, row2, column) => Optional.from(warehouse.access[key(row2, column)]);
  const findItem = (warehouse, item2, comparator) => {
    const filtered = filterItems(warehouse, (detail2) => {
      return comparator(item2, detail2.element);
    });
    return filtered.length > 0 ? Optional.some(filtered[0]) : Optional.none();
  };
  const filterItems = (warehouse, predicate) => {
    const all3 = bind$2(warehouse.all, (r2) => {
      return r2.cells;
    });
    return filter$2(all3, predicate);
  };
  const generateColumns = (rowData) => {
    const columnsGroup = {};
    let index = 0;
    each$2(rowData.cells, (column) => {
      const colspan = column.colspan;
      range$1(colspan, (columnIndex) => {
        const colIndex = index + columnIndex;
        columnsGroup[colIndex] = columnext(column.element, colspan, colIndex);
      });
      index += colspan;
    });
    return columnsGroup;
  };
  const generate$1 = (list2) => {
    const access = {};
    const cells2 = [];
    const tableOpt = head(list2).map((rowData) => rowData.element).bind(table);
    const lockedColumns = tableOpt.bind(getLockedColumnsFromTable).getOr({});
    let maxRows = 0;
    let maxColumns = 0;
    let rowCount = 0;
    const {
      pass: colgroupRows,
      fail: rows2
    } = partition(list2, (rowData) => rowData.section === "colgroup");
    each$2(rows2, (rowData) => {
      const currentRow = [];
      each$2(rowData.cells, (rowCell) => {
        let start2 = 0;
        while (access[key(rowCount, start2)] !== void 0) {
          start2++;
        }
        const isLocked = hasNonNullableKey(lockedColumns, start2.toString());
        const current = extended(rowCell.element, rowCell.rowspan, rowCell.colspan, rowCount, start2, isLocked);
        for (let occupiedColumnPosition = 0; occupiedColumnPosition < rowCell.colspan; occupiedColumnPosition++) {
          for (let occupiedRowPosition = 0; occupiedRowPosition < rowCell.rowspan; occupiedRowPosition++) {
            const rowPosition = rowCount + occupiedRowPosition;
            const columnPosition = start2 + occupiedColumnPosition;
            const newpos = key(rowPosition, columnPosition);
            access[newpos] = current;
            maxColumns = Math.max(maxColumns, columnPosition + 1);
          }
        }
        currentRow.push(current);
      });
      maxRows++;
      cells2.push(rowdetail(rowData.element, currentRow, rowData.section));
      rowCount++;
    });
    const { columns: columns2, colgroups } = last$2(colgroupRows).map((rowData) => {
      const columns3 = generateColumns(rowData);
      const colgroup$1 = colgroup(rowData.element, values(columns3));
      return {
        colgroups: [colgroup$1],
        columns: columns3
      };
    }).getOrThunk(() => ({
      colgroups: [],
      columns: {}
    }));
    const grid$1 = grid(maxRows, maxColumns);
    return {
      grid: grid$1,
      access,
      all: cells2,
      columns: columns2,
      colgroups
    };
  };
  const fromTable = (table2) => {
    const list2 = fromTable$1(table2);
    return generate$1(list2);
  };
  const justCells = (warehouse) => bind$2(warehouse.all, (w) => w.cells);
  const justColumns = (warehouse) => values(warehouse.columns);
  const hasColumns = (warehouse) => keys(warehouse.columns).length > 0;
  const getColumnAt = (warehouse, columnIndex) => Optional.from(warehouse.columns[columnIndex]);
  const Warehouse = {
    fromTable,
    generate: generate$1,
    getAt,
    findItem,
    filterItems,
    justCells,
    justColumns,
    hasColumns,
    getColumnAt
  };
  const columns = (warehouse, isValidCell = always) => {
    const grid2 = warehouse.grid;
    const cols = range$1(grid2.columns, identity);
    const rowsArr = range$1(grid2.rows, identity);
    return map$1(cols, (col2) => {
      const getBlock = () => bind$2(rowsArr, (r2) => Warehouse.getAt(warehouse, r2, col2).filter((detail2) => detail2.column === col2).toArray());
      const isValid = (detail2) => detail2.colspan === 1 && isValidCell(detail2.element);
      const getFallback = () => Warehouse.getAt(warehouse, 0, col2);
      return decide(getBlock, isValid, getFallback);
    });
  };
  const decide = (getBlock, isValid, getFallback) => {
    const inBlock = getBlock();
    const validInBlock = find$1(inBlock, isValid);
    const detailOption = validInBlock.orThunk(() => Optional.from(inBlock[0]).orThunk(getFallback));
    return detailOption.map((detail2) => detail2.element);
  };
  const rows = (warehouse) => {
    const grid2 = warehouse.grid;
    const rowsArr = range$1(grid2.rows, identity);
    const cols = range$1(grid2.columns, identity);
    return map$1(rowsArr, (row2) => {
      const getBlock = () => bind$2(cols, (c) => Warehouse.getAt(warehouse, row2, c).filter((detail2) => detail2.row === row2).fold(constant([]), (detail2) => [detail2]));
      const isSingle = (detail2) => detail2.rowspan === 1;
      const getFallback = () => Warehouse.getAt(warehouse, row2, 0);
      return decide(getBlock, isSingle, getFallback);
    });
  };
  const deduce = (xs, index) => {
    if (index < 0 || index >= xs.length - 1) {
      return Optional.none();
    }
    const current = xs[index].fold(() => {
      const rest = reverse(xs.slice(0, index));
      return findMap(rest, (a, i) => a.map((aa) => ({
        value: aa,
        delta: i + 1
      })));
    }, (c) => Optional.some({
      value: c,
      delta: 0
    }));
    const next = xs[index + 1].fold(() => {
      const rest = xs.slice(index + 1);
      return findMap(rest, (a, i) => a.map((aa) => ({
        value: aa,
        delta: i + 1
      })));
    }, (n) => Optional.some({
      value: n,
      delta: 1
    }));
    return current.bind((c) => next.map((n) => {
      const extras = n.delta + c.delta;
      return Math.abs(n.value - c.value) / extras;
    }));
  };
  const onDirection = (isLtr, isRtl) => (element) => getDirection(element) === "rtl" ? isRtl : isLtr;
  const getDirection = (element) => get$a(element, "direction") === "rtl" ? "rtl" : "ltr";
  const api$1 = Dimension("height", (element) => {
    const dom = element.dom;
    return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;
  });
  const get$8 = (element) => api$1.get(element);
  const getOuter$1 = (element) => api$1.getOuter(element);
  const getRuntime = getHeight$1;
  const r = (left3, top2) => {
    const translate2 = (x, y) => r(left3 + x, top2 + y);
    return {
      left: left3,
      top: top2,
      translate: translate2
    };
  };
  const SugarPosition = r;
  const boxPosition = (dom) => {
    const box = dom.getBoundingClientRect();
    return SugarPosition(box.left, box.top);
  };
  const firstDefinedOrZero = (a, b) => {
    if (a !== void 0) {
      return a;
    } else {
      return b !== void 0 ? b : 0;
    }
  };
  const absolute = (element) => {
    const doc = element.dom.ownerDocument;
    const body2 = doc.body;
    const win = doc.defaultView;
    const html = doc.documentElement;
    if (body2 === element.dom) {
      return SugarPosition(body2.offsetLeft, body2.offsetTop);
    }
    const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);
    const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);
    const clientTop = firstDefinedOrZero(html.clientTop, body2.clientTop);
    const clientLeft = firstDefinedOrZero(html.clientLeft, body2.clientLeft);
    return viewport2(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);
  };
  const viewport2 = (element) => {
    const dom = element.dom;
    const doc = dom.ownerDocument;
    const body2 = doc.body;
    if (body2 === dom) {
      return SugarPosition(body2.offsetLeft, body2.offsetTop);
    }
    if (!inBody(element)) {
      return SugarPosition(0, 0);
    }
    return boxPosition(dom);
  };
  const rowInfo = (row2, y) => ({
    row: row2,
    y
  });
  const colInfo = (col2, x) => ({
    col: col2,
    x
  });
  const rtlEdge = (cell2) => {
    const pos = absolute(cell2);
    return pos.left + getOuter$2(cell2);
  };
  const ltrEdge = (cell2) => {
    return absolute(cell2).left;
  };
  const getLeftEdge = (index, cell2) => {
    return colInfo(index, ltrEdge(cell2));
  };
  const getRightEdge = (index, cell2) => {
    return colInfo(index, rtlEdge(cell2));
  };
  const getTop$1 = (cell2) => {
    return absolute(cell2).top;
  };
  const getTopEdge = (index, cell2) => {
    return rowInfo(index, getTop$1(cell2));
  };
  const getBottomEdge = (index, cell2) => {
    return rowInfo(index, getTop$1(cell2) + getOuter$1(cell2));
  };
  const findPositions = (getInnerEdge, getOuterEdge, array) => {
    if (array.length === 0) {
      return [];
    }
    const lines = map$1(array.slice(1), (cellOption, index) => {
      return cellOption.map((cell2) => {
        return getInnerEdge(index, cell2);
      });
    });
    const lastLine = array[array.length - 1].map((cell2) => {
      return getOuterEdge(array.length - 1, cell2);
    });
    return lines.concat([lastLine]);
  };
  const negate = (step) => {
    return -step;
  };
  const height2 = {
    delta: identity,
    positions: (optElements) => findPositions(getTopEdge, getBottomEdge, optElements),
    edge: getTop$1
  };
  const ltr$1 = {
    delta: identity,
    edge: ltrEdge,
    positions: (optElements) => findPositions(getLeftEdge, getRightEdge, optElements)
  };
  const rtl$1 = {
    delta: negate,
    edge: rtlEdge,
    positions: (optElements) => findPositions(getRightEdge, getLeftEdge, optElements)
  };
  const detect$1 = onDirection(ltr$1, rtl$1);
  const width2 = {
    delta: (amount, table2) => detect$1(table2).delta(amount, table2),
    positions: (cols, table2) => detect$1(table2).positions(cols, table2),
    edge: (cell2) => detect$1(cell2).edge(cell2)
  };
  const units = {
    unsupportedLength: [
      "em",
      "ex",
      "cap",
      "ch",
      "ic",
      "rem",
      "lh",
      "rlh",
      "vw",
      "vh",
      "vi",
      "vb",
      "vmin",
      "vmax",
      "cm",
      "mm",
      "Q",
      "in",
      "pc",
      "pt",
      "px"
    ],
    fixed: [
      "px",
      "pt"
    ],
    relative: ["%"],
    empty: [""]
  };
  const pattern = (() => {
    const decimalDigits = "[0-9]+";
    const signedInteger = "[+-]?" + decimalDigits;
    const exponentPart = "[eE]" + signedInteger;
    const dot = "\\.";
    const opt = (input) => `(?:${input})?`;
    const unsignedDecimalLiteral = [
      "Infinity",
      decimalDigits + dot + opt(decimalDigits) + opt(exponentPart),
      dot + decimalDigits + opt(exponentPart),
      decimalDigits + opt(exponentPart)
    ].join("|");
    const float = `[+-]?(?:${unsignedDecimalLiteral})`;
    return new RegExp(`^(${float})(.*)$`);
  })();
  const isUnit = (unit, accepted) => exists(accepted, (acc) => exists(units[acc], (check) => unit === check));
  const parse2 = (input, accepted) => {
    const match = Optional.from(pattern.exec(input));
    return match.bind((array) => {
      const value2 = Number(array[1]);
      const unitRaw = array[2];
      if (isUnit(unitRaw, accepted)) {
        return Optional.some({
          value: value2,
          unit: unitRaw
        });
      } else {
        return Optional.none();
      }
    });
  };
  const rPercentageBasedSizeRegex = /(\d+(\.\d+)?)%/;
  const rPixelBasedSizeRegex = /(\d+(\.\d+)?)px|em/;
  const isCol$2 = isTag("col");
  const getPercentSize = (elm, outerGetter, innerGetter) => {
    const relativeParent = parentElement(elm).getOrThunk(() => getBody$1(owner(elm)));
    return outerGetter(elm) / innerGetter(relativeParent) * 100;
  };
  const setPixelWidth = (cell2, amount) => {
    set$1(cell2, "width", amount + "px");
  };
  const setPercentageWidth = (cell2, amount) => {
    set$1(cell2, "width", amount + "%");
  };
  const setHeight = (cell2, amount) => {
    set$1(cell2, "height", amount + "px");
  };
  const getHeightValue = (cell2) => getRuntime(cell2) + "px";
  const convert = (cell2, number, getter, setter) => {
    const newSize = table(cell2).map((table2) => {
      const total2 = getter(table2);
      return Math.floor(number / 100 * total2);
    }).getOr(number);
    setter(cell2, newSize);
    return newSize;
  };
  const normalizePixelSize = (value2, cell2, getter, setter) => {
    const number = parseFloat(value2);
    return endsWith2(value2, "%") && name2(cell2) !== "table" ? convert(cell2, number, getter, setter) : number;
  };
  const getTotalHeight = (cell2) => {
    const value2 = getHeightValue(cell2);
    if (!value2) {
      return get$8(cell2);
    }
    return normalizePixelSize(value2, cell2, get$8, setHeight);
  };
  const get$7 = (cell2, type2, f) => {
    const v = f(cell2);
    const span = getSpan(cell2, type2);
    return v / span;
  };
  const getRaw$1 = (element, prop) => {
    return getRaw$2(element, prop).orThunk(() => {
      return getOpt(element, prop).map((val) => val + "px");
    });
  };
  const getRawWidth$1 = (element) => getRaw$1(element, "width");
  const getRawHeight = (element) => getRaw$1(element, "height");
  const getPercentageWidth = (cell2) => getPercentSize(cell2, get$9, getInner);
  const getPixelWidth$1 = (cell2) => isCol$2(cell2) ? get$9(cell2) : getRuntime$1(cell2);
  const getHeight = (cell2) => {
    return get$7(cell2, "rowspan", getTotalHeight);
  };
  const getGenericWidth = (cell2) => {
    const width3 = getRawWidth$1(cell2);
    return width3.bind((w) => parse2(w, [
      "fixed",
      "relative",
      "empty"
    ]));
  };
  const setGenericWidth = (cell2, amount, unit) => {
    set$1(cell2, "width", amount + unit);
  };
  const getPixelTableWidth = (table2) => get$9(table2) + "px";
  const getPercentTableWidth = (table2) => getPercentSize(table2, get$9, getInner) + "%";
  const isPercentSizing$1 = (table2) => getRawWidth$1(table2).exists((size) => rPercentageBasedSizeRegex.test(size));
  const isPixelSizing$1 = (table2) => getRawWidth$1(table2).exists((size) => rPixelBasedSizeRegex.test(size));
  const isNoneSizing$1 = (table2) => getRawWidth$1(table2).isNone();
  const percentageBasedSizeRegex = constant(rPercentageBasedSizeRegex);
  const isCol$1 = isTag("col");
  const getRawW = (cell2) => {
    return getRawWidth$1(cell2).getOrThunk(() => getPixelWidth$1(cell2) + "px");
  };
  const getRawH = (cell2) => {
    return getRawHeight(cell2).getOrThunk(() => getHeight(cell2) + "px");
  };
  const justCols = (warehouse) => map$1(Warehouse.justColumns(warehouse), (column) => Optional.from(column.element));
  const isValidColumn = (cell2) => {
    const browser2 = detect$2().browser;
    const supportsColWidths = browser2.isChromium() || browser2.isFirefox();
    return isCol$1(cell2) ? supportsColWidths : true;
  };
  const getDimension = (cellOpt, index, backups, filter3, getter, fallback2) => cellOpt.filter(filter3).fold(() => fallback2(deduce(backups, index)), (cell2) => getter(cell2));
  const getWidthFrom = (warehouse, table2, getWidth2, fallback2) => {
    const columnCells = columns(warehouse);
    const columns$12 = Warehouse.hasColumns(warehouse) ? justCols(warehouse) : columnCells;
    const backups = [Optional.some(width2.edge(table2))].concat(map$1(width2.positions(columnCells, table2), (pos) => pos.map((p) => p.x)));
    const colFilter = not(hasColspan);
    return map$1(columns$12, (cellOption, c) => {
      return getDimension(cellOption, c, backups, colFilter, (column) => {
        if (isValidColumn(column)) {
          return getWidth2(column);
        } else {
          const cell2 = bindFrom(columnCells[c], identity);
          return getDimension(cell2, c, backups, colFilter, (cell3) => fallback2(Optional.some(get$9(cell3))), fallback2);
        }
      }, fallback2);
    });
  };
  const getDeduced = (deduced) => {
    return deduced.map((d) => {
      return d + "px";
    }).getOr("");
  };
  const getRawWidths = (warehouse, table2) => {
    return getWidthFrom(warehouse, table2, getRawW, getDeduced);
  };
  const getPercentageWidths = (warehouse, table2, tableSize) => {
    return getWidthFrom(warehouse, table2, getPercentageWidth, (deduced) => {
      return deduced.fold(() => {
        return tableSize.minCellWidth();
      }, (cellWidth) => {
        return cellWidth / tableSize.pixelWidth() * 100;
      });
    });
  };
  const getPixelWidths = (warehouse, table2, tableSize) => {
    return getWidthFrom(warehouse, table2, getPixelWidth$1, (deduced) => {
      return deduced.getOrThunk(tableSize.minCellWidth);
    });
  };
  const getHeightFrom = (warehouse, table2, direction, getHeight2, fallback2) => {
    const rows$12 = rows(warehouse);
    const backups = [Optional.some(direction.edge(table2))].concat(map$1(direction.positions(rows$12, table2), (pos) => pos.map((p) => p.y)));
    return map$1(rows$12, (cellOption, c) => {
      return getDimension(cellOption, c, backups, not(hasRowspan), getHeight2, fallback2);
    });
  };
  const getPixelHeights = (warehouse, table2, direction) => {
    return getHeightFrom(warehouse, table2, direction, getHeight, (deduced) => {
      return deduced.getOrThunk(minHeight);
    });
  };
  const getRawHeights = (warehouse, table2, direction) => {
    return getHeightFrom(warehouse, table2, direction, getRawH, getDeduced);
  };
  const widthLookup = (table2, getter) => () => {
    if (inBody(table2)) {
      return getter(table2);
    } else {
      return parseFloat(getRaw$2(table2, "width").getOr("0"));
    }
  };
  const noneSize = (table2) => {
    const getWidth2 = widthLookup(table2, get$9);
    const zero2 = constant(0);
    const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table2, tableSize);
    return {
      width: getWidth2,
      pixelWidth: getWidth2,
      getWidths,
      getCellDelta: zero2,
      singleColumnWidth: constant([0]),
      minCellWidth: zero2,
      setElementWidth: noop2,
      adjustTableWidth: noop2,
      isRelative: true,
      label: "none"
    };
  };
  const percentageSize = (table2) => {
    const getFloatWidth = widthLookup(table2, (elem) => parseFloat(getPercentTableWidth(elem)));
    const getWidth2 = widthLookup(table2, get$9);
    const getCellDelta = (delta) => delta / getWidth2() * 100;
    const singleColumnWidth = (w, _delta) => [100 - w];
    const minCellWidth = () => minWidth() / getWidth2() * 100;
    const adjustTableWidth = (delta) => {
      const currentWidth = getFloatWidth();
      const change = delta / 100 * currentWidth;
      const newWidth = currentWidth + change;
      setPercentageWidth(table2, newWidth);
    };
    const getWidths = (warehouse, tableSize) => getPercentageWidths(warehouse, table2, tableSize);
    return {
      width: getFloatWidth,
      pixelWidth: getWidth2,
      getWidths,
      getCellDelta,
      singleColumnWidth,
      minCellWidth,
      setElementWidth: setPercentageWidth,
      adjustTableWidth,
      isRelative: true,
      label: "percent"
    };
  };
  const pixelSize = (table2) => {
    const getWidth2 = widthLookup(table2, get$9);
    const getCellDelta = identity;
    const singleColumnWidth = (w, delta) => {
      const newNext = Math.max(minWidth(), w + delta);
      return [newNext - w];
    };
    const adjustTableWidth = (delta) => {
      const newWidth = getWidth2() + delta;
      setPixelWidth(table2, newWidth);
    };
    const getWidths = (warehouse, tableSize) => getPixelWidths(warehouse, table2, tableSize);
    return {
      width: getWidth2,
      pixelWidth: getWidth2,
      getWidths,
      getCellDelta,
      singleColumnWidth,
      minCellWidth: minWidth,
      setElementWidth: setPixelWidth,
      adjustTableWidth,
      isRelative: false,
      label: "pixel"
    };
  };
  const chooseSize = (element, width3) => {
    const percentMatch = percentageBasedSizeRegex().exec(width3);
    if (percentMatch !== null) {
      return percentageSize(element);
    } else {
      return pixelSize(element);
    }
  };
  const getTableSize = (table2) => {
    const width3 = getRawWidth$1(table2);
    return width3.fold(() => noneSize(table2), (w) => chooseSize(table2, w));
  };
  const TableSize = {
    getTableSize,
    pixelSize,
    percentageSize,
    noneSize
  };
  const statsStruct = (minRow, minCol, maxRow, maxCol, allCells, selectedCells) => ({
    minRow,
    minCol,
    maxRow,
    maxCol,
    allCells,
    selectedCells
  });
  const findSelectedStats = (house, isSelected) => {
    const totalColumns = house.grid.columns;
    const totalRows = house.grid.rows;
    let minRow = totalRows;
    let minCol = totalColumns;
    let maxRow = 0;
    let maxCol = 0;
    const allCells = [];
    const selectedCells = [];
    each$1(house.access, (detail2) => {
      allCells.push(detail2);
      if (isSelected(detail2)) {
        selectedCells.push(detail2);
        const startRow = detail2.row;
        const endRow = startRow + detail2.rowspan - 1;
        const startCol = detail2.column;
        const endCol = startCol + detail2.colspan - 1;
        if (startRow < minRow) {
          minRow = startRow;
        } else if (endRow > maxRow) {
          maxRow = endRow;
        }
        if (startCol < minCol) {
          minCol = startCol;
        } else if (endCol > maxCol) {
          maxCol = endCol;
        }
      }
    });
    return statsStruct(minRow, minCol, maxRow, maxCol, allCells, selectedCells);
  };
  const makeCell = (list2, seenSelected, rowIndex) => {
    const row2 = list2[rowIndex].element;
    const td = SugarElement.fromTag("td");
    append$1(td, SugarElement.fromTag("br"));
    const f = seenSelected ? append$1 : prepend;
    f(row2, td);
  };
  const fillInGaps = (list2, house, stats, isSelected) => {
    const rows2 = filter$2(list2, (row2) => row2.section !== "colgroup");
    const totalColumns = house.grid.columns;
    const totalRows = house.grid.rows;
    for (let i = 0; i < totalRows; i++) {
      let seenSelected = false;
      for (let j = 0; j < totalColumns; j++) {
        if (!(i < stats.minRow || i > stats.maxRow || j < stats.minCol || j > stats.maxCol)) {
          const needCell = Warehouse.getAt(house, i, j).filter(isSelected).isNone();
          if (needCell) {
            makeCell(rows2, seenSelected, i);
          } else {
            seenSelected = true;
          }
        }
      }
    }
  };
  const clean = (replica, stats, house, widthDelta) => {
    each$1(house.columns, (col2) => {
      if (col2.column < stats.minCol || col2.column > stats.maxCol) {
        remove$6(col2.element);
      }
    });
    const emptyRows = filter$2(firstLayer(replica, "tr"), (row2) => row2.dom.childElementCount === 0);
    each$2(emptyRows, remove$6);
    if (stats.minCol === stats.maxCol || stats.minRow === stats.maxRow) {
      each$2(firstLayer(replica, "th,td"), (cell2) => {
        remove$7(cell2, "rowspan");
        remove$7(cell2, "colspan");
      });
    }
    remove$7(replica, LOCKED_COL_ATTR);
    remove$7(replica, "data-snooker-col-series");
    const tableSize = TableSize.getTableSize(replica);
    tableSize.adjustTableWidth(widthDelta);
  };
  const getTableWidthDelta = (table2, warehouse, tableSize, stats) => {
    if (stats.minCol === 0 && warehouse.grid.columns === stats.maxCol + 1) {
      return 0;
    }
    const colWidths = getPixelWidths(warehouse, table2, tableSize);
    const allColsWidth = foldl(colWidths, (acc, width3) => acc + width3, 0);
    const selectedColsWidth = foldl(colWidths.slice(stats.minCol, stats.maxCol + 1), (acc, width3) => acc + width3, 0);
    const newWidth = selectedColsWidth / allColsWidth * tableSize.pixelWidth();
    const delta = newWidth - tableSize.pixelWidth();
    return tableSize.getCellDelta(delta);
  };
  const extract$1 = (table2, selectedSelector) => {
    const isSelected = (detail2) => is$2(detail2.element, selectedSelector);
    const replica = deep(table2);
    const list2 = fromTable$1(replica);
    const tableSize = TableSize.getTableSize(table2);
    const replicaHouse = Warehouse.generate(list2);
    const replicaStats = findSelectedStats(replicaHouse, isSelected);
    const selector = "th:not(" + selectedSelector + "),td:not(" + selectedSelector + ")";
    const unselectedCells = filterFirstLayer(replica, "th,td", (cell2) => is$2(cell2, selector));
    each$2(unselectedCells, remove$6);
    fillInGaps(list2, replicaHouse, replicaStats, isSelected);
    const house = Warehouse.fromTable(table2);
    const widthDelta = getTableWidthDelta(table2, house, tableSize, replicaStats);
    clean(replica, replicaStats, replicaHouse, widthDelta);
    return replica;
  };
  const nbsp = " ";
  const NodeValue = (is2, name3) => {
    const get2 = (element) => {
      if (!is2(element)) {
        throw new Error("Can only get " + name3 + " value of a " + name3 + " node");
      }
      return getOption2(element).getOr("");
    };
    const getOption2 = (element) => is2(element) ? Optional.from(element.dom.nodeValue) : Optional.none();
    const set2 = (element, value2) => {
      if (!is2(element)) {
        throw new Error("Can only set raw " + name3 + " value of a " + name3 + " node");
      }
      element.dom.nodeValue = value2;
    };
    return {
      get: get2,
      getOption: getOption2,
      set: set2
    };
  };
  const api = NodeValue(isText, "text");
  const get$6 = (element) => api.get(element);
  const getOption = (element) => api.getOption(element);
  const set = (element, value2) => api.set(element, value2);
  const getEnd = (element) => name2(element) === "img" ? 1 : getOption(element).fold(() => children$2(element).length, (v) => v.length);
  const isTextNodeWithCursorPosition = (el) => getOption(el).filter((text2) => text2.trim().length !== 0 || text2.indexOf(nbsp) > -1).isSome();
  const isContentEditableFalse = (elem) => isHTMLElement2(elem) && get$b(elem, "contenteditable") === "false";
  const elementsWithCursorPosition = [
    "img",
    "br"
  ];
  const isCursorPosition = (elem) => {
    const hasCursorPosition = isTextNodeWithCursorPosition(elem);
    return hasCursorPosition || contains$2(elementsWithCursorPosition, name2(elem)) || isContentEditableFalse(elem);
  };
  const first = (element) => descendant$1(element, isCursorPosition);
  const last$1 = (element) => descendantRtl(element, isCursorPosition);
  const descendantRtl = (scope, predicate) => {
    const descend = (element) => {
      const children2 = children$2(element);
      for (let i = children2.length - 1; i >= 0; i--) {
        const child2 = children2[i];
        if (predicate(child2)) {
          return Optional.some(child2);
        }
        const res2 = descend(child2);
        if (res2.isSome()) {
          return res2;
        }
      }
      return Optional.none();
    };
    return descend(scope);
  };
  const transferableAttributes = {
    scope: [
      "row",
      "col"
    ]
  };
  const createCell = (doc) => () => {
    const td = SugarElement.fromTag("td", doc.dom);
    append$1(td, SugarElement.fromTag("br", doc.dom));
    return td;
  };
  const createCol = (doc) => () => {
    return SugarElement.fromTag("col", doc.dom);
  };
  const createColgroup = (doc) => () => {
    return SugarElement.fromTag("colgroup", doc.dom);
  };
  const createRow$1 = (doc) => () => {
    return SugarElement.fromTag("tr", doc.dom);
  };
  const replace$1 = (cell2, tag, attrs) => {
    const replica = copy$2(cell2, tag);
    each$1(attrs, (v, k) => {
      if (v === null) {
        remove$7(replica, k);
      } else {
        set$2(replica, k, v);
      }
    });
    return replica;
  };
  const pasteReplace = (cell2) => {
    return cell2;
  };
  const cloneFormats = (oldCell, newCell, formats) => {
    const first$1 = first(oldCell);
    return first$1.map((firstText) => {
      const formatSelector = formats.join(",");
      const parents2 = ancestors$3(firstText, formatSelector, (element) => {
        return eq$1(element, oldCell);
      });
      return foldr(parents2, (last2, parent2) => {
        const clonedFormat = shallow(parent2);
        append$1(last2, clonedFormat);
        return clonedFormat;
      }, newCell);
    }).getOr(newCell);
  };
  const cloneAppropriateAttributes = (original, clone2) => {
    each$1(transferableAttributes, (validAttributes, attributeName) => getOpt(original, attributeName).filter((attribute) => contains$2(validAttributes, attribute)).each((attribute) => set$2(clone2, attributeName, attribute)));
  };
  const cellOperations = (mutate2, doc, formatsToClone) => {
    const cloneCss = (prev, clone2) => {
      copy$1(prev.element, clone2);
      remove$5(clone2, "height");
      if (prev.colspan !== 1) {
        remove$5(clone2, "width");
      }
    };
    const newCell = (prev) => {
      const td = SugarElement.fromTag(name2(prev.element), doc.dom);
      const formats = formatsToClone.getOr([
        "strong",
        "em",
        "b",
        "i",
        "span",
        "font",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div"
      ]);
      const lastNode = formats.length > 0 ? cloneFormats(prev.element, td, formats) : td;
      append$1(lastNode, SugarElement.fromTag("br"));
      cloneCss(prev, td);
      cloneAppropriateAttributes(prev.element, td);
      mutate2(prev.element, td);
      return td;
    };
    const newCol = (prev) => {
      const col2 = SugarElement.fromTag(name2(prev.element), doc.dom);
      cloneCss(prev, col2);
      mutate2(prev.element, col2);
      return col2;
    };
    return {
      col: newCol,
      colgroup: createColgroup(doc),
      row: createRow$1(doc),
      cell: newCell,
      replace: replace$1,
      colGap: createCol(doc),
      gap: createCell(doc)
    };
  };
  const paste$1 = (doc) => {
    return {
      col: createCol(doc),
      colgroup: createColgroup(doc),
      row: createRow$1(doc),
      cell: createCell(doc),
      replace: pasteReplace,
      colGap: createCol(doc),
      gap: createCell(doc)
    };
  };
  const fromHtml = (html, scope) => {
    const doc = scope || document;
    const div = doc.createElement("div");
    div.innerHTML = html;
    return children$2(SugarElement.fromDom(div));
  };
  const fromDom = (nodes) => map$1(nodes, SugarElement.fromDom);
  const closest = (target) => closest$1(target, "[contenteditable]");
  const isEditable$1 = (element, assumeEditable = false) => {
    if (inBody(element)) {
      return element.dom.isContentEditable;
    } else {
      return closest(element).fold(constant(assumeEditable), (editable) => getRaw(editable) === "true");
    }
  };
  const getRaw = (element) => element.dom.contentEditable;
  const getBody = (editor) => SugarElement.fromDom(editor.getBody());
  const getIsRoot = (editor) => (element) => eq$1(element, getBody(editor));
  const removeDataStyle = (table2) => {
    remove$7(table2, "data-mce-style");
    const removeStyleAttribute = (element) => remove$7(element, "data-mce-style");
    each$2(cells$1(table2), removeStyleAttribute);
    each$2(columns$1(table2), removeStyleAttribute);
    each$2(rows$1(table2), removeStyleAttribute);
  };
  const getSelectionStart = (editor) => SugarElement.fromDom(editor.selection.getStart());
  const getPixelWidth = (elm) => elm.getBoundingClientRect().width;
  const getPixelHeight = (elm) => elm.getBoundingClientRect().height;
  const getRawWidth = (editor, elm) => {
    const raw = editor.dom.getStyle(elm, "width") || editor.dom.getAttrib(elm, "width");
    return Optional.from(raw).filter(isNotEmpty);
  };
  const isPercentage$1 = (value2) => /^(\d+(\.\d+)?)%$/.test(value2);
  const isPixel = (value2) => /^(\d+(\.\d+)?)px$/.test(value2);
  const isInEditableContext$1 = (cell2) => closest$2(cell2, isTag("table")).exists(isEditable$1);
  const inSelection = (bounds2, detail2) => {
    const leftEdge = detail2.column;
    const rightEdge = detail2.column + detail2.colspan - 1;
    const topEdge = detail2.row;
    const bottomEdge = detail2.row + detail2.rowspan - 1;
    return leftEdge <= bounds2.finishCol && rightEdge >= bounds2.startCol && (topEdge <= bounds2.finishRow && bottomEdge >= bounds2.startRow);
  };
  const isWithin = (bounds2, detail2) => {
    return detail2.column >= bounds2.startCol && detail2.column + detail2.colspan - 1 <= bounds2.finishCol && detail2.row >= bounds2.startRow && detail2.row + detail2.rowspan - 1 <= bounds2.finishRow;
  };
  const isRectangular = (warehouse, bounds2) => {
    let isRect = true;
    const detailIsWithin = curry(isWithin, bounds2);
    for (let i = bounds2.startRow; i <= bounds2.finishRow; i++) {
      for (let j = bounds2.startCol; j <= bounds2.finishCol; j++) {
        isRect = isRect && Warehouse.getAt(warehouse, i, j).exists(detailIsWithin);
      }
    }
    return isRect ? Optional.some(bounds2) : Optional.none();
  };
  const getBounds = (detailA, detailB) => {
    return bounds(Math.min(detailA.row, detailB.row), Math.min(detailA.column, detailB.column), Math.max(detailA.row + detailA.rowspan - 1, detailB.row + detailB.rowspan - 1), Math.max(detailA.column + detailA.colspan - 1, detailB.column + detailB.colspan - 1));
  };
  const getAnyBox = (warehouse, startCell, finishCell) => {
    const startCoords = Warehouse.findItem(warehouse, startCell, eq$1);
    const finishCoords = Warehouse.findItem(warehouse, finishCell, eq$1);
    return startCoords.bind((sc) => {
      return finishCoords.map((fc) => {
        return getBounds(sc, fc);
      });
    });
  };
  const getBox$1 = (warehouse, startCell, finishCell) => {
    return getAnyBox(warehouse, startCell, finishCell).bind((bounds2) => {
      return isRectangular(warehouse, bounds2);
    });
  };
  const moveBy$1 = (warehouse, cell2, row2, column) => {
    return Warehouse.findItem(warehouse, cell2, eq$1).bind((detail2) => {
      const startRow = row2 > 0 ? detail2.row + detail2.rowspan - 1 : detail2.row;
      const startCol = column > 0 ? detail2.column + detail2.colspan - 1 : detail2.column;
      const dest = Warehouse.getAt(warehouse, startRow + row2, startCol + column);
      return dest.map((d) => {
        return d.element;
      });
    });
  };
  const intercepts$1 = (warehouse, start2, finish) => {
    return getAnyBox(warehouse, start2, finish).map((bounds2) => {
      const inside = Warehouse.filterItems(warehouse, curry(inSelection, bounds2));
      return map$1(inside, (detail2) => {
        return detail2.element;
      });
    });
  };
  const parentCell = (warehouse, innerCell) => {
    const isContainedBy = (c1, c2) => {
      return contains$1(c2, c1);
    };
    return Warehouse.findItem(warehouse, innerCell, isContainedBy).map((detail2) => {
      return detail2.element;
    });
  };
  const moveBy = (cell2, deltaRow, deltaColumn) => {
    return table(cell2).bind((table2) => {
      const warehouse = getWarehouse(table2);
      return moveBy$1(warehouse, cell2, deltaRow, deltaColumn);
    });
  };
  const intercepts = (table2, first2, last2) => {
    const warehouse = getWarehouse(table2);
    return intercepts$1(warehouse, first2, last2);
  };
  const nestedIntercepts = (table2, first2, firstTable, last2, lastTable) => {
    const warehouse = getWarehouse(table2);
    const optStartCell = eq$1(table2, firstTable) ? Optional.some(first2) : parentCell(warehouse, first2);
    const optLastCell = eq$1(table2, lastTable) ? Optional.some(last2) : parentCell(warehouse, last2);
    return optStartCell.bind((startCell) => optLastCell.bind((lastCell) => intercepts$1(warehouse, startCell, lastCell)));
  };
  const getBox = (table2, first2, last2) => {
    const warehouse = getWarehouse(table2);
    return getBox$1(warehouse, first2, last2);
  };
  const getWarehouse = Warehouse.fromTable;
  var TagBoundaries = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "li",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ];
  var DomUniverse = () => {
    const clone2 = (element) => {
      return SugarElement.fromDom(element.dom.cloneNode(false));
    };
    const document2 = (element) => documentOrOwner(element).dom;
    const isBoundary = (element) => {
      if (!isElement2(element)) {
        return false;
      }
      if (name2(element) === "body") {
        return true;
      }
      return contains$2(TagBoundaries, name2(element));
    };
    const isEmptyTag2 = (element) => {
      if (!isElement2(element)) {
        return false;
      }
      return contains$2([
        "br",
        "img",
        "hr",
        "input"
      ], name2(element));
    };
    const isNonEditable = (element) => isElement2(element) && get$b(element, "contenteditable") === "false";
    const comparePosition = (element, other) => {
      return element.dom.compareDocumentPosition(other.dom);
    };
    const copyAttributesTo = (source, destination) => {
      const as = clone$2(source);
      setAll$1(destination, as);
    };
    const isSpecial = (element) => {
      const tag = name2(element);
      return contains$2([
        "script",
        "noscript",
        "iframe",
        "noframes",
        "noembed",
        "title",
        "style",
        "textarea",
        "xmp"
      ], tag);
    };
    const getLanguage = (element) => isElement2(element) ? getOpt(element, "lang") : Optional.none();
    return {
      up: constant({
        selector: ancestor$1,
        closest: closest$1,
        predicate: ancestor$2,
        all: parents
      }),
      down: constant({
        selector: descendants,
        predicate: descendants$1
      }),
      styles: constant({
        get: get$a,
        getRaw: getRaw$2,
        set: set$1,
        remove: remove$5
      }),
      attrs: constant({
        get: get$b,
        set: set$2,
        remove: remove$7,
        copyTo: copyAttributesTo
      }),
      insert: constant({
        before: before$3,
        after: after$5,
        afterAll: after$4,
        append: append$1,
        appendAll: append2,
        prepend,
        wrap
      }),
      remove: constant({
        unwrap,
        remove: remove$6
      }),
      create: constant({
        nu: SugarElement.fromTag,
        clone: clone2,
        text: SugarElement.fromText
      }),
      query: constant({
        comparePosition,
        prevSibling,
        nextSibling
      }),
      property: constant({
        children: children$2,
        name: name2,
        parent,
        document: document2,
        isText,
        isComment,
        isElement: isElement2,
        isSpecial,
        getLanguage,
        getText: get$6,
        setText: set,
        isBoundary,
        isEmptyTag: isEmptyTag2,
        isNonEditable
      }),
      eq: eq$1,
      is: is$1
    };
  };
  const all2 = (universe2, look, elements, f) => {
    const head2 = elements[0];
    const tail = elements.slice(1);
    return f(universe2, look, head2, tail);
  };
  const oneAll = (universe2, look, elements) => {
    return elements.length > 0 ? all2(universe2, look, elements, unsafeOne) : Optional.none();
  };
  const unsafeOne = (universe2, look, head2, tail) => {
    const start2 = look(universe2, head2);
    return foldr(tail, (b, a) => {
      const current = look(universe2, a);
      return commonElement(universe2, b, current);
    }, start2);
  };
  const commonElement = (universe2, start2, end2) => {
    return start2.bind((s) => {
      return end2.filter(curry(universe2.eq, s));
    });
  };
  const eq = (universe2, item2) => {
    return curry(universe2.eq, item2);
  };
  const ancestors$2 = (universe2, start2, end2, isRoot = never) => {
    const ps1 = [start2].concat(universe2.up().all(start2));
    const ps2 = [end2].concat(universe2.up().all(end2));
    const prune2 = (path2) => {
      const index = findIndex(path2, isRoot);
      return index.fold(() => {
        return path2;
      }, (ind) => {
        return path2.slice(0, ind + 1);
      });
    };
    const pruned1 = prune2(ps1);
    const pruned2 = prune2(ps2);
    const shared = find$1(pruned1, (x) => {
      return exists(pruned2, eq(universe2, x));
    });
    return {
      firstpath: pruned1,
      secondpath: pruned2,
      shared
    };
  };
  const sharedOne$1 = oneAll;
  const ancestors$1 = ancestors$2;
  const universe$3 = DomUniverse();
  const sharedOne = (look, elements) => {
    return sharedOne$1(universe$3, (_universe, element) => {
      return look(element);
    }, elements);
  };
  const ancestors = (start2, finish, isRoot) => {
    return ancestors$1(universe$3, start2, finish, isRoot);
  };
  const lookupTable = (container) => {
    return ancestor$1(container, "table");
  };
  const identify = (start2, finish, isRoot) => {
    const getIsRoot2 = (rootTable) => {
      return (element) => {
        return isRoot !== void 0 && isRoot(element) || eq$1(element, rootTable);
      };
    };
    if (eq$1(start2, finish)) {
      return Optional.some({
        boxes: Optional.some([start2]),
        start: start2,
        finish
      });
    } else {
      return lookupTable(start2).bind((startTable) => {
        return lookupTable(finish).bind((finishTable) => {
          if (eq$1(startTable, finishTable)) {
            return Optional.some({
              boxes: intercepts(startTable, start2, finish),
              start: start2,
              finish
            });
          } else if (contains$1(startTable, finishTable)) {
            const ancestorCells = ancestors$3(finish, "td,th", getIsRoot2(startTable));
            const finishCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : finish;
            return Optional.some({
              boxes: nestedIntercepts(startTable, start2, startTable, finish, finishTable),
              start: start2,
              finish: finishCell
            });
          } else if (contains$1(finishTable, startTable)) {
            const ancestorCells = ancestors$3(start2, "td,th", getIsRoot2(finishTable));
            const startCell = ancestorCells.length > 0 ? ancestorCells[ancestorCells.length - 1] : start2;
            return Optional.some({
              boxes: nestedIntercepts(finishTable, start2, startTable, finish, finishTable),
              start: start2,
              finish: startCell
            });
          } else {
            return ancestors(start2, finish).shared.bind((lca) => {
              return closest$1(lca, "table", isRoot).bind((lcaTable) => {
                const finishAncestorCells = ancestors$3(finish, "td,th", getIsRoot2(lcaTable));
                const finishCell = finishAncestorCells.length > 0 ? finishAncestorCells[finishAncestorCells.length - 1] : finish;
                const startAncestorCells = ancestors$3(start2, "td,th", getIsRoot2(lcaTable));
                const startCell = startAncestorCells.length > 0 ? startAncestorCells[startAncestorCells.length - 1] : start2;
                return Optional.some({
                  boxes: nestedIntercepts(lcaTable, start2, startTable, finish, finishTable),
                  start: startCell,
                  finish: finishCell
                });
              });
            });
          }
        });
      });
    }
  };
  const retrieve$1 = (container, selector) => {
    const sels = descendants(container, selector);
    return sels.length > 0 ? Optional.some(sels) : Optional.none();
  };
  const getLast = (boxes, lastSelectedSelector) => {
    return find$1(boxes, (box) => {
      return is$2(box, lastSelectedSelector);
    });
  };
  const getEdges = (container, firstSelectedSelector, lastSelectedSelector) => {
    return descendant(container, firstSelectedSelector).bind((first2) => {
      return descendant(container, lastSelectedSelector).bind((last2) => {
        return sharedOne(lookupTable, [
          first2,
          last2
        ]).map((table2) => {
          return {
            first: first2,
            last: last2,
            table: table2
          };
        });
      });
    });
  };
  const expandTo = (finish, firstSelectedSelector) => {
    return ancestor$1(finish, "table").bind((table2) => {
      return descendant(table2, firstSelectedSelector).bind((start2) => {
        return identify(start2, finish).bind((identified) => {
          return identified.boxes.map((boxes) => {
            return {
              boxes,
              start: identified.start,
              finish: identified.finish
            };
          });
        });
      });
    });
  };
  const shiftSelection = (boxes, deltaRow, deltaColumn, firstSelectedSelector, lastSelectedSelector) => {
    return getLast(boxes, lastSelectedSelector).bind((last2) => {
      return moveBy(last2, deltaRow, deltaColumn).bind((finish) => {
        return expandTo(finish, firstSelectedSelector);
      });
    });
  };
  const retrieve = (container, selector) => {
    return retrieve$1(container, selector);
  };
  const retrieveBox = (container, firstSelectedSelector, lastSelectedSelector) => {
    return getEdges(container, firstSelectedSelector, lastSelectedSelector).bind((edges) => {
      const isRoot = (ancestor2) => {
        return eq$1(container, ancestor2);
      };
      const sectionSelector = "thead,tfoot,tbody,table";
      const firstAncestor = ancestor$1(edges.first, sectionSelector, isRoot);
      const lastAncestor = ancestor$1(edges.last, sectionSelector, isRoot);
      return firstAncestor.bind((fA) => {
        return lastAncestor.bind((lA) => {
          return eq$1(fA, lA) ? getBox(edges.table, edges.first, edges.last) : Optional.none();
        });
      });
    });
  };
  const selection = identity;
  const unmergable = (selectedCells) => {
    const hasSpan = (elem, type2) => getOpt(elem, type2).exists((span) => parseInt(span, 10) > 1);
    const hasRowOrColSpan = (elem) => hasSpan(elem, "rowspan") || hasSpan(elem, "colspan");
    return selectedCells.length > 0 && forall(selectedCells, hasRowOrColSpan) ? Optional.some(selectedCells) : Optional.none();
  };
  const mergable = (table2, selectedCells, ephemera2) => {
    if (selectedCells.length <= 1) {
      return Optional.none();
    } else {
      return retrieveBox(table2, ephemera2.firstSelectedSelector, ephemera2.lastSelectedSelector).map((bounds2) => ({
        bounds: bounds2,
        cells: selectedCells
      }));
    }
  };
  const strSelected = "data-mce-selected";
  const strSelectedSelector = "td[" + strSelected + "],th[" + strSelected + "]";
  const strAttributeSelector = "[" + strSelected + "]";
  const strFirstSelected = "data-mce-first-selected";
  const strFirstSelectedSelector = "td[" + strFirstSelected + "],th[" + strFirstSelected + "]";
  const strLastSelected = "data-mce-last-selected";
  const strLastSelectedSelector = "td[" + strLastSelected + "],th[" + strLastSelected + "]";
  const attributeSelector = strAttributeSelector;
  const ephemera = {
    selected: strSelected,
    selectedSelector: strSelectedSelector,
    firstSelected: strFirstSelected,
    firstSelectedSelector: strFirstSelectedSelector,
    lastSelected: strLastSelected,
    lastSelectedSelector: strLastSelectedSelector
  };
  const forMenu = (selectedCells, table2, cell2) => ({
    element: cell2,
    mergable: mergable(table2, selectedCells, ephemera),
    unmergable: unmergable(selectedCells),
    selection: selection(selectedCells)
  });
  const paste = (element, clipboard, generators) => ({
    element,
    clipboard,
    generators
  });
  const pasteRows = (selectedCells, _cell, clipboard, generators) => ({
    selection: selection(selectedCells),
    clipboard,
    generators
  });
  const getSelectionCellFallback = (element) => table(element).bind((table2) => retrieve(table2, ephemera.firstSelectedSelector)).fold(constant(element), (cells2) => cells2[0]);
  const getSelectionFromSelector = (selector) => (initCell, isRoot) => {
    const cellName = name2(initCell);
    const cell2 = cellName === "col" || cellName === "colgroup" ? getSelectionCellFallback(initCell) : initCell;
    return closest$1(cell2, selector, isRoot);
  };
  const getSelectionCellOrCaption = getSelectionFromSelector("th,td,caption");
  const getSelectionCell = getSelectionFromSelector("th,td");
  const getCellsFromSelection = (editor) => fromDom(editor.model.table.getSelectedCells());
  const getCellsFromFakeSelection = (editor) => filter$2(getCellsFromSelection(editor), (cell2) => is$2(cell2, ephemera.selectedSelector));
  const extractSelected = (cells2) => {
    return table(cells2[0]).map((table2) => {
      const replica = extract$1(table2, attributeSelector);
      removeDataStyle(replica);
      return [replica];
    });
  };
  const serializeElements = (editor, elements) => map$1(elements, (elm) => editor.selection.serializer.serialize(elm.dom, {})).join("");
  const getTextContent = (elements) => map$1(elements, (element) => element.dom.innerText).join("");
  const registerEvents = (editor, actions2) => {
    editor.on("BeforeGetContent", (e) => {
      const multiCellContext = (cells2) => {
        e.preventDefault();
        extractSelected(cells2).each((elements) => {
          e.content = e.format === "text" ? getTextContent(elements) : serializeElements(editor, elements);
        });
      };
      if (e.selection === true) {
        const cells2 = getCellsFromFakeSelection(editor);
        if (cells2.length >= 1) {
          multiCellContext(cells2);
        }
      }
    });
    editor.on("BeforeSetContent", (e) => {
      if (e.selection === true && e.paste === true) {
        const selectedCells = getCellsFromSelection(editor);
        head(selectedCells).each((cell2) => {
          table(cell2).each((table2) => {
            const elements = filter$2(fromHtml(e.content), (content) => {
              return name2(content) !== "meta";
            });
            const isTable2 = isTag("table");
            if (elements.length === 1 && isTable2(elements[0])) {
              e.preventDefault();
              const doc = SugarElement.fromDom(editor.getDoc());
              const generators = paste$1(doc);
              const targets = paste(cell2, elements[0], generators);
              actions2.pasteCells(table2, targets).each(() => {
                editor.focus();
              });
            }
          });
        });
      }
    });
  };
  const point = (element, offset2) => ({
    element,
    offset: offset2
  });
  const scan$1 = (universe2, element, direction) => {
    if (universe2.property().isText(element) && universe2.property().getText(element).trim().length === 0 || universe2.property().isComment(element)) {
      return direction(element).bind((elem) => {
        return scan$1(universe2, elem, direction).orThunk(() => {
          return Optional.some(elem);
        });
      });
    } else {
      return Optional.none();
    }
  };
  const toEnd = (universe2, element) => {
    if (universe2.property().isText(element)) {
      return universe2.property().getText(element).length;
    }
    const children2 = universe2.property().children(element);
    return children2.length;
  };
  const freefallRtl$2 = (universe2, element) => {
    const candidate = scan$1(universe2, element, universe2.query().prevSibling).getOr(element);
    if (universe2.property().isText(candidate)) {
      return point(candidate, toEnd(universe2, candidate));
    }
    const children2 = universe2.property().children(candidate);
    return children2.length > 0 ? freefallRtl$2(universe2, children2[children2.length - 1]) : point(candidate, toEnd(universe2, candidate));
  };
  const freefallRtl$1 = freefallRtl$2;
  const universe$2 = DomUniverse();
  const freefallRtl = (element) => {
    return freefallRtl$1(universe$2, element);
  };
  const halve = (main2, other) => {
    if (!hasColspan(main2)) {
      const width3 = getGenericWidth(main2);
      width3.each((w) => {
        const newWidth = w.value / 2;
        setGenericWidth(main2, newWidth, w.unit);
        setGenericWidth(other, newWidth, w.unit);
      });
    }
  };
  const zero = (array) => map$1(array, constant(0));
  const surround = (sizes, startIndex, endIndex, results, f) => f(sizes.slice(0, startIndex)).concat(results).concat(f(sizes.slice(endIndex)));
  const clampDeltaHelper = (predicate) => (sizes, index, delta, minCellSize) => {
    if (!predicate(delta)) {
      return delta;
    } else {
      const newSize = Math.max(minCellSize, sizes[index] - Math.abs(delta));
      const diff = Math.abs(newSize - sizes[index]);
      return delta >= 0 ? diff : -diff;
    }
  };
  const clampNegativeDelta = clampDeltaHelper((delta) => delta < 0);
  const clampDelta = clampDeltaHelper(always);
  const resizeTable = () => {
    const calcFixedDeltas = (sizes, index, next, delta, minCellSize) => {
      const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
      return surround(sizes, index, next + 1, [
        clampedDelta,
        0
      ], zero);
    };
    const calcRelativeDeltas = (sizes, index, delta, minCellSize) => {
      const ratio = (100 + delta) / 100;
      const newThis = Math.max(minCellSize, (sizes[index] + delta) / ratio);
      return map$1(sizes, (size, idx) => {
        const newSize = idx === index ? newThis : size / ratio;
        return newSize - size;
      });
    };
    const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize, isRelative) => {
      if (isRelative) {
        return calcRelativeDeltas(sizes, index, delta, minCellSize);
      } else {
        return calcFixedDeltas(sizes, index, next, delta, minCellSize);
      }
    };
    const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize, isRelative) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize, isRelative);
    const resizeTable2 = (resizer, delta) => resizer(delta);
    const calcRightEdgeDeltas = (sizes, _prev, index, delta, minCellSize, isRelative) => {
      if (isRelative) {
        return calcRelativeDeltas(sizes, index, delta, minCellSize);
      } else {
        const clampedDelta = clampNegativeDelta(sizes, index, delta, minCellSize);
        return zero(sizes.slice(0, index)).concat([clampedDelta]);
      }
    };
    const calcRedestributedWidths = (sizes, totalWidth, pixelDelta, isRelative) => {
      if (isRelative) {
        const tableWidth = totalWidth + pixelDelta;
        const ratio = tableWidth / totalWidth;
        const newSizes = map$1(sizes, (size) => size / ratio);
        return {
          delta: ratio * 100 - 100,
          newSizes
        };
      } else {
        return {
          delta: pixelDelta,
          newSizes: sizes
        };
      }
    };
    return {
      resizeTable: resizeTable2,
      clampTableDelta: clampNegativeDelta,
      calcLeftEdgeDeltas,
      calcMiddleDeltas,
      calcRightEdgeDeltas,
      calcRedestributedWidths
    };
  };
  const preserveTable = () => {
    const calcLeftEdgeDeltas = (sizes, index, next, delta, minCellSize) => {
      const idx = delta >= 0 ? next : index;
      const clampedDelta = clampDelta(sizes, idx, delta, minCellSize);
      return surround(sizes, index, next + 1, [
        clampedDelta,
        -clampedDelta
      ], zero);
    };
    const calcMiddleDeltas = (sizes, _prev, index, next, delta, minCellSize) => calcLeftEdgeDeltas(sizes, index, next, delta, minCellSize);
    const resizeTable2 = (resizer, delta, isLastColumn) => {
      if (isLastColumn) {
        resizer(delta);
      }
    };
    const calcRightEdgeDeltas = (sizes, _prev, _index, delta, _minCellSize, isRelative) => {
      if (isRelative) {
        return zero(sizes);
      } else {
        const diff = delta / sizes.length;
        return map$1(sizes, constant(diff));
      }
    };
    const clampTableDelta = (sizes, index, delta, minCellSize, isLastColumn) => {
      if (isLastColumn) {
        if (delta >= 0) {
          return delta;
        } else {
          const maxDelta = foldl(sizes, (a, b) => a + b - minCellSize, 0);
          return Math.max(-maxDelta, delta);
        }
      } else {
        return clampNegativeDelta(sizes, index, delta, minCellSize);
      }
    };
    const calcRedestributedWidths = (sizes, _totalWidth, _pixelDelta, _isRelative) => ({
      delta: 0,
      newSizes: sizes
    });
    return {
      resizeTable: resizeTable2,
      clampTableDelta,
      calcLeftEdgeDeltas,
      calcMiddleDeltas,
      calcRightEdgeDeltas,
      calcRedestributedWidths
    };
  };
  const getGridSize = (table2) => {
    const warehouse = Warehouse.fromTable(table2);
    return warehouse.grid;
  };
  const isHeaderCell = isTag("th");
  const isHeaderCells = (cells2) => forall(cells2, (cell2) => isHeaderCell(cell2.element));
  const getRowHeaderType = (isHeaderRow, isHeaderCells2) => {
    if (isHeaderRow && isHeaderCells2) {
      return "sectionCells";
    } else if (isHeaderRow) {
      return "section";
    } else {
      return "cells";
    }
  };
  const getRowType = (row2) => {
    const isHeaderRow = row2.section === "thead";
    const isHeaderCells2 = is(findCommonCellType(row2.cells), "th");
    if (row2.section === "tfoot") {
      return { type: "footer" };
    } else if (isHeaderRow || isHeaderCells2) {
      return {
        type: "header",
        subType: getRowHeaderType(isHeaderRow, isHeaderCells2)
      };
    } else {
      return { type: "body" };
    }
  };
  const findCommonCellType = (cells2) => {
    const headerCells = filter$2(cells2, (cell2) => isHeaderCell(cell2.element));
    if (headerCells.length === 0) {
      return Optional.some("td");
    } else if (headerCells.length === cells2.length) {
      return Optional.some("th");
    } else {
      return Optional.none();
    }
  };
  const findCommonRowType = (rows2) => {
    const rowTypes = map$1(rows2, (row2) => getRowType(row2).type);
    const hasHeader = contains$2(rowTypes, "header");
    const hasFooter = contains$2(rowTypes, "footer");
    if (!hasHeader && !hasFooter) {
      return Optional.some("body");
    } else {
      const hasBody = contains$2(rowTypes, "body");
      if (hasHeader && !hasBody && !hasFooter) {
        return Optional.some("header");
      } else if (!hasHeader && !hasBody && hasFooter) {
        return Optional.some("footer");
      } else {
        return Optional.none();
      }
    }
  };
  const findTableRowHeaderType = (warehouse) => findMap(warehouse.all, (row2) => {
    const rowType = getRowType(row2);
    return rowType.type === "header" ? Optional.from(rowType.subType) : Optional.none();
  });
  const transformCell = (cell2, comparator, substitution) => elementnew(substitution(cell2.element, comparator), true, cell2.isLocked);
  const transformRow = (row2, section2) => row2.section !== section2 ? rowcells(row2.element, row2.cells, section2, row2.isNew) : row2;
  const section = () => ({
    transformRow,
    transformCell: (cell2, comparator, substitution) => {
      const newCell = substitution(cell2.element, comparator);
      const fixedCell = name2(newCell) !== "td" ? mutate$1(newCell, "td") : newCell;
      return elementnew(fixedCell, cell2.isNew, cell2.isLocked);
    }
  });
  const sectionCells = () => ({
    transformRow,
    transformCell
  });
  const cells = () => ({
    transformRow: (row2, section2) => {
      const newSection = section2 === "thead" ? "tbody" : section2;
      return transformRow(row2, newSection);
    },
    transformCell
  });
  const fallback = () => ({
    transformRow: identity,
    transformCell
  });
  const getTableSectionType = (table2, fallback2) => {
    const warehouse = Warehouse.fromTable(table2);
    const type2 = findTableRowHeaderType(warehouse).getOr(fallback2);
    switch (type2) {
      case "section":
        return section();
      case "sectionCells":
        return sectionCells();
      case "cells":
        return cells();
    }
  };
  const TableSection = {
    getTableSectionType,
    section,
    sectionCells,
    cells,
    fallback
  };
  const setIfNot = (element, property, value2, ignore) => {
    if (value2 === ignore) {
      remove$7(element, property);
    } else {
      set$2(element, property, value2);
    }
  };
  const insert$1 = (table2, selector, element) => {
    last$2(children(table2, selector)).fold(() => prepend(table2, element), (child2) => after$5(child2, element));
  };
  const generateSection = (table2, sectionName) => {
    const section2 = child(table2, sectionName).getOrThunk(() => {
      const newSection = SugarElement.fromTag(sectionName, owner(table2).dom);
      if (sectionName === "thead") {
        insert$1(table2, "caption,colgroup", newSection);
      } else if (sectionName === "colgroup") {
        insert$1(table2, "caption", newSection);
      } else {
        append$1(table2, newSection);
      }
      return newSection;
    });
    empty(section2);
    return section2;
  };
  const render$1 = (table2, grid2) => {
    const newRows = [];
    const newCells = [];
    const syncRows = (gridSection) => map$1(gridSection, (row2) => {
      if (row2.isNew) {
        newRows.push(row2.element);
      }
      const tr = row2.element;
      empty(tr);
      each$2(row2.cells, (cell2) => {
        if (cell2.isNew) {
          newCells.push(cell2.element);
        }
        setIfNot(cell2.element, "colspan", cell2.colspan, 1);
        setIfNot(cell2.element, "rowspan", cell2.rowspan, 1);
        append$1(tr, cell2.element);
      });
      return tr;
    });
    const syncColGroup = (gridSection) => bind$2(gridSection, (colGroup) => map$1(colGroup.cells, (col2) => {
      setIfNot(col2.element, "span", col2.colspan, 1);
      return col2.element;
    }));
    const renderSection = (gridSection, sectionName) => {
      const section2 = generateSection(table2, sectionName);
      const sync2 = sectionName === "colgroup" ? syncColGroup : syncRows;
      const sectionElems = sync2(gridSection);
      append2(section2, sectionElems);
    };
    const removeSection = (sectionName) => {
      child(table2, sectionName).each(remove$6);
    };
    const renderOrRemoveSection = (gridSection, sectionName) => {
      if (gridSection.length > 0) {
        renderSection(gridSection, sectionName);
      } else {
        removeSection(sectionName);
      }
    };
    const headSection = [];
    const bodySection = [];
    const footSection = [];
    const columnGroupsSection = [];
    each$2(grid2, (row2) => {
      switch (row2.section) {
        case "thead":
          headSection.push(row2);
          break;
        case "tbody":
          bodySection.push(row2);
          break;
        case "tfoot":
          footSection.push(row2);
          break;
        case "colgroup":
          columnGroupsSection.push(row2);
          break;
      }
    });
    renderOrRemoveSection(columnGroupsSection, "colgroup");
    renderOrRemoveSection(headSection, "thead");
    renderOrRemoveSection(bodySection, "tbody");
    renderOrRemoveSection(footSection, "tfoot");
    return {
      newRows,
      newCells
    };
  };
  const copy = (grid2) => map$1(grid2, (row2) => {
    const tr = shallow(row2.element);
    each$2(row2.cells, (cell2) => {
      const clonedCell = deep(cell2.element);
      setIfNot(clonedCell, "colspan", cell2.colspan, 1);
      setIfNot(clonedCell, "rowspan", cell2.rowspan, 1);
      append$1(tr, clonedCell);
    });
    return tr;
  });
  const getColumn = (grid2, index) => {
    return map$1(grid2, (row2) => {
      return getCell(row2, index);
    });
  };
  const getRow = (grid2, index) => {
    return grid2[index];
  };
  const findDiff = (xs, comp) => {
    if (xs.length === 0) {
      return 0;
    }
    const first2 = xs[0];
    const index = findIndex(xs, (x) => {
      return !comp(first2.element, x.element);
    });
    return index.getOr(xs.length);
  };
  const subgrid = (grid2, row2, column, comparator) => {
    const gridRow = getRow(grid2, row2);
    const isColRow = gridRow.section === "colgroup";
    const colspan = findDiff(gridRow.cells.slice(column), comparator);
    const rowspan = isColRow ? 1 : findDiff(getColumn(grid2.slice(row2), column), comparator);
    return {
      colspan,
      rowspan
    };
  };
  const toDetails = (grid2, comparator) => {
    const seen = map$1(grid2, (row2) => map$1(row2.cells, never));
    const updateSeen = (rowIndex, columnIndex, rowspan, colspan) => {
      for (let row2 = rowIndex; row2 < rowIndex + rowspan; row2++) {
        for (let column = columnIndex; column < columnIndex + colspan; column++) {
          seen[row2][column] = true;
        }
      }
    };
    return map$1(grid2, (row2, rowIndex) => {
      const details = bind$2(row2.cells, (cell2, columnIndex) => {
        if (seen[rowIndex][columnIndex] === false) {
          const result = subgrid(grid2, rowIndex, columnIndex, comparator);
          updateSeen(rowIndex, columnIndex, result.rowspan, result.colspan);
          return [detailnew(cell2.element, result.rowspan, result.colspan, cell2.isNew)];
        } else {
          return [];
        }
      });
      return rowdetailnew(row2.element, details, row2.section, row2.isNew);
    });
  };
  const toGrid = (warehouse, generators, isNew) => {
    const grid2 = [];
    each$2(warehouse.colgroups, (colgroup2) => {
      const colgroupCols = [];
      for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
        const element = Warehouse.getColumnAt(warehouse, columnIndex).map((column) => elementnew(column.element, isNew, false)).getOrThunk(() => elementnew(generators.colGap(), true, false));
        colgroupCols.push(element);
      }
      grid2.push(rowcells(colgroup2.element, colgroupCols, "colgroup", isNew));
    });
    for (let rowIndex = 0; rowIndex < warehouse.grid.rows; rowIndex++) {
      const rowCells = [];
      for (let columnIndex = 0; columnIndex < warehouse.grid.columns; columnIndex++) {
        const element = Warehouse.getAt(warehouse, rowIndex, columnIndex).map((item2) => elementnew(item2.element, isNew, item2.isLocked)).getOrThunk(() => elementnew(generators.gap(), true, false));
        rowCells.push(element);
      }
      const rowDetail = warehouse.all[rowIndex];
      const row2 = rowcells(rowDetail.element, rowCells, rowDetail.section, isNew);
      grid2.push(row2);
    }
    return grid2;
  };
  const fromWarehouse = (warehouse, generators) => toGrid(warehouse, generators, false);
  const toDetailList = (grid2) => toDetails(grid2, eq$1);
  const findInWarehouse = (warehouse, element) => findMap(warehouse.all, (r2) => find$1(r2.cells, (e) => eq$1(element, e.element)));
  const extractCells = (warehouse, target, predicate) => {
    const details = map$1(target.selection, (cell$1) => {
      return cell(cell$1).bind((lc) => findInWarehouse(warehouse, lc)).filter(predicate);
    });
    const cells2 = cat(details);
    return someIf(cells2.length > 0, cells2);
  };
  const run2 = (operation, extract2, adjustment, postAction, genWrappers) => (table2, target, generators, behaviours) => {
    const warehouse = Warehouse.fromTable(table2);
    const tableSection = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.section).getOrThunk(TableSection.fallback);
    const output = extract2(warehouse, target).map((info) => {
      const model = fromWarehouse(warehouse, generators);
      const result = operation(model, info, eq$1, genWrappers(generators), tableSection);
      const lockedColumns = getLockedColumnsFromGrid(result.grid);
      const grid2 = toDetailList(result.grid);
      return {
        info,
        grid: grid2,
        cursor: result.cursor,
        lockedColumns
      };
    });
    return output.bind((out) => {
      const newElements = render$1(table2, out.grid);
      const tableSizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.sizing).getOrThunk(() => TableSize.getTableSize(table2));
      const resizing = Optional.from(behaviours === null || behaviours === void 0 ? void 0 : behaviours.resize).getOrThunk(preserveTable);
      adjustment(table2, out.grid, out.info, {
        sizing: tableSizing,
        resize: resizing,
        section: tableSection
      });
      postAction(table2);
      remove$7(table2, LOCKED_COL_ATTR);
      if (out.lockedColumns.length > 0) {
        set$2(table2, LOCKED_COL_ATTR, out.lockedColumns.join(","));
      }
      return Optional.some({
        cursor: out.cursor,
        newRows: newElements.newRows,
        newCells: newElements.newCells
      });
    });
  };
  const onPaste = (warehouse, target) => cell(target.element).bind((cell2) => findInWarehouse(warehouse, cell2).map((details) => {
    const value2 = {
      ...details,
      generators: target.generators,
      clipboard: target.clipboard
    };
    return value2;
  }));
  const onPasteByEditor = (warehouse, target) => extractCells(warehouse, target, always).map((cells2) => ({
    cells: cells2,
    generators: target.generators,
    clipboard: target.clipboard
  }));
  const onMergable = (_warehouse, target) => target.mergable;
  const onUnmergable = (_warehouse, target) => target.unmergable;
  const onCells = (warehouse, target) => extractCells(warehouse, target, always);
  const onUnlockedCells = (warehouse, target) => extractCells(warehouse, target, (detail2) => !detail2.isLocked);
  const isUnlockedTableCell = (warehouse, cell2) => findInWarehouse(warehouse, cell2).exists((detail2) => !detail2.isLocked);
  const allUnlocked = (warehouse, cells2) => forall(cells2, (cell2) => isUnlockedTableCell(warehouse, cell2));
  const onUnlockedMergable = (warehouse, target) => onMergable(warehouse, target).filter((mergeable) => allUnlocked(warehouse, mergeable.cells));
  const onUnlockedUnmergable = (warehouse, target) => onUnmergable(warehouse, target).filter((cells2) => allUnlocked(warehouse, cells2));
  const merge$2 = (grid2, bounds2, comparator, substitution) => {
    const rows2 = extractGridDetails(grid2).rows;
    if (rows2.length === 0) {
      return grid2;
    }
    for (let i = bounds2.startRow; i <= bounds2.finishRow; i++) {
      for (let j = bounds2.startCol; j <= bounds2.finishCol; j++) {
        const row2 = rows2[i];
        const isLocked = getCell(row2, j).isLocked;
        mutateCell(row2, j, elementnew(substitution(), false, isLocked));
      }
    }
    return grid2;
  };
  const unmerge = (grid2, target, comparator, substitution) => {
    const rows2 = extractGridDetails(grid2).rows;
    let first2 = true;
    for (let i = 0; i < rows2.length; i++) {
      for (let j = 0; j < cellLength(rows2[0]); j++) {
        const row2 = rows2[i];
        const currentCell = getCell(row2, j);
        const currentCellElm = currentCell.element;
        const isToReplace = comparator(currentCellElm, target);
        if (isToReplace && !first2) {
          mutateCell(row2, j, elementnew(substitution(), true, currentCell.isLocked));
        } else if (isToReplace) {
          first2 = false;
        }
      }
    }
    return grid2;
  };
  const uniqueCells = (row2, comparator) => {
    return foldl(row2, (rest, cell2) => {
      return exists(rest, (currentCell) => {
        return comparator(currentCell.element, cell2.element);
      }) ? rest : rest.concat([cell2]);
    }, []);
  };
  const splitCols = (grid2, index, comparator, substitution) => {
    if (index > 0 && index < grid2[0].cells.length) {
      each$2(grid2, (row2) => {
        const prevCell = row2.cells[index - 1];
        let offset2 = 0;
        const substitute = substitution();
        while (row2.cells.length > index + offset2 && comparator(prevCell.element, row2.cells[index + offset2].element)) {
          mutateCell(row2, index + offset2, elementnew(substitute, true, row2.cells[index + offset2].isLocked));
          offset2++;
        }
      });
    }
    return grid2;
  };
  const splitRows = (grid2, index, comparator, substitution) => {
    const rows2 = extractGridDetails(grid2).rows;
    if (index > 0 && index < rows2.length) {
      const rowPrevCells = rows2[index - 1].cells;
      const cells2 = uniqueCells(rowPrevCells, comparator);
      each$2(cells2, (cell2) => {
        let replacement = Optional.none();
        for (let i = index; i < rows2.length; i++) {
          for (let j = 0; j < cellLength(rows2[0]); j++) {
            const row2 = rows2[i];
            const current = getCell(row2, j);
            const isToReplace = comparator(current.element, cell2.element);
            if (isToReplace) {
              if (replacement.isNone()) {
                replacement = Optional.some(substitution());
              }
              replacement.each((sub) => {
                mutateCell(row2, j, elementnew(sub, true, current.isLocked));
              });
            }
          }
        }
      });
    }
    return grid2;
  };
  const value$1 = (value2) => {
    const applyHelper = (fn3) => fn3(value2);
    const constHelper = constant(value2);
    const outputHelper = () => output;
    const output = {
      tag: true,
      inner: value2,
      fold: (_onError, onValue) => onValue(value2),
      isValue: always,
      isError: never,
      map: (mapper) => Result.value(mapper(value2)),
      mapError: outputHelper,
      bind: applyHelper,
      exists: applyHelper,
      forall: applyHelper,
      getOr: constHelper,
      or: outputHelper,
      getOrThunk: constHelper,
      orThunk: outputHelper,
      getOrDie: constHelper,
      each: (fn3) => {
        fn3(value2);
      },
      toOptional: () => Optional.some(value2)
    };
    return output;
  };
  const error2 = (error3) => {
    const outputHelper = () => output;
    const output = {
      tag: false,
      inner: error3,
      fold: (onError, _onValue) => onError(error3),
      isValue: never,
      isError: always,
      map: outputHelper,
      mapError: (mapper) => Result.error(mapper(error3)),
      bind: outputHelper,
      exists: never,
      forall: always,
      getOr: identity,
      or: identity,
      getOrThunk: apply,
      orThunk: apply,
      getOrDie: die(String(error3)),
      each: noop2,
      toOptional: Optional.none
    };
    return output;
  };
  const fromOption = (optional, err) => optional.fold(() => error2(err), value$1);
  const Result = {
    value: value$1,
    error: error2,
    fromOption
  };
  const measure = (startAddress, gridA, gridB) => {
    if (startAddress.row >= gridA.length || startAddress.column > cellLength(gridA[0])) {
      return Result.error("invalid start address out of table bounds, row: " + startAddress.row + ", column: " + startAddress.column);
    }
    const rowRemainder = gridA.slice(startAddress.row);
    const colRemainder = rowRemainder[0].cells.slice(startAddress.column);
    const colRequired = cellLength(gridB[0]);
    const rowRequired = gridB.length;
    return Result.value({
      rowDelta: rowRemainder.length - rowRequired,
      colDelta: colRemainder.length - colRequired
    });
  };
  const measureWidth = (gridA, gridB) => {
    const colLengthA = cellLength(gridA[0]);
    const colLengthB = cellLength(gridB[0]);
    return {
      rowDelta: 0,
      colDelta: colLengthA - colLengthB
    };
  };
  const measureHeight = (gridA, gridB) => {
    const rowLengthA = gridA.length;
    const rowLengthB = gridB.length;
    return {
      rowDelta: rowLengthA - rowLengthB,
      colDelta: 0
    };
  };
  const generateElements = (amount, row2, generators, isLocked) => {
    const generator = row2.section === "colgroup" ? generators.col : generators.cell;
    return range$1(amount, (idx) => elementnew(generator(), true, isLocked(idx)));
  };
  const rowFill = (grid2, amount, generators, lockedColumns) => {
    const exampleRow = grid2[grid2.length - 1];
    return grid2.concat(range$1(amount, () => {
      const generator = exampleRow.section === "colgroup" ? generators.colgroup : generators.row;
      const row2 = clone(exampleRow, generator, identity);
      const elements = generateElements(row2.cells.length, row2, generators, (idx) => has$1(lockedColumns, idx.toString()));
      return setCells(row2, elements);
    }));
  };
  const colFill = (grid2, amount, generators, startIndex) => map$1(grid2, (row2) => {
    const newChildren = generateElements(amount, row2, generators, never);
    return addCells(row2, startIndex, newChildren);
  });
  const lockedColFill = (grid2, generators, lockedColumns) => map$1(grid2, (row2) => {
    return foldl(lockedColumns, (acc, colNum) => {
      const newChild = generateElements(1, row2, generators, always)[0];
      return addCell(acc, colNum, newChild);
    }, row2);
  });
  const tailor = (gridA, delta, generators) => {
    const fillCols = delta.colDelta < 0 ? colFill : identity;
    const fillRows = delta.rowDelta < 0 ? rowFill : identity;
    const lockedColumns = getLockedColumnsFromGrid(gridA);
    const gridWidth = cellLength(gridA[0]);
    const isLastColLocked = exists(lockedColumns, (locked) => locked === gridWidth - 1);
    const modifiedCols = fillCols(gridA, Math.abs(delta.colDelta), generators, isLastColLocked ? gridWidth - 1 : gridWidth);
    const newLockedColumns = getLockedColumnsFromGrid(modifiedCols);
    return fillRows(modifiedCols, Math.abs(delta.rowDelta), generators, mapToObject(newLockedColumns, always));
  };
  const isSpanning = (grid2, row2, col2, comparator) => {
    const candidate = getCell(grid2[row2], col2);
    const matching = curry(comparator, candidate.element);
    const currentRow = grid2[row2];
    return grid2.length > 1 && cellLength(currentRow) > 1 && (col2 > 0 && matching(getCellElement(currentRow, col2 - 1)) || col2 < currentRow.cells.length - 1 && matching(getCellElement(currentRow, col2 + 1)) || row2 > 0 && matching(getCellElement(grid2[row2 - 1], col2)) || row2 < grid2.length - 1 && matching(getCellElement(grid2[row2 + 1], col2)));
  };
  const mergeTables = (startAddress, gridA, gridBRows, generator, comparator, lockedColumns) => {
    const startRow = startAddress.row;
    const startCol = startAddress.column;
    const mergeHeight = gridBRows.length;
    const mergeWidth = cellLength(gridBRows[0]);
    const endRow = startRow + mergeHeight;
    const endCol = startCol + mergeWidth + lockedColumns.length;
    const lockedColumnObj = mapToObject(lockedColumns, always);
    for (let r2 = startRow; r2 < endRow; r2++) {
      let skippedCol = 0;
      for (let c = startCol; c < endCol; c++) {
        if (lockedColumnObj[c]) {
          skippedCol++;
          continue;
        }
        if (isSpanning(gridA, r2, c, comparator)) {
          unmerge(gridA, getCellElement(gridA[r2], c), comparator, generator.cell);
        }
        const gridBColIndex = c - startCol - skippedCol;
        const newCell = getCell(gridBRows[r2 - startRow], gridBColIndex);
        const newCellElm = newCell.element;
        const replacement = generator.replace(newCellElm);
        mutateCell(gridA[r2], c, elementnew(replacement, true, newCell.isLocked));
      }
    }
    return gridA;
  };
  const getValidStartAddress = (currentStartAddress, grid2, lockedColumns) => {
    const gridColLength = cellLength(grid2[0]);
    const adjustedRowAddress = extractGridDetails(grid2).cols.length + currentStartAddress.row;
    const possibleColAddresses = range$1(gridColLength - currentStartAddress.column, (num) => num + currentStartAddress.column);
    const validColAddress = find$1(possibleColAddresses, (num) => forall(lockedColumns, (col2) => col2 !== num)).getOr(gridColLength - 1);
    return {
      row: adjustedRowAddress,
      column: validColAddress
    };
  };
  const getLockedColumnsWithinBounds = (startAddress, rows2, lockedColumns) => filter$2(lockedColumns, (colNum) => colNum >= startAddress.column && colNum <= cellLength(rows2[0]) + startAddress.column);
  const merge$1 = (startAddress, gridA, gridB, generator, comparator) => {
    const lockedColumns = getLockedColumnsFromGrid(gridA);
    const validStartAddress = getValidStartAddress(startAddress, gridA, lockedColumns);
    const gridBRows = extractGridDetails(gridB).rows;
    const lockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, lockedColumns);
    const result = measure(validStartAddress, gridA, gridBRows);
    return result.map((diff) => {
      const delta = {
        ...diff,
        colDelta: diff.colDelta - lockedColumnsWithinBounds.length
      };
      const fittedGrid = tailor(gridA, delta, generator);
      const newLockedColumns = getLockedColumnsFromGrid(fittedGrid);
      const newLockedColumnsWithinBounds = getLockedColumnsWithinBounds(validStartAddress, gridBRows, newLockedColumns);
      return mergeTables(validStartAddress, fittedGrid, gridBRows, generator, comparator, newLockedColumnsWithinBounds);
    });
  };
  const insertCols = (index, gridA, gridB, generator, comparator) => {
    splitCols(gridA, index, comparator, generator.cell);
    const delta = measureHeight(gridB, gridA);
    const fittedNewGrid = tailor(gridB, delta, generator);
    const secondDelta = measureHeight(gridA, fittedNewGrid);
    const fittedOldGrid = tailor(gridA, secondDelta, generator);
    return map$1(fittedOldGrid, (gridRow, i) => {
      return addCells(gridRow, index, fittedNewGrid[i].cells);
    });
  };
  const insertRows = (index, gridA, gridB, generator, comparator) => {
    splitRows(gridA, index, comparator, generator.cell);
    const locked = getLockedColumnsFromGrid(gridA);
    const diff = measureWidth(gridA, gridB);
    const delta = {
      ...diff,
      colDelta: diff.colDelta - locked.length
    };
    const fittedOldGrid = tailor(gridA, delta, generator);
    const {
      cols: oldCols,
      rows: oldRows
    } = extractGridDetails(fittedOldGrid);
    const newLocked = getLockedColumnsFromGrid(fittedOldGrid);
    const secondDiff = measureWidth(gridB, gridA);
    const secondDelta = {
      ...secondDiff,
      colDelta: secondDiff.colDelta + newLocked.length
    };
    const fittedGridB = lockedColFill(gridB, generator, newLocked);
    const fittedNewGrid = tailor(fittedGridB, secondDelta, generator);
    return [
      ...oldCols,
      ...oldRows.slice(0, index),
      ...fittedNewGrid,
      ...oldRows.slice(index, oldRows.length)
    ];
  };
  const cloneRow = (row2, cloneCell, comparator, substitution) => clone(row2, (elem) => substitution(elem, comparator), cloneCell);
  const insertRowAt = (grid2, index, example, comparator, substitution) => {
    const { rows: rows2, cols } = extractGridDetails(grid2);
    const before2 = rows2.slice(0, index);
    const after2 = rows2.slice(index);
    const newRow = cloneRow(rows2[example], (ex, c) => {
      const withinSpan = index > 0 && index < rows2.length && comparator(getCellElement(rows2[index - 1], c), getCellElement(rows2[index], c));
      const ret = withinSpan ? getCell(rows2[index], c) : elementnew(substitution(ex.element, comparator), true, ex.isLocked);
      return ret;
    }, comparator, substitution);
    return [
      ...cols,
      ...before2,
      newRow,
      ...after2
    ];
  };
  const getElementFor = (row2, column, section2, withinSpan, example, comparator, substitution) => {
    if (section2 === "colgroup" || !withinSpan) {
      const cell2 = getCell(row2, example);
      return elementnew(substitution(cell2.element, comparator), true, false);
    } else {
      return getCell(row2, column);
    }
  };
  const insertColumnAt = (grid2, index, example, comparator, substitution) => map$1(grid2, (row2) => {
    const withinSpan = index > 0 && index < cellLength(row2) && comparator(getCellElement(row2, index - 1), getCellElement(row2, index));
    const sub = getElementFor(row2, index, row2.section, withinSpan, example, comparator, substitution);
    return addCell(row2, index, sub);
  });
  const deleteColumnsAt = (grid2, columns2) => bind$2(grid2, (row2) => {
    const existingCells = row2.cells;
    const cells2 = foldr(columns2, (acc, column) => column >= 0 && column < acc.length ? acc.slice(0, column).concat(acc.slice(column + 1)) : acc, existingCells);
    return cells2.length > 0 ? [rowcells(row2.element, cells2, row2.section, row2.isNew)] : [];
  });
  const deleteRowsAt = (grid2, start2, finish) => {
    const { rows: rows2, cols } = extractGridDetails(grid2);
    return [
      ...cols,
      ...rows2.slice(0, start2),
      ...rows2.slice(finish + 1)
    ];
  };
  const notInStartRow = (grid2, rowIndex, colIndex, comparator) => getCellElement(grid2[rowIndex], colIndex) !== void 0 && (rowIndex > 0 && comparator(getCellElement(grid2[rowIndex - 1], colIndex), getCellElement(grid2[rowIndex], colIndex)));
  const notInStartColumn = (row2, index, comparator) => index > 0 && comparator(getCellElement(row2, index - 1), getCellElement(row2, index));
  const isDuplicatedCell = (grid2, rowIndex, colIndex, comparator) => notInStartRow(grid2, rowIndex, colIndex, comparator) || notInStartColumn(grid2[rowIndex], colIndex, comparator);
  const rowReplacerPredicate = (targetRow, columnHeaders) => {
    const entireTableIsHeader = forall(columnHeaders, identity) && isHeaderCells(targetRow.cells);
    return entireTableIsHeader ? always : (cell2, _rowIndex, colIndex) => {
      const type2 = name2(cell2.element);
      return !(type2 === "th" && columnHeaders[colIndex]);
    };
  };
  const columnReplacePredicate = (targetColumn, rowHeaders) => {
    const entireTableIsHeader = forall(rowHeaders, identity) && isHeaderCells(targetColumn);
    return entireTableIsHeader ? always : (cell2, rowIndex, _colIndex) => {
      const type2 = name2(cell2.element);
      return !(type2 === "th" && rowHeaders[rowIndex]);
    };
  };
  const determineScope = (applyScope, cell2, newScope, isInHeader) => {
    const hasSpan = (scope) => scope === "row" ? hasRowspan(cell2) : hasColspan(cell2);
    const getScope = (scope) => hasSpan(scope) ? `${scope}group` : scope;
    if (applyScope) {
      return isHeaderCell(cell2) ? getScope(newScope) : null;
    } else if (isInHeader && isHeaderCell(cell2)) {
      const oppositeScope = newScope === "row" ? "col" : "row";
      return getScope(oppositeScope);
    } else {
      return null;
    }
  };
  const rowScopeGenerator = (applyScope, columnHeaders) => (cell2, rowIndex, columnIndex) => Optional.some(determineScope(applyScope, cell2.element, "col", columnHeaders[columnIndex]));
  const columnScopeGenerator = (applyScope, rowHeaders) => (cell2, rowIndex) => Optional.some(determineScope(applyScope, cell2.element, "row", rowHeaders[rowIndex]));
  const replace = (cell2, comparator, substitute) => elementnew(substitute(cell2.element, comparator), true, cell2.isLocked);
  const replaceIn = (grid2, targets, comparator, substitute, replacer, genScope, shouldReplace) => {
    const isTarget = (cell2) => {
      return exists(targets, (target) => {
        return comparator(cell2.element, target.element);
      });
    };
    return map$1(grid2, (row2, rowIndex) => {
      return mapCells(row2, (cell2, colIndex) => {
        if (isTarget(cell2)) {
          const newCell = shouldReplace(cell2, rowIndex, colIndex) ? replacer(cell2, comparator, substitute) : cell2;
          genScope(newCell, rowIndex, colIndex).each((scope) => {
            setOptions2(newCell.element, { scope: Optional.from(scope) });
          });
          return newCell;
        } else {
          return cell2;
        }
      });
    });
  };
  const getColumnCells = (rows2, columnIndex, comparator) => bind$2(rows2, (row2, i) => {
    return isDuplicatedCell(rows2, i, columnIndex, comparator) ? [] : [getCell(row2, columnIndex)];
  });
  const getRowCells = (rows2, rowIndex, comparator) => {
    const targetRow = rows2[rowIndex];
    return bind$2(targetRow.cells, (item2, i) => {
      return isDuplicatedCell(rows2, rowIndex, i, comparator) ? [] : [item2];
    });
  };
  const replaceColumns = (grid2, indexes, applyScope, comparator, substitution) => {
    const rows2 = extractGridDetails(grid2).rows;
    const targets = bind$2(indexes, (index) => getColumnCells(rows2, index, comparator));
    const rowHeaders = map$1(rows2, (row2) => isHeaderCells(row2.cells));
    const shouldReplaceCell = columnReplacePredicate(targets, rowHeaders);
    const scopeGenerator = columnScopeGenerator(applyScope, rowHeaders);
    return replaceIn(grid2, targets, comparator, substitution, replace, scopeGenerator, shouldReplaceCell);
  };
  const replaceRows = (grid2, indexes, section2, applyScope, comparator, substitution, tableSection) => {
    const { cols, rows: rows2 } = extractGridDetails(grid2);
    const targetRow = rows2[indexes[0]];
    const targets = bind$2(indexes, (index) => getRowCells(rows2, index, comparator));
    const columnHeaders = map$1(targetRow.cells, (_cell, index) => isHeaderCells(getColumnCells(rows2, index, comparator)));
    const newRows = [...rows2];
    each$2(indexes, (index) => {
      newRows[index] = tableSection.transformRow(rows2[index], section2);
    });
    const newGrid = [
      ...cols,
      ...newRows
    ];
    const shouldReplaceCell = rowReplacerPredicate(targetRow, columnHeaders);
    const scopeGenerator = rowScopeGenerator(applyScope, columnHeaders);
    return replaceIn(newGrid, targets, comparator, substitution, tableSection.transformCell, scopeGenerator, shouldReplaceCell);
  };
  const replaceCells = (grid2, details, comparator, substitution) => {
    const rows2 = extractGridDetails(grid2).rows;
    const targetCells = map$1(details, (detail2) => getCell(rows2[detail2.row], detail2.column));
    return replaceIn(grid2, targetCells, comparator, substitution, replace, Optional.none, always);
  };
  const generate = (cases) => {
    if (!isArray2(cases)) {
      throw new Error("cases must be an array");
    }
    if (cases.length === 0) {
      throw new Error("there must be at least one case");
    }
    const constructors = [];
    const adt2 = {};
    each$2(cases, (acase, count) => {
      const keys$1 = keys(acase);
      if (keys$1.length !== 1) {
        throw new Error("one and only one name per case");
      }
      const key2 = keys$1[0];
      const value2 = acase[key2];
      if (adt2[key2] !== void 0) {
        throw new Error("duplicate key detected:" + key2);
      } else if (key2 === "cata") {
        throw new Error("cannot have a case named cata (sorry)");
      } else if (!isArray2(value2)) {
        throw new Error("case arguments must be an array");
      }
      constructors.push(key2);
      adt2[key2] = (...args) => {
        const argLength = args.length;
        if (argLength !== value2.length) {
          throw new Error("Wrong number of arguments to case " + key2 + ". Expected " + value2.length + " (" + value2 + "), got " + argLength);
        }
        const match = (branches) => {
          const branchKeys = keys(branches);
          if (constructors.length !== branchKeys.length) {
            throw new Error("Wrong number of arguments to match. Expected: " + constructors.join(",") + "\nActual: " + branchKeys.join(","));
          }
          const allReqd = forall(constructors, (reqKey) => {
            return contains$2(branchKeys, reqKey);
          });
          if (!allReqd) {
            throw new Error("Not all branches were specified when using match. Specified: " + branchKeys.join(", ") + "\nRequired: " + constructors.join(", "));
          }
          return branches[key2].apply(null, args);
        };
        return {
          fold: (...foldArgs) => {
            if (foldArgs.length !== cases.length) {
              throw new Error("Wrong number of arguments to fold. Expected " + cases.length + ", got " + foldArgs.length);
            }
            const target = foldArgs[count];
            return target.apply(null, args);
          },
          match,
          log: (label) => {
            console.log(label, {
              constructors,
              constructor: key2,
              params: args
            });
          }
        };
      };
    });
    return adt2;
  };
  const Adt = { generate };
  const adt$6 = Adt.generate([
    { none: [] },
    { only: ["index"] },
    {
      left: [
        "index",
        "next"
      ]
    },
    {
      middle: [
        "prev",
        "index",
        "next"
      ]
    },
    {
      right: [
        "prev",
        "index"
      ]
    }
  ]);
  const ColumnContext = { ...adt$6 };
  const neighbours = (input, index) => {
    if (input.length === 0) {
      return ColumnContext.none();
    }
    if (input.length === 1) {
      return ColumnContext.only(0);
    }
    if (index === 0) {
      return ColumnContext.left(0, 1);
    }
    if (index === input.length - 1) {
      return ColumnContext.right(index - 1, index);
    }
    if (index > 0 && index < input.length - 1) {
      return ColumnContext.middle(index - 1, index, index + 1);
    }
    return ColumnContext.none();
  };
  const determine = (input, column, step, tableSize, resize2) => {
    const result = input.slice(0);
    const context = neighbours(input, column);
    const onNone = constant(map$1(result, constant(0)));
    const onOnly = (index) => tableSize.singleColumnWidth(result[index], step);
    const onLeft = (index, next) => resize2.calcLeftEdgeDeltas(result, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
    const onMiddle = (prev, index, next) => resize2.calcMiddleDeltas(result, prev, index, next, step, tableSize.minCellWidth(), tableSize.isRelative);
    const onRight = (prev, index) => resize2.calcRightEdgeDeltas(result, prev, index, step, tableSize.minCellWidth(), tableSize.isRelative);
    return context.fold(onNone, onOnly, onLeft, onMiddle, onRight);
  };
  const total = (start2, end2, measures) => {
    let r2 = 0;
    for (let i = start2; i < end2; i++) {
      r2 += measures[i] !== void 0 ? measures[i] : 0;
    }
    return r2;
  };
  const recalculateWidthForCells = (warehouse, widths) => {
    const all3 = Warehouse.justCells(warehouse);
    return map$1(all3, (cell2) => {
      const width3 = total(cell2.column, cell2.column + cell2.colspan, widths);
      return {
        element: cell2.element,
        width: width3,
        colspan: cell2.colspan
      };
    });
  };
  const recalculateWidthForColumns = (warehouse, widths) => {
    const groups = Warehouse.justColumns(warehouse);
    return map$1(groups, (column, index) => ({
      element: column.element,
      width: widths[index],
      colspan: column.colspan
    }));
  };
  const recalculateHeightForCells = (warehouse, heights) => {
    const all3 = Warehouse.justCells(warehouse);
    return map$1(all3, (cell2) => {
      const height3 = total(cell2.row, cell2.row + cell2.rowspan, heights);
      return {
        element: cell2.element,
        height: height3,
        rowspan: cell2.rowspan
      };
    });
  };
  const matchRowHeight = (warehouse, heights) => {
    return map$1(warehouse.all, (row2, i) => {
      return {
        element: row2.element,
        height: heights[i]
      };
    });
  };
  const sumUp = (newSize) => foldr(newSize, (b, a) => b + a, 0);
  const recalculate = (warehouse, widths) => {
    if (Warehouse.hasColumns(warehouse)) {
      return recalculateWidthForColumns(warehouse, widths);
    } else {
      return recalculateWidthForCells(warehouse, widths);
    }
  };
  const recalculateAndApply = (warehouse, widths, tableSize) => {
    const newSizes = recalculate(warehouse, widths);
    each$2(newSizes, (cell2) => {
      tableSize.setElementWidth(cell2.element, cell2.width);
    });
  };
  const adjustWidth = (table2, delta, index, resizing, tableSize) => {
    const warehouse = Warehouse.fromTable(table2);
    const step = tableSize.getCellDelta(delta);
    const widths = tableSize.getWidths(warehouse, tableSize);
    const isLastColumn = index === warehouse.grid.columns - 1;
    const clampedStep = resizing.clampTableDelta(widths, index, step, tableSize.minCellWidth(), isLastColumn);
    const deltas = determine(widths, index, clampedStep, tableSize, resizing);
    const newWidths = map$1(deltas, (dx, i) => dx + widths[i]);
    recalculateAndApply(warehouse, newWidths, tableSize);
    resizing.resizeTable(tableSize.adjustTableWidth, clampedStep, isLastColumn);
  };
  const adjustHeight = (table2, delta, index, direction) => {
    const warehouse = Warehouse.fromTable(table2);
    const heights = getPixelHeights(warehouse, table2, direction);
    const newHeights = map$1(heights, (dy, i) => index === i ? Math.max(delta + dy, minHeight()) : dy);
    const newCellSizes = recalculateHeightForCells(warehouse, newHeights);
    const newRowSizes = matchRowHeight(warehouse, newHeights);
    each$2(newRowSizes, (row2) => {
      setHeight(row2.element, row2.height);
    });
    each$2(newCellSizes, (cell2) => {
      setHeight(cell2.element, cell2.height);
    });
    const total2 = sumUp(newHeights);
    setHeight(table2, total2);
  };
  const adjustAndRedistributeWidths$1 = (_table, list2, details, tableSize, resizeBehaviour) => {
    const warehouse = Warehouse.generate(list2);
    const sizes = tableSize.getWidths(warehouse, tableSize);
    const tablePixelWidth = tableSize.pixelWidth();
    const { newSizes, delta } = resizeBehaviour.calcRedestributedWidths(sizes, tablePixelWidth, details.pixelDelta, tableSize.isRelative);
    recalculateAndApply(warehouse, newSizes, tableSize);
    tableSize.adjustTableWidth(delta);
  };
  const adjustWidthTo = (_table, list2, _info, tableSize) => {
    const warehouse = Warehouse.generate(list2);
    const widths = tableSize.getWidths(warehouse, tableSize);
    recalculateAndApply(warehouse, widths, tableSize);
  };
  const uniqueColumns = (details) => {
    const uniqueCheck = (rest, detail2) => {
      const columnExists = exists(rest, (currentDetail) => currentDetail.column === detail2.column);
      return columnExists ? rest : rest.concat([detail2]);
    };
    return foldl(details, uniqueCheck, []).sort((detailA, detailB) => detailA.column - detailB.column);
  };
  const isCol = isTag("col");
  const isColgroup = isTag("colgroup");
  const isRow$1 = (element) => name2(element) === "tr" || isColgroup(element);
  const elementToData = (element) => {
    const colspan = getAttrValue(element, "colspan", 1);
    const rowspan = getAttrValue(element, "rowspan", 1);
    return {
      element,
      colspan,
      rowspan
    };
  };
  const modification = (generators, toData = elementToData) => {
    const nuCell = (data2) => isCol(data2.element) ? generators.col(data2) : generators.cell(data2);
    const nuRow = (data2) => isColgroup(data2.element) ? generators.colgroup(data2) : generators.row(data2);
    const add2 = (element) => {
      if (isRow$1(element)) {
        return nuRow({ element });
      } else {
        const cell2 = element;
        const replacement = nuCell(toData(cell2));
        recent = Optional.some({
          item: cell2,
          replacement
        });
        return replacement;
      }
    };
    let recent = Optional.none();
    const getOrInit = (element, comparator) => {
      return recent.fold(() => {
        return add2(element);
      }, (p) => {
        return comparator(element, p.item) ? p.replacement : add2(element);
      });
    };
    return { getOrInit };
  };
  const transform$1 = (tag) => {
    return (generators) => {
      const list2 = [];
      const find3 = (element, comparator) => {
        return find$1(list2, (x) => {
          return comparator(x.item, element);
        });
      };
      const makeNew = (element) => {
        const attrs = tag === "td" ? { scope: null } : {};
        const cell2 = generators.replace(element, tag, attrs);
        list2.push({
          item: element,
          sub: cell2
        });
        return cell2;
      };
      const replaceOrInit = (element, comparator) => {
        if (isRow$1(element) || isCol(element)) {
          return element;
        } else {
          const cell2 = element;
          return find3(cell2, comparator).fold(() => {
            return makeNew(cell2);
          }, (p) => {
            return comparator(element, p.item) ? p.sub : makeNew(cell2);
          });
        }
      };
      return { replaceOrInit };
    };
  };
  const getScopeAttribute = (cell2) => getOpt(cell2, "scope").map((attribute) => attribute.substr(0, 3));
  const merging = (generators) => {
    const unmerge2 = (cell2) => {
      const scope = getScopeAttribute(cell2);
      scope.each((attribute) => set$2(cell2, "scope", attribute));
      return () => {
        const raw = generators.cell({
          element: cell2,
          colspan: 1,
          rowspan: 1
        });
        remove$5(raw, "width");
        remove$5(cell2, "width");
        scope.each((attribute) => set$2(raw, "scope", attribute));
        return raw;
      };
    };
    const merge3 = (cells2) => {
      const getScopeProperty = () => {
        const stringAttributes = cat(map$1(cells2, getScopeAttribute));
        if (stringAttributes.length === 0) {
          return Optional.none();
        } else {
          const baseScope = stringAttributes[0];
          const scopes = [
            "row",
            "col"
          ];
          const isMixed = exists(stringAttributes, (attribute) => {
            return attribute !== baseScope && contains$2(scopes, attribute);
          });
          return isMixed ? Optional.none() : Optional.from(baseScope);
        }
      };
      remove$5(cells2[0], "width");
      getScopeProperty().fold(() => remove$7(cells2[0], "scope"), (attribute) => set$2(cells2[0], "scope", attribute + "group"));
      return constant(cells2[0]);
    };
    return {
      unmerge: unmerge2,
      merge: merge3
    };
  };
  const Generators = {
    modification,
    transform: transform$1,
    merging
  };
  const blockList = [
    "body",
    "p",
    "div",
    "article",
    "aside",
    "figcaption",
    "figure",
    "footer",
    "header",
    "nav",
    "section",
    "ol",
    "ul",
    "table",
    "thead",
    "tfoot",
    "tbody",
    "caption",
    "tr",
    "td",
    "th",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "blockquote",
    "pre",
    "address"
  ];
  const isList$1 = (universe2, item2) => {
    const tagName = universe2.property().name(item2);
    return contains$2([
      "ol",
      "ul"
    ], tagName);
  };
  const isBlock$1 = (universe2, item2) => {
    const tagName = universe2.property().name(item2);
    return contains$2(blockList, tagName);
  };
  const isEmptyTag$1 = (universe2, item2) => {
    return contains$2([
      "br",
      "img",
      "hr",
      "input"
    ], universe2.property().name(item2));
  };
  const universe$1 = DomUniverse();
  const isBlock = (element) => {
    return isBlock$1(universe$1, element);
  };
  const isList = (element) => {
    return isList$1(universe$1, element);
  };
  const isEmptyTag = (element) => {
    return isEmptyTag$1(universe$1, element);
  };
  const merge2 = (cells2) => {
    const isBr2 = isTag("br");
    const advancedBr = (children2) => {
      return forall(children2, (c) => {
        return isBr2(c) || isText(c) && get$6(c).trim().length === 0;
      });
    };
    const isListItem = (el) => {
      return name2(el) === "li" || ancestor$2(el, isList).isSome();
    };
    const siblingIsBlock = (el) => {
      return nextSibling(el).map((rightSibling) => {
        if (isBlock(rightSibling)) {
          return true;
        }
        if (isEmptyTag(rightSibling)) {
          return name2(rightSibling) === "img" ? false : true;
        }
        return false;
      }).getOr(false);
    };
    const markCell = (cell2) => {
      return last$1(cell2).bind((rightEdge) => {
        const rightSiblingIsBlock = siblingIsBlock(rightEdge);
        return parent(rightEdge).map((parent2) => {
          return rightSiblingIsBlock === true || isListItem(parent2) || isBr2(rightEdge) || isBlock(parent2) && !eq$1(cell2, parent2) ? [] : [SugarElement.fromTag("br")];
        });
      }).getOr([]);
    };
    const markContent = () => {
      const content = bind$2(cells2, (cell2) => {
        const children2 = children$2(cell2);
        return advancedBr(children2) ? [] : children2.concat(markCell(cell2));
      });
      return content.length === 0 ? [SugarElement.fromTag("br")] : content;
    };
    const contents = markContent();
    empty(cells2[0]);
    append2(cells2[0], contents);
  };
  const isEditable = (elem) => isEditable$1(elem, true);
  const prune = (table2) => {
    const cells2 = cells$1(table2);
    if (cells2.length === 0) {
      remove$6(table2);
    }
  };
  const outcome = (grid2, cursor) => ({
    grid: grid2,
    cursor
  });
  const findEditableCursorPosition = (rows2) => findMap(rows2, (row2) => findMap(row2.cells, (cell2) => {
    const elem = cell2.element;
    return someIf(isEditable(elem), elem);
  }));
  const elementFromGrid = (grid2, row2, column) => {
    var _a, _b;
    const rows2 = extractGridDetails(grid2).rows;
    return Optional.from((_b = (_a = rows2[row2]) === null || _a === void 0 ? void 0 : _a.cells[column]) === null || _b === void 0 ? void 0 : _b.element).filter(isEditable).orThunk(() => findEditableCursorPosition(rows2));
  };
  const bundle = (grid2, row2, column) => {
    const cursorElement = elementFromGrid(grid2, row2, column);
    return outcome(grid2, cursorElement);
  };
  const uniqueRows = (details) => {
    const rowCompilation = (rest, detail2) => {
      const rowExists = exists(rest, (currentDetail) => currentDetail.row === detail2.row);
      return rowExists ? rest : rest.concat([detail2]);
    };
    return foldl(details, rowCompilation, []).sort((detailA, detailB) => detailA.row - detailB.row);
  };
  const opInsertRowsBefore = (grid2, details, comparator, genWrappers) => {
    const targetIndex = details[0].row;
    const rows2 = uniqueRows(details);
    const newGrid = foldr(rows2, (acc, row2) => {
      const newG = insertRowAt(acc.grid, targetIndex, row2.row + acc.delta, comparator, genWrappers.getOrInit);
      return {
        grid: newG,
        delta: acc.delta + 1
      };
    }, {
      grid: grid2,
      delta: 0
    }).grid;
    return bundle(newGrid, targetIndex, details[0].column);
  };
  const opInsertRowsAfter = (grid2, details, comparator, genWrappers) => {
    const rows2 = uniqueRows(details);
    const target = rows2[rows2.length - 1];
    const targetIndex = target.row + target.rowspan;
    const newGrid = foldr(rows2, (newG, row2) => {
      return insertRowAt(newG, targetIndex, row2.row, comparator, genWrappers.getOrInit);
    }, grid2);
    return bundle(newGrid, targetIndex, details[0].column);
  };
  const opInsertColumnsBefore = (grid2, extractDetail, comparator, genWrappers) => {
    const details = extractDetail.details;
    const columns2 = uniqueColumns(details);
    const targetIndex = columns2[0].column;
    const newGrid = foldr(columns2, (acc, col2) => {
      const newG = insertColumnAt(acc.grid, targetIndex, col2.column + acc.delta, comparator, genWrappers.getOrInit);
      return {
        grid: newG,
        delta: acc.delta + 1
      };
    }, {
      grid: grid2,
      delta: 0
    }).grid;
    return bundle(newGrid, details[0].row, targetIndex);
  };
  const opInsertColumnsAfter = (grid2, extractDetail, comparator, genWrappers) => {
    const details = extractDetail.details;
    const target = details[details.length - 1];
    const targetIndex = target.column + target.colspan;
    const columns2 = uniqueColumns(details);
    const newGrid = foldr(columns2, (newG, col2) => {
      return insertColumnAt(newG, targetIndex, col2.column, comparator, genWrappers.getOrInit);
    }, grid2);
    return bundle(newGrid, details[0].row, targetIndex);
  };
  const opMakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {
    const columns2 = uniqueColumns(details);
    const columnIndexes = map$1(columns2, (detail2) => detail2.column);
    const newGrid = replaceColumns(initialGrid, columnIndexes, true, comparator, genWrappers.replaceOrInit);
    return bundle(newGrid, details[0].row, details[0].column);
  };
  const opMakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {
    const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
    return bundle(newGrid, details[0].row, details[0].column);
  };
  const opUnmakeColumnsHeader = (initialGrid, details, comparator, genWrappers) => {
    const columns2 = uniqueColumns(details);
    const columnIndexes = map$1(columns2, (detail2) => detail2.column);
    const newGrid = replaceColumns(initialGrid, columnIndexes, false, comparator, genWrappers.replaceOrInit);
    return bundle(newGrid, details[0].row, details[0].column);
  };
  const opUnmakeCellsHeader = (initialGrid, details, comparator, genWrappers) => {
    const newGrid = replaceCells(initialGrid, details, comparator, genWrappers.replaceOrInit);
    return bundle(newGrid, details[0].row, details[0].column);
  };
  const makeRowsSection = (section2, applyScope) => (initialGrid, details, comparator, genWrappers, tableSection) => {
    const rows2 = uniqueRows(details);
    const rowIndexes = map$1(rows2, (detail2) => detail2.row);
    const newGrid = replaceRows(initialGrid, rowIndexes, section2, applyScope, comparator, genWrappers.replaceOrInit, tableSection);
    return bundle(newGrid, details[0].row, details[0].column);
  };
  const opMakeRowsHeader = makeRowsSection("thead", true);
  const opMakeRowsBody = makeRowsSection("tbody", false);
  const opMakeRowsFooter = makeRowsSection("tfoot", false);
  const opEraseColumns = (grid2, extractDetail, _comparator, _genWrappers) => {
    const columns2 = uniqueColumns(extractDetail.details);
    const newGrid = deleteColumnsAt(grid2, map$1(columns2, (column) => column.column));
    const maxColIndex = newGrid.length > 0 ? newGrid[0].cells.length - 1 : 0;
    return bundle(newGrid, columns2[0].row, Math.min(columns2[0].column, maxColIndex));
  };
  const opEraseRows = (grid2, details, _comparator, _genWrappers) => {
    const rows2 = uniqueRows(details);
    const newGrid = deleteRowsAt(grid2, rows2[0].row, rows2[rows2.length - 1].row);
    const maxRowIndex = newGrid.length > 0 ? newGrid.length - 1 : 0;
    return bundle(newGrid, Math.min(details[0].row, maxRowIndex), details[0].column);
  };
  const opMergeCells = (grid2, mergable2, comparator, genWrappers) => {
    const cells2 = mergable2.cells;
    merge2(cells2);
    const newGrid = merge$2(grid2, mergable2.bounds, comparator, genWrappers.merge(cells2));
    return outcome(newGrid, Optional.from(cells2[0]));
  };
  const opUnmergeCells = (grid2, unmergable2, comparator, genWrappers) => {
    const unmerge$1 = (b, cell2) => unmerge(b, cell2, comparator, genWrappers.unmerge(cell2));
    const newGrid = foldr(unmergable2, unmerge$1, grid2);
    return outcome(newGrid, Optional.from(unmergable2[0]));
  };
  const opPasteCells = (grid2, pasteDetails, comparator, _genWrappers) => {
    const gridify = (table2, generators) => {
      const wh = Warehouse.fromTable(table2);
      return toGrid(wh, generators, true);
    };
    const gridB = gridify(pasteDetails.clipboard, pasteDetails.generators);
    const startAddress = address(pasteDetails.row, pasteDetails.column);
    const mergedGrid = merge$1(startAddress, grid2, gridB, pasteDetails.generators, comparator);
    return mergedGrid.fold(() => outcome(grid2, Optional.some(pasteDetails.element)), (newGrid) => {
      return bundle(newGrid, pasteDetails.row, pasteDetails.column);
    });
  };
  const gridifyRows = (rows2, generators, context) => {
    const pasteDetails = fromPastedRows(rows2, context.section);
    const wh = Warehouse.generate(pasteDetails);
    return toGrid(wh, generators, true);
  };
  const opPasteColsBefore = (grid2, pasteDetails, comparator, _genWrappers) => {
    const rows2 = extractGridDetails(grid2).rows;
    const index = pasteDetails.cells[0].column;
    const context = rows2[pasteDetails.cells[0].row];
    const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
    const mergedGrid = insertCols(index, grid2, gridB, pasteDetails.generators, comparator);
    return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
  };
  const opPasteColsAfter = (grid2, pasteDetails, comparator, _genWrappers) => {
    const rows2 = extractGridDetails(grid2).rows;
    const index = pasteDetails.cells[pasteDetails.cells.length - 1].column + pasteDetails.cells[pasteDetails.cells.length - 1].colspan;
    const context = rows2[pasteDetails.cells[0].row];
    const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
    const mergedGrid = insertCols(index, grid2, gridB, pasteDetails.generators, comparator);
    return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
  };
  const opPasteRowsBefore = (grid2, pasteDetails, comparator, _genWrappers) => {
    const rows2 = extractGridDetails(grid2).rows;
    const index = pasteDetails.cells[0].row;
    const context = rows2[index];
    const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
    const mergedGrid = insertRows(index, grid2, gridB, pasteDetails.generators, comparator);
    return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
  };
  const opPasteRowsAfter = (grid2, pasteDetails, comparator, _genWrappers) => {
    const rows2 = extractGridDetails(grid2).rows;
    const index = pasteDetails.cells[pasteDetails.cells.length - 1].row + pasteDetails.cells[pasteDetails.cells.length - 1].rowspan;
    const context = rows2[pasteDetails.cells[0].row];
    const gridB = gridifyRows(pasteDetails.clipboard, pasteDetails.generators, context);
    const mergedGrid = insertRows(index, grid2, gridB, pasteDetails.generators, comparator);
    return bundle(mergedGrid, pasteDetails.cells[0].row, pasteDetails.cells[0].column);
  };
  const opGetColumnsType = (table2, target) => {
    const house = Warehouse.fromTable(table2);
    const details = onCells(house, target);
    return details.bind((selectedCells) => {
      const lastSelectedCell = selectedCells[selectedCells.length - 1];
      const minColRange = selectedCells[0].column;
      const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
      const selectedColumnCells = flatten(map$1(house.all, (row2) => filter$2(row2.cells, (cell2) => cell2.column >= minColRange && cell2.column < maxColRange)));
      return findCommonCellType(selectedColumnCells);
    }).getOr("");
  };
  const opGetCellsType = (table2, target) => {
    const house = Warehouse.fromTable(table2);
    const details = onCells(house, target);
    return details.bind(findCommonCellType).getOr("");
  };
  const opGetRowsType = (table2, target) => {
    const house = Warehouse.fromTable(table2);
    const details = onCells(house, target);
    return details.bind((selectedCells) => {
      const lastSelectedCell = selectedCells[selectedCells.length - 1];
      const minRowRange = selectedCells[0].row;
      const maxRowRange = lastSelectedCell.row + lastSelectedCell.rowspan;
      const selectedRows = house.all.slice(minRowRange, maxRowRange);
      return findCommonRowType(selectedRows);
    }).getOr("");
  };
  const resize = (table2, list2, details, behaviours) => adjustWidthTo(table2, list2, details, behaviours.sizing);
  const adjustAndRedistributeWidths = (table2, list2, details, behaviours) => adjustAndRedistributeWidths$1(table2, list2, details, behaviours.sizing, behaviours.resize);
  const firstColumnIsLocked = (_warehouse, details) => exists(details, (detail2) => detail2.column === 0 && detail2.isLocked);
  const lastColumnIsLocked = (warehouse, details) => exists(details, (detail2) => detail2.column + detail2.colspan >= warehouse.grid.columns && detail2.isLocked);
  const getColumnsWidth = (warehouse, details) => {
    const columns$12 = columns(warehouse);
    const uniqueCols = uniqueColumns(details);
    return foldl(uniqueCols, (acc, detail2) => {
      const column = columns$12[detail2.column];
      const colWidth = column.map(getOuter$2).getOr(0);
      return acc + colWidth;
    }, 0);
  };
  const insertColumnsExtractor = (before2) => (warehouse, target) => onCells(warehouse, target).filter((details) => {
    const checkLocked = before2 ? firstColumnIsLocked : lastColumnIsLocked;
    return !checkLocked(warehouse, details);
  }).map((details) => ({
    details,
    pixelDelta: getColumnsWidth(warehouse, details)
  }));
  const eraseColumnsExtractor = (warehouse, target) => onUnlockedCells(warehouse, target).map((details) => ({
    details,
    pixelDelta: -getColumnsWidth(warehouse, details)
  }));
  const pasteColumnsExtractor = (before2) => (warehouse, target) => onPasteByEditor(warehouse, target).filter((details) => {
    const checkLocked = before2 ? firstColumnIsLocked : lastColumnIsLocked;
    return !checkLocked(warehouse, details.cells);
  });
  const headerCellGenerator = Generators.transform("th");
  const bodyCellGenerator = Generators.transform("td");
  const insertRowsBefore = run2(opInsertRowsBefore, onCells, noop2, noop2, Generators.modification);
  const insertRowsAfter = run2(opInsertRowsAfter, onCells, noop2, noop2, Generators.modification);
  const insertColumnsBefore = run2(opInsertColumnsBefore, insertColumnsExtractor(true), adjustAndRedistributeWidths, noop2, Generators.modification);
  const insertColumnsAfter = run2(opInsertColumnsAfter, insertColumnsExtractor(false), adjustAndRedistributeWidths, noop2, Generators.modification);
  const eraseColumns = run2(opEraseColumns, eraseColumnsExtractor, adjustAndRedistributeWidths, prune, Generators.modification);
  const eraseRows = run2(opEraseRows, onCells, noop2, prune, Generators.modification);
  const makeColumnsHeader = run2(opMakeColumnsHeader, onUnlockedCells, noop2, noop2, headerCellGenerator);
  const unmakeColumnsHeader = run2(opUnmakeColumnsHeader, onUnlockedCells, noop2, noop2, bodyCellGenerator);
  const makeRowsHeader = run2(opMakeRowsHeader, onUnlockedCells, noop2, noop2, headerCellGenerator);
  const makeRowsBody = run2(opMakeRowsBody, onUnlockedCells, noop2, noop2, bodyCellGenerator);
  const makeRowsFooter = run2(opMakeRowsFooter, onUnlockedCells, noop2, noop2, bodyCellGenerator);
  const makeCellsHeader = run2(opMakeCellsHeader, onUnlockedCells, noop2, noop2, headerCellGenerator);
  const unmakeCellsHeader = run2(opUnmakeCellsHeader, onUnlockedCells, noop2, noop2, bodyCellGenerator);
  const mergeCells = run2(opMergeCells, onUnlockedMergable, resize, noop2, Generators.merging);
  const unmergeCells = run2(opUnmergeCells, onUnlockedUnmergable, resize, noop2, Generators.merging);
  const pasteCells = run2(opPasteCells, onPaste, resize, noop2, Generators.modification);
  const pasteColsBefore = run2(opPasteColsBefore, pasteColumnsExtractor(true), noop2, noop2, Generators.modification);
  const pasteColsAfter = run2(opPasteColsAfter, pasteColumnsExtractor(false), noop2, noop2, Generators.modification);
  const pasteRowsBefore = run2(opPasteRowsBefore, onPasteByEditor, noop2, noop2, Generators.modification);
  const pasteRowsAfter = run2(opPasteRowsAfter, onPasteByEditor, noop2, noop2, Generators.modification);
  const getColumnsType = opGetColumnsType;
  const getCellsType = opGetCellsType;
  const getRowsType = opGetRowsType;
  const fireNewRow = (editor, row2) => editor.dispatch("NewRow", { node: row2 });
  const fireNewCell = (editor, cell2) => editor.dispatch("NewCell", { node: cell2 });
  const fireTableModified = (editor, table2, data2) => {
    editor.dispatch("TableModified", {
      ...data2,
      table: table2
    });
  };
  const fireTableSelectionChange = (editor, cells2, start2, finish, otherCells) => {
    editor.dispatch("TableSelectionChange", {
      cells: cells2,
      start: start2,
      finish,
      otherCells
    });
  };
  const fireTableSelectionClear = (editor) => {
    editor.dispatch("TableSelectionClear");
  };
  const fireObjectResizeStart = (editor, target, width3, height3, origin) => {
    editor.dispatch("ObjectResizeStart", {
      target,
      width: width3,
      height: height3,
      origin
    });
  };
  const fireObjectResized = (editor, target, width3, height3, origin) => {
    editor.dispatch("ObjectResized", {
      target,
      width: width3,
      height: height3,
      origin
    });
  };
  const styleModified = {
    structure: false,
    style: true
  };
  const structureModified = {
    structure: true,
    style: false
  };
  const styleAndStructureModified = {
    structure: true,
    style: true
  };
  const option2 = (name3) => (editor) => editor.options.get(name3);
  const defaultWidth = "100%";
  const getPixelForcedWidth = (editor) => {
    var _a;
    const dom = editor.dom;
    const parentBlock = (_a = dom.getParent(editor.selection.getStart(), dom.isBlock)) !== null && _a !== void 0 ? _a : editor.getBody();
    return getInner(SugarElement.fromDom(parentBlock)) + "px";
  };
  const determineDefaultTableStyles = (editor, defaultStyles) => {
    if (isTableResponsiveForced(editor) || !shouldStyleWithCss(editor)) {
      return defaultStyles;
    } else if (isTablePixelsForced(editor)) {
      return {
        ...defaultStyles,
        width: getPixelForcedWidth(editor)
      };
    } else {
      return {
        ...defaultStyles,
        width: defaultWidth
      };
    }
  };
  const determineDefaultTableAttributes = (editor, defaultAttributes) => {
    if (isTableResponsiveForced(editor) || shouldStyleWithCss(editor)) {
      return defaultAttributes;
    } else if (isTablePixelsForced(editor)) {
      return {
        ...defaultAttributes,
        width: getPixelForcedWidth(editor)
      };
    } else {
      return {
        ...defaultAttributes,
        width: defaultWidth
      };
    }
  };
  const register = (editor) => {
    const registerOption = editor.options.register;
    registerOption("table_clone_elements", { processor: "string[]" });
    registerOption("table_use_colgroups", {
      processor: "boolean",
      default: true
    });
    registerOption("table_header_type", {
      processor: (value2) => {
        const valid = contains$2([
          "section",
          "cells",
          "sectionCells",
          "auto"
        ], value2);
        return valid ? {
          value: value2,
          valid
        } : {
          valid: false,
          message: "Must be one of: section, cells, sectionCells or auto."
        };
      },
      default: "section"
    });
    registerOption("table_sizing_mode", {
      processor: "string",
      default: "auto"
    });
    registerOption("table_default_attributes", {
      processor: "object",
      default: { border: "1" }
    });
    registerOption("table_default_styles", {
      processor: "object",
      default: { "border-collapse": "collapse" }
    });
    registerOption("table_column_resizing", {
      processor: (value2) => {
        const valid = contains$2([
          "preservetable",
          "resizetable"
        ], value2);
        return valid ? {
          value: value2,
          valid
        } : {
          valid: false,
          message: "Must be preservetable, or resizetable."
        };
      },
      default: "preservetable"
    });
    registerOption("table_resize_bars", {
      processor: "boolean",
      default: true
    });
    registerOption("table_style_by_css", {
      processor: "boolean",
      default: true
    });
  };
  const getTableCloneElements = (editor) => {
    return Optional.from(editor.options.get("table_clone_elements"));
  };
  const hasTableObjectResizing = (editor) => {
    const objectResizing = editor.options.get("object_resizing");
    return contains$2(objectResizing.split(","), "table");
  };
  const getTableHeaderType = option2("table_header_type");
  const getTableColumnResizingBehaviour = option2("table_column_resizing");
  const isPreserveTableColumnResizing = (editor) => getTableColumnResizingBehaviour(editor) === "preservetable";
  const isResizeTableColumnResizing = (editor) => getTableColumnResizingBehaviour(editor) === "resizetable";
  const getTableSizingMode = option2("table_sizing_mode");
  const isTablePercentagesForced = (editor) => getTableSizingMode(editor) === "relative";
  const isTablePixelsForced = (editor) => getTableSizingMode(editor) === "fixed";
  const isTableResponsiveForced = (editor) => getTableSizingMode(editor) === "responsive";
  const hasTableResizeBars = option2("table_resize_bars");
  const shouldStyleWithCss = option2("table_style_by_css");
  const getTableDefaultAttributes = (editor) => {
    const options = editor.options;
    const defaultAttributes = options.get("table_default_attributes");
    return options.isSet("table_default_attributes") ? defaultAttributes : determineDefaultTableAttributes(editor, defaultAttributes);
  };
  const getTableDefaultStyles = (editor) => {
    const options = editor.options;
    const defaultStyles = options.get("table_default_styles");
    return options.isSet("table_default_styles") ? defaultStyles : determineDefaultTableStyles(editor, defaultStyles);
  };
  const tableUseColumnGroup = option2("table_use_colgroups");
  const get$5 = (editor, table2) => {
    if (isTablePercentagesForced(editor)) {
      return TableSize.percentageSize(table2);
    } else if (isTablePixelsForced(editor)) {
      return TableSize.pixelSize(table2);
    } else {
      return TableSize.getTableSize(table2);
    }
  };
  const TableActions = (editor, resizeHandler, cellSelectionHandler) => {
    const isTableBody = (editor2) => name2(getBody(editor2)) === "table";
    const lastRowGuard = (table2) => !isTableBody(editor) || getGridSize(table2).rows > 1;
    const lastColumnGuard = (table2) => !isTableBody(editor) || getGridSize(table2).columns > 1;
    const cloneFormats2 = getTableCloneElements(editor);
    const colMutationOp = isResizeTableColumnResizing(editor) ? noop2 : halve;
    const getTableSectionType2 = (table2) => {
      switch (getTableHeaderType(editor)) {
        case "section":
          return TableSection.section();
        case "sectionCells":
          return TableSection.sectionCells();
        case "cells":
          return TableSection.cells();
        default:
          return TableSection.getTableSectionType(table2, "section");
      }
    };
    const setSelectionFromAction = (table2, result) => result.cursor.fold(() => {
      const cells2 = cells$1(table2);
      return head(cells2).filter(inBody).map((firstCell) => {
        cellSelectionHandler.clearSelectedCells(table2.dom);
        const rng = editor.dom.createRng();
        rng.selectNode(firstCell.dom);
        editor.selection.setRng(rng);
        set$2(firstCell, "data-mce-selected", "1");
        return rng;
      });
    }, (cell2) => {
      const des = freefallRtl(cell2);
      const rng = editor.dom.createRng();
      rng.setStart(des.element.dom, des.offset);
      rng.setEnd(des.element.dom, des.offset);
      editor.selection.setRng(rng);
      cellSelectionHandler.clearSelectedCells(table2.dom);
      return Optional.some(rng);
    });
    const execute2 = (operation, guard, mutate2, effect2) => (table2, target, noEvents = false) => {
      removeDataStyle(table2);
      const doc = SugarElement.fromDom(editor.getDoc());
      const generators = cellOperations(mutate2, doc, cloneFormats2);
      const behaviours = {
        sizing: get$5(editor, table2),
        resize: isResizeTableColumnResizing(editor) ? resizeTable() : preserveTable(),
        section: getTableSectionType2(table2)
      };
      return guard(table2) ? operation(table2, target, generators, behaviours).bind((result) => {
        resizeHandler.refresh(table2.dom);
        each$2(result.newRows, (row2) => {
          fireNewRow(editor, row2.dom);
        });
        each$2(result.newCells, (cell2) => {
          fireNewCell(editor, cell2.dom);
        });
        const range2 = setSelectionFromAction(table2, result);
        if (inBody(table2)) {
          removeDataStyle(table2);
          if (!noEvents) {
            fireTableModified(editor, table2.dom, effect2);
          }
        }
        return range2.map((rng) => ({
          rng,
          effect: effect2
        }));
      }) : Optional.none();
    };
    const deleteRow = execute2(eraseRows, lastRowGuard, noop2, structureModified);
    const deleteColumn = execute2(eraseColumns, lastColumnGuard, noop2, structureModified);
    const insertRowsBefore$1 = execute2(insertRowsBefore, always, noop2, structureModified);
    const insertRowsAfter$1 = execute2(insertRowsAfter, always, noop2, structureModified);
    const insertColumnsBefore$1 = execute2(insertColumnsBefore, always, colMutationOp, structureModified);
    const insertColumnsAfter$1 = execute2(insertColumnsAfter, always, colMutationOp, structureModified);
    const mergeCells$1 = execute2(mergeCells, always, noop2, structureModified);
    const unmergeCells$1 = execute2(unmergeCells, always, noop2, structureModified);
    const pasteColsBefore$1 = execute2(pasteColsBefore, always, noop2, structureModified);
    const pasteColsAfter$1 = execute2(pasteColsAfter, always, noop2, structureModified);
    const pasteRowsBefore$1 = execute2(pasteRowsBefore, always, noop2, structureModified);
    const pasteRowsAfter$1 = execute2(pasteRowsAfter, always, noop2, structureModified);
    const pasteCells$1 = execute2(pasteCells, always, noop2, styleAndStructureModified);
    const makeCellsHeader$1 = execute2(makeCellsHeader, always, noop2, structureModified);
    const unmakeCellsHeader$1 = execute2(unmakeCellsHeader, always, noop2, structureModified);
    const makeColumnsHeader$1 = execute2(makeColumnsHeader, always, noop2, structureModified);
    const unmakeColumnsHeader$1 = execute2(unmakeColumnsHeader, always, noop2, structureModified);
    const makeRowsHeader$1 = execute2(makeRowsHeader, always, noop2, structureModified);
    const makeRowsBody$1 = execute2(makeRowsBody, always, noop2, structureModified);
    const makeRowsFooter$1 = execute2(makeRowsFooter, always, noop2, structureModified);
    const getTableCellType = getCellsType;
    const getTableColType = getColumnsType;
    const getTableRowType = getRowsType;
    return {
      deleteRow,
      deleteColumn,
      insertRowsBefore: insertRowsBefore$1,
      insertRowsAfter: insertRowsAfter$1,
      insertColumnsBefore: insertColumnsBefore$1,
      insertColumnsAfter: insertColumnsAfter$1,
      mergeCells: mergeCells$1,
      unmergeCells: unmergeCells$1,
      pasteColsBefore: pasteColsBefore$1,
      pasteColsAfter: pasteColsAfter$1,
      pasteRowsBefore: pasteRowsBefore$1,
      pasteRowsAfter: pasteRowsAfter$1,
      pasteCells: pasteCells$1,
      makeCellsHeader: makeCellsHeader$1,
      unmakeCellsHeader: unmakeCellsHeader$1,
      makeColumnsHeader: makeColumnsHeader$1,
      unmakeColumnsHeader: unmakeColumnsHeader$1,
      makeRowsHeader: makeRowsHeader$1,
      makeRowsBody: makeRowsBody$1,
      makeRowsFooter: makeRowsFooter$1,
      getTableRowType,
      getTableCellType,
      getTableColType
    };
  };
  const constrainSpan = (element, property, value2) => {
    const currentColspan = getAttrValue(element, property, 1);
    if (value2 === 1 || currentColspan <= 1) {
      remove$7(element, property);
    } else {
      set$2(element, property, Math.min(value2, currentColspan));
    }
  };
  const isColInRange = (minColRange, maxColRange) => (cell2) => {
    const endCol = cell2.column + cell2.colspan - 1;
    const startCol = cell2.column;
    return endCol >= minColRange && startCol < maxColRange;
  };
  const generateColGroup = (house, minColRange, maxColRange) => {
    if (Warehouse.hasColumns(house)) {
      const colsToCopy = filter$2(Warehouse.justColumns(house), isColInRange(minColRange, maxColRange));
      const copiedCols = map$1(colsToCopy, (c) => {
        const clonedCol = deep(c.element);
        constrainSpan(clonedCol, "span", maxColRange - minColRange);
        return clonedCol;
      });
      const fakeColgroup = SugarElement.fromTag("colgroup");
      append2(fakeColgroup, copiedCols);
      return [fakeColgroup];
    } else {
      return [];
    }
  };
  const generateRows = (house, minColRange, maxColRange) => map$1(house.all, (row2) => {
    const cellsToCopy = filter$2(row2.cells, isColInRange(minColRange, maxColRange));
    const copiedCells = map$1(cellsToCopy, (cell2) => {
      const clonedCell = deep(cell2.element);
      constrainSpan(clonedCell, "colspan", maxColRange - minColRange);
      return clonedCell;
    });
    const fakeTR = SugarElement.fromTag("tr");
    append2(fakeTR, copiedCells);
    return fakeTR;
  });
  const copyCols = (table2, target) => {
    const house = Warehouse.fromTable(table2);
    const details = onUnlockedCells(house, target);
    return details.map((selectedCells) => {
      const lastSelectedCell = selectedCells[selectedCells.length - 1];
      const minColRange = selectedCells[0].column;
      const maxColRange = lastSelectedCell.column + lastSelectedCell.colspan;
      const fakeColGroups = generateColGroup(house, minColRange, maxColRange);
      const fakeRows = generateRows(house, minColRange, maxColRange);
      return [
        ...fakeColGroups,
        ...fakeRows
      ];
    });
  };
  const copyRows = (table2, target, generators) => {
    const warehouse = Warehouse.fromTable(table2);
    const details = onCells(warehouse, target);
    return details.bind((selectedCells) => {
      const grid2 = toGrid(warehouse, generators, false);
      const rows2 = extractGridDetails(grid2).rows;
      const slicedGrid = rows2.slice(selectedCells[0].row, selectedCells[selectedCells.length - 1].row + selectedCells[selectedCells.length - 1].rowspan);
      const filteredGrid = bind$2(slicedGrid, (row2) => {
        const newCells = filter$2(row2.cells, (cell2) => !cell2.isLocked);
        return newCells.length > 0 ? [{
          ...row2,
          cells: newCells
        }] : [];
      });
      const slicedDetails = toDetailList(filteredGrid);
      return someIf(slicedDetails.length > 0, slicedDetails);
    }).map((slicedDetails) => copy(slicedDetails));
  };
  const adt$5 = Adt.generate([
    { invalid: ["raw"] },
    { pixels: ["value"] },
    { percent: ["value"] }
  ]);
  const validateFor = (suffix, type2, value2) => {
    const rawAmount = value2.substring(0, value2.length - suffix.length);
    const amount = parseFloat(rawAmount);
    return rawAmount === amount.toString() ? type2(amount) : adt$5.invalid(value2);
  };
  const from = (value2) => {
    if (endsWith2(value2, "%")) {
      return validateFor("%", adt$5.percent, value2);
    }
    if (endsWith2(value2, "px")) {
      return validateFor("px", adt$5.pixels, value2);
    }
    return adt$5.invalid(value2);
  };
  const Size = {
    ...adt$5,
    from
  };
  const redistributeToPercent = (widths, totalWidth) => {
    return map$1(widths, (w) => {
      const colType = Size.from(w);
      return colType.fold(() => {
        return w;
      }, (px) => {
        const ratio = px / totalWidth * 100;
        return ratio + "%";
      }, (pc) => {
        return pc + "%";
      });
    });
  };
  const redistributeToPx = (widths, totalWidth, newTotalWidth) => {
    const scale = newTotalWidth / totalWidth;
    return map$1(widths, (w) => {
      const colType = Size.from(w);
      return colType.fold(() => {
        return w;
      }, (px) => {
        return px * scale + "px";
      }, (pc) => {
        return pc / 100 * newTotalWidth + "px";
      });
    });
  };
  const redistributeEmpty = (newWidthType, columns2) => {
    const f = newWidthType.fold(() => constant(""), (pixels) => {
      const num = pixels / columns2;
      return constant(num + "px");
    }, () => {
      const num = 100 / columns2;
      return constant(num + "%");
    });
    return range$1(columns2, f);
  };
  const redistributeValues = (newWidthType, widths, totalWidth) => {
    return newWidthType.fold(() => {
      return widths;
    }, (px) => {
      return redistributeToPx(widths, totalWidth, px);
    }, (_pc) => {
      return redistributeToPercent(widths, totalWidth);
    });
  };
  const redistribute$1 = (widths, totalWidth, newWidth) => {
    const newType = Size.from(newWidth);
    const floats = forall(widths, (s) => {
      return s === "0px";
    }) ? redistributeEmpty(newType, widths.length) : redistributeValues(newType, widths, totalWidth);
    return normalize(floats);
  };
  const sum = (values2, fallback2) => {
    if (values2.length === 0) {
      return fallback2;
    }
    return foldr(values2, (rest, v) => {
      return Size.from(v).fold(constant(0), identity, identity) + rest;
    }, 0);
  };
  const roundDown = (num, unit) => {
    const floored = Math.floor(num);
    return {
      value: floored + unit,
      remainder: num - floored
    };
  };
  const add$3 = (value2, amount) => {
    return Size.from(value2).fold(constant(value2), (px) => {
      return px + amount + "px";
    }, (pc) => {
      return pc + amount + "%";
    });
  };
  const normalize = (values2) => {
    if (values2.length === 0) {
      return values2;
    }
    const scan2 = foldr(values2, (rest, value2) => {
      const info = Size.from(value2).fold(() => ({
        value: value2,
        remainder: 0
      }), (num) => roundDown(num, "px"), (num) => ({
        value: num + "%",
        remainder: 0
      }));
      return {
        output: [info.value].concat(rest.output),
        remainder: rest.remainder + info.remainder
      };
    }, {
      output: [],
      remainder: 0
    });
    const r2 = scan2.output;
    return r2.slice(0, r2.length - 1).concat([add$3(r2[r2.length - 1], Math.round(scan2.remainder))]);
  };
  const validate = Size.from;
  const redistributeToW = (newWidths, cells2, unit) => {
    each$2(cells2, (cell2) => {
      const widths = newWidths.slice(cell2.column, cell2.colspan + cell2.column);
      const w = sum(widths, minWidth());
      set$1(cell2.element, "width", w + unit);
    });
  };
  const redistributeToColumns = (newWidths, columns2, unit) => {
    each$2(columns2, (column, index) => {
      const width3 = sum([newWidths[index]], minWidth());
      set$1(column.element, "width", width3 + unit);
    });
  };
  const redistributeToH = (newHeights, rows2, cells2, unit) => {
    each$2(cells2, (cell2) => {
      const heights = newHeights.slice(cell2.row, cell2.rowspan + cell2.row);
      const h = sum(heights, minHeight());
      set$1(cell2.element, "height", h + unit);
    });
    each$2(rows2, (row2, i) => {
      set$1(row2.element, "height", newHeights[i]);
    });
  };
  const getUnit = (newSize) => {
    return validate(newSize).fold(constant("px"), constant("px"), constant("%"));
  };
  const redistribute = (table2, optWidth, optHeight) => {
    const warehouse = Warehouse.fromTable(table2);
    const rows2 = warehouse.all;
    const cells2 = Warehouse.justCells(warehouse);
    const columns2 = Warehouse.justColumns(warehouse);
    optWidth.each((newWidth) => {
      const widthUnit = getUnit(newWidth);
      const totalWidth = get$9(table2);
      const oldWidths = getRawWidths(warehouse, table2);
      const nuWidths = redistribute$1(oldWidths, totalWidth, newWidth);
      if (Warehouse.hasColumns(warehouse)) {
        redistributeToColumns(nuWidths, columns2, widthUnit);
      } else {
        redistributeToW(nuWidths, cells2, widthUnit);
      }
      set$1(table2, "width", newWidth);
    });
    optHeight.each((newHeight) => {
      const hUnit = getUnit(newHeight);
      const totalHeight = get$8(table2);
      const oldHeights = getRawHeights(warehouse, table2, height2);
      const nuHeights = redistribute$1(oldHeights, totalHeight, newHeight);
      redistributeToH(nuHeights, rows2, cells2, hUnit);
      set$1(table2, "height", newHeight);
    });
  };
  const isPercentSizing = isPercentSizing$1;
  const isPixelSizing = isPixelSizing$1;
  const isNoneSizing = isNoneSizing$1;
  const cleanupLegacyAttributes = (element) => {
    remove$7(element, "width");
  };
  const convertToPercentSize = (table2) => {
    const newWidth = getPercentTableWidth(table2);
    redistribute(table2, Optional.some(newWidth), Optional.none());
    cleanupLegacyAttributes(table2);
  };
  const convertToPixelSize = (table2) => {
    const newWidth = getPixelTableWidth(table2);
    redistribute(table2, Optional.some(newWidth), Optional.none());
    cleanupLegacyAttributes(table2);
  };
  const convertToNoneSize = (table2) => {
    remove$5(table2, "width");
    const columns2 = columns$1(table2);
    const rowElements = columns2.length > 0 ? columns2 : cells$1(table2);
    each$2(rowElements, (cell2) => {
      remove$5(cell2, "width");
      cleanupLegacyAttributes(cell2);
    });
    cleanupLegacyAttributes(table2);
  };
  const DefaultRenderOptions = {
    styles: {
      "border-collapse": "collapse",
      "width": "100%"
    },
    attributes: { border: "1" },
    colGroups: false
  };
  const tableHeaderCell = () => SugarElement.fromTag("th");
  const tableCell = () => SugarElement.fromTag("td");
  const tableColumn = () => SugarElement.fromTag("col");
  const createRow = (columns2, rowHeaders, columnHeaders, rowIndex) => {
    const tr = SugarElement.fromTag("tr");
    for (let j = 0; j < columns2; j++) {
      const td = rowIndex < rowHeaders || j < columnHeaders ? tableHeaderCell() : tableCell();
      if (j < columnHeaders) {
        set$2(td, "scope", "row");
      }
      if (rowIndex < rowHeaders) {
        set$2(td, "scope", "col");
      }
      append$1(td, SugarElement.fromTag("br"));
      append$1(tr, td);
    }
    return tr;
  };
  const createGroupRow = (columns2) => {
    const columnGroup = SugarElement.fromTag("colgroup");
    range$1(columns2, () => append$1(columnGroup, tableColumn()));
    return columnGroup;
  };
  const createRows = (rows2, columns2, rowHeaders, columnHeaders) => range$1(rows2, (r2) => createRow(columns2, rowHeaders, columnHeaders, r2));
  const render = (rows2, columns2, rowHeaders, columnHeaders, headerType, renderOpts = DefaultRenderOptions) => {
    const table2 = SugarElement.fromTag("table");
    const rowHeadersGoInThead = headerType !== "cells";
    setAll(table2, renderOpts.styles);
    setAll$1(table2, renderOpts.attributes);
    if (renderOpts.colGroups) {
      append$1(table2, createGroupRow(columns2));
    }
    const actualRowHeaders = Math.min(rows2, rowHeaders);
    if (rowHeadersGoInThead && rowHeaders > 0) {
      const thead = SugarElement.fromTag("thead");
      append$1(table2, thead);
      const theadRowHeaders = headerType === "sectionCells" ? actualRowHeaders : 0;
      const theadRows = createRows(rowHeaders, columns2, theadRowHeaders, columnHeaders);
      append2(thead, theadRows);
    }
    const tbody = SugarElement.fromTag("tbody");
    append$1(table2, tbody);
    const numRows = rowHeadersGoInThead ? rows2 - actualRowHeaders : rows2;
    const numRowHeaders = rowHeadersGoInThead ? 0 : rowHeaders;
    const tbodyRows = createRows(numRows, columns2, numRowHeaders, columnHeaders);
    append2(tbody, tbodyRows);
    return table2;
  };
  const get$4 = (element) => element.dom.innerHTML;
  const getOuter = (element) => {
    const container = SugarElement.fromTag("div");
    const clone2 = SugarElement.fromDom(element.dom.cloneNode(true));
    append$1(container, clone2);
    return get$4(container);
  };
  const placeCaretInCell = (editor, cell2) => {
    editor.selection.select(cell2.dom, true);
    editor.selection.collapse(true);
  };
  const selectFirstCellInTable = (editor, tableElm) => {
    descendant(tableElm, "td,th").each(curry(placeCaretInCell, editor));
  };
  const fireEvents = (editor, table2) => {
    each$2(descendants(table2, "tr"), (row2) => {
      fireNewRow(editor, row2.dom);
      each$2(descendants(row2, "th,td"), (cell2) => {
        fireNewCell(editor, cell2.dom);
      });
    });
  };
  const isPercentage = (width3) => isString2(width3) && width3.indexOf("%") !== -1;
  const insert = (editor, columns2, rows2, colHeaders, rowHeaders) => {
    const defaultStyles = getTableDefaultStyles(editor);
    const options = {
      styles: defaultStyles,
      attributes: getTableDefaultAttributes(editor),
      colGroups: tableUseColumnGroup(editor)
    };
    editor.undoManager.ignore(() => {
      const table2 = render(rows2, columns2, rowHeaders, colHeaders, getTableHeaderType(editor), options);
      set$2(table2, "data-mce-id", "__mce");
      const html = getOuter(table2);
      editor.insertContent(html);
      editor.addVisual();
    });
    return descendant(getBody(editor), 'table[data-mce-id="__mce"]').map((table2) => {
      if (isTablePixelsForced(editor)) {
        convertToPixelSize(table2);
      } else if (isTableResponsiveForced(editor)) {
        convertToNoneSize(table2);
      } else if (isTablePercentagesForced(editor) || isPercentage(defaultStyles.width)) {
        convertToPercentSize(table2);
      }
      removeDataStyle(table2);
      remove$7(table2, "data-mce-id");
      fireEvents(editor, table2);
      selectFirstCellInTable(editor, table2);
      return table2.dom;
    }).getOrNull();
  };
  const insertTable = (editor, rows2, columns2, options = {}) => {
    const checkInput = (val) => isNumber2(val) && val > 0;
    if (checkInput(rows2) && checkInput(columns2)) {
      const headerRows = options.headerRows || 0;
      const headerColumns = options.headerColumns || 0;
      return insert(editor, columns2, rows2, headerColumns, headerRows);
    } else {
      console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table.");
      return null;
    }
  };
  var global2 = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
  const tableTypeBase = "x-tinymce/dom-table-";
  const tableTypeRow = tableTypeBase + "rows";
  const tableTypeColumn = tableTypeBase + "columns";
  const setData = (items) => {
    const fakeClipboardItem = global2.FakeClipboardItem(items);
    global2.write([fakeClipboardItem]);
  };
  const getData = (type2) => {
    var _a;
    const items = (_a = global2.read()) !== null && _a !== void 0 ? _a : [];
    return findMap(items, (item2) => Optional.from(item2.getType(type2)));
  };
  const clearData = (type2) => {
    if (getData(type2).isSome()) {
      global2.clear();
    }
  };
  const setRows = (rowsOpt) => {
    rowsOpt.fold(clearRows, (rows2) => setData({ [tableTypeRow]: rows2 }));
  };
  const getRows = () => getData(tableTypeRow);
  const clearRows = () => clearData(tableTypeRow);
  const setColumns = (columnsOpt) => {
    columnsOpt.fold(clearColumns, (columns2) => setData({ [tableTypeColumn]: columns2 }));
  };
  const getColumns = () => getData(tableTypeColumn);
  const clearColumns = () => clearData(tableTypeColumn);
  const getSelectionStartCellOrCaption = (editor) => getSelectionCellOrCaption(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);
  const getSelectionStartCell = (editor) => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)).filter(isInEditableContext$1);
  const registerCommands = (editor, actions2) => {
    const isRoot = getIsRoot(editor);
    const eraseTable = () => getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
      table(cellOrCaption, isRoot).filter(not(isRoot)).each((table2) => {
        const cursor = SugarElement.fromText("");
        after$5(table2, cursor);
        remove$6(table2);
        if (editor.dom.isEmpty(editor.getBody())) {
          editor.setContent("");
          editor.selection.setCursorLocation();
        } else {
          const rng = editor.dom.createRng();
          rng.setStart(cursor.dom, 0);
          rng.setEnd(cursor.dom, 0);
          editor.selection.setRng(rng);
          editor.nodeChanged();
        }
      });
    });
    const setSizingMode = (sizing) => getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
      const isForcedSizing = isTableResponsiveForced(editor) || isTablePixelsForced(editor) || isTablePercentagesForced(editor);
      if (!isForcedSizing) {
        table(cellOrCaption, isRoot).each((table2) => {
          if (sizing === "relative" && !isPercentSizing(table2)) {
            convertToPercentSize(table2);
          } else if (sizing === "fixed" && !isPixelSizing(table2)) {
            convertToPixelSize(table2);
          } else if (sizing === "responsive" && !isNoneSizing(table2)) {
            convertToNoneSize(table2);
          }
          removeDataStyle(table2);
          fireTableModified(editor, table2.dom, structureModified);
        });
      }
    });
    const getTableFromCell = (cell2) => table(cell2, isRoot);
    const performActionOnSelection = (action) => getSelectionStartCell(editor).bind((cell2) => getTableFromCell(cell2).map((table2) => action(table2, cell2)));
    const toggleTableClass = (_ui, clazz) => {
      performActionOnSelection((table2) => {
        editor.formatter.toggle("tableclass", { value: clazz }, table2.dom);
        fireTableModified(editor, table2.dom, styleModified);
      });
    };
    const toggleTableCellClass = (_ui, clazz) => {
      performActionOnSelection((table2) => {
        const selectedCells = getCellsFromSelection(editor);
        const allHaveClass = forall(selectedCells, (cell2) => editor.formatter.match("tablecellclass", { value: clazz }, cell2.dom));
        const formatterAction = allHaveClass ? editor.formatter.remove : editor.formatter.apply;
        each$2(selectedCells, (cell2) => formatterAction("tablecellclass", { value: clazz }, cell2.dom));
        fireTableModified(editor, table2.dom, styleModified);
      });
    };
    const toggleCaption = () => {
      getSelectionStartCellOrCaption(editor).each((cellOrCaption) => {
        table(cellOrCaption, isRoot).each((table2) => {
          child(table2, "caption").fold(() => {
            const caption = SugarElement.fromTag("caption");
            append$1(caption, SugarElement.fromText("Caption"));
            appendAt(table2, caption, 0);
            editor.selection.setCursorLocation(caption.dom, 0);
          }, (caption) => {
            if (isTag("caption")(cellOrCaption)) {
              one("td", table2).each((td) => editor.selection.setCursorLocation(td.dom, 0));
            }
            remove$6(caption);
          });
          fireTableModified(editor, table2.dom, structureModified);
        });
      });
    };
    const postExecute = (_data) => {
      editor.focus();
    };
    const actOnSelection = (execute2, noEvents = false) => performActionOnSelection((table2, startCell) => {
      const targets = forMenu(getCellsFromSelection(editor), table2, startCell);
      execute2(table2, targets, noEvents).each(postExecute);
    });
    const copyRowSelection = () => performActionOnSelection((table2, startCell) => {
      const targets = forMenu(getCellsFromSelection(editor), table2, startCell);
      const generators = cellOperations(noop2, SugarElement.fromDom(editor.getDoc()), Optional.none());
      return copyRows(table2, targets, generators);
    });
    const copyColSelection = () => performActionOnSelection((table2, startCell) => {
      const targets = forMenu(getCellsFromSelection(editor), table2, startCell);
      return copyCols(table2, targets);
    });
    const pasteOnSelection = (execute2, getRows2) => getRows2().each((rows2) => {
      const clonedRows = map$1(rows2, (row2) => deep(row2));
      performActionOnSelection((table2, startCell) => {
        const generators = paste$1(SugarElement.fromDom(editor.getDoc()));
        const targets = pasteRows(getCellsFromSelection(editor), startCell, clonedRows, generators);
        execute2(table2, targets).each(postExecute);
      });
    });
    const actOnType = (getAction) => (_ui, args) => get$c(args, "type").each((type2) => {
      actOnSelection(getAction(type2), args.no_events);
    });
    each$1({
      mceTableSplitCells: () => actOnSelection(actions2.unmergeCells),
      mceTableMergeCells: () => actOnSelection(actions2.mergeCells),
      mceTableInsertRowBefore: () => actOnSelection(actions2.insertRowsBefore),
      mceTableInsertRowAfter: () => actOnSelection(actions2.insertRowsAfter),
      mceTableInsertColBefore: () => actOnSelection(actions2.insertColumnsBefore),
      mceTableInsertColAfter: () => actOnSelection(actions2.insertColumnsAfter),
      mceTableDeleteCol: () => actOnSelection(actions2.deleteColumn),
      mceTableDeleteRow: () => actOnSelection(actions2.deleteRow),
      mceTableCutCol: () => copyColSelection().each((selection2) => {
        setColumns(selection2);
        actOnSelection(actions2.deleteColumn);
      }),
      mceTableCutRow: () => copyRowSelection().each((selection2) => {
        setRows(selection2);
        actOnSelection(actions2.deleteRow);
      }),
      mceTableCopyCol: () => copyColSelection().each((selection2) => setColumns(selection2)),
      mceTableCopyRow: () => copyRowSelection().each((selection2) => setRows(selection2)),
      mceTablePasteColBefore: () => pasteOnSelection(actions2.pasteColsBefore, getColumns),
      mceTablePasteColAfter: () => pasteOnSelection(actions2.pasteColsAfter, getColumns),
      mceTablePasteRowBefore: () => pasteOnSelection(actions2.pasteRowsBefore, getRows),
      mceTablePasteRowAfter: () => pasteOnSelection(actions2.pasteRowsAfter, getRows),
      mceTableDelete: eraseTable,
      mceTableCellToggleClass: toggleTableCellClass,
      mceTableToggleClass: toggleTableClass,
      mceTableToggleCaption: toggleCaption,
      mceTableSizingMode: (_ui, sizing) => setSizingMode(sizing),
      mceTableCellType: actOnType((type2) => type2 === "th" ? actions2.makeCellsHeader : actions2.unmakeCellsHeader),
      mceTableColType: actOnType((type2) => type2 === "th" ? actions2.makeColumnsHeader : actions2.unmakeColumnsHeader),
      mceTableRowType: actOnType((type2) => {
        switch (type2) {
          case "header":
            return actions2.makeRowsHeader;
          case "footer":
            return actions2.makeRowsFooter;
          default:
            return actions2.makeRowsBody;
        }
      })
    }, (func, name3) => editor.addCommand(name3, func));
    editor.addCommand("mceInsertTable", (_ui, args) => {
      insertTable(editor, args.rows, args.columns, args.options);
    });
    editor.addCommand("mceTableApplyCellStyle", (_ui, args) => {
      const getFormatName = (style) => "tablecell" + style.toLowerCase().replace("-", "");
      if (!isObject2(args)) {
        return;
      }
      const cells2 = filter$2(getCellsFromSelection(editor), isInEditableContext$1);
      if (cells2.length === 0) {
        return;
      }
      const validArgs = filter$1(args, (value2, style) => editor.formatter.has(getFormatName(style)) && isString2(value2));
      if (isEmpty2(validArgs)) {
        return;
      }
      each$1(validArgs, (value2, style) => {
        const formatName = getFormatName(style);
        each$2(cells2, (cell2) => {
          if (value2 === "") {
            editor.formatter.remove(formatName, { value: null }, cell2.dom, true);
          } else {
            editor.formatter.apply(formatName, { value: value2 }, cell2.dom);
          }
        });
      });
      getTableFromCell(cells2[0]).each((table2) => fireTableModified(editor, table2.dom, styleModified));
    });
  };
  const registerQueryCommands = (editor, actions2) => {
    const isRoot = getIsRoot(editor);
    const lookupOnSelection = (action) => getSelectionCell(getSelectionStart(editor)).bind((cell2) => table(cell2, isRoot).map((table2) => {
      const targets = forMenu(getCellsFromSelection(editor), table2, cell2);
      return action(table2, targets);
    })).getOr("");
    each$1({
      mceTableRowType: () => lookupOnSelection(actions2.getTableRowType),
      mceTableCellType: () => lookupOnSelection(actions2.getTableCellType),
      mceTableColType: () => lookupOnSelection(actions2.getTableColType)
    }, (func, name3) => editor.addQueryValueHandler(name3, func));
  };
  const adt$4 = Adt.generate([
    { before: ["element"] },
    {
      on: [
        "element",
        "offset"
      ]
    },
    { after: ["element"] }
  ]);
  const cata$1 = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);
  const getStart$1 = (situ) => situ.fold(identity, identity, identity);
  const before$2 = adt$4.before;
  const on2 = adt$4.on;
  const after$3 = adt$4.after;
  const Situ = {
    before: before$2,
    on: on2,
    after: after$3,
    cata: cata$1,
    getStart: getStart$1
  };
  const create$42 = (selection2, kill) => ({
    selection: selection2,
    kill
  });
  const Response = { create: create$42 };
  const selectNode = (win, element) => {
    const rng = win.document.createRange();
    rng.selectNode(element.dom);
    return rng;
  };
  const selectNodeContents = (win, element) => {
    const rng = win.document.createRange();
    selectNodeContentsUsing(rng, element);
    return rng;
  };
  const selectNodeContentsUsing = (rng, element) => rng.selectNodeContents(element.dom);
  const setStart = (rng, situ) => {
    situ.fold((e) => {
      rng.setStartBefore(e.dom);
    }, (e, o) => {
      rng.setStart(e.dom, o);
    }, (e) => {
      rng.setStartAfter(e.dom);
    });
  };
  const setFinish = (rng, situ) => {
    situ.fold((e) => {
      rng.setEndBefore(e.dom);
    }, (e, o) => {
      rng.setEnd(e.dom, o);
    }, (e) => {
      rng.setEndAfter(e.dom);
    });
  };
  const relativeToNative = (win, startSitu, finishSitu) => {
    const range2 = win.document.createRange();
    setStart(range2, startSitu);
    setFinish(range2, finishSitu);
    return range2;
  };
  const exactToNative = (win, start2, soffset, finish, foffset) => {
    const rng = win.document.createRange();
    rng.setStart(start2.dom, soffset);
    rng.setEnd(finish.dom, foffset);
    return rng;
  };
  const toRect = (rect) => ({
    left: rect.left,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    width: rect.width,
    height: rect.height
  });
  const getFirstRect$1 = (rng) => {
    const rects = rng.getClientRects();
    const rect = rects.length > 0 ? rects[0] : rng.getBoundingClientRect();
    return rect.width > 0 || rect.height > 0 ? Optional.some(rect).map(toRect) : Optional.none();
  };
  const adt$3 = Adt.generate([
    {
      ltr: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    },
    {
      rtl: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]);
  const fromRange = (win, type2, range2) => type2(SugarElement.fromDom(range2.startContainer), range2.startOffset, SugarElement.fromDom(range2.endContainer), range2.endOffset);
  const getRanges = (win, selection2) => selection2.match({
    domRange: (rng) => {
      return {
        ltr: constant(rng),
        rtl: Optional.none
      };
    },
    relative: (startSitu, finishSitu) => {
      return {
        ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),
        rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))
      };
    },
    exact: (start2, soffset, finish, foffset) => {
      return {
        ltr: cached(() => exactToNative(win, start2, soffset, finish, foffset)),
        rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start2, soffset)))
      };
    }
  });
  const doDiagnose = (win, ranges) => {
    const rng = ranges.ltr();
    if (rng.collapsed) {
      const reversed = ranges.rtl().filter((rev) => rev.collapsed === false);
      return reversed.map((rev) => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));
    } else {
      return fromRange(win, adt$3.ltr, rng);
    }
  };
  const diagnose = (win, selection2) => {
    const ranges = getRanges(win, selection2);
    return doDiagnose(win, ranges);
  };
  const asLtrRange = (win, selection2) => {
    const diagnosis = diagnose(win, selection2);
    return diagnosis.match({
      ltr: (start2, soffset, finish, foffset) => {
        const rng = win.document.createRange();
        rng.setStart(start2.dom, soffset);
        rng.setEnd(finish.dom, foffset);
        return rng;
      },
      rtl: (start2, soffset, finish, foffset) => {
        const rng = win.document.createRange();
        rng.setStart(finish.dom, foffset);
        rng.setEnd(start2.dom, soffset);
        return rng;
      }
    });
  };
  adt$3.ltr;
  adt$3.rtl;
  const create$32 = (start2, soffset, finish, foffset) => ({
    start: start2,
    soffset,
    finish,
    foffset
  });
  const SimRange = { create: create$32 };
  const create$22 = (start2, soffset, finish, foffset) => {
    return {
      start: Situ.on(start2, soffset),
      finish: Situ.on(finish, foffset)
    };
  };
  const Situs = { create: create$22 };
  const convertToRange = (win, selection2) => {
    const rng = asLtrRange(win, selection2);
    return SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset);
  };
  const makeSitus = Situs.create;
  const sync = (container, isRoot, start2, soffset, finish, foffset, selectRange) => {
    if (!(eq$1(start2, finish) && soffset === foffset)) {
      return closest$1(start2, "td,th", isRoot).bind((s) => {
        return closest$1(finish, "td,th", isRoot).bind((f) => {
          return detect(container, isRoot, s, f, selectRange);
        });
      });
    } else {
      return Optional.none();
    }
  };
  const detect = (container, isRoot, start2, finish, selectRange) => {
    if (!eq$1(start2, finish)) {
      return identify(start2, finish, isRoot).bind((cellSel) => {
        const boxes = cellSel.boxes.getOr([]);
        if (boxes.length > 1) {
          selectRange(container, boxes, cellSel.start, cellSel.finish);
          return Optional.some(Response.create(Optional.some(makeSitus(start2, 0, start2, getEnd(start2))), true));
        } else {
          return Optional.none();
        }
      });
    } else {
      return Optional.none();
    }
  };
  const update = (rows2, columns2, container, selected, annotations) => {
    const updateSelection = (newSels) => {
      annotations.clearBeforeUpdate(container);
      annotations.selectRange(container, newSels.boxes, newSels.start, newSels.finish);
      return newSels.boxes;
    };
    return shiftSelection(selected, rows2, columns2, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map(updateSelection);
  };
  const traverse = (item2, mode) => ({
    item: item2,
    mode
  });
  const backtrack = (universe2, item2, _direction, transition = sidestep) => {
    return universe2.property().parent(item2).map((p) => {
      return traverse(p, transition);
    });
  };
  const sidestep = (universe2, item2, direction, transition = advance) => {
    return direction.sibling(universe2, item2).map((p) => {
      return traverse(p, transition);
    });
  };
  const advance = (universe2, item2, direction, transition = advance) => {
    const children2 = universe2.property().children(item2);
    const result = direction.first(children2);
    return result.map((r2) => {
      return traverse(r2, transition);
    });
  };
  const successors = [
    {
      current: backtrack,
      next: sidestep,
      fallback: Optional.none()
    },
    {
      current: sidestep,
      next: advance,
      fallback: Optional.some(backtrack)
    },
    {
      current: advance,
      next: advance,
      fallback: Optional.some(sidestep)
    }
  ];
  const go = (universe2, item2, mode, direction, rules = successors) => {
    const ruleOpt = find$1(rules, (succ) => {
      return succ.current === mode;
    });
    return ruleOpt.bind((rule) => {
      return rule.current(universe2, item2, direction, rule.next).orThunk(() => {
        return rule.fallback.bind((fb) => {
          return go(universe2, item2, fb, direction);
        });
      });
    });
  };
  const left$1 = () => {
    const sibling = (universe2, item2) => {
      return universe2.query().prevSibling(item2);
    };
    const first2 = (children2) => {
      return children2.length > 0 ? Optional.some(children2[children2.length - 1]) : Optional.none();
    };
    return {
      sibling,
      first: first2
    };
  };
  const right$1 = () => {
    const sibling = (universe2, item2) => {
      return universe2.query().nextSibling(item2);
    };
    const first2 = (children2) => {
      return children2.length > 0 ? Optional.some(children2[0]) : Optional.none();
    };
    return {
      sibling,
      first: first2
    };
  };
  const Walkers = {
    left: left$1,
    right: right$1
  };
  const hone = (universe2, item2, predicate, mode, direction, isRoot) => {
    const next = go(universe2, item2, mode, direction);
    return next.bind((n) => {
      if (isRoot(n.item)) {
        return Optional.none();
      } else {
        return predicate(n.item) ? Optional.some(n.item) : hone(universe2, n.item, predicate, n.mode, direction, isRoot);
      }
    });
  };
  const left2 = (universe2, item2, predicate, isRoot) => {
    return hone(universe2, item2, predicate, sidestep, Walkers.left(), isRoot);
  };
  const right2 = (universe2, item2, predicate, isRoot) => {
    return hone(universe2, item2, predicate, sidestep, Walkers.right(), isRoot);
  };
  const isLeaf = (universe2) => (element) => universe2.property().children(element).length === 0;
  const before$1 = (universe2, item2, isRoot) => {
    return seekLeft$1(universe2, item2, isLeaf(universe2), isRoot);
  };
  const after$2 = (universe2, item2, isRoot) => {
    return seekRight$1(universe2, item2, isLeaf(universe2), isRoot);
  };
  const seekLeft$1 = left2;
  const seekRight$1 = right2;
  const universe = DomUniverse();
  const before = (element, isRoot) => {
    return before$1(universe, element, isRoot);
  };
  const after$1 = (element, isRoot) => {
    return after$2(universe, element, isRoot);
  };
  const seekLeft = (element, predicate, isRoot) => {
    return seekLeft$1(universe, element, predicate, isRoot);
  };
  const seekRight = (element, predicate, isRoot) => {
    return seekRight$1(universe, element, predicate, isRoot);
  };
  const ancestor = (scope, predicate, isRoot) => ancestor$2(scope, predicate, isRoot).isSome();
  const adt$2 = Adt.generate([
    { none: ["message"] },
    { success: [] },
    { failedUp: ["cell"] },
    { failedDown: ["cell"] }
  ]);
  const isOverlapping = (bridge, before2, after2) => {
    const beforeBounds = bridge.getRect(before2);
    const afterBounds = bridge.getRect(after2);
    return afterBounds.right > beforeBounds.left && afterBounds.left < beforeBounds.right;
  };
  const isRow = (elem) => {
    return closest$1(elem, "tr");
  };
  const verify = (bridge, before2, beforeOffset, after2, afterOffset, failure, isRoot) => {
    return closest$1(after2, "td,th", isRoot).bind((afterCell) => {
      return closest$1(before2, "td,th", isRoot).map((beforeCell) => {
        if (!eq$1(afterCell, beforeCell)) {
          return sharedOne(isRow, [
            afterCell,
            beforeCell
          ]).fold(() => {
            return isOverlapping(bridge, beforeCell, afterCell) ? adt$2.success() : failure(beforeCell);
          }, (_sharedRow) => {
            return failure(beforeCell);
          });
        } else {
          return eq$1(after2, afterCell) && getEnd(afterCell) === afterOffset ? failure(beforeCell) : adt$2.none("in same cell");
        }
      });
    }).getOr(adt$2.none("default"));
  };
  const cata = (subject, onNone, onSuccess, onFailedUp, onFailedDown) => {
    return subject.fold(onNone, onSuccess, onFailedUp, onFailedDown);
  };
  const BeforeAfter = {
    ...adt$2,
    verify,
    cata
  };
  const inParent = (parent2, children2, element, index) => ({
    parent: parent2,
    children: children2,
    element,
    index
  });
  const indexInParent = (element) => parent(element).bind((parent2) => {
    const children2 = children$2(parent2);
    return indexOf(children2, element).map((index) => inParent(parent2, children2, element, index));
  });
  const indexOf = (elements, element) => findIndex(elements, curry(eq$1, element));
  const isBr = isTag("br");
  const gatherer = (cand, gather, isRoot) => {
    return gather(cand, isRoot).bind((target) => {
      return isText(target) && get$6(target).trim().length === 0 ? gatherer(target, gather, isRoot) : Optional.some(target);
    });
  };
  const handleBr = (isRoot, element, direction) => {
    return direction.traverse(element).orThunk(() => {
      return gatherer(element, direction.gather, isRoot);
    }).map(direction.relative);
  };
  const findBr = (element, offset2) => {
    return child$2(element, offset2).filter(isBr).orThunk(() => {
      return child$2(element, offset2 - 1).filter(isBr);
    });
  };
  const handleParent = (isRoot, element, offset2, direction) => {
    return findBr(element, offset2).bind((br) => {
      return direction.traverse(br).fold(() => {
        return gatherer(br, direction.gather, isRoot).map(direction.relative);
      }, (adjacent) => {
        return indexInParent(adjacent).map((info) => {
          return Situ.on(info.parent, info.index);
        });
      });
    });
  };
  const tryBr = (isRoot, element, offset2, direction) => {
    const target = isBr(element) ? handleBr(isRoot, element, direction) : handleParent(isRoot, element, offset2, direction);
    return target.map((tgt) => {
      return {
        start: tgt,
        finish: tgt
      };
    });
  };
  const process = (analysis) => {
    return BeforeAfter.cata(analysis, (_message) => {
      return Optional.none();
    }, () => {
      return Optional.none();
    }, (cell2) => {
      return Optional.some(point(cell2, 0));
    }, (cell2) => {
      return Optional.some(point(cell2, getEnd(cell2)));
    });
  };
  const moveDown = (caret, amount) => {
    return {
      left: caret.left,
      top: caret.top + amount,
      right: caret.right,
      bottom: caret.bottom + amount
    };
  };
  const moveUp = (caret, amount) => {
    return {
      left: caret.left,
      top: caret.top - amount,
      right: caret.right,
      bottom: caret.bottom - amount
    };
  };
  const translate = (caret, xDelta, yDelta) => {
    return {
      left: caret.left + xDelta,
      top: caret.top + yDelta,
      right: caret.right + xDelta,
      bottom: caret.bottom + yDelta
    };
  };
  const getTop = (caret) => {
    return caret.top;
  };
  const getBottom = (caret) => {
    return caret.bottom;
  };
  const getPartialBox = (bridge, element, offset2) => {
    if (offset2 >= 0 && offset2 < getEnd(element)) {
      return bridge.getRangedRect(element, offset2, element, offset2 + 1);
    } else if (offset2 > 0) {
      return bridge.getRangedRect(element, offset2 - 1, element, offset2);
    }
    return Optional.none();
  };
  const toCaret = (rect) => ({
    left: rect.left,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom
  });
  const getElemBox = (bridge, element) => {
    return Optional.some(bridge.getRect(element));
  };
  const getBoxAt = (bridge, element, offset2) => {
    if (isElement2(element)) {
      return getElemBox(bridge, element).map(toCaret);
    } else if (isText(element)) {
      return getPartialBox(bridge, element, offset2).map(toCaret);
    } else {
      return Optional.none();
    }
  };
  const getEntireBox = (bridge, element) => {
    if (isElement2(element)) {
      return getElemBox(bridge, element).map(toCaret);
    } else if (isText(element)) {
      return bridge.getRangedRect(element, 0, element, getEnd(element)).map(toCaret);
    } else {
      return Optional.none();
    }
  };
  const JUMP_SIZE = 5;
  const NUM_RETRIES = 100;
  const adt$1 = Adt.generate([
    { none: [] },
    { retry: ["caret"] }
  ]);
  const isOutside = (caret, box) => {
    return caret.left < box.left || Math.abs(box.right - caret.left) < 1 || caret.left > box.right;
  };
  const inOutsideBlock = (bridge, element, caret) => {
    return closest$2(element, isBlock).fold(never, (cell2) => {
      return getEntireBox(bridge, cell2).exists((box) => {
        return isOutside(caret, box);
      });
    });
  };
  const adjustDown = (bridge, element, guessBox, original, caret) => {
    const lowerCaret = moveDown(caret, JUMP_SIZE);
    if (Math.abs(guessBox.bottom - original.bottom) < 1) {
      return adt$1.retry(lowerCaret);
    } else if (guessBox.top > caret.bottom) {
      return adt$1.retry(lowerCaret);
    } else if (guessBox.top === caret.bottom) {
      return adt$1.retry(moveDown(caret, 1));
    } else {
      return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(lowerCaret, JUMP_SIZE, 0)) : adt$1.none();
    }
  };
  const adjustUp = (bridge, element, guessBox, original, caret) => {
    const higherCaret = moveUp(caret, JUMP_SIZE);
    if (Math.abs(guessBox.top - original.top) < 1) {
      return adt$1.retry(higherCaret);
    } else if (guessBox.bottom < caret.top) {
      return adt$1.retry(higherCaret);
    } else if (guessBox.bottom === caret.top) {
      return adt$1.retry(moveUp(caret, 1));
    } else {
      return inOutsideBlock(bridge, element, caret) ? adt$1.retry(translate(higherCaret, JUMP_SIZE, 0)) : adt$1.none();
    }
  };
  const upMovement = {
    point: getTop,
    adjuster: adjustUp,
    move: moveUp,
    gather: before
  };
  const downMovement = {
    point: getBottom,
    adjuster: adjustDown,
    move: moveDown,
    gather: after$1
  };
  const isAtTable = (bridge, x, y) => {
    return bridge.elementFromPoint(x, y).filter((elm) => {
      return name2(elm) === "table";
    }).isSome();
  };
  const adjustForTable = (bridge, movement, original, caret, numRetries) => {
    return adjustTil(bridge, movement, original, movement.move(caret, JUMP_SIZE), numRetries);
  };
  const adjustTil = (bridge, movement, original, caret, numRetries) => {
    if (numRetries === 0) {
      return Optional.some(caret);
    }
    if (isAtTable(bridge, caret.left, movement.point(caret))) {
      return adjustForTable(bridge, movement, original, caret, numRetries - 1);
    }
    return bridge.situsFromPoint(caret.left, movement.point(caret)).bind((guess) => {
      return guess.start.fold(Optional.none, (element) => {
        return getEntireBox(bridge, element).bind((guessBox) => {
          return movement.adjuster(bridge, element, guessBox, original, caret).fold(Optional.none, (newCaret) => {
            return adjustTil(bridge, movement, original, newCaret, numRetries - 1);
          });
        }).orThunk(() => {
          return Optional.some(caret);
        });
      }, Optional.none);
    });
  };
  const checkScroll = (movement, adjusted, bridge) => {
    if (movement.point(adjusted) > bridge.getInnerHeight()) {
      return Optional.some(movement.point(adjusted) - bridge.getInnerHeight());
    } else if (movement.point(adjusted) < 0) {
      return Optional.some(-movement.point(adjusted));
    } else {
      return Optional.none();
    }
  };
  const retry = (movement, bridge, caret) => {
    const moved = movement.move(caret, JUMP_SIZE);
    const adjusted = adjustTil(bridge, movement, caret, moved, NUM_RETRIES).getOr(moved);
    return checkScroll(movement, adjusted, bridge).fold(() => {
      return bridge.situsFromPoint(adjusted.left, movement.point(adjusted));
    }, (delta) => {
      bridge.scrollBy(0, delta);
      return bridge.situsFromPoint(adjusted.left, movement.point(adjusted) - delta);
    });
  };
  const Retries = {
    tryUp: curry(retry, upMovement),
    tryDown: curry(retry, downMovement),
    getJumpSize: constant(JUMP_SIZE)
  };
  const MAX_RETRIES = 20;
  const findSpot = (bridge, isRoot, direction) => {
    return bridge.getSelection().bind((sel) => {
      return tryBr(isRoot, sel.finish, sel.foffset, direction).fold(() => {
        return Optional.some(point(sel.finish, sel.foffset));
      }, (brNeighbour) => {
        const range2 = bridge.fromSitus(brNeighbour);
        const analysis = BeforeAfter.verify(bridge, sel.finish, sel.foffset, range2.finish, range2.foffset, direction.failure, isRoot);
        return process(analysis);
      });
    });
  };
  const scan = (bridge, isRoot, element, offset2, direction, numRetries) => {
    if (numRetries === 0) {
      return Optional.none();
    }
    return tryCursor(bridge, isRoot, element, offset2, direction).bind((situs) => {
      const range2 = bridge.fromSitus(situs);
      const analysis = BeforeAfter.verify(bridge, element, offset2, range2.finish, range2.foffset, direction.failure, isRoot);
      return BeforeAfter.cata(analysis, () => {
        return Optional.none();
      }, () => {
        return Optional.some(situs);
      }, (cell2) => {
        if (eq$1(element, cell2) && offset2 === 0) {
          return tryAgain(bridge, element, offset2, moveUp, direction);
        } else {
          return scan(bridge, isRoot, cell2, 0, direction, numRetries - 1);
        }
      }, (cell2) => {
        if (eq$1(element, cell2) && offset2 === getEnd(cell2)) {
          return tryAgain(bridge, element, offset2, moveDown, direction);
        } else {
          return scan(bridge, isRoot, cell2, getEnd(cell2), direction, numRetries - 1);
        }
      });
    });
  };
  const tryAgain = (bridge, element, offset2, move, direction) => {
    return getBoxAt(bridge, element, offset2).bind((box) => {
      return tryAt(bridge, direction, move(box, Retries.getJumpSize()));
    });
  };
  const tryAt = (bridge, direction, box) => {
    const browser2 = detect$2().browser;
    if (browser2.isChromium() || browser2.isSafari() || browser2.isFirefox()) {
      return direction.retry(bridge, box);
    } else {
      return Optional.none();
    }
  };
  const tryCursor = (bridge, isRoot, element, offset2, direction) => {
    return getBoxAt(bridge, element, offset2).bind((box) => {
      return tryAt(bridge, direction, box);
    });
  };
  const handle$1 = (bridge, isRoot, direction) => {
    return findSpot(bridge, isRoot, direction).bind((spot) => {
      return scan(bridge, isRoot, spot.element, spot.offset, direction, MAX_RETRIES).map(bridge.fromSitus);
    });
  };
  const inSameTable = (elem, table2) => {
    return ancestor(elem, (e) => {
      return parent(e).exists((p) => {
        return eq$1(p, table2);
      });
    });
  };
  const simulate = (bridge, isRoot, direction, initial, anchor) => {
    return closest$1(initial, "td,th", isRoot).bind((start2) => {
      return closest$1(start2, "table", isRoot).bind((table2) => {
        if (!inSameTable(anchor, table2)) {
          return Optional.none();
        }
        return handle$1(bridge, isRoot, direction).bind((range2) => {
          return closest$1(range2.finish, "td,th", isRoot).map((finish) => {
            return {
              start: start2,
              finish,
              range: range2
            };
          });
        });
      });
    });
  };
  const navigate = (bridge, isRoot, direction, initial, anchor, precheck) => {
    return precheck(initial, isRoot).orThunk(() => {
      return simulate(bridge, isRoot, direction, initial, anchor).map((info) => {
        const range2 = info.range;
        return Response.create(Optional.some(makeSitus(range2.start, range2.soffset, range2.finish, range2.foffset)), true);
      });
    });
  };
  const firstUpCheck = (initial, isRoot) => {
    return closest$1(initial, "tr", isRoot).bind((startRow) => {
      return closest$1(startRow, "table", isRoot).bind((table2) => {
        const rows2 = descendants(table2, "tr");
        if (eq$1(startRow, rows2[0])) {
          return seekLeft(table2, (element) => {
            return last$1(element).isSome();
          }, isRoot).map((last2) => {
            const lastOffset = getEnd(last2);
            return Response.create(Optional.some(makeSitus(last2, lastOffset, last2, lastOffset)), true);
          });
        } else {
          return Optional.none();
        }
      });
    });
  };
  const lastDownCheck = (initial, isRoot) => {
    return closest$1(initial, "tr", isRoot).bind((startRow) => {
      return closest$1(startRow, "table", isRoot).bind((table2) => {
        const rows2 = descendants(table2, "tr");
        if (eq$1(startRow, rows2[rows2.length - 1])) {
          return seekRight(table2, (element) => {
            return first(element).isSome();
          }, isRoot).map((first2) => {
            return Response.create(Optional.some(makeSitus(first2, 0, first2, 0)), true);
          });
        } else {
          return Optional.none();
        }
      });
    });
  };
  const select = (bridge, container, isRoot, direction, initial, anchor, selectRange) => {
    return simulate(bridge, isRoot, direction, initial, anchor).bind((info) => {
      return detect(container, isRoot, info.start, info.finish, selectRange);
    });
  };
  const Cell = (initial) => {
    let value2 = initial;
    const get2 = () => {
      return value2;
    };
    const set2 = (v) => {
      value2 = v;
    };
    return {
      get: get2,
      set: set2
    };
  };
  const singleton = (doRevoke) => {
    const subject = Cell(Optional.none());
    const revoke = () => subject.get().each(doRevoke);
    const clear3 = () => {
      revoke();
      subject.set(Optional.none());
    };
    const isSet = () => subject.get().isSome();
    const get2 = () => subject.get();
    const set2 = (s) => {
      revoke();
      subject.set(Optional.some(s));
    };
    return {
      clear: clear3,
      isSet,
      get: get2,
      set: set2
    };
  };
  const value = () => {
    const subject = singleton(noop2);
    const on3 = (f) => subject.get().each(f);
    return {
      ...subject,
      on: on3
    };
  };
  const findCell = (target, isRoot) => closest$1(target, "td,th", isRoot);
  const isInEditableContext = (cell2) => parentElement(cell2).exists(isEditable$1);
  const MouseSelection = (bridge, container, isRoot, annotations) => {
    const cursor = value();
    const clearstate = cursor.clear;
    const applySelection = (event) => {
      cursor.on((start2) => {
        annotations.clearBeforeUpdate(container);
        findCell(event.target, isRoot).each((finish) => {
          identify(start2, finish, isRoot).each((cellSel) => {
            const boxes = cellSel.boxes.getOr([]);
            if (boxes.length === 1) {
              const singleCell = boxes[0];
              const isNonEditableCell = getRaw(singleCell) === "false";
              const isCellClosestContentEditable = is(closest(event.target), singleCell, eq$1);
              if (isNonEditableCell && isCellClosestContentEditable) {
                annotations.selectRange(container, boxes, singleCell, singleCell);
                bridge.selectContents(singleCell);
              }
            } else if (boxes.length > 1) {
              annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
              bridge.selectContents(finish);
            }
          });
        });
      });
    };
    const mousedown = (event) => {
      annotations.clear(container);
      findCell(event.target, isRoot).filter(isInEditableContext).each(cursor.set);
    };
    const mouseover = (event) => {
      applySelection(event);
    };
    const mouseup = (event) => {
      applySelection(event);
      clearstate();
    };
    return {
      clearstate,
      mousedown,
      mouseover,
      mouseup
    };
  };
  const down = {
    traverse: nextSibling,
    gather: after$1,
    relative: Situ.before,
    retry: Retries.tryDown,
    failure: BeforeAfter.failedDown
  };
  const up = {
    traverse: prevSibling,
    gather: before,
    relative: Situ.before,
    retry: Retries.tryUp,
    failure: BeforeAfter.failedUp
  };
  const isKey = (key2) => {
    return (keycode) => {
      return keycode === key2;
    };
  };
  const isUp = isKey(38);
  const isDown = isKey(40);
  const isNavigation = (keycode) => {
    return keycode >= 37 && keycode <= 40;
  };
  const ltr = {
    isBackward: isKey(37),
    isForward: isKey(39)
  };
  const rtl = {
    isBackward: isKey(39),
    isForward: isKey(37)
  };
  const get$3 = (_DOC) => {
    const doc = _DOC !== void 0 ? _DOC.dom : document;
    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;
    const y = doc.body.scrollTop || doc.documentElement.scrollTop;
    return SugarPosition(x, y);
  };
  const by = (x, y, _DOC) => {
    const doc = _DOC !== void 0 ? _DOC.dom : document;
    const win = doc.defaultView;
    if (win) {
      win.scrollBy(x, y);
    }
  };
  const adt = Adt.generate([
    { domRange: ["rng"] },
    {
      relative: [
        "startSitu",
        "finishSitu"
      ]
    },
    {
      exact: [
        "start",
        "soffset",
        "finish",
        "foffset"
      ]
    }
  ]);
  const exactFromRange = (simRange) => adt.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);
  const getStart = (selection2) => selection2.match({
    domRange: (rng) => SugarElement.fromDom(rng.startContainer),
    relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),
    exact: (start2, _soffset, _finish, _foffset) => start2
  });
  const domRange = adt.domRange;
  const relative = adt.relative;
  const exact = adt.exact;
  const getWin = (selection2) => {
    const start2 = getStart(selection2);
    return defaultView(start2);
  };
  const range = SimRange.create;
  const SimSelection = {
    domRange,
    relative,
    exact,
    exactFromRange,
    getWin,
    range
  };
  const caretPositionFromPoint = (doc, x, y) => {
    var _a, _b;
    return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind((pos) => {
      if (pos.offsetNode === null) {
        return Optional.none();
      }
      const r2 = doc.dom.createRange();
      r2.setStart(pos.offsetNode, pos.offset);
      r2.collapse();
      return Optional.some(r2);
    });
  };
  const caretRangeFromPoint = (doc, x, y) => {
    var _a, _b;
    return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));
  };
  const availableSearch = (() => {
    if (document.caretPositionFromPoint) {
      return caretPositionFromPoint;
    } else if (document.caretRangeFromPoint) {
      return caretRangeFromPoint;
    } else {
      return Optional.none;
    }
  })();
  const fromPoint = (win, x, y) => {
    const doc = SugarElement.fromDom(win.document);
    return availableSearch(doc, x, y).map((rng) => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));
  };
  const beforeSpecial = (element, offset2) => {
    const name$1 = name2(element);
    if ("input" === name$1) {
      return Situ.after(element);
    } else if (!contains$2([
      "br",
      "img"
    ], name$1)) {
      return Situ.on(element, offset2);
    } else {
      return offset2 === 0 ? Situ.before(element) : Situ.after(element);
    }
  };
  const preprocessRelative = (startSitu, finishSitu) => {
    const start2 = startSitu.fold(Situ.before, beforeSpecial, Situ.after);
    const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);
    return SimSelection.relative(start2, finish);
  };
  const preprocessExact = (start2, soffset, finish, foffset) => {
    const startSitu = beforeSpecial(start2, soffset);
    const finishSitu = beforeSpecial(finish, foffset);
    return SimSelection.relative(startSitu, finishSitu);
  };
  const makeRange = (start2, soffset, finish, foffset) => {
    const doc = owner(start2);
    const rng = doc.dom.createRange();
    rng.setStart(start2.dom, soffset);
    rng.setEnd(finish.dom, foffset);
    return rng;
  };
  const after = (start2, soffset, finish, foffset) => {
    const r2 = makeRange(start2, soffset, finish, foffset);
    const same = eq$1(start2, finish) && soffset === foffset;
    return r2.collapsed && !same;
  };
  const getNativeSelection = (win) => Optional.from(win.getSelection());
  const doSetNativeRange = (win, rng) => {
    getNativeSelection(win).each((selection2) => {
      selection2.removeAllRanges();
      selection2.addRange(rng);
    });
  };
  const doSetRange = (win, start2, soffset, finish, foffset) => {
    const rng = exactToNative(win, start2, soffset, finish, foffset);
    doSetNativeRange(win, rng);
  };
  const setLegacyRtlRange = (win, selection2, start2, soffset, finish, foffset) => {
    selection2.collapse(start2.dom, soffset);
    selection2.extend(finish.dom, foffset);
  };
  const setRangeFromRelative = (win, relative2) => diagnose(win, relative2).match({
    ltr: (start2, soffset, finish, foffset) => {
      doSetRange(win, start2, soffset, finish, foffset);
    },
    rtl: (start2, soffset, finish, foffset) => {
      getNativeSelection(win).each((selection2) => {
        if (selection2.setBaseAndExtent) {
          selection2.setBaseAndExtent(start2.dom, soffset, finish.dom, foffset);
        } else if (selection2.extend) {
          try {
            setLegacyRtlRange(win, selection2, start2, soffset, finish, foffset);
          } catch (e) {
            doSetRange(win, finish, foffset, start2, soffset);
          }
        } else {
          doSetRange(win, finish, foffset, start2, soffset);
        }
      });
    }
  });
  const setExact = (win, start2, soffset, finish, foffset) => {
    const relative2 = preprocessExact(start2, soffset, finish, foffset);
    setRangeFromRelative(win, relative2);
  };
  const setRelative = (win, startSitu, finishSitu) => {
    const relative2 = preprocessRelative(startSitu, finishSitu);
    setRangeFromRelative(win, relative2);
  };
  const readRange = (selection2) => {
    if (selection2.rangeCount > 0) {
      const firstRng = selection2.getRangeAt(0);
      const lastRng = selection2.getRangeAt(selection2.rangeCount - 1);
      return Optional.some(SimRange.create(SugarElement.fromDom(firstRng.startContainer), firstRng.startOffset, SugarElement.fromDom(lastRng.endContainer), lastRng.endOffset));
    } else {
      return Optional.none();
    }
  };
  const doGetExact = (selection2) => {
    if (selection2.anchorNode === null || selection2.focusNode === null) {
      return readRange(selection2);
    } else {
      const anchor = SugarElement.fromDom(selection2.anchorNode);
      const focus = SugarElement.fromDom(selection2.focusNode);
      return after(anchor, selection2.anchorOffset, focus, selection2.focusOffset) ? Optional.some(SimRange.create(anchor, selection2.anchorOffset, focus, selection2.focusOffset)) : readRange(selection2);
    }
  };
  const setToElement = (win, element, selectNodeContents$1 = true) => {
    const rngGetter = selectNodeContents$1 ? selectNodeContents : selectNode;
    const rng = rngGetter(win, element);
    doSetNativeRange(win, rng);
  };
  const getExact = (win) => getNativeSelection(win).filter((sel) => sel.rangeCount > 0).bind(doGetExact);
  const get$2 = (win) => getExact(win).map((range2) => SimSelection.exact(range2.start, range2.soffset, range2.finish, range2.foffset));
  const getFirstRect = (win, selection2) => {
    const rng = asLtrRange(win, selection2);
    return getFirstRect$1(rng);
  };
  const getAtPoint = (win, x, y) => fromPoint(win, x, y);
  const clear2 = (win) => {
    getNativeSelection(win).each((selection2) => selection2.removeAllRanges());
  };
  const WindowBridge = (win) => {
    const elementFromPoint2 = (x, y) => {
      return SugarElement.fromPoint(SugarElement.fromDom(win.document), x, y);
    };
    const getRect = (element) => {
      return element.dom.getBoundingClientRect();
    };
    const getRangedRect = (start2, soffset, finish, foffset) => {
      const sel = SimSelection.exact(start2, soffset, finish, foffset);
      return getFirstRect(win, sel);
    };
    const getSelection = () => {
      return get$2(win).map((exactAdt) => {
        return convertToRange(win, exactAdt);
      });
    };
    const fromSitus = (situs) => {
      const relative2 = SimSelection.relative(situs.start, situs.finish);
      return convertToRange(win, relative2);
    };
    const situsFromPoint = (x, y) => {
      return getAtPoint(win, x, y).map((exact2) => {
        return Situs.create(exact2.start, exact2.soffset, exact2.finish, exact2.foffset);
      });
    };
    const clearSelection = () => {
      clear2(win);
    };
    const collapseSelection = (toStart = false) => {
      get$2(win).each((sel) => sel.fold((rng) => rng.collapse(toStart), (startSitu, finishSitu) => {
        const situ = toStart ? startSitu : finishSitu;
        setRelative(win, situ, situ);
      }, (start2, soffset, finish, foffset) => {
        const node = toStart ? start2 : finish;
        const offset2 = toStart ? soffset : foffset;
        setExact(win, node, offset2, node, offset2);
      }));
    };
    const selectNode2 = (element) => {
      setToElement(win, element, false);
    };
    const selectContents = (element) => {
      setToElement(win, element);
    };
    const setSelection = (sel) => {
      setExact(win, sel.start, sel.soffset, sel.finish, sel.foffset);
    };
    const setRelativeSelection = (start2, finish) => {
      setRelative(win, start2, finish);
    };
    const getInnerHeight = () => {
      return win.innerHeight;
    };
    const getScrollY = () => {
      const pos = get$3(SugarElement.fromDom(win.document));
      return pos.top;
    };
    const scrollBy = (x, y) => {
      by(x, y, SugarElement.fromDom(win.document));
    };
    return {
      elementFromPoint: elementFromPoint2,
      getRect,
      getRangedRect,
      getSelection,
      fromSitus,
      situsFromPoint,
      clearSelection,
      collapseSelection,
      setSelection,
      setRelativeSelection,
      selectNode: selectNode2,
      selectContents,
      getInnerHeight,
      getScrollY,
      scrollBy
    };
  };
  const rc = (rows2, cols) => ({
    rows: rows2,
    cols
  });
  const mouse = (win, container, isRoot, annotations) => {
    const bridge = WindowBridge(win);
    const handlers = MouseSelection(bridge, container, isRoot, annotations);
    return {
      clearstate: handlers.clearstate,
      mousedown: handlers.mousedown,
      mouseover: handlers.mouseover,
      mouseup: handlers.mouseup
    };
  };
  const isEditableNode = (node) => closest$2(node, isHTMLElement2).exists(isEditable$1);
  const isEditableSelection = (start2, finish) => isEditableNode(start2) || isEditableNode(finish);
  const keyboard = (win, container, isRoot, annotations) => {
    const bridge = WindowBridge(win);
    const clearToNavigate = () => {
      annotations.clear(container);
      return Optional.none();
    };
    const keydown = (event, start2, soffset, finish, foffset, direction) => {
      const realEvent = event.raw;
      const keycode = realEvent.which;
      const shiftKey = realEvent.shiftKey === true;
      const handler = retrieve$1(container, annotations.selectedSelector).fold(() => {
        if (isNavigation(keycode) && !shiftKey) {
          annotations.clearBeforeUpdate(container);
        }
        if (isNavigation(keycode) && shiftKey && !isEditableSelection(start2, finish)) {
          return Optional.none;
        } else if (isDown(keycode) && shiftKey) {
          return curry(select, bridge, container, isRoot, down, finish, start2, annotations.selectRange);
        } else if (isUp(keycode) && shiftKey) {
          return curry(select, bridge, container, isRoot, up, finish, start2, annotations.selectRange);
        } else if (isDown(keycode)) {
          return curry(navigate, bridge, isRoot, down, finish, start2, lastDownCheck);
        } else if (isUp(keycode)) {
          return curry(navigate, bridge, isRoot, up, finish, start2, firstUpCheck);
        } else {
          return Optional.none;
        }
      }, (selected) => {
        const update$1 = (attempts) => {
          return () => {
            const navigation = findMap(attempts, (delta) => {
              return update(delta.rows, delta.cols, container, selected, annotations);
            });
            return navigation.fold(() => {
              return getEdges(container, annotations.firstSelectedSelector, annotations.lastSelectedSelector).map((edges) => {
                const relative2 = isDown(keycode) || direction.isForward(keycode) ? Situ.after : Situ.before;
                bridge.setRelativeSelection(Situ.on(edges.first, 0), relative2(edges.table));
                annotations.clear(container);
                return Response.create(Optional.none(), true);
              });
            }, (_2) => {
              return Optional.some(Response.create(Optional.none(), true));
            });
          };
        };
        if (isNavigation(keycode) && shiftKey && !isEditableSelection(start2, finish)) {
          return Optional.none;
        } else if (isDown(keycode) && shiftKey) {
          return update$1([rc(1, 0)]);
        } else if (isUp(keycode) && shiftKey) {
          return update$1([rc(-1, 0)]);
        } else if (direction.isBackward(keycode) && shiftKey) {
          return update$1([
            rc(0, -1),
            rc(-1, 0)
          ]);
        } else if (direction.isForward(keycode) && shiftKey) {
          return update$1([
            rc(0, 1),
            rc(1, 0)
          ]);
        } else if (isNavigation(keycode) && !shiftKey) {
          return clearToNavigate;
        } else {
          return Optional.none;
        }
      });
      return handler();
    };
    const keyup = (event, start2, soffset, finish, foffset) => {
      return retrieve$1(container, annotations.selectedSelector).fold(() => {
        const realEvent = event.raw;
        const keycode = realEvent.which;
        const shiftKey = realEvent.shiftKey === true;
        if (!shiftKey) {
          return Optional.none();
        }
        if (isNavigation(keycode) && isEditableSelection(start2, finish)) {
          return sync(container, isRoot, start2, soffset, finish, foffset, annotations.selectRange);
        } else {
          return Optional.none();
        }
      }, Optional.none);
    };
    return {
      keydown,
      keyup
    };
  };
  const external = (win, container, isRoot, annotations) => {
    const bridge = WindowBridge(win);
    return (start2, finish) => {
      annotations.clearBeforeUpdate(container);
      identify(start2, finish, isRoot).each((cellSel) => {
        const boxes = cellSel.boxes.getOr([]);
        annotations.selectRange(container, boxes, cellSel.start, cellSel.finish);
        bridge.selectContents(finish);
        bridge.collapseSelection();
      });
    };
  };
  const read2 = (element, attr2) => {
    const value2 = get$b(element, attr2);
    return value2 === void 0 || value2 === "" ? [] : value2.split(" ");
  };
  const add$2 = (element, attr2, id) => {
    const old = read2(element, attr2);
    const nu2 = old.concat([id]);
    set$2(element, attr2, nu2.join(" "));
    return true;
  };
  const remove$4 = (element, attr2, id) => {
    const nu2 = filter$2(read2(element, attr2), (v) => v !== id);
    if (nu2.length > 0) {
      set$2(element, attr2, nu2.join(" "));
    } else {
      remove$7(element, attr2);
    }
    return false;
  };
  const supports = (element) => element.dom.classList !== void 0;
  const get$1 = (element) => read2(element, "class");
  const add$1 = (element, clazz) => add$2(element, "class", clazz);
  const remove$3 = (element, clazz) => remove$4(element, "class", clazz);
  const add = (element, clazz) => {
    if (supports(element)) {
      element.dom.classList.add(clazz);
    } else {
      add$1(element, clazz);
    }
  };
  const cleanClass = (element) => {
    const classList = supports(element) ? element.dom.classList : get$1(element);
    if (classList.length === 0) {
      remove$7(element, "class");
    }
  };
  const remove$2 = (element, clazz) => {
    if (supports(element)) {
      const classList = element.dom.classList;
      classList.remove(clazz);
    } else {
      remove$3(element, clazz);
    }
    cleanClass(element);
  };
  const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);
  const remove$1 = (element, classes) => {
    each$2(classes, (x) => {
      remove$2(element, x);
    });
  };
  const addClass = (clazz) => (element) => {
    add(element, clazz);
  };
  const removeClasses = (classes) => (element) => {
    remove$1(element, classes);
  };
  const byClass = (ephemera2) => {
    const addSelectionClass = addClass(ephemera2.selected);
    const removeSelectionClasses = removeClasses([
      ephemera2.selected,
      ephemera2.lastSelected,
      ephemera2.firstSelected
    ]);
    const clear3 = (container) => {
      const sels = descendants(container, ephemera2.selectedSelector);
      each$2(sels, removeSelectionClasses);
    };
    const selectRange = (container, cells2, start2, finish) => {
      clear3(container);
      each$2(cells2, addSelectionClass);
      add(start2, ephemera2.firstSelected);
      add(finish, ephemera2.lastSelected);
    };
    return {
      clearBeforeUpdate: clear3,
      clear: clear3,
      selectRange,
      selectedSelector: ephemera2.selectedSelector,
      firstSelectedSelector: ephemera2.firstSelectedSelector,
      lastSelectedSelector: ephemera2.lastSelectedSelector
    };
  };
  const byAttr = (ephemera2, onSelection, onClear) => {
    const removeSelectionAttributes = (element) => {
      remove$7(element, ephemera2.selected);
      remove$7(element, ephemera2.firstSelected);
      remove$7(element, ephemera2.lastSelected);
    };
    const addSelectionAttribute = (element) => {
      set$2(element, ephemera2.selected, "1");
    };
    const clear3 = (container) => {
      clearBeforeUpdate(container);
      onClear();
    };
    const clearBeforeUpdate = (container) => {
      const sels = descendants(container, `${ephemera2.selectedSelector},${ephemera2.firstSelectedSelector},${ephemera2.lastSelectedSelector}`);
      each$2(sels, removeSelectionAttributes);
    };
    const selectRange = (container, cells2, start2, finish) => {
      clear3(container);
      each$2(cells2, addSelectionAttribute);
      set$2(start2, ephemera2.firstSelected, "1");
      set$2(finish, ephemera2.lastSelected, "1");
      onSelection(cells2, start2, finish);
    };
    return {
      clearBeforeUpdate,
      clear: clear3,
      selectRange,
      selectedSelector: ephemera2.selectedSelector,
      firstSelectedSelector: ephemera2.firstSelectedSelector,
      lastSelectedSelector: ephemera2.lastSelectedSelector
    };
  };
  const SelectionAnnotation = {
    byClass,
    byAttr
  };
  const fold = (subject, onNone, onMultiple, onSingle) => {
    switch (subject.tag) {
      case "none":
        return onNone();
      case "single":
        return onSingle(subject.element);
      case "multiple":
        return onMultiple(subject.elements);
    }
  };
  const none = () => ({ tag: "none" });
  const multiple = (elements) => ({
    tag: "multiple",
    elements
  });
  const single = (element) => ({
    tag: "single",
    element
  });
  const Selections = (lazyRoot, getStart2, selectedSelector) => {
    const get2 = () => retrieve(lazyRoot(), selectedSelector).fold(() => getStart2().fold(none, single), multiple);
    return { get: get2 };
  };
  const getUpOrLeftCells = (grid2, selectedCells) => {
    const upGrid = grid2.slice(0, selectedCells[selectedCells.length - 1].row + 1);
    const upDetails = toDetailList(upGrid);
    return bind$2(upDetails, (detail2) => {
      const slicedCells = detail2.cells.slice(0, selectedCells[selectedCells.length - 1].column + 1);
      return map$1(slicedCells, (cell2) => cell2.element);
    });
  };
  const getDownOrRightCells = (grid2, selectedCells) => {
    const downGrid = grid2.slice(selectedCells[0].row + selectedCells[0].rowspan - 1, grid2.length);
    const downDetails = toDetailList(downGrid);
    return bind$2(downDetails, (detail2) => {
      const slicedCells = detail2.cells.slice(selectedCells[0].column + selectedCells[0].colspan - 1, detail2.cells.length);
      return map$1(slicedCells, (cell2) => cell2.element);
    });
  };
  const getOtherCells = (table2, target, generators) => {
    const warehouse = Warehouse.fromTable(table2);
    const details = onCells(warehouse, target);
    return details.map((selectedCells) => {
      const grid2 = toGrid(warehouse, generators, false);
      const { rows: rows2 } = extractGridDetails(grid2);
      const upOrLeftCells = getUpOrLeftCells(rows2, selectedCells);
      const downOrRightCells = getDownOrRightCells(rows2, selectedCells);
      return {
        upOrLeftCells,
        downOrRightCells
      };
    });
  };
  const mkEvent = (target, x, y, stop, prevent2, kill, raw) => ({
    target,
    x,
    y,
    stop,
    prevent: prevent2,
    kill,
    raw
  });
  const fromRawEvent$1 = (rawEvent) => {
    const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));
    const stop = () => rawEvent.stopPropagation();
    const prevent2 = () => rawEvent.preventDefault();
    const kill = compose(prevent2, stop);
    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent2, kill, rawEvent);
  };
  const handle = (filter3, handler) => (rawEvent) => {
    if (filter3(rawEvent)) {
      handler(fromRawEvent$1(rawEvent));
    }
  };
  const binder = (element, event, filter3, handler, useCapture) => {
    const wrapped = handle(filter3, handler);
    element.dom.addEventListener(event, wrapped, useCapture);
    return { unbind: curry(unbind, element, event, wrapped, useCapture) };
  };
  const bind$1 = (element, event, filter3, handler) => binder(element, event, filter3, handler, false);
  const unbind = (element, event, handler, useCapture) => {
    element.dom.removeEventListener(event, handler, useCapture);
  };
  const filter2 = always;
  const bind2 = (element, event, handler) => bind$1(element, event, filter2, handler);
  const fromRawEvent = fromRawEvent$1;
  const hasInternalTarget = (e) => !has(SugarElement.fromDom(e.target), "ephox-snooker-resizer-bar");
  const TableCellSelectionHandler = (editor, resizeHandler) => {
    const cellSelection = Selections(() => SugarElement.fromDom(editor.getBody()), () => getSelectionCell(getSelectionStart(editor), getIsRoot(editor)), ephemera.selectedSelector);
    const onSelection = (cells2, start2, finish) => {
      const tableOpt = table(start2);
      tableOpt.each((table2) => {
        const cloneFormats2 = getTableCloneElements(editor);
        const generators = cellOperations(noop2, SugarElement.fromDom(editor.getDoc()), cloneFormats2);
        const selectedCells = getCellsFromSelection(editor);
        const otherCells = getOtherCells(table2, { selection: selectedCells }, generators);
        fireTableSelectionChange(editor, cells2, start2, finish, otherCells);
      });
    };
    const onClear = () => fireTableSelectionClear(editor);
    const annotations = SelectionAnnotation.byAttr(ephemera, onSelection, onClear);
    editor.on("init", (_e) => {
      const win = editor.getWin();
      const body2 = getBody(editor);
      const isRoot = getIsRoot(editor);
      const syncSelection = () => {
        const sel = editor.selection;
        const start2 = SugarElement.fromDom(sel.getStart());
        const end2 = SugarElement.fromDom(sel.getEnd());
        const shared = sharedOne(table, [
          start2,
          end2
        ]);
        shared.fold(() => annotations.clear(body2), noop2);
      };
      const mouseHandlers = mouse(win, body2, isRoot, annotations);
      const keyHandlers = keyboard(win, body2, isRoot, annotations);
      const external$1 = external(win, body2, isRoot, annotations);
      const hasShiftKey = (event) => event.raw.shiftKey === true;
      editor.on("TableSelectorChange", (e) => external$1(e.start, e.finish));
      const handleResponse = (event, response) => {
        if (!hasShiftKey(event)) {
          return;
        }
        if (response.kill) {
          event.kill();
        }
        response.selection.each((ns2) => {
          const relative2 = SimSelection.relative(ns2.start, ns2.finish);
          const rng = asLtrRange(win, relative2);
          editor.selection.setRng(rng);
        });
      };
      const keyup = (event) => {
        const wrappedEvent = fromRawEvent(event);
        if (wrappedEvent.raw.shiftKey && isNavigation(wrappedEvent.raw.which)) {
          const rng = editor.selection.getRng();
          const start2 = SugarElement.fromDom(rng.startContainer);
          const end2 = SugarElement.fromDom(rng.endContainer);
          keyHandlers.keyup(wrappedEvent, start2, rng.startOffset, end2, rng.endOffset).each((response) => {
            handleResponse(wrappedEvent, response);
          });
        }
      };
      const keydown = (event) => {
        const wrappedEvent = fromRawEvent(event);
        resizeHandler.hide();
        const rng = editor.selection.getRng();
        const start2 = SugarElement.fromDom(rng.startContainer);
        const end2 = SugarElement.fromDom(rng.endContainer);
        const direction = onDirection(ltr, rtl)(SugarElement.fromDom(editor.selection.getStart()));
        keyHandlers.keydown(wrappedEvent, start2, rng.startOffset, end2, rng.endOffset, direction).each((response) => {
          handleResponse(wrappedEvent, response);
        });
        resizeHandler.show();
      };
      const isLeftMouse = (raw) => raw.button === 0;
      const isLeftButtonPressed = (raw) => {
        if (raw.buttons === void 0) {
          return true;
        }
        return (raw.buttons & 1) !== 0;
      };
      const dragStart = (_e2) => {
        mouseHandlers.clearstate();
      };
      const mouseDown = (e) => {
        if (isLeftMouse(e) && hasInternalTarget(e)) {
          mouseHandlers.mousedown(fromRawEvent(e));
        }
      };
      const mouseOver = (e) => {
        if (isLeftButtonPressed(e) && hasInternalTarget(e)) {
          mouseHandlers.mouseover(fromRawEvent(e));
        }
      };
      const mouseUp = (e) => {
        if (isLeftMouse(e) && hasInternalTarget(e)) {
          mouseHandlers.mouseup(fromRawEvent(e));
        }
      };
      const getDoubleTap = () => {
        const lastTarget = Cell(SugarElement.fromDom(body2));
        const lastTimeStamp = Cell(0);
        const touchEnd = (t) => {
          const target = SugarElement.fromDom(t.target);
          if (isTag("td")(target) || isTag("th")(target)) {
            const lT = lastTarget.get();
            const lTS = lastTimeStamp.get();
            if (eq$1(lT, target) && t.timeStamp - lTS < 300) {
              t.preventDefault();
              external$1(target, target);
            }
          }
          lastTarget.set(target);
          lastTimeStamp.set(t.timeStamp);
        };
        return { touchEnd };
      };
      const doubleTap = getDoubleTap();
      editor.on("dragstart", dragStart);
      editor.on("mousedown", mouseDown);
      editor.on("mouseover", mouseOver);
      editor.on("mouseup", mouseUp);
      editor.on("touchend", doubleTap.touchEnd);
      editor.on("keyup", keyup);
      editor.on("keydown", keydown);
      editor.on("NodeChange", syncSelection);
    });
    editor.on("PreInit", () => {
      editor.serializer.addTempAttr(ephemera.firstSelected);
      editor.serializer.addTempAttr(ephemera.lastSelected);
    });
    const clearSelectedCells = (container) => annotations.clear(SugarElement.fromDom(container));
    const getSelectedCells = () => fold(cellSelection.get(), constant([]), (cells2) => {
      return map$1(cells2, (cell2) => cell2.dom);
    }, (cell2) => [cell2.dom]);
    return {
      getSelectedCells,
      clearSelectedCells
    };
  };
  const Event2 = (fields) => {
    let handlers = [];
    const bind3 = (handler) => {
      if (handler === void 0) {
        throw new Error("Event bind error: undefined handler");
      }
      handlers.push(handler);
    };
    const unbind2 = (handler) => {
      handlers = filter$2(handlers, (h) => {
        return h !== handler;
      });
    };
    const trigger = (...args) => {
      const event = {};
      each$2(fields, (name3, i) => {
        event[name3] = args[i];
      });
      each$2(handlers, (handler) => {
        handler(event);
      });
    };
    return {
      bind: bind3,
      unbind: unbind2,
      trigger
    };
  };
  const create$12 = (typeDefs) => {
    const registry = map2(typeDefs, (event) => {
      return {
        bind: event.bind,
        unbind: event.unbind
      };
    });
    const trigger = map2(typeDefs, (event) => {
      return event.trigger;
    });
    return {
      registry,
      trigger
    };
  };
  const last = (fn3, rate) => {
    let timer = null;
    const cancel = () => {
      if (!isNull2(timer)) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const throttle = (...args) => {
      cancel();
      timer = setTimeout(() => {
        timer = null;
        fn3.apply(null, args);
      }, rate);
    };
    return {
      cancel,
      throttle
    };
  };
  const sort = (arr) => {
    return arr.slice(0).sort();
  };
  const reqMessage = (required, keys2) => {
    throw new Error("All required keys (" + sort(required).join(", ") + ") were not specified. Specified keys were: " + sort(keys2).join(", ") + ".");
  };
  const unsuppMessage = (unsupported) => {
    throw new Error("Unsupported keys for object: " + sort(unsupported).join(", "));
  };
  const validateStrArr = (label, array) => {
    if (!isArray2(array)) {
      throw new Error("The " + label + " fields must be an array. Was: " + array + ".");
    }
    each$2(array, (a) => {
      if (!isString2(a)) {
        throw new Error("The value " + a + " in the " + label + " fields was not a string.");
      }
    });
  };
  const invalidTypeMessage = (incorrect, type2) => {
    throw new Error("All values need to be of type: " + type2 + ". Keys (" + sort(incorrect).join(", ") + ") were not.");
  };
  const checkDupes = (everything) => {
    const sorted = sort(everything);
    const dupe = find$1(sorted, (s, i) => {
      return i < sorted.length - 1 && s === sorted[i + 1];
    });
    dupe.each((d) => {
      throw new Error("The field: " + d + " occurs more than once in the combined fields: [" + sorted.join(", ") + "].");
    });
  };
  const base = (handleUnsupported, required) => {
    return baseWith(handleUnsupported, required, {
      validate: isFunction2,
      label: "function"
    });
  };
  const baseWith = (handleUnsupported, required, pred) => {
    if (required.length === 0) {
      throw new Error("You must specify at least one required field.");
    }
    validateStrArr("required", required);
    checkDupes(required);
    return (obj) => {
      const keys$1 = keys(obj);
      const allReqd = forall(required, (req) => {
        return contains$2(keys$1, req);
      });
      if (!allReqd) {
        reqMessage(required, keys$1);
      }
      handleUnsupported(required, keys$1);
      const invalidKeys = filter$2(required, (key2) => {
        return !pred.validate(obj[key2], key2);
      });
      if (invalidKeys.length > 0) {
        invalidTypeMessage(invalidKeys, pred.label);
      }
      return obj;
    };
  };
  const handleExact = (required, keys2) => {
    const unsupported = filter$2(keys2, (key2) => {
      return !contains$2(required, key2);
    });
    if (unsupported.length > 0) {
      unsuppMessage(unsupported);
    }
  };
  const exactly = (required) => base(handleExact, required);
  const DragMode = exactly([
    "compare",
    "extract",
    "mutate",
    "sink"
  ]);
  const DragSink = exactly([
    "element",
    "start",
    "stop",
    "destroy"
  ]);
  const DragApi = exactly([
    "forceDrop",
    "drop",
    "move",
    "delayDrop"
  ]);
  const InDrag = () => {
    let previous = Optional.none();
    const reset = () => {
      previous = Optional.none();
    };
    const update2 = (mode, nu2) => {
      const result = previous.map((old) => {
        return mode.compare(old, nu2);
      });
      previous = Optional.some(nu2);
      return result;
    };
    const onEvent = (event, mode) => {
      const dataOption = mode.extract(event);
      dataOption.each((data2) => {
        const offset2 = update2(mode, data2);
        offset2.each((d) => {
          events.trigger.move(d);
        });
      });
    };
    const events = create$12({ move: Event2(["info"]) });
    return {
      onEvent,
      reset,
      events: events.registry
    };
  };
  const NoDrag = () => {
    const events = create$12({ move: Event2(["info"]) });
    return {
      onEvent: noop2,
      reset: noop2,
      events: events.registry
    };
  };
  const Movement = () => {
    const noDragState = NoDrag();
    const inDragState = InDrag();
    let dragState = noDragState;
    const on3 = () => {
      dragState.reset();
      dragState = inDragState;
    };
    const off = () => {
      dragState.reset();
      dragState = noDragState;
    };
    const onEvent = (event, mode) => {
      dragState.onEvent(event, mode);
    };
    const isOn = () => {
      return dragState === inDragState;
    };
    return {
      on: on3,
      off,
      isOn,
      onEvent,
      events: inDragState.events
    };
  };
  const setup = (mutation, mode, settings) => {
    let active = false;
    const events = create$12({
      start: Event2([]),
      stop: Event2([])
    });
    const movement = Movement();
    const drop2 = () => {
      sink2.stop();
      if (movement.isOn()) {
        movement.off();
        events.trigger.stop();
      }
    };
    const throttledDrop = last(drop2, 200);
    const go2 = (parent2) => {
      sink2.start(parent2);
      movement.on();
      events.trigger.start();
    };
    const mousemove = (event) => {
      throttledDrop.cancel();
      movement.onEvent(event, mode);
    };
    movement.events.move.bind((event) => {
      mode.mutate(mutation, event.info);
    });
    const on3 = () => {
      active = true;
    };
    const off = () => {
      active = false;
    };
    const isActive = () => active;
    const runIfActive = (f) => {
      return (...args) => {
        if (active) {
          f.apply(null, args);
        }
      };
    };
    const sink2 = mode.sink(DragApi({
      forceDrop: drop2,
      drop: runIfActive(drop2),
      move: runIfActive(mousemove),
      delayDrop: runIfActive(throttledDrop.throttle)
    }), settings);
    const destroy3 = () => {
      sink2.destroy();
    };
    return {
      element: sink2.element,
      go: go2,
      on: on3,
      off,
      isActive,
      destroy: destroy3,
      events: events.registry
    };
  };
  const css = (namespace) => {
    const dashNamespace = namespace.replace(/\./g, "-");
    const resolve2 = (str) => {
      return dashNamespace + "-" + str;
    };
    return { resolve: resolve2 };
  };
  const styles$1 = css("ephox-dragster");
  const resolve$1 = styles$1.resolve;
  const Blocker = (options) => {
    const settings = {
      layerClass: resolve$1("blocker"),
      ...options
    };
    const div = SugarElement.fromTag("div");
    set$2(div, "role", "presentation");
    setAll(div, {
      position: "fixed",
      left: "0px",
      top: "0px",
      width: "100%",
      height: "100%"
    });
    add(div, resolve$1("blocker"));
    add(div, settings.layerClass);
    const element = constant(div);
    const destroy3 = () => {
      remove$6(div);
    };
    return {
      element,
      destroy: destroy3
    };
  };
  const compare = (old, nu2) => {
    return SugarPosition(nu2.left - old.left, nu2.top - old.top);
  };
  const extract = (event) => {
    return Optional.some(SugarPosition(event.x, event.y));
  };
  const mutate = (mutation, info) => {
    mutation.mutate(info.left, info.top);
  };
  const sink = (dragApi, settings) => {
    const blocker = Blocker(settings);
    const mdown = bind2(blocker.element(), "mousedown", dragApi.forceDrop);
    const mup = bind2(blocker.element(), "mouseup", dragApi.drop);
    const mmove = bind2(blocker.element(), "mousemove", dragApi.move);
    const mout = bind2(blocker.element(), "mouseout", dragApi.delayDrop);
    const destroy3 = () => {
      blocker.destroy();
      mup.unbind();
      mmove.unbind();
      mout.unbind();
      mdown.unbind();
    };
    const start2 = (parent2) => {
      append$1(parent2, blocker.element());
    };
    const stop = () => {
      remove$6(blocker.element());
    };
    return DragSink({
      element: blocker.element,
      start: start2,
      stop,
      destroy: destroy3
    });
  };
  var MouseDrag = DragMode({
    compare,
    extract,
    sink,
    mutate
  });
  const transform = (mutation, settings = {}) => {
    var _a;
    const mode = (_a = settings.mode) !== null && _a !== void 0 ? _a : MouseDrag;
    return setup(mutation, mode, settings);
  };
  const styles2 = css("ephox-snooker");
  const resolve = styles2.resolve;
  const Mutation = () => {
    const events = create$12({
      drag: Event2([
        "xDelta",
        "yDelta"
      ])
    });
    const mutate2 = (x, y) => {
      events.trigger.drag(x, y);
    };
    return {
      mutate: mutate2,
      events: events.registry
    };
  };
  const BarMutation = () => {
    const events = create$12({
      drag: Event2([
        "xDelta",
        "yDelta",
        "target"
      ])
    });
    let target = Optional.none();
    const delegate = Mutation();
    delegate.events.drag.bind((event) => {
      target.each((t) => {
        events.trigger.drag(event.xDelta, event.yDelta, t);
      });
    });
    const assign = (t) => {
      target = Optional.some(t);
    };
    const get2 = () => {
      return target;
    };
    return {
      assign,
      get: get2,
      mutate: delegate.mutate,
      events: events.registry
    };
  };
  const col = (column, x, y, w, h) => {
    const bar = SugarElement.fromTag("div");
    setAll(bar, {
      position: "absolute",
      left: x - w / 2 + "px",
      top: y + "px",
      height: h + "px",
      width: w + "px"
    });
    setAll$1(bar, {
      "data-column": column,
      "role": "presentation"
    });
    return bar;
  };
  const row = (r2, x, y, w, h) => {
    const bar = SugarElement.fromTag("div");
    setAll(bar, {
      position: "absolute",
      left: x + "px",
      top: y - h / 2 + "px",
      height: h + "px",
      width: w + "px"
    });
    setAll$1(bar, {
      "data-row": r2,
      "role": "presentation"
    });
    return bar;
  };
  const resizeBar = resolve("resizer-bar");
  const resizeRowBar = resolve("resizer-rows");
  const resizeColBar = resolve("resizer-cols");
  const BAR_THICKNESS = 7;
  const resizableRows = (warehouse, isResizable2) => bind$2(warehouse.all, (row2, i) => isResizable2(row2.element) ? [i] : []);
  const resizableColumns = (warehouse, isResizable2) => {
    const resizableCols = [];
    range$1(warehouse.grid.columns, (index) => {
      const colElmOpt = Warehouse.getColumnAt(warehouse, index).map((col2) => col2.element);
      if (colElmOpt.forall(isResizable2)) {
        resizableCols.push(index);
      }
    });
    return filter$2(resizableCols, (colIndex) => {
      const columnCells = Warehouse.filterItems(warehouse, (cell2) => cell2.column === colIndex);
      return forall(columnCells, (cell2) => isResizable2(cell2.element));
    });
  };
  const destroy2 = (wire) => {
    const previous = descendants(wire.parent(), "." + resizeBar);
    each$2(previous, remove$6);
  };
  const drawBar = (wire, positions, create3) => {
    const origin = wire.origin();
    each$2(positions, (cpOption) => {
      cpOption.each((cp) => {
        const bar = create3(origin, cp);
        add(bar, resizeBar);
        append$1(wire.parent(), bar);
      });
    });
  };
  const refreshCol = (wire, colPositions, position, tableHeight) => {
    drawBar(wire, colPositions, (origin, cp) => {
      const colBar = col(cp.col, cp.x - origin.left, position.top - origin.top, BAR_THICKNESS, tableHeight);
      add(colBar, resizeColBar);
      return colBar;
    });
  };
  const refreshRow = (wire, rowPositions, position, tableWidth) => {
    drawBar(wire, rowPositions, (origin, cp) => {
      const rowBar = row(cp.row, position.left - origin.left, cp.y - origin.top, tableWidth, BAR_THICKNESS);
      add(rowBar, resizeRowBar);
      return rowBar;
    });
  };
  const refreshGrid = (warhouse, wire, table2, rows2, cols) => {
    const position = absolute(table2);
    const isResizable2 = wire.isResizable;
    const rowPositions = rows2.length > 0 ? height2.positions(rows2, table2) : [];
    const resizableRowBars = rowPositions.length > 0 ? resizableRows(warhouse, isResizable2) : [];
    const resizableRowPositions = filter$2(rowPositions, (_pos, i) => exists(resizableRowBars, (barIndex) => i === barIndex));
    refreshRow(wire, resizableRowPositions, position, getOuter$2(table2));
    const colPositions = cols.length > 0 ? width2.positions(cols, table2) : [];
    const resizableColBars = colPositions.length > 0 ? resizableColumns(warhouse, isResizable2) : [];
    const resizableColPositions = filter$2(colPositions, (_pos, i) => exists(resizableColBars, (barIndex) => i === barIndex));
    refreshCol(wire, resizableColPositions, position, getOuter$1(table2));
  };
  const refresh = (wire, table2) => {
    destroy2(wire);
    if (wire.isResizable(table2)) {
      const warehouse = Warehouse.fromTable(table2);
      const rows$12 = rows(warehouse);
      const cols = columns(warehouse);
      refreshGrid(warehouse, wire, table2, rows$12, cols);
    }
  };
  const each = (wire, f) => {
    const bars = descendants(wire.parent(), "." + resizeBar);
    each$2(bars, f);
  };
  const hide2 = (wire) => {
    each(wire, (bar) => {
      set$1(bar, "display", "none");
    });
  };
  const show = (wire) => {
    each(wire, (bar) => {
      set$1(bar, "display", "block");
    });
  };
  const isRowBar = (element) => {
    return has(element, resizeRowBar);
  };
  const isColBar = (element) => {
    return has(element, resizeColBar);
  };
  const resizeBarDragging = resolve("resizer-bar-dragging");
  const BarManager = (wire) => {
    const mutation = BarMutation();
    const resizing = transform(mutation, {});
    let hoverTable = Optional.none();
    const getResizer = (element, type2) => {
      return Optional.from(get$b(element, type2));
    };
    mutation.events.drag.bind((event) => {
      getResizer(event.target, "data-row").each((_dataRow) => {
        const currentRow = getCssValue(event.target, "top");
        set$1(event.target, "top", currentRow + event.yDelta + "px");
      });
      getResizer(event.target, "data-column").each((_dataCol) => {
        const currentCol = getCssValue(event.target, "left");
        set$1(event.target, "left", currentCol + event.xDelta + "px");
      });
    });
    const getDelta = (target, dir) => {
      const newX = getCssValue(target, dir);
      const oldX = getAttrValue(target, "data-initial-" + dir, 0);
      return newX - oldX;
    };
    resizing.events.stop.bind(() => {
      mutation.get().each((target) => {
        hoverTable.each((table2) => {
          getResizer(target, "data-row").each((row2) => {
            const delta = getDelta(target, "top");
            remove$7(target, "data-initial-top");
            events.trigger.adjustHeight(table2, delta, parseInt(row2, 10));
          });
          getResizer(target, "data-column").each((column) => {
            const delta = getDelta(target, "left");
            remove$7(target, "data-initial-left");
            events.trigger.adjustWidth(table2, delta, parseInt(column, 10));
          });
          refresh(wire, table2);
        });
      });
    });
    const handler = (target, dir) => {
      events.trigger.startAdjust();
      mutation.assign(target);
      set$2(target, "data-initial-" + dir, getCssValue(target, dir));
      add(target, resizeBarDragging);
      set$1(target, "opacity", "0.2");
      resizing.go(wire.parent());
    };
    const mousedown = bind2(wire.parent(), "mousedown", (event) => {
      if (isRowBar(event.target)) {
        handler(event.target, "top");
      }
      if (isColBar(event.target)) {
        handler(event.target, "left");
      }
    });
    const isRoot = (e) => {
      return eq$1(e, wire.view());
    };
    const findClosestEditableTable = (target) => closest$1(target, "table", isRoot).filter(isEditable$1);
    const mouseover = bind2(wire.view(), "mouseover", (event) => {
      findClosestEditableTable(event.target).fold(() => {
        if (inBody(event.target)) {
          destroy2(wire);
        }
      }, (table2) => {
        if (resizing.isActive()) {
          hoverTable = Optional.some(table2);
          refresh(wire, table2);
        }
      });
    });
    const destroy$1 = () => {
      mousedown.unbind();
      mouseover.unbind();
      resizing.destroy();
      destroy2(wire);
    };
    const refresh$1 = (tbl) => {
      refresh(wire, tbl);
    };
    const events = create$12({
      adjustHeight: Event2([
        "table",
        "delta",
        "row"
      ]),
      adjustWidth: Event2([
        "table",
        "delta",
        "column"
      ]),
      startAdjust: Event2([])
    });
    return {
      destroy: destroy$1,
      refresh: refresh$1,
      on: resizing.on,
      off: resizing.off,
      hideBars: curry(hide2, wire),
      showBars: curry(show, wire),
      events: events.registry
    };
  };
  const create2 = (wire, resizing, lazySizing) => {
    const hdirection = height2;
    const vdirection = width2;
    const manager = BarManager(wire);
    const events = create$12({
      beforeResize: Event2([
        "table",
        "type"
      ]),
      afterResize: Event2([
        "table",
        "type"
      ]),
      startDrag: Event2([])
    });
    manager.events.adjustHeight.bind((event) => {
      const table2 = event.table;
      events.trigger.beforeResize(table2, "row");
      const delta = hdirection.delta(event.delta, table2);
      adjustHeight(table2, delta, event.row, hdirection);
      events.trigger.afterResize(table2, "row");
    });
    manager.events.startAdjust.bind((_event) => {
      events.trigger.startDrag();
    });
    manager.events.adjustWidth.bind((event) => {
      const table2 = event.table;
      events.trigger.beforeResize(table2, "col");
      const delta = vdirection.delta(event.delta, table2);
      const tableSize = lazySizing(table2);
      adjustWidth(table2, delta, event.column, resizing, tableSize);
      events.trigger.afterResize(table2, "col");
    });
    return {
      on: manager.on,
      off: manager.off,
      refreshBars: manager.refresh,
      hideBars: manager.hideBars,
      showBars: manager.showBars,
      destroy: manager.destroy,
      events: events.registry
    };
  };
  const TableResize = { create: create2 };
  const only = (element, isResizable2) => {
    const parent2 = isDocument(element) ? documentElement(element) : element;
    return {
      parent: constant(parent2),
      view: constant(element),
      origin: constant(SugarPosition(0, 0)),
      isResizable: isResizable2
    };
  };
  const detached = (editable, chrome, isResizable2) => {
    const origin = () => absolute(chrome);
    return {
      parent: constant(chrome),
      view: constant(editable),
      origin,
      isResizable: isResizable2
    };
  };
  const body = (editable, chrome, isResizable2) => {
    return {
      parent: constant(chrome),
      view: constant(editable),
      origin: constant(SugarPosition(0, 0)),
      isResizable: isResizable2
    };
  };
  const ResizeWire = {
    only,
    detached,
    body
  };
  const createContainer = () => {
    const container = SugarElement.fromTag("div");
    setAll(container, {
      position: "static",
      height: "0",
      width: "0",
      padding: "0",
      margin: "0",
      border: "0"
    });
    append$1(body$1(), container);
    return container;
  };
  const get = (editor, isResizable2) => {
    return editor.inline ? ResizeWire.body(SugarElement.fromDom(editor.getBody()), createContainer(), isResizable2) : ResizeWire.only(SugarElement.fromDom(editor.getDoc()), isResizable2);
  };
  const remove = (editor, wire) => {
    if (editor.inline) {
      remove$6(wire.parent());
    }
  };
  const isTable = (node) => isNonNullable(node) && node.nodeName === "TABLE";
  const barResizerPrefix = "bar-";
  const isResizable = (elm) => get$b(elm, "data-mce-resize") !== "false";
  const syncPixels = (table2) => {
    const warehouse = Warehouse.fromTable(table2);
    if (!Warehouse.hasColumns(warehouse)) {
      each$2(cells$1(table2), (cell2) => {
        const computedWidth = get$a(cell2, "width");
        set$1(cell2, "width", computedWidth);
        remove$7(cell2, "width");
      });
    }
  };
  const TableResizeHandler = (editor) => {
    const selectionRng = value();
    const tableResize = value();
    const resizeWire = value();
    let startW;
    let startRawW;
    const lazySizing = (table2) => get$5(editor, table2);
    const lazyResizingBehaviour = () => isPreserveTableColumnResizing(editor) ? preserveTable() : resizeTable();
    const getNumColumns = (table2) => getGridSize(table2).columns;
    const afterCornerResize = (table2, origin, width3) => {
      const isRightEdgeResize = endsWith2(origin, "e");
      if (startRawW === "") {
        convertToPercentSize(table2);
      }
      if (width3 !== startW && startRawW !== "") {
        set$1(table2, "width", startRawW);
        const resizing = lazyResizingBehaviour();
        const tableSize = lazySizing(table2);
        const col2 = isPreserveTableColumnResizing(editor) || isRightEdgeResize ? getNumColumns(table2) - 1 : 0;
        adjustWidth(table2, width3 - startW, col2, resizing, tableSize);
      } else if (isPercentage$1(startRawW)) {
        const percentW = parseFloat(startRawW.replace("%", ""));
        const targetPercentW = width3 * percentW / startW;
        set$1(table2, "width", targetPercentW + "%");
      }
      if (isPixel(startRawW)) {
        syncPixels(table2);
      }
    };
    const destroy3 = () => {
      tableResize.on((sz) => {
        sz.destroy();
      });
      resizeWire.on((w) => {
        remove(editor, w);
      });
    };
    editor.on("init", () => {
      const rawWire = get(editor, isResizable);
      resizeWire.set(rawWire);
      if (hasTableObjectResizing(editor) && hasTableResizeBars(editor)) {
        const resizing = lazyResizingBehaviour();
        const sz = TableResize.create(rawWire, resizing, lazySizing);
        sz.on();
        sz.events.startDrag.bind((_event) => {
          selectionRng.set(editor.selection.getRng());
        });
        sz.events.beforeResize.bind((event) => {
          const rawTable = event.table.dom;
          fireObjectResizeStart(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
        });
        sz.events.afterResize.bind((event) => {
          const table2 = event.table;
          const rawTable = table2.dom;
          removeDataStyle(table2);
          selectionRng.on((rng) => {
            editor.selection.setRng(rng);
            editor.focus();
          });
          fireObjectResized(editor, rawTable, getPixelWidth(rawTable), getPixelHeight(rawTable), barResizerPrefix + event.type);
          editor.undoManager.add();
        });
        tableResize.set(sz);
      }
    });
    editor.on("ObjectResizeStart", (e) => {
      const targetElm = e.target;
      if (isTable(targetElm)) {
        const table2 = SugarElement.fromDom(targetElm);
        each$2(editor.dom.select(".mce-clonedresizable"), (clone2) => {
          editor.dom.addClass(clone2, "mce-" + getTableColumnResizingBehaviour(editor) + "-columns");
        });
        if (!isPixelSizing(table2) && isTablePixelsForced(editor)) {
          convertToPixelSize(table2);
        } else if (!isPercentSizing(table2) && isTablePercentagesForced(editor)) {
          convertToPercentSize(table2);
        }
        if (isNoneSizing(table2) && startsWith(e.origin, barResizerPrefix)) {
          convertToPercentSize(table2);
        }
        startW = e.width;
        startRawW = isTableResponsiveForced(editor) ? "" : getRawWidth(editor, targetElm).getOr("");
      }
    });
    editor.on("ObjectResized", (e) => {
      const targetElm = e.target;
      if (isTable(targetElm)) {
        const table2 = SugarElement.fromDom(targetElm);
        const origin = e.origin;
        if (startsWith(origin, "corner-")) {
          afterCornerResize(table2, origin, e.width);
        }
        removeDataStyle(table2);
        fireTableModified(editor, table2.dom, styleModified);
      }
    });
    editor.on("SwitchMode", () => {
      tableResize.on((resize2) => {
        if (editor.mode.isReadOnly()) {
          resize2.hideBars();
        } else {
          resize2.showBars();
        }
      });
    });
    editor.on("dragstart dragend", (e) => {
      tableResize.on((resize2) => {
        if (e.type === "dragstart") {
          resize2.hideBars();
          resize2.off();
        } else {
          resize2.on();
          resize2.showBars();
        }
      });
    });
    editor.on("remove", () => {
      destroy3();
    });
    const refresh2 = (table2) => {
      tableResize.on((resize2) => resize2.refreshBars(SugarElement.fromDom(table2)));
    };
    const hide3 = () => {
      tableResize.on((resize2) => resize2.hideBars());
    };
    const show2 = () => {
      tableResize.on((resize2) => resize2.showBars());
    };
    return {
      refresh: refresh2,
      hide: hide3,
      show: show2
    };
  };
  const setupTable = (editor) => {
    register(editor);
    const resizeHandler = TableResizeHandler(editor);
    const cellSelectionHandler = TableCellSelectionHandler(editor, resizeHandler);
    const actions2 = TableActions(editor, resizeHandler, cellSelectionHandler);
    registerCommands(editor, actions2);
    registerQueryCommands(editor, actions2);
    registerEvents(editor, actions2);
    return {
      getSelectedCells: cellSelectionHandler.getSelectedCells,
      clearSelectedCells: cellSelectionHandler.clearSelectedCells
    };
  };
  const DomModel = (editor) => {
    const table2 = setupTable(editor);
    return { table: table2 };
  };
  var Model = () => {
    global$1.add("dom", DomModel);
  };
  Model();
})();
const skin = "";
/*!
 * FilePond 4.30.4
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isNode = (value) => value instanceof HTMLElement;
const createStore = (initialState, queries2 = [], actions2 = []) => {
  const state2 = {
    ...initialState
  };
  const actionQueue = [];
  const dispatchQueue = [];
  const getState = () => ({ ...state2 });
  const processActionQueue = () => {
    const queue = [...actionQueue];
    actionQueue.length = 0;
    return queue;
  };
  const processDispatchQueue = () => {
    const queue = [...dispatchQueue];
    dispatchQueue.length = 0;
    queue.forEach(({ type, data: data2 }) => {
      dispatch(type, data2);
    });
  };
  const dispatch = (type, data2, isBlocking) => {
    if (isBlocking && !document.hidden) {
      dispatchQueue.push({ type, data: data2 });
      return;
    }
    if (actionHandlers[type]) {
      actionHandlers[type](data2);
    }
    actionQueue.push({
      type,
      data: data2
    });
  };
  const query = (str, ...args) => queryHandles[str] ? queryHandles[str](...args) : null;
  const api = {
    getState,
    processActionQueue,
    processDispatchQueue,
    dispatch,
    query
  };
  let queryHandles = {};
  queries2.forEach((query2) => {
    queryHandles = {
      ...query2(state2),
      ...queryHandles
    };
  });
  let actionHandlers = {};
  actions2.forEach((action) => {
    actionHandlers = {
      ...action(dispatch, query, state2),
      ...actionHandlers
    };
  });
  return api;
};
const defineProperty = (obj, property, definition) => {
  if (typeof definition === "function") {
    obj[property] = definition;
    return;
  }
  Object.defineProperty(obj, property, { ...definition });
};
const forin = (obj, cb) => {
  for (const key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    cb(key, obj[key]);
  }
};
const createObject = (definition) => {
  const obj = {};
  forin(definition, (property) => {
    defineProperty(obj, property, definition[property]);
  });
  return obj;
};
const attr = (node, name2, value = null) => {
  if (value === null) {
    return node.getAttribute(name2) || node.hasAttribute(name2);
  }
  node.setAttribute(name2, value);
};
const ns$2 = "http://www.w3.org/2000/svg";
const svgElements = ["svg", "path"];
const isSVGElement = (tag) => svgElements.includes(tag);
const createElement = (tag, className, attributes = {}) => {
  if (typeof className === "object") {
    attributes = className;
    className = null;
  }
  const element = isSVGElement(tag) ? document.createElementNS(ns$2, tag) : document.createElement(tag);
  if (className) {
    if (isSVGElement(tag)) {
      attr(element, "class", className);
    } else {
      element.className = className;
    }
  }
  forin(attributes, (name2, value) => {
    attr(element, name2, value);
  });
  return element;
};
const appendChild = (parent) => (child, index) => {
  if (typeof index !== "undefined" && parent.children[index]) {
    parent.insertBefore(child, parent.children[index]);
  } else {
    parent.appendChild(child);
  }
};
const appendChildView = (parent, childViews) => (view, index) => {
  if (typeof index !== "undefined") {
    childViews.splice(index, 0, view);
  } else {
    childViews.push(view);
  }
  return view;
};
const removeChildView = (parent, childViews) => (view) => {
  childViews.splice(childViews.indexOf(view), 1);
  if (view.element.parentNode) {
    parent.removeChild(view.element);
  }
  return view;
};
const IS_BROWSER$2 = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
const isBrowser$9 = () => IS_BROWSER$2;
const testElement = isBrowser$9() ? createElement("svg") : {};
const getChildCount = "children" in testElement ? (el) => el.children.length : (el) => el.childNodes.length;
const getViewRect = (elementRect, childViews, offset2, scale) => {
  const left2 = offset2[0] || elementRect.left;
  const top2 = offset2[1] || elementRect.top;
  const right2 = left2 + elementRect.width;
  const bottom2 = top2 + elementRect.height * (scale[1] || 1);
  const rect = {
    // the rectangle of the element itself
    element: {
      ...elementRect
    },
    // the rectangle of the element expanded to contain its children, does not include any margins
    inner: {
      left: elementRect.left,
      top: elementRect.top,
      right: elementRect.right,
      bottom: elementRect.bottom
    },
    // the rectangle of the element expanded to contain its children including own margin and child margins
    // margins will be added after we've recalculated the size
    outer: {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    }
  };
  childViews.filter((childView) => !childView.isRectIgnored()).map((childView) => childView.rect).forEach((childViewRect) => {
    expandRect(rect.inner, { ...childViewRect.inner });
    expandRect(rect.outer, { ...childViewRect.outer });
  });
  calculateRectSize(rect.inner);
  rect.outer.bottom += rect.element.marginBottom;
  rect.outer.right += rect.element.marginRight;
  calculateRectSize(rect.outer);
  return rect;
};
const expandRect = (parent, child) => {
  child.top += parent.top;
  child.right += parent.left;
  child.bottom += parent.top;
  child.left += parent.left;
  if (child.bottom > parent.bottom) {
    parent.bottom = child.bottom;
  }
  if (child.right > parent.right) {
    parent.right = child.right;
  }
};
const calculateRectSize = (rect) => {
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
};
const isNumber$1 = (value) => typeof value === "number";
const thereYet = (position, destination, velocity, errorMargin = 1e-3) => {
  return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;
};
const spring = (
  // default options
  ({ stiffness = 0.5, damping = 0.75, mass = 10 } = {}) => {
    let target = null;
    let position = null;
    let velocity = 0;
    let resting = false;
    const interpolate = (ts, skipToEndState) => {
      if (resting)
        return;
      if (!(isNumber$1(target) && isNumber$1(position))) {
        resting = true;
        velocity = 0;
        return;
      }
      const f = -(position - target) * stiffness;
      velocity += f / mass;
      position += velocity;
      velocity *= damping;
      if (thereYet(position, target, velocity) || skipToEndState) {
        position = target;
        velocity = 0;
        resting = true;
        api.onupdate(position);
        api.oncomplete(position);
      } else {
        api.onupdate(position);
      }
    };
    const setTarget = (value) => {
      if (isNumber$1(value) && !isNumber$1(position)) {
        position = value;
      }
      if (target === null) {
        target = value;
        position = value;
      }
      target = value;
      if (position === target || typeof target === "undefined") {
        resting = true;
        velocity = 0;
        api.onupdate(position);
        api.oncomplete(position);
        return;
      }
      resting = false;
    };
    const api = createObject({
      interpolate,
      target: {
        set: setTarget,
        get: () => target
      },
      resting: {
        get: () => resting
      },
      onupdate: (value) => {
      },
      oncomplete: (value) => {
      }
    });
    return api;
  }
);
const easeInOutQuad = (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
const tween = (
  // default values
  ({ duration = 500, easing = easeInOutQuad, delay = 0 } = {}) => {
    let start2 = null;
    let t;
    let p;
    let resting = true;
    let reverse = false;
    let target = null;
    const interpolate = (ts, skipToEndState) => {
      if (resting || target === null)
        return;
      if (start2 === null) {
        start2 = ts;
      }
      if (ts - start2 < delay)
        return;
      t = ts - start2 - delay;
      if (t >= duration || skipToEndState) {
        t = 1;
        p = reverse ? 0 : 1;
        api.onupdate(p * target);
        api.oncomplete(p * target);
        resting = true;
      } else {
        p = t / duration;
        api.onupdate((t >= 0 ? easing(reverse ? 1 - p : p) : 0) * target);
      }
    };
    const api = createObject({
      interpolate,
      target: {
        get: () => reverse ? 0 : target,
        set: (value) => {
          if (target === null) {
            target = value;
            api.onupdate(value);
            api.oncomplete(value);
            return;
          }
          if (value < target) {
            target = 1;
            reverse = true;
          } else {
            reverse = false;
            target = value;
          }
          resting = false;
          start2 = null;
        }
      },
      resting: {
        get: () => resting
      },
      onupdate: (value) => {
      },
      oncomplete: (value) => {
      }
    });
    return api;
  }
);
const animator = {
  spring,
  tween
};
const createAnimator = (definition, category, property) => {
  const def = definition[category] && typeof definition[category][property] === "object" ? definition[category][property] : definition[category] || definition;
  const type = typeof def === "string" ? def : def.type;
  const props = typeof def === "object" ? { ...def } : {};
  return animator[type] ? animator[type](props) : null;
};
const addGetSet = (keys, obj, props, overwrite = false) => {
  obj = Array.isArray(obj) ? obj : [obj];
  obj.forEach((o) => {
    keys.forEach((key) => {
      let name2 = key;
      let getter = () => props[key];
      let setter = (value) => props[key] = value;
      if (typeof key === "object") {
        name2 = key.key;
        getter = key.getter || getter;
        setter = key.setter || setter;
      }
      if (o[name2] && !overwrite) {
        return;
      }
      o[name2] = {
        get: getter,
        set: setter
      };
    });
  });
};
const animations = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI }) => {
  const initialProps = { ...viewProps };
  const animations2 = [];
  forin(mixinConfig, (property, animation) => {
    const animator2 = createAnimator(animation);
    if (!animator2) {
      return;
    }
    animator2.onupdate = (value) => {
      viewProps[property] = value;
    };
    animator2.target = initialProps[property];
    const prop = {
      key: property,
      setter: (value) => {
        if (animator2.target === value) {
          return;
        }
        animator2.target = value;
      },
      getter: () => viewProps[property]
    };
    addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);
    animations2.push(animator2);
  });
  return {
    write: (ts) => {
      let skipToEndState = document.hidden;
      let resting = true;
      animations2.forEach((animation) => {
        if (!animation.resting)
          resting = false;
        animation.interpolate(ts, skipToEndState);
      });
      return resting;
    },
    destroy: () => {
    }
  };
};
const addEvent = (element) => (type, fn3) => {
  element.addEventListener(type, fn3);
};
const removeEvent = (element) => (type, fn3) => {
  element.removeEventListener(type, fn3);
};
const listeners = ({
  mixinConfig,
  viewProps,
  viewInternalAPI,
  viewExternalAPI,
  viewState,
  view
}) => {
  const events = [];
  const add = addEvent(view.element);
  const remove = removeEvent(view.element);
  viewExternalAPI.on = (type, fn3) => {
    events.push({
      type,
      fn: fn3
    });
    add(type, fn3);
  };
  viewExternalAPI.off = (type, fn3) => {
    events.splice(events.findIndex((event) => event.type === type && event.fn === fn3), 1);
    remove(type, fn3);
  };
  return {
    write: () => {
      return true;
    },
    destroy: () => {
      events.forEach((event) => {
        remove(event.type, event.fn);
      });
    }
  };
};
const apis = ({ mixinConfig, viewProps, viewExternalAPI }) => {
  addGetSet(mixinConfig, viewExternalAPI, viewProps);
};
const isDefined$2 = (value) => value != null;
const defaults$2 = {
  opacity: 1,
  scaleX: 1,
  scaleY: 1,
  translateX: 0,
  translateY: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  originX: 0,
  originY: 0
};
const styles = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view }) => {
  const initialProps = { ...viewProps };
  const currentProps = {};
  addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);
  const getOffset = () => [viewProps["translateX"] || 0, viewProps["translateY"] || 0];
  const getScale = () => [viewProps["scaleX"] || 0, viewProps["scaleY"] || 0];
  const getRect = () => view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;
  viewInternalAPI.rect = { get: getRect };
  viewExternalAPI.rect = { get: getRect };
  mixinConfig.forEach((key) => {
    viewProps[key] = typeof initialProps[key] === "undefined" ? defaults$2[key] : initialProps[key];
  });
  return {
    write: () => {
      if (!propsHaveChanged(currentProps, viewProps)) {
        return;
      }
      applyStyles$2(view.element, viewProps);
      Object.assign(currentProps, { ...viewProps });
      return true;
    },
    destroy: () => {
    }
  };
};
const propsHaveChanged = (currentProps, newProps) => {
  if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
    return true;
  }
  for (const prop in newProps) {
    if (newProps[prop] !== currentProps[prop]) {
      return true;
    }
  }
  return false;
};
const applyStyles$2 = (element, {
  opacity,
  perspective,
  translateX,
  translateY,
  scaleX,
  scaleY,
  rotateX,
  rotateY,
  rotateZ,
  originX,
  originY,
  width: width2,
  height: height2
}) => {
  let transforms2 = "";
  let styles2 = "";
  if (isDefined$2(originX) || isDefined$2(originY)) {
    styles2 += `transform-origin: ${originX || 0}px ${originY || 0}px;`;
  }
  if (isDefined$2(perspective)) {
    transforms2 += `perspective(${perspective}px) `;
  }
  if (isDefined$2(translateX) || isDefined$2(translateY)) {
    transforms2 += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;
  }
  if (isDefined$2(scaleX) || isDefined$2(scaleY)) {
    transforms2 += `scale3d(${isDefined$2(scaleX) ? scaleX : 1}, ${isDefined$2(scaleY) ? scaleY : 1}, 1) `;
  }
  if (isDefined$2(rotateZ)) {
    transforms2 += `rotateZ(${rotateZ}rad) `;
  }
  if (isDefined$2(rotateX)) {
    transforms2 += `rotateX(${rotateX}rad) `;
  }
  if (isDefined$2(rotateY)) {
    transforms2 += `rotateY(${rotateY}rad) `;
  }
  if (transforms2.length) {
    styles2 += `transform:${transforms2};`;
  }
  if (isDefined$2(opacity)) {
    styles2 += `opacity:${opacity};`;
    if (opacity === 0) {
      styles2 += `visibility:hidden;`;
    }
    if (opacity < 1) {
      styles2 += `pointer-events:none;`;
    }
  }
  if (isDefined$2(height2)) {
    styles2 += `height:${height2}px;`;
  }
  if (isDefined$2(width2)) {
    styles2 += `width:${width2}px;`;
  }
  const elementCurrentStyle = element.elementCurrentStyle || "";
  if (styles2.length !== elementCurrentStyle.length || styles2 !== elementCurrentStyle) {
    element.style.cssText = styles2;
    element.elementCurrentStyle = styles2;
  }
};
const Mixins = {
  styles,
  listeners,
  animations,
  apis
};
const updateRect$2 = (rect = {}, element = {}, style = {}) => {
  if (!element.layoutCalculated) {
    rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
    rect.marginTop = parseInt(style.marginTop, 10) || 0;
    rect.marginRight = parseInt(style.marginRight, 10) || 0;
    rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
    rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
    element.layoutCalculated = true;
  }
  rect.left = element.offsetLeft || 0;
  rect.top = element.offsetTop || 0;
  rect.width = element.offsetWidth || 0;
  rect.height = element.offsetHeight || 0;
  rect.right = rect.left + rect.width;
  rect.bottom = rect.top + rect.height;
  rect.scrollTop = element.scrollTop;
  rect.hidden = element.offsetParent === null;
  return rect;
};
const createView = (
  // default view definition
  ({
    // element definition
    tag = "div",
    name: name2 = null,
    attributes = {},
    // view interaction
    read: read2 = () => {
    },
    write: write2 = () => {
    },
    create: create2 = () => {
    },
    destroy: destroy2 = () => {
    },
    // hooks
    filterFrameActionsForChild = (child, actions2) => actions2,
    didCreateView = () => {
    },
    didWriteView = () => {
    },
    // rect related
    ignoreRect = false,
    ignoreRectUpdate = false,
    // mixins
    mixins = []
  } = {}) => (store, props = {}) => {
    const element = createElement(tag, `filepond--${name2}`, attributes);
    const style = window.getComputedStyle(element, null);
    const rect = updateRect$2();
    let frameRect = null;
    let isResting = false;
    const childViews = [];
    const activeMixins = [];
    const ref = {};
    const state2 = {};
    const writers = [
      write2
      // default writer
    ];
    const readers = [
      read2
      // default reader
    ];
    const destroyers = [
      destroy2
      // default destroy
    ];
    const getElement2 = () => element;
    const getChildViews = () => childViews.concat();
    const getReference = () => ref;
    const createChildView = (store2) => (view, props2) => view(store2, props2);
    const getRect = () => {
      if (frameRect) {
        return frameRect;
      }
      frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
      return frameRect;
    };
    const getStyle = () => style;
    const _read = () => {
      frameRect = null;
      childViews.forEach((child) => child._read());
      const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
      if (shouldUpdate) {
        updateRect$2(rect, element, style);
      }
      const api = { root: internalAPI, props, rect };
      readers.forEach((reader) => reader(api));
    };
    const _write = (ts, frameActions, shouldOptimize) => {
      let resting = frameActions.length === 0;
      writers.forEach((writer) => {
        const writerResting = writer({
          props,
          root: internalAPI,
          actions: frameActions,
          timestamp: ts,
          shouldOptimize
        });
        if (writerResting === false) {
          resting = false;
        }
      });
      activeMixins.forEach((mixin) => {
        const mixinResting = mixin.write(ts);
        if (mixinResting === false) {
          resting = false;
        }
      });
      childViews.filter((child) => !!child.element.parentNode).forEach((child) => {
        const childResting = child._write(
          ts,
          filterFrameActionsForChild(child, frameActions),
          shouldOptimize
        );
        if (!childResting) {
          resting = false;
        }
      });
      childViews.forEach((child, index) => {
        if (child.element.parentNode) {
          return;
        }
        internalAPI.appendChild(child.element, index);
        child._read();
        child._write(
          ts,
          filterFrameActionsForChild(child, frameActions),
          shouldOptimize
        );
        resting = false;
      });
      isResting = resting;
      didWriteView({
        props,
        root: internalAPI,
        actions: frameActions,
        timestamp: ts
      });
      return resting;
    };
    const _destroy = () => {
      activeMixins.forEach((mixin) => mixin.destroy());
      destroyers.forEach((destroyer) => {
        destroyer({ root: internalAPI, props });
      });
      childViews.forEach((child) => child._destroy());
    };
    const sharedAPIDefinition = {
      element: {
        get: getElement2
      },
      style: {
        get: getStyle
      },
      childViews: {
        get: getChildViews
      }
    };
    const internalAPIDefinition = {
      ...sharedAPIDefinition,
      rect: {
        get: getRect
      },
      // access to custom children references
      ref: {
        get: getReference
      },
      // dom modifiers
      is: (needle) => name2 === needle,
      appendChild: appendChild(element),
      createChildView: createChildView(store),
      linkView: (view) => {
        childViews.push(view);
        return view;
      },
      unlinkView: (view) => {
        childViews.splice(childViews.indexOf(view), 1);
      },
      appendChildView: appendChildView(element, childViews),
      removeChildView: removeChildView(element, childViews),
      registerWriter: (writer) => writers.push(writer),
      registerReader: (reader) => readers.push(reader),
      registerDestroyer: (destroyer) => destroyers.push(destroyer),
      invalidateLayout: () => element.layoutCalculated = false,
      // access to data store
      dispatch: store.dispatch,
      query: store.query
    };
    const externalAPIDefinition = {
      element: {
        get: getElement2
      },
      childViews: {
        get: getChildViews
      },
      rect: {
        get: getRect
      },
      resting: {
        get: () => isResting
      },
      isRectIgnored: () => ignoreRect,
      _read,
      _write,
      _destroy
    };
    const mixinAPIDefinition = {
      ...sharedAPIDefinition,
      rect: {
        get: () => rect
      }
    };
    Object.keys(mixins).sort((a, b) => {
      if (a === "styles") {
        return 1;
      } else if (b === "styles") {
        return -1;
      }
      return 0;
    }).forEach((key) => {
      const mixinAPI = Mixins[key]({
        mixinConfig: mixins[key],
        viewProps: props,
        viewState: state2,
        viewInternalAPI: internalAPIDefinition,
        viewExternalAPI: externalAPIDefinition,
        view: createObject(mixinAPIDefinition)
      });
      if (mixinAPI) {
        activeMixins.push(mixinAPI);
      }
    });
    const internalAPI = createObject(internalAPIDefinition);
    create2({
      root: internalAPI,
      props
    });
    const childCount = getChildCount(element);
    childViews.forEach((child, index) => {
      internalAPI.appendChild(child.element, childCount + index);
    });
    didCreateView(internalAPI);
    return createObject(externalAPIDefinition);
  }
);
const createPainter = (read2, write2, fps = 60) => {
  const name2 = "__framePainter";
  if (window[name2]) {
    window[name2].readers.push(read2);
    window[name2].writers.push(write2);
    return;
  }
  window[name2] = {
    readers: [read2],
    writers: [write2]
  };
  const painter = window[name2];
  const interval = 1e3 / fps;
  let last = null;
  let id = null;
  let requestTick = null;
  let cancelTick = null;
  const setTimerType = () => {
    if (document.hidden) {
      requestTick = () => window.setTimeout(() => tick(performance.now()), interval);
      cancelTick = () => window.clearTimeout(id);
    } else {
      requestTick = () => window.requestAnimationFrame(tick);
      cancelTick = () => window.cancelAnimationFrame(id);
    }
  };
  document.addEventListener("visibilitychange", () => {
    if (cancelTick)
      cancelTick();
    setTimerType();
    tick(performance.now());
  });
  const tick = (ts) => {
    id = requestTick(tick);
    if (!last) {
      last = ts;
    }
    const delta = ts - last;
    if (delta <= interval) {
      return;
    }
    last = ts - delta % interval;
    painter.readers.forEach((read3) => read3());
    painter.writers.forEach((write3) => write3(ts));
  };
  setTimerType();
  tick(performance.now());
  return {
    pause: () => {
      cancelTick(id);
    }
  };
};
const createRoute = (routes, fn3) => ({ root: root2, props, actions: actions2 = [], timestamp, shouldOptimize }) => {
  actions2.filter((action) => routes[action.type]).forEach(
    (action) => routes[action.type]({ root: root2, props, action: action.data, timestamp, shouldOptimize })
  );
  if (fn3) {
    fn3({ root: root2, props, actions: actions2, timestamp, shouldOptimize });
  }
};
const insertBefore = (newNode, referenceNode) => referenceNode.parentNode.insertBefore(newNode, referenceNode);
const insertAfter = (newNode, referenceNode) => {
  return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
};
const isArray$1 = (value) => Array.isArray(value);
const isEmpty = (value) => value == null;
const trim$1 = (str) => str.trim();
const toString$1 = (value) => "" + value;
const toArray$1 = (value, splitter = ",") => {
  if (isEmpty(value)) {
    return [];
  }
  if (isArray$1(value)) {
    return value;
  }
  return toString$1(value).split(splitter).map(trim$1).filter((str) => str.length);
};
const isBoolean$1 = (value) => typeof value === "boolean";
const toBoolean = (value) => isBoolean$1(value) ? value : value === "true";
const isString$1 = (value) => typeof value === "string";
const toNumber = (value) => isNumber$1(value) ? value : isString$1(value) ? toString$1(value).replace(/[a-z]+/gi, "") : 0;
const toInt = (value) => parseInt(toNumber(value), 10);
const toFloat = (value) => parseFloat(toNumber(value));
const isInt = (value) => isNumber$1(value) && isFinite(value) && Math.floor(value) === value;
const toBytes = (value, base = 1e3) => {
  if (isInt(value)) {
    return value;
  }
  let naturalFileSize = toString$1(value).trim();
  if (/MB$/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/MB$i/, "").trim();
    return toInt(naturalFileSize) * base * base;
  }
  if (/KB/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/KB$i/, "").trim();
    return toInt(naturalFileSize) * base;
  }
  return toInt(naturalFileSize);
};
const isFunction$1 = (value) => typeof value === "function";
const toFunctionReference = (string) => {
  let ref = self;
  let levels = string.split(".");
  let level = null;
  while (level = levels.shift()) {
    ref = ref[level];
    if (!ref) {
      return null;
    }
  }
  return ref;
};
const methods = {
  process: "POST",
  patch: "PATCH",
  revert: "DELETE",
  fetch: "GET",
  restore: "GET",
  load: "GET"
};
const createServerAPI = (outline) => {
  const api = {};
  api.url = isString$1(outline) ? outline : outline.url || "";
  api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
  api.headers = outline.headers ? outline.headers : {};
  forin(methods, (key) => {
    api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);
  });
  api.process = outline.process || isString$1(outline) || outline.url ? api.process : null;
  api.remove = outline.remove || null;
  delete api.headers;
  return api;
};
const createAction = (name2, outline, method, timeout, headers) => {
  if (outline === null) {
    return null;
  }
  if (typeof outline === "function") {
    return outline;
  }
  const action = {
    url: method === "GET" || method === "PATCH" ? `?${name2}=` : "",
    method,
    headers,
    withCredentials: false,
    timeout,
    onload: null,
    ondata: null,
    onerror: null
  };
  if (isString$1(outline)) {
    action.url = outline;
    return action;
  }
  Object.assign(action, outline);
  if (isString$1(action.headers)) {
    const parts = action.headers.split(/:(.+)/);
    action.headers = {
      header: parts[0],
      value: parts[1]
    };
  }
  action.withCredentials = toBoolean(action.withCredentials);
  return action;
};
const toServerAPI = (value) => createServerAPI(value);
const isNull = (value) => value === null;
const isObject$1 = (value) => typeof value === "object" && value !== null;
const isAPI = (value) => {
  return isObject$1(value) && isString$1(value.url) && isObject$1(value.process) && isObject$1(value.revert) && isObject$1(value.restore) && isObject$1(value.fetch);
};
const getType = (value) => {
  if (isArray$1(value)) {
    return "array";
  }
  if (isNull(value)) {
    return "null";
  }
  if (isInt(value)) {
    return "int";
  }
  if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
    return "bytes";
  }
  if (isAPI(value)) {
    return "api";
  }
  return typeof value;
};
const replaceSingleQuotes = (str) => str.replace(/{\s*'/g, '{"').replace(/'\s*}/g, '"}').replace(/'\s*:/g, '":').replace(/:\s*'/g, ':"').replace(/,\s*'/g, ',"').replace(/'\s*,/g, '",');
const conversionTable = {
  array: toArray$1,
  boolean: toBoolean,
  int: (value) => getType(value) === "bytes" ? toBytes(value) : toInt(value),
  number: toFloat,
  float: toFloat,
  bytes: toBytes,
  string: (value) => isFunction$1(value) ? value : toString$1(value),
  function: (value) => toFunctionReference(value),
  serverapi: toServerAPI,
  object: (value) => {
    try {
      return JSON.parse(replaceSingleQuotes(value));
    } catch (e) {
      return null;
    }
  }
};
const convertTo = (value, type) => conversionTable[type](value);
const getValueByType = (newValue, defaultValue, valueType) => {
  if (newValue === defaultValue) {
    return newValue;
  }
  let newValueType = getType(newValue);
  if (newValueType !== valueType) {
    const convertedValue = convertTo(newValue, valueType);
    newValueType = getType(convertedValue);
    if (convertedValue === null) {
      throw `Trying to assign value with incorrect type to "${option}", allowed type: "${valueType}"`;
    } else {
      newValue = convertedValue;
    }
  }
  return newValue;
};
const createOption = (defaultValue, valueType) => {
  let currentValue = defaultValue;
  return {
    enumerable: true,
    get: () => currentValue,
    set: (newValue) => {
      currentValue = getValueByType(newValue, defaultValue, valueType);
    }
  };
};
const createOptions = (options) => {
  const obj = {};
  forin(options, (prop) => {
    const optionDefinition = options[prop];
    obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
  });
  return createObject(obj);
};
const createInitialState = (options) => ({
  // model
  items: [],
  // timeout used for calling update items
  listUpdateTimeout: null,
  // timeout used for stacking metadata updates
  itemUpdateTimeout: null,
  // queue of items waiting to be processed
  processingQueue: [],
  // options
  options: createOptions(options)
});
const fromCamels = (string, separator = "-") => string.split(/(?=[A-Z])/).map((part) => part.toLowerCase()).join(separator);
const createOptionAPI = (store, options) => {
  const obj = {};
  forin(options, (key) => {
    obj[key] = {
      get: () => store.getState().options[key],
      set: (value) => {
        store.dispatch(`SET_${fromCamels(key, "_").toUpperCase()}`, {
          value
        });
      }
    };
  });
  return obj;
};
const createOptionActions = (options) => (dispatch, query, state2) => {
  const obj = {};
  forin(options, (key) => {
    const name2 = fromCamels(key, "_").toUpperCase();
    obj[`SET_${name2}`] = (action) => {
      try {
        state2.options[key] = action.value;
      } catch (e) {
      }
      dispatch(`DID_SET_${name2}`, { value: state2.options[key] });
    };
  });
  return obj;
};
const createOptionQueries = (options) => (state2) => {
  const obj = {};
  forin(options, (key) => {
    obj[`GET_${fromCamels(key, "_").toUpperCase()}`] = (action) => state2.options[key];
  });
  return obj;
};
const InteractionMethod = {
  API: 1,
  DROP: 2,
  BROWSE: 3,
  PASTE: 4,
  NONE: 5
};
const getUniqueId$1 = () => Math.random().toString(36).substring(2, 11);
const arrayRemove = (arr, index) => arr.splice(index, 1);
const run = (cb, sync) => {
  if (sync) {
    cb();
  } else if (document.hidden) {
    Promise.resolve(1).then(cb);
  } else {
    setTimeout(cb, 0);
  }
};
const on = () => {
  const listeners2 = [];
  const off = (event, cb) => {
    arrayRemove(
      listeners2,
      listeners2.findIndex((listener) => listener.event === event && (listener.cb === cb || !cb))
    );
  };
  const fire = (event, args, sync) => {
    listeners2.filter((listener) => listener.event === event).map((listener) => listener.cb).forEach((cb) => run(() => cb(...args), sync));
  };
  return {
    fireSync: (event, ...args) => {
      fire(event, args, true);
    },
    fire: (event, ...args) => {
      fire(event, args, false);
    },
    on: (event, cb) => {
      listeners2.push({ event, cb });
    },
    onOnce: (event, cb) => {
      listeners2.push({
        event,
        cb: (...args) => {
          off(event, cb);
          cb(...args);
        }
      });
    },
    off
  };
};
const copyObjectPropertiesToObject = (src, target, excluded) => {
  Object.getOwnPropertyNames(src).filter((property) => !excluded.includes(property)).forEach(
    (key) => Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key))
  );
};
const PRIVATE = [
  "fire",
  "process",
  "revert",
  "load",
  "on",
  "off",
  "onOnce",
  "retryLoad",
  "extend",
  "archive",
  "archived",
  "release",
  "released",
  "requestProcessing",
  "freeze"
];
const createItemAPI = (item2) => {
  const api = {};
  copyObjectPropertiesToObject(item2, api, PRIVATE);
  return api;
};
const removeReleasedItems = (items) => {
  items.forEach((item2, index) => {
    if (item2.released) {
      arrayRemove(items, index);
    }
  });
};
const ItemStatus = {
  INIT: 1,
  IDLE: 2,
  PROCESSING_QUEUED: 9,
  PROCESSING: 3,
  PROCESSING_COMPLETE: 5,
  PROCESSING_ERROR: 6,
  PROCESSING_REVERT_ERROR: 10,
  LOADING: 7,
  LOAD_ERROR: 8
};
const FileOrigin = {
  INPUT: 1,
  LIMBO: 2,
  LOCAL: 3
};
const getNonNumeric = (str) => /[^0-9]+/.exec(str);
const getDecimalSeparator = () => getNonNumeric(1.1.toLocaleString())[0];
const getThousandsSeparator = () => {
  const decimalSeparator = getDecimalSeparator();
  const thousandsStringWithSeparator = 1e3.toLocaleString();
  const thousandsStringWithoutSeparator = 1e3.toString();
  if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
    return getNonNumeric(thousandsStringWithSeparator)[0];
  }
  return decimalSeparator === "." ? "," : ".";
};
const Type = {
  BOOLEAN: "boolean",
  INT: "int",
  NUMBER: "number",
  STRING: "string",
  ARRAY: "array",
  OBJECT: "object",
  FUNCTION: "function",
  ACTION: "action",
  SERVER_API: "serverapi",
  REGEX: "regex"
};
const filters = [];
const applyFilterChain = (key, value, utils2) => new Promise((resolve, reject) => {
  const matchingFilters = filters.filter((f) => f.key === key).map((f) => f.cb);
  if (matchingFilters.length === 0) {
    resolve(value);
    return;
  }
  const initialFilter = matchingFilters.shift();
  matchingFilters.reduce(
    // loop over promises passing value to next promise
    (current, next) => current.then((value2) => next(value2, utils2)),
    // call initial filter, will return a promise
    initialFilter(value, utils2)
    // all executed
  ).then((value2) => resolve(value2)).catch((error2) => reject(error2));
});
const applyFilters = (key, value, utils2) => filters.filter((f) => f.key === key).map((f) => f.cb(value, utils2));
const addFilter = (key, cb) => filters.push({ key, cb });
const extendDefaultOptions = (additionalOptions) => Object.assign(defaultOptions, additionalOptions);
const getOptions = () => ({ ...defaultOptions });
const setOptions = (opts) => {
  forin(opts, (key, value) => {
    if (!defaultOptions[key]) {
      return;
    }
    defaultOptions[key][0] = getValueByType(
      value,
      defaultOptions[key][0],
      defaultOptions[key][1]
    );
  });
};
const defaultOptions = {
  // the id to add to the root element
  id: [null, Type.STRING],
  // input field name to use
  name: ["filepond", Type.STRING],
  // disable the field
  disabled: [false, Type.BOOLEAN],
  // classname to put on wrapper
  className: [null, Type.STRING],
  // is the field required
  required: [false, Type.BOOLEAN],
  // Allow media capture when value is set
  captureMethod: [null, Type.STRING],
  // - "camera", "microphone" or "camcorder",
  // - Does not work with multiple on apple devices
  // - If set, acceptedFileTypes must be made to match with media wildcard "image/*", "audio/*" or "video/*"
  // sync `acceptedFileTypes` property with `accept` attribute
  allowSyncAcceptAttribute: [true, Type.BOOLEAN],
  // Feature toggles
  allowDrop: [true, Type.BOOLEAN],
  // Allow dropping of files
  allowBrowse: [true, Type.BOOLEAN],
  // Allow browsing the file system
  allowPaste: [true, Type.BOOLEAN],
  // Allow pasting files
  allowMultiple: [false, Type.BOOLEAN],
  // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)
  allowReplace: [true, Type.BOOLEAN],
  // Allow dropping a file on other file to replace it (only works when multiple is set to false)
  allowRevert: [true, Type.BOOLEAN],
  // Allows user to revert file upload
  allowRemove: [true, Type.BOOLEAN],
  // Allow user to remove a file
  allowProcess: [true, Type.BOOLEAN],
  // Allows user to process a file, when set to false, this removes the file upload button
  allowReorder: [false, Type.BOOLEAN],
  // Allow reordering of files
  allowDirectoriesOnly: [false, Type.BOOLEAN],
  // Allow only selecting directories with browse (no support for filtering dnd at this point)
  // Try store file if `server` not set
  storeAsFile: [false, Type.BOOLEAN],
  // Revert mode
  forceRevert: [false, Type.BOOLEAN],
  // Set to 'force' to require the file to be reverted before removal
  // Input requirements
  maxFiles: [null, Type.INT],
  // Max number of files
  checkValidity: [false, Type.BOOLEAN],
  // Enables custom validity messages
  // Where to put file
  itemInsertLocationFreedom: [true, Type.BOOLEAN],
  // Set to false to always add items to begin or end of list
  itemInsertLocation: ["before", Type.STRING],
  // Default index in list to add items that have been dropped at the top of the list
  itemInsertInterval: [75, Type.INT],
  // Drag 'n Drop related
  dropOnPage: [false, Type.BOOLEAN],
  // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)
  dropOnElement: [true, Type.BOOLEAN],
  // Drop needs to happen on element (set to false to also load drops outside of Up)
  dropValidation: [false, Type.BOOLEAN],
  // Enable or disable validating files on drop
  ignoredFiles: [[".ds_store", "thumbs.db", "desktop.ini"], Type.ARRAY],
  // Upload related
  instantUpload: [true, Type.BOOLEAN],
  // Should upload files immediately on drop
  maxParallelUploads: [2, Type.INT],
  // Maximum files to upload in parallel
  allowMinimumUploadDuration: [true, Type.BOOLEAN],
  // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened
  // Chunks
  chunkUploads: [false, Type.BOOLEAN],
  // Enable chunked uploads
  chunkForce: [false, Type.BOOLEAN],
  // Force use of chunk uploads even for files smaller than chunk size
  chunkSize: [5e6, Type.INT],
  // Size of chunks (5MB default)
  chunkRetryDelays: [[500, 1e3, 3e3], Type.ARRAY],
  // Amount of times to retry upload of a chunk when it fails
  // The server api end points to use for uploading (see docs)
  server: [null, Type.SERVER_API],
  // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000
  fileSizeBase: [1e3, Type.INT],
  // Labels and status messages
  labelFileSizeBytes: ["bytes", Type.STRING],
  labelFileSizeKilobytes: ["KB", Type.STRING],
  labelFileSizeMegabytes: ["MB", Type.STRING],
  labelFileSizeGigabytes: ["GB", Type.STRING],
  labelDecimalSeparator: [getDecimalSeparator(), Type.STRING],
  // Default is locale separator
  labelThousandsSeparator: [getThousandsSeparator(), Type.STRING],
  // Default is locale separator
  labelIdle: [
    'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
    Type.STRING
  ],
  labelInvalidField: ["Field contains invalid files", Type.STRING],
  labelFileWaitingForSize: ["Waiting for size", Type.STRING],
  labelFileSizeNotAvailable: ["Size not available", Type.STRING],
  labelFileCountSingular: ["file in list", Type.STRING],
  labelFileCountPlural: ["files in list", Type.STRING],
  labelFileLoading: ["Loading", Type.STRING],
  labelFileAdded: ["Added", Type.STRING],
  // assistive only
  labelFileLoadError: ["Error during load", Type.STRING],
  labelFileRemoved: ["Removed", Type.STRING],
  // assistive only
  labelFileRemoveError: ["Error during remove", Type.STRING],
  labelFileProcessing: ["Uploading", Type.STRING],
  labelFileProcessingComplete: ["Upload complete", Type.STRING],
  labelFileProcessingAborted: ["Upload cancelled", Type.STRING],
  labelFileProcessingError: ["Error during upload", Type.STRING],
  labelFileProcessingRevertError: ["Error during revert", Type.STRING],
  labelTapToCancel: ["tap to cancel", Type.STRING],
  labelTapToRetry: ["tap to retry", Type.STRING],
  labelTapToUndo: ["tap to undo", Type.STRING],
  labelButtonRemoveItem: ["Remove", Type.STRING],
  labelButtonAbortItemLoad: ["Abort", Type.STRING],
  labelButtonRetryItemLoad: ["Retry", Type.STRING],
  labelButtonAbortItemProcessing: ["Cancel", Type.STRING],
  labelButtonUndoItemProcessing: ["Undo", Type.STRING],
  labelButtonRetryItemProcessing: ["Retry", Type.STRING],
  labelButtonProcessItem: ["Upload", Type.STRING],
  // make sure width and height plus viewpox are even numbers so icons are nicely centered
  iconRemove: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconProcess: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
    Type.STRING
  ],
  iconRetry: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconUndo: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconDone: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  // event handlers
  oninit: [null, Type.FUNCTION],
  onwarning: [null, Type.FUNCTION],
  onerror: [null, Type.FUNCTION],
  onactivatefile: [null, Type.FUNCTION],
  oninitfile: [null, Type.FUNCTION],
  onaddfilestart: [null, Type.FUNCTION],
  onaddfileprogress: [null, Type.FUNCTION],
  onaddfile: [null, Type.FUNCTION],
  onprocessfilestart: [null, Type.FUNCTION],
  onprocessfileprogress: [null, Type.FUNCTION],
  onprocessfileabort: [null, Type.FUNCTION],
  onprocessfilerevert: [null, Type.FUNCTION],
  onprocessfile: [null, Type.FUNCTION],
  onprocessfiles: [null, Type.FUNCTION],
  onremovefile: [null, Type.FUNCTION],
  onpreparefile: [null, Type.FUNCTION],
  onupdatefiles: [null, Type.FUNCTION],
  onreorderfiles: [null, Type.FUNCTION],
  // hooks
  beforeDropFile: [null, Type.FUNCTION],
  beforeAddFile: [null, Type.FUNCTION],
  beforeRemoveFile: [null, Type.FUNCTION],
  beforePrepareFile: [null, Type.FUNCTION],
  // styles
  stylePanelLayout: [null, Type.STRING],
  // null 'integrated', 'compact', 'circle'
  stylePanelAspectRatio: [null, Type.STRING],
  // null or '3:2' or 1
  styleItemPanelAspectRatio: [null, Type.STRING],
  styleButtonRemoveItemPosition: ["left", Type.STRING],
  styleButtonProcessItemPosition: ["right", Type.STRING],
  styleLoadIndicatorPosition: ["right", Type.STRING],
  styleProgressIndicatorPosition: ["right", Type.STRING],
  styleButtonRemoveItemAlign: [false, Type.BOOLEAN],
  // custom initial files array
  files: [[], Type.ARRAY],
  // show support by displaying credits
  credits: [["https://pqina.nl/", "Powered by PQINA"], Type.ARRAY]
};
const getItemByQuery = (items, query) => {
  if (isEmpty(query)) {
    return items[0] || null;
  }
  if (isInt(query)) {
    return items[query] || null;
  }
  if (typeof query === "object") {
    query = query.id;
  }
  return items.find((item2) => item2.id === query) || null;
};
const getNumericAspectRatioFromString = (aspectRatio) => {
  if (isEmpty(aspectRatio)) {
    return aspectRatio;
  }
  if (/:/.test(aspectRatio)) {
    const parts = aspectRatio.split(":");
    return parts[1] / parts[0];
  }
  return parseFloat(aspectRatio);
};
const getActiveItems = (items) => items.filter((item2) => !item2.archived);
const Status = {
  EMPTY: 0,
  IDLE: 1,
  // waiting
  ERROR: 2,
  // a file is in error state
  BUSY: 3,
  // busy processing or loading
  READY: 4
  // all files uploaded
};
let res = null;
const canUpdateFileInput = () => {
  if (res === null) {
    try {
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(new File(["hello world"], "This_Works.txt"));
      const el = document.createElement("input");
      el.setAttribute("type", "file");
      el.files = dataTransfer.files;
      res = el.files.length === 1;
    } catch (err) {
      res = false;
    }
  }
  return res;
};
const ITEM_ERROR = [
  ItemStatus.LOAD_ERROR,
  ItemStatus.PROCESSING_ERROR,
  ItemStatus.PROCESSING_REVERT_ERROR
];
const ITEM_BUSY = [
  ItemStatus.LOADING,
  ItemStatus.PROCESSING,
  ItemStatus.PROCESSING_QUEUED,
  ItemStatus.INIT
];
const ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];
const isItemInErrorState = (item2) => ITEM_ERROR.includes(item2.status);
const isItemInBusyState = (item2) => ITEM_BUSY.includes(item2.status);
const isItemInReadyState = (item2) => ITEM_READY.includes(item2.status);
const isAsync = (state2) => isObject$1(state2.options.server) && (isObject$1(state2.options.server.process) || isFunction$1(state2.options.server.process));
const queries = (state2) => ({
  GET_STATUS: () => {
    const items = getActiveItems(state2.items);
    const { EMPTY, ERROR, BUSY, IDLE, READY } = Status;
    if (items.length === 0)
      return EMPTY;
    if (items.some(isItemInErrorState))
      return ERROR;
    if (items.some(isItemInBusyState))
      return BUSY;
    if (items.some(isItemInReadyState))
      return READY;
    return IDLE;
  },
  GET_ITEM: (query) => getItemByQuery(state2.items, query),
  GET_ACTIVE_ITEM: (query) => getItemByQuery(getActiveItems(state2.items), query),
  GET_ACTIVE_ITEMS: () => getActiveItems(state2.items),
  GET_ITEMS: () => state2.items,
  GET_ITEM_NAME: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.filename : null;
  },
  GET_ITEM_SIZE: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.fileSize : null;
  },
  GET_STYLES: () => Object.keys(state2.options).filter((key) => /^style/.test(key)).map((option2) => ({
    name: option2,
    value: state2.options[option2]
  })),
  GET_PANEL_ASPECT_RATIO: () => {
    const isShapeCircle = /circle/.test(state2.options.stylePanelLayout);
    const aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state2.options.stylePanelAspectRatio);
    return aspectRatio;
  },
  GET_ITEM_PANEL_ASPECT_RATIO: () => state2.options.styleItemPanelAspectRatio,
  GET_ITEMS_BY_STATUS: (status) => getActiveItems(state2.items).filter((item2) => item2.status === status),
  GET_TOTAL_ITEMS: () => getActiveItems(state2.items).length,
  SHOULD_UPDATE_FILE_INPUT: () => state2.options.storeAsFile && canUpdateFileInput() && !isAsync(state2),
  IS_ASYNC: () => isAsync(state2),
  GET_FILE_SIZE_LABELS: (query) => ({
    labelBytes: query("GET_LABEL_FILE_SIZE_BYTES") || void 0,
    labelKilobytes: query("GET_LABEL_FILE_SIZE_KILOBYTES") || void 0,
    labelMegabytes: query("GET_LABEL_FILE_SIZE_MEGABYTES") || void 0,
    labelGigabytes: query("GET_LABEL_FILE_SIZE_GIGABYTES") || void 0
  })
});
const hasRoomForItem = (state2) => {
  const count = getActiveItems(state2.items).length;
  if (!state2.options.allowMultiple) {
    return count === 0;
  }
  const maxFileCount = state2.options.maxFiles;
  if (maxFileCount === null) {
    return true;
  }
  if (count < maxFileCount) {
    return true;
  }
  return false;
};
const limit = (value, min2, max2) => Math.max(Math.min(max2, value), min2);
const arrayInsert = (arr, index, item2) => arr.splice(index, 0, item2);
const insertItem = (items, item2, index) => {
  if (isEmpty(item2)) {
    return null;
  }
  if (typeof index === "undefined") {
    items.push(item2);
    return item2;
  }
  index = limit(index, 0, items.length);
  arrayInsert(items, index, item2);
  return item2;
};
const isBase64DataURI = (str) => /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
  str
);
const getFilenameFromURL = (url) => url.split("/").pop().split("?").shift();
const getExtensionFromFilename = (name2) => name2.split(".").pop();
const guesstimateExtension = (type) => {
  if (typeof type !== "string") {
    return "";
  }
  const subtype = type.split("/").pop();
  if (/svg/.test(subtype)) {
    return "svg";
  }
  if (/zip|compressed/.test(subtype)) {
    return "zip";
  }
  if (/plain/.test(subtype)) {
    return "txt";
  }
  if (/msword/.test(subtype)) {
    return "doc";
  }
  if (/[a-z]+/.test(subtype)) {
    if (subtype === "jpeg") {
      return "jpg";
    }
    return subtype;
  }
  return "";
};
const leftPad = (value, padding = "") => (padding + value).slice(-padding.length);
const getDateString = (date = /* @__PURE__ */ new Date()) => `${date.getFullYear()}-${leftPad(date.getMonth() + 1, "00")}-${leftPad(
  date.getDate(),
  "00"
)}_${leftPad(date.getHours(), "00")}-${leftPad(date.getMinutes(), "00")}-${leftPad(
  date.getSeconds(),
  "00"
)}`;
const getFileFromBlob = (blob2, filename, type = null, extension = null) => {
  const file2 = typeof type === "string" ? blob2.slice(0, blob2.size, type) : blob2.slice(0, blob2.size, blob2.type);
  file2.lastModifiedDate = /* @__PURE__ */ new Date();
  if (blob2._relativePath)
    file2._relativePath = blob2._relativePath;
  if (!isString$1(filename)) {
    filename = getDateString();
  }
  if (filename && extension === null && getExtensionFromFilename(filename)) {
    file2.name = filename;
  } else {
    extension = extension || guesstimateExtension(file2.type);
    file2.name = filename + (extension ? "." + extension : "");
  }
  return file2;
};
const getBlobBuilder$1 = () => {
  return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
};
const createBlob$1 = (arrayBuffer, mimeType) => {
  const BB = getBlobBuilder$1();
  if (BB) {
    const bb = new BB();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeType);
  }
  return new Blob([arrayBuffer], {
    type: mimeType
  });
};
const getBlobFromByteStringWithMimeType = (byteString, mimeType) => {
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return createBlob$1(ab, mimeType);
};
const getMimeTypeFromBase64DataURI = (dataURI) => {
  return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
};
const getBase64DataFromBase64DataURI = (dataURI) => {
  const data2 = dataURI.split(",")[1];
  return data2.replace(/\s/g, "");
};
const getByteStringFromBase64DataURI = (dataURI) => {
  return atob(getBase64DataFromBase64DataURI(dataURI));
};
const getBlobFromBase64DataURI = (dataURI) => {
  const mimeType = getMimeTypeFromBase64DataURI(dataURI);
  const byteString = getByteStringFromBase64DataURI(dataURI);
  return getBlobFromByteStringWithMimeType(byteString, mimeType);
};
const getFileFromBase64DataURI = (dataURI, filename, extension) => {
  return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);
};
const getFileNameFromHeader = (header) => {
  if (!/^content-disposition:/i.test(header))
    return null;
  const matches = header.split(/filename=|filename\*=.+''/).splice(1).map((name2) => name2.trim().replace(/^["']|[;"']{0,2}$/g, "")).filter((name2) => name2.length);
  return matches.length ? decodeURI(matches[matches.length - 1]) : null;
};
const getFileSizeFromHeader = (header) => {
  if (/content-length:/i.test(header)) {
    const size = header.match(/[0-9]+/)[0];
    return size ? parseInt(size, 10) : null;
  }
  return null;
};
const getTranfserIdFromHeader = (header) => {
  if (/x-content-transfer-id:/i.test(header)) {
    const id = (header.split(":")[1] || "").trim();
    return id || null;
  }
  return null;
};
const getFileInfoFromHeaders = (headers) => {
  const info = {
    source: null,
    name: null,
    size: null
  };
  const rows = headers.split("\n");
  for (let header of rows) {
    const name2 = getFileNameFromHeader(header);
    if (name2) {
      info.name = name2;
      continue;
    }
    const size = getFileSizeFromHeader(header);
    if (size) {
      info.size = size;
      continue;
    }
    const source = getTranfserIdFromHeader(header);
    if (source) {
      info.source = source;
      continue;
    }
  }
  return info;
};
const createFileLoader = (fetchFn) => {
  const state2 = {
    source: null,
    complete: false,
    progress: 0,
    size: null,
    timestamp: null,
    duration: 0,
    request: null
  };
  const getProgress = () => state2.progress;
  const abort = () => {
    if (state2.request && state2.request.abort) {
      state2.request.abort();
    }
  };
  const load = () => {
    const source = state2.source;
    api.fire("init", source);
    if (source instanceof File) {
      api.fire("load", source);
    } else if (source instanceof Blob) {
      api.fire("load", getFileFromBlob(source, source.name));
    } else if (isBase64DataURI(source)) {
      api.fire("load", getFileFromBase64DataURI(source));
    } else {
      loadURL(source);
    }
  };
  const loadURL = (url) => {
    if (!fetchFn) {
      api.fire("error", {
        type: "error",
        body: "Can't load URL",
        code: 400
      });
      return;
    }
    state2.timestamp = Date.now();
    state2.request = fetchFn(
      url,
      (response) => {
        state2.duration = Date.now() - state2.timestamp;
        state2.complete = true;
        if (response instanceof Blob) {
          response = getFileFromBlob(response, response.name || getFilenameFromURL(url));
        }
        api.fire(
          "load",
          // if has received blob, we go with blob, if no response, we return null
          response instanceof Blob ? response : response ? response.body : null
        );
      },
      (error2) => {
        api.fire(
          "error",
          typeof error2 === "string" ? {
            type: "error",
            code: 0,
            body: error2
          } : error2
        );
      },
      (computable, current, total) => {
        if (total) {
          state2.size = total;
        }
        state2.duration = Date.now() - state2.timestamp;
        if (!computable) {
          state2.progress = null;
          return;
        }
        state2.progress = current / total;
        api.fire("progress", state2.progress);
      },
      () => {
        api.fire("abort");
      },
      (response) => {
        const fileinfo = getFileInfoFromHeaders(
          typeof response === "string" ? response : response.headers
        );
        api.fire("meta", {
          size: state2.size || fileinfo.size,
          filename: fileinfo.name,
          source: fileinfo.source
        });
      }
    );
  };
  const api = {
    ...on(),
    setSource: (source) => state2.source = source,
    getProgress,
    // file load progress
    abort,
    // abort file load
    load
    // start load
  };
  return api;
};
const isGet = (method) => /GET|HEAD/.test(method);
const sendRequest = (data2, url, options) => {
  const api = {
    onheaders: () => {
    },
    onprogress: () => {
    },
    onload: () => {
    },
    ontimeout: () => {
    },
    onerror: () => {
    },
    onabort: () => {
    },
    abort: () => {
      aborted = true;
      xhr.abort();
    }
  };
  let aborted = false;
  let headersReceived = false;
  options = {
    method: "POST",
    headers: {},
    withCredentials: false,
    ...options
  };
  url = encodeURI(url);
  if (isGet(options.method) && data2) {
    url = `${url}${encodeURIComponent(typeof data2 === "string" ? data2 : JSON.stringify(data2))}`;
  }
  const xhr = new XMLHttpRequest();
  const process = isGet(options.method) ? xhr : xhr.upload;
  process.onprogress = (e) => {
    if (aborted) {
      return;
    }
    api.onprogress(e.lengthComputable, e.loaded, e.total);
  };
  xhr.onreadystatechange = () => {
    if (xhr.readyState < 2) {
      return;
    }
    if (xhr.readyState === 4 && xhr.status === 0) {
      return;
    }
    if (headersReceived) {
      return;
    }
    headersReceived = true;
    api.onheaders(xhr);
  };
  xhr.onload = () => {
    if (xhr.status >= 200 && xhr.status < 300) {
      api.onload(xhr);
    } else {
      api.onerror(xhr);
    }
  };
  xhr.onerror = () => api.onerror(xhr);
  xhr.onabort = () => {
    aborted = true;
    api.onabort();
  };
  xhr.ontimeout = () => api.ontimeout(xhr);
  xhr.open(options.method, url, true);
  if (isInt(options.timeout)) {
    xhr.timeout = options.timeout;
  }
  Object.keys(options.headers).forEach((key) => {
    const value = unescape(encodeURIComponent(options.headers[key]));
    xhr.setRequestHeader(key, value);
  });
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.send(data2);
  return api;
};
const createResponse = (type, code, body, headers) => ({
  type,
  code,
  body,
  headers
});
const createTimeoutResponse = (cb) => (xhr) => {
  cb(createResponse("error", 0, "Timeout", xhr.getAllResponseHeaders()));
};
const hasQS = (str) => /\?/.test(str);
const buildURL$1 = (...parts) => {
  let url = "";
  parts.forEach((part) => {
    url += hasQS(url) && hasQS(part) ? part.replace(/\?/, "&") : part;
  });
  return url;
};
const createFetchFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString$1(action.url)) {
    return null;
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (url, load, error2, progress, abort, headers) => {
    const request = sendRequest(url, buildURL$1(apiUrl, action.url), {
      ...action,
      responseType: "blob"
    });
    request.onload = (xhr) => {
      const headers2 = xhr.getAllResponseHeaders();
      const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
      load(
        createResponse(
          "load",
          xhr.status,
          action.method === "HEAD" ? null : getFileFromBlob(onload(xhr.response), filename),
          headers2
        )
      );
    };
    request.onerror = (xhr) => {
      error2(
        createResponse(
          "error",
          xhr.status,
          onerror(xhr.response) || xhr.statusText,
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.onheaders = (xhr) => {
      headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
    };
    request.ontimeout = createTimeoutResponse(error2);
    request.onprogress = progress;
    request.onabort = abort;
    return request;
  };
};
const ChunkStatus = {
  QUEUED: 0,
  COMPLETE: 1,
  PROCESSING: 2,
  ERROR: 3,
  WAITING: 4
};
const processFileChunked = (apiUrl, action, name2, file2, metadata, load, error2, progress, abort, transfer, options) => {
  const chunks = [];
  const { chunkTransferId, chunkServer, chunkSize, chunkRetryDelays } = options;
  const state2 = {
    serverId: chunkTransferId,
    aborted: false
  };
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((xhr, method) => method === "HEAD" ? xhr.getResponseHeader("Upload-Offset") : xhr.response);
  const onerror = action.onerror || ((res2) => null);
  const requestTransferId = (cb) => {
    const formData = new FormData();
    if (isObject$1(metadata))
      formData.append(name2, JSON.stringify(metadata));
    const headers = typeof action.headers === "function" ? action.headers(file2, metadata) : {
      ...action.headers,
      "Upload-Length": file2.size
    };
    const requestParams = {
      ...action,
      headers
    };
    const request = sendRequest(ondata(formData), buildURL$1(apiUrl, action.url), requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
    request.ontimeout = createTimeoutResponse(error2);
  };
  const requestTransferOffset = (cb) => {
    const requestUrl = buildURL$1(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof action.headers === "function" ? action.headers(state2.serverId) : {
      ...action.headers
    };
    const requestParams = {
      headers,
      method: "HEAD"
    };
    const request = sendRequest(null, requestUrl, requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
    request.ontimeout = createTimeoutResponse(error2);
  };
  const lastChunkIndex = Math.floor(file2.size / chunkSize);
  for (let i = 0; i <= lastChunkIndex; i++) {
    const offset2 = i * chunkSize;
    const data2 = file2.slice(offset2, offset2 + chunkSize, "application/offset+octet-stream");
    chunks[i] = {
      index: i,
      size: data2.size,
      offset: offset2,
      data: data2,
      file: file2,
      progress: 0,
      retries: [...chunkRetryDelays],
      status: ChunkStatus.QUEUED,
      error: null,
      request: null,
      timeout: null
    };
  }
  const completeProcessingChunks = () => load(state2.serverId);
  const canProcessChunk = (chunk) => chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;
  const processChunk = (chunk) => {
    if (state2.aborted)
      return;
    chunk = chunk || chunks.find(canProcessChunk);
    if (!chunk) {
      if (chunks.every((chunk2) => chunk2.status === ChunkStatus.COMPLETE)) {
        completeProcessingChunks();
      }
      return;
    }
    chunk.status = ChunkStatus.PROCESSING;
    chunk.progress = null;
    const ondata2 = chunkServer.ondata || ((fd) => fd);
    const onerror2 = chunkServer.onerror || ((res2) => null);
    const requestUrl = buildURL$1(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof chunkServer.headers === "function" ? chunkServer.headers(chunk) : {
      ...chunkServer.headers,
      "Content-Type": "application/offset+octet-stream",
      "Upload-Offset": chunk.offset,
      "Upload-Length": file2.size,
      "Upload-Name": file2.name
    };
    const request = chunk.request = sendRequest(ondata2(chunk.data), requestUrl, {
      ...chunkServer,
      headers
    });
    request.onload = () => {
      chunk.status = ChunkStatus.COMPLETE;
      chunk.request = null;
      processChunks();
    };
    request.onprogress = (lengthComputable, loaded, total) => {
      chunk.progress = lengthComputable ? loaded : null;
      updateTotalProgress();
    };
    request.onerror = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      chunk.error = onerror2(xhr.response) || xhr.statusText;
      if (!retryProcessChunk(chunk)) {
        error2(
          createResponse(
            "error",
            xhr.status,
            onerror2(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      }
    };
    request.ontimeout = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      if (!retryProcessChunk(chunk)) {
        createTimeoutResponse(error2)(xhr);
      }
    };
    request.onabort = () => {
      chunk.status = ChunkStatus.QUEUED;
      chunk.request = null;
      abort();
    };
  };
  const retryProcessChunk = (chunk) => {
    if (chunk.retries.length === 0)
      return false;
    chunk.status = ChunkStatus.WAITING;
    clearTimeout(chunk.timeout);
    chunk.timeout = setTimeout(() => {
      processChunk(chunk);
    }, chunk.retries.shift());
    return true;
  };
  const updateTotalProgress = () => {
    const totalBytesTransfered = chunks.reduce((p, chunk) => {
      if (p === null || chunk.progress === null)
        return null;
      return p + chunk.progress;
    }, 0);
    if (totalBytesTransfered === null)
      return progress(false, 0, 0);
    const totalSize = chunks.reduce((total, chunk) => total + chunk.size, 0);
    progress(true, totalBytesTransfered, totalSize);
  };
  const processChunks = () => {
    const totalProcessing = chunks.filter((chunk) => chunk.status === ChunkStatus.PROCESSING).length;
    if (totalProcessing >= 1)
      return;
    processChunk();
  };
  const abortChunks = () => {
    chunks.forEach((chunk) => {
      clearTimeout(chunk.timeout);
      if (chunk.request) {
        chunk.request.abort();
      }
    });
  };
  if (!state2.serverId) {
    requestTransferId((serverId) => {
      if (state2.aborted)
        return;
      transfer(serverId);
      state2.serverId = serverId;
      processChunks();
    });
  } else {
    requestTransferOffset((offset2) => {
      if (state2.aborted)
        return;
      chunks.filter((chunk) => chunk.offset < offset2).forEach((chunk) => {
        chunk.status = ChunkStatus.COMPLETE;
        chunk.progress = chunk.size;
      });
      processChunks();
    });
  }
  return {
    abort: () => {
      state2.aborted = true;
      abortChunks();
    }
  };
};
const createFileProcessorFunction = (apiUrl, action, name2, options) => (file2, metadata, load, error2, progress, abort, transfer) => {
  if (!file2)
    return;
  const canChunkUpload = options.chunkUploads;
  const shouldChunkUpload = canChunkUpload && file2.size > options.chunkSize;
  const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);
  if (file2 instanceof Blob && willChunkUpload)
    return processFileChunked(
      apiUrl,
      action,
      name2,
      file2,
      metadata,
      load,
      error2,
      progress,
      abort,
      transfer,
      options
    );
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  const headers = typeof action.headers === "function" ? action.headers(file2, metadata) || {} : {
    ...action.headers
  };
  const requestParams = {
    ...action,
    headers
  };
  var formData = new FormData();
  if (isObject$1(metadata)) {
    formData.append(name2, JSON.stringify(metadata));
  }
  (file2 instanceof Blob ? [{ name: null, file: file2 }] : file2).forEach((item2) => {
    formData.append(
      name2,
      item2.file,
      item2.name === null ? item2.file.name : `${item2.name}${item2.file.name}`
    );
  });
  const request = sendRequest(ondata(formData), buildURL$1(apiUrl, action.url), requestParams);
  request.onload = (xhr) => {
    load(createResponse("load", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));
  };
  request.onerror = (xhr) => {
    error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
const createProcessorFunction = (apiUrl = "", action, name2, options) => {
  if (typeof action === "function")
    return (...params) => action(name2, ...params, options);
  if (!action || !isString$1(action.url))
    return null;
  return createFileProcessorFunction(apiUrl, action, name2, options);
};
const createRevertFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString$1(action.url)) {
    return (uniqueFileId, load) => load();
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (uniqueFileId, load, error2) => {
    const request = sendRequest(
      uniqueFileId,
      apiUrl + action.url,
      action
      // contains method, headers and withCredentials properties
    );
    request.onload = (xhr) => {
      load(
        createResponse(
          "load",
          xhr.status,
          onload(xhr.response),
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.onerror = (xhr) => {
      error2(
        createResponse(
          "error",
          xhr.status,
          onerror(xhr.response) || xhr.statusText,
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.ontimeout = createTimeoutResponse(error2);
    return request;
  };
};
const getRandomNumber = (min2 = 0, max2 = 1) => min2 + Math.random() * (max2 - min2);
const createPerceivedPerformanceUpdater = (cb, duration = 1e3, offset2 = 0, tickMin = 25, tickMax = 250) => {
  let timeout = null;
  const start2 = Date.now();
  const tick = () => {
    let runtime = Date.now() - start2;
    let delay = getRandomNumber(tickMin, tickMax);
    if (runtime + delay > duration) {
      delay = runtime + delay - duration;
    }
    let progress = runtime / duration;
    if (progress >= 1 || document.hidden) {
      cb(1);
      return;
    }
    cb(progress);
    timeout = setTimeout(tick, delay);
  };
  if (duration > 0)
    tick();
  return {
    clear: () => {
      clearTimeout(timeout);
    }
  };
};
const createFileProcessor = (processFn, options) => {
  const state2 = {
    complete: false,
    perceivedProgress: 0,
    perceivedPerformanceUpdater: null,
    progress: null,
    timestamp: null,
    perceivedDuration: 0,
    duration: 0,
    request: null,
    response: null
  };
  const { allowMinimumUploadDuration } = options;
  const process = (file2, metadata) => {
    const progressFn = () => {
      if (state2.duration === 0 || state2.progress === null)
        return;
      api.fire("progress", api.getProgress());
    };
    const completeFn = () => {
      state2.complete = true;
      api.fire("load-perceived", state2.response.body);
    };
    api.fire("start");
    state2.timestamp = Date.now();
    state2.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(
      (progress) => {
        state2.perceivedProgress = progress;
        state2.perceivedDuration = Date.now() - state2.timestamp;
        progressFn();
        if (state2.response && state2.perceivedProgress === 1 && !state2.complete) {
          completeFn();
        }
      },
      // random delay as in a list of files you start noticing
      // files uploading at the exact same speed
      allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0
    );
    state2.request = processFn(
      // the file to process
      file2,
      // the metadata to send along
      metadata,
      // callbacks (load, error, progress, abort, transfer)
      // load expects the body to be a server id if
      // you want to make use of revert
      (response) => {
        state2.response = isObject$1(response) ? response : {
          type: "load",
          code: 200,
          body: `${response}`,
          headers: {}
        };
        state2.duration = Date.now() - state2.timestamp;
        state2.progress = 1;
        api.fire("load", state2.response.body);
        if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state2.perceivedProgress === 1) {
          completeFn();
        }
      },
      // error is expected to be an object with type, code, body
      (error2) => {
        state2.perceivedPerformanceUpdater.clear();
        api.fire(
          "error",
          isObject$1(error2) ? error2 : {
            type: "error",
            code: 0,
            body: `${error2}`
          }
        );
      },
      // actual processing progress
      (computable, current, total) => {
        state2.duration = Date.now() - state2.timestamp;
        state2.progress = computable ? current / total : null;
        progressFn();
      },
      // abort does not expect a value
      () => {
        state2.perceivedPerformanceUpdater.clear();
        api.fire("abort", state2.response ? state2.response.body : null);
      },
      // register the id for this transfer
      (transferId) => {
        api.fire("transfer", transferId);
      }
    );
  };
  const abort = () => {
    if (!state2.request)
      return;
    state2.perceivedPerformanceUpdater.clear();
    if (state2.request.abort)
      state2.request.abort();
    state2.complete = true;
  };
  const reset = () => {
    abort();
    state2.complete = false;
    state2.perceivedProgress = 0;
    state2.progress = 0;
    state2.timestamp = null;
    state2.perceivedDuration = 0;
    state2.duration = 0;
    state2.request = null;
    state2.response = null;
  };
  const getProgress = allowMinimumUploadDuration ? () => state2.progress ? Math.min(state2.progress, state2.perceivedProgress) : null : () => state2.progress || null;
  const getDuration = allowMinimumUploadDuration ? () => Math.min(state2.duration, state2.perceivedDuration) : () => state2.duration;
  const api = {
    ...on(),
    process,
    // start processing file
    abort,
    // abort active process request
    getProgress,
    getDuration,
    reset
  };
  return api;
};
const getFilenameWithoutExtension$1 = (name2) => name2.substring(0, name2.lastIndexOf(".")) || name2;
const createFileStub = (source) => {
  let data2 = [source.name, source.size, source.type];
  if (source instanceof Blob || isBase64DataURI(source)) {
    data2[0] = source.name || getDateString();
  } else if (isBase64DataURI(source)) {
    data2[1] = source.length;
    data2[2] = getMimeTypeFromBase64DataURI(source);
  } else if (isString$1(source)) {
    data2[0] = getFilenameFromURL(source);
    data2[1] = 0;
    data2[2] = "application/octet-stream";
  }
  return {
    name: data2[0],
    size: data2[1],
    type: data2[2]
  };
};
const isFile$1 = (value) => !!(value instanceof File || value instanceof Blob && value.name);
const deepCloneObject = (src) => {
  if (!isObject$1(src))
    return src;
  const target = isArray$1(src) ? [] : {};
  for (const key in src) {
    if (!src.hasOwnProperty(key))
      continue;
    const v = src[key];
    target[key] = v && isObject$1(v) ? deepCloneObject(v) : v;
  }
  return target;
};
const createItem = (origin = null, serverFileReference = null, file2 = null) => {
  const id = getUniqueId$1();
  const state2 = {
    // is archived
    archived: false,
    // if is frozen, no longer fires events
    frozen: false,
    // removed from view
    released: false,
    // original source
    source: null,
    // file model reference
    file: file2,
    // id of file on server
    serverFileReference,
    // id of file transfer on server
    transferId: null,
    // is aborted
    processingAborted: false,
    // current item status
    status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,
    // active processes
    activeLoader: null,
    activeProcessor: null
  };
  let abortProcessingRequestComplete = null;
  const metadata = {};
  const setStatus = (status) => state2.status = status;
  const fire = (event, ...params) => {
    if (state2.released || state2.frozen)
      return;
    api.fire(event, ...params);
  };
  const getFileExtension = () => getExtensionFromFilename(state2.file.name);
  const getFileType = () => state2.file.type;
  const getFileSize = () => state2.file.size;
  const getFile = () => state2.file;
  const load = (source, loader, onload) => {
    state2.source = source;
    api.fireSync("init");
    if (state2.file) {
      api.fireSync("load-skip");
      return;
    }
    state2.file = createFileStub(source);
    loader.on("init", () => {
      fire("load-init");
    });
    loader.on("meta", (meta) => {
      state2.file.size = meta.size;
      state2.file.filename = meta.filename;
      if (meta.source) {
        origin = FileOrigin.LIMBO;
        state2.serverFileReference = meta.source;
        state2.status = ItemStatus.PROCESSING_COMPLETE;
      }
      fire("load-meta");
    });
    loader.on("progress", (progress) => {
      setStatus(ItemStatus.LOADING);
      fire("load-progress", progress);
    });
    loader.on("error", (error2) => {
      setStatus(ItemStatus.LOAD_ERROR);
      fire("load-request-error", error2);
    });
    loader.on("abort", () => {
      setStatus(ItemStatus.INIT);
      fire("load-abort");
    });
    loader.on("load", (file3) => {
      state2.activeLoader = null;
      const success = (result) => {
        state2.file = isFile$1(result) ? result : state2.file;
        if (origin === FileOrigin.LIMBO && state2.serverFileReference) {
          setStatus(ItemStatus.PROCESSING_COMPLETE);
        } else {
          setStatus(ItemStatus.IDLE);
        }
        fire("load");
      };
      const error2 = (result) => {
        state2.file = file3;
        fire("load-meta");
        setStatus(ItemStatus.LOAD_ERROR);
        fire("load-file-error", result);
      };
      if (state2.serverFileReference) {
        success(file3);
        return;
      }
      onload(file3, success, error2);
    });
    loader.setSource(source);
    state2.activeLoader = loader;
    loader.load();
  };
  const retryLoad = () => {
    if (!state2.activeLoader) {
      return;
    }
    state2.activeLoader.load();
  };
  const abortLoad = () => {
    if (state2.activeLoader) {
      state2.activeLoader.abort();
      return;
    }
    setStatus(ItemStatus.INIT);
    fire("load-abort");
  };
  const process = (processor, onprocess) => {
    if (state2.processingAborted) {
      state2.processingAborted = false;
      return;
    }
    setStatus(ItemStatus.PROCESSING);
    abortProcessingRequestComplete = null;
    if (!(state2.file instanceof Blob)) {
      api.on("load", () => {
        process(processor, onprocess);
      });
      return;
    }
    processor.on("load", (serverFileReference2) => {
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
    });
    processor.on("transfer", (transferId) => {
      state2.transferId = transferId;
    });
    processor.on("load-perceived", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.PROCESSING_COMPLETE);
      fire("process-complete", serverFileReference2);
    });
    processor.on("start", () => {
      fire("process-start");
    });
    processor.on("error", (error3) => {
      state2.activeProcessor = null;
      setStatus(ItemStatus.PROCESSING_ERROR);
      fire("process-error", error3);
    });
    processor.on("abort", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.IDLE);
      fire("process-abort");
      if (abortProcessingRequestComplete) {
        abortProcessingRequestComplete();
      }
    });
    processor.on("progress", (progress) => {
      fire("process-progress", progress);
    });
    const success = (file3) => {
      if (state2.archived)
        return;
      processor.process(file3, { ...metadata });
    };
    const error2 = console.error;
    onprocess(state2.file, success, error2);
    state2.activeProcessor = processor;
  };
  const requestProcessing = () => {
    state2.processingAborted = false;
    setStatus(ItemStatus.PROCESSING_QUEUED);
  };
  const abortProcessing = () => new Promise((resolve) => {
    if (!state2.activeProcessor) {
      state2.processingAborted = true;
      setStatus(ItemStatus.IDLE);
      fire("process-abort");
      resolve();
      return;
    }
    abortProcessingRequestComplete = () => {
      resolve();
    };
    state2.activeProcessor.abort();
  });
  const revert = (revertFileUpload, forceRevert) => new Promise((resolve, reject) => {
    const serverTransferId = state2.serverFileReference !== null ? state2.serverFileReference : state2.transferId;
    if (serverTransferId === null) {
      resolve();
      return;
    }
    revertFileUpload(
      serverTransferId,
      () => {
        state2.serverFileReference = null;
        state2.transferId = null;
        resolve();
      },
      (error2) => {
        if (!forceRevert) {
          resolve();
          return;
        }
        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
        fire("process-revert-error");
        reject(error2);
      }
    );
    setStatus(ItemStatus.IDLE);
    fire("process-revert");
  });
  const setMetadata = (key, value, silent) => {
    const keys = key.split(".");
    const root2 = keys[0];
    const last = keys.pop();
    let data2 = metadata;
    keys.forEach((key2) => data2 = data2[key2]);
    if (JSON.stringify(data2[last]) === JSON.stringify(value))
      return;
    data2[last] = value;
    fire("metadata-update", {
      key: root2,
      value: metadata[root2],
      silent
    });
  };
  const getMetadata = (key) => deepCloneObject(key ? metadata[key] : metadata);
  const api = {
    id: { get: () => id },
    origin: { get: () => origin, set: (value) => origin = value },
    serverId: { get: () => state2.serverFileReference },
    transferId: { get: () => state2.transferId },
    status: { get: () => state2.status },
    filename: { get: () => state2.file.name },
    filenameWithoutExtension: { get: () => getFilenameWithoutExtension$1(state2.file.name) },
    fileExtension: { get: getFileExtension },
    fileType: { get: getFileType },
    fileSize: { get: getFileSize },
    file: { get: getFile },
    relativePath: { get: () => state2.file._relativePath },
    source: { get: () => state2.source },
    getMetadata,
    setMetadata: (key, value, silent) => {
      if (isObject$1(key)) {
        const data2 = key;
        Object.keys(data2).forEach((key2) => {
          setMetadata(key2, data2[key2], value);
        });
        return key;
      }
      setMetadata(key, value, silent);
      return value;
    },
    extend: (name2, handler) => itemAPI[name2] = handler,
    abortLoad,
    retryLoad,
    requestProcessing,
    abortProcessing,
    load,
    process,
    revert,
    ...on(),
    freeze: () => state2.frozen = true,
    release: () => state2.released = true,
    released: { get: () => state2.released },
    archive: () => state2.archived = true,
    archived: { get: () => state2.archived }
  };
  const itemAPI = createObject(api);
  return itemAPI;
};
const getItemIndexByQuery = (items, query) => {
  if (isEmpty(query)) {
    return 0;
  }
  if (!isString$1(query)) {
    return -1;
  }
  return items.findIndex((item2) => item2.id === query);
};
const getItemById = (items, itemId) => {
  const index = getItemIndexByQuery(items, itemId);
  if (index < 0) {
    return;
  }
  return items[index] || null;
};
const fetchBlob = (url, load, error2, progress, abort, headers) => {
  const request = sendRequest(null, url, {
    method: "GET",
    responseType: "blob"
  });
  request.onload = (xhr) => {
    const headers2 = xhr.getAllResponseHeaders();
    const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
    load(createResponse("load", xhr.status, getFileFromBlob(xhr.response, filename), headers2));
  };
  request.onerror = (xhr) => {
    error2(createResponse("error", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));
  };
  request.onheaders = (xhr) => {
    headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
const getDomainFromURL = (url) => {
  if (url.indexOf("//") === 0) {
    url = location.protocol + url;
  }
  return url.toLowerCase().replace("blob:", "").replace(/([a-z])?:\/\//, "$1").split("/")[0];
};
const isExternalURL = (url) => (url.indexOf(":") > -1 || url.indexOf("//") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);
const dynamicLabel = (label) => (...params) => isFunction$1(label) ? label(...params) : label;
const isMockItem = (item2) => !isFile$1(item2.file);
const listUpdated = (dispatch, state2) => {
  clearTimeout(state2.listUpdateTimeout);
  state2.listUpdateTimeout = setTimeout(() => {
    dispatch("DID_UPDATE_ITEMS", { items: getActiveItems(state2.items) });
  }, 0);
};
const optionalPromise = (fn3, ...params) => new Promise((resolve) => {
  if (!fn3) {
    return resolve(true);
  }
  const result = fn3(...params);
  if (result == null) {
    return resolve(true);
  }
  if (typeof result === "boolean") {
    return resolve(result);
  }
  if (typeof result.then === "function") {
    result.then(resolve);
  }
});
const sortItems = (state2, compare) => {
  state2.items.sort((a, b) => compare(createItemAPI(a), createItemAPI(b)));
};
const getItemByQueryFromState = (state2, itemHandler) => ({
  query,
  success = () => {
  },
  failure = () => {
  },
  ...options
} = {}) => {
  const item2 = getItemByQuery(state2.items, query);
  if (!item2) {
    failure({
      error: createResponse("error", 0, "Item not found"),
      file: null
    });
    return;
  }
  itemHandler(item2, success, failure, options || {});
};
const actions = (dispatch, query, state2) => ({
  /**
   * Aborts all ongoing processes
   */
  ABORT_ALL: () => {
    getActiveItems(state2.items).forEach((item2) => {
      item2.freeze();
      item2.abortLoad();
      item2.abortProcessing();
    });
  },
  /**
   * Sets initial files
   */
  DID_SET_FILES: ({ value = [] }) => {
    const files = value.map((file2) => ({
      source: file2.source ? file2.source : file2,
      options: file2.options
    }));
    let activeItems = getActiveItems(state2.items);
    activeItems.forEach((item2) => {
      if (!files.find((file2) => file2.source === item2.source || file2.source === item2.file)) {
        dispatch("REMOVE_ITEM", { query: item2, remove: false });
      }
    });
    activeItems = getActiveItems(state2.items);
    files.forEach((file2, index) => {
      if (activeItems.find((item2) => item2.source === file2.source || item2.file === file2.source))
        return;
      dispatch("ADD_ITEM", {
        ...file2,
        interactionMethod: InteractionMethod.NONE,
        index
      });
    });
  },
  DID_UPDATE_ITEM_METADATA: ({ id, action, change }) => {
    if (change.silent)
      return;
    clearTimeout(state2.itemUpdateTimeout);
    state2.itemUpdateTimeout = setTimeout(() => {
      const item2 = getItemById(state2.items, id);
      if (!query("IS_ASYNC")) {
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {
          item: item2,
          query,
          action,
          change
        }).then((shouldPrepareOutput) => {
          const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
          if (beforePrepareFile)
            shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
          if (!shouldPrepareOutput)
            return;
          dispatch(
            "REQUEST_PREPARE_OUTPUT",
            {
              query: id,
              item: item2,
              success: (file2) => {
                dispatch("DID_PREPARE_OUTPUT", { id, file: file2 });
              }
            },
            true
          );
        });
        return;
      }
      if (item2.origin === FileOrigin.LOCAL) {
        dispatch("DID_LOAD_ITEM", {
          id: item2.id,
          error: null,
          serverFileReference: item2.source
        });
      }
      const upload = () => {
        setTimeout(() => {
          dispatch("REQUEST_ITEM_PROCESSING", { query: id });
        }, 32);
      };
      const revert = (doUpload) => {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        ).then(doUpload ? upload : () => {
        }).catch(() => {
        });
      };
      const abort = (doUpload) => {
        item2.abortProcessing().then(doUpload ? upload : () => {
        });
      };
      if (item2.status === ItemStatus.PROCESSING_COMPLETE) {
        return revert(state2.options.instantUpload);
      }
      if (item2.status === ItemStatus.PROCESSING) {
        return abort(state2.options.instantUpload);
      }
      if (state2.options.instantUpload) {
        upload();
      }
    }, 0);
  },
  MOVE_ITEM: ({ query: query2, index }) => {
    const item2 = getItemByQuery(state2.items, query2);
    if (!item2)
      return;
    const currentIndex = state2.items.indexOf(item2);
    index = limit(index, 0, state2.items.length - 1);
    if (currentIndex === index)
      return;
    state2.items.splice(index, 0, state2.items.splice(currentIndex, 1)[0]);
  },
  SORT: ({ compare }) => {
    sortItems(state2, compare);
    dispatch("DID_SORT_ITEMS", {
      items: query("GET_ACTIVE_ITEMS")
    });
  },
  ADD_ITEMS: ({ items, index, interactionMethod, success = () => {
  }, failure = () => {
  } }) => {
    let currentIndex = index;
    if (index === -1 || typeof index === "undefined") {
      const insertLocation = query("GET_ITEM_INSERT_LOCATION");
      const totalItems = query("GET_TOTAL_ITEMS");
      currentIndex = insertLocation === "before" ? 0 : totalItems;
    }
    const ignoredFiles = query("GET_IGNORED_FILES");
    const isValidFile = (source) => isFile$1(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);
    const validItems = items.filter(isValidFile);
    const promises = validItems.map(
      (source) => new Promise((resolve, reject) => {
        dispatch("ADD_ITEM", {
          interactionMethod,
          source: source.source || source,
          success: resolve,
          failure: reject,
          index: currentIndex++,
          options: source.options || {}
        });
      })
    );
    Promise.all(promises).then(success).catch(failure);
  },
  /**
   * @param source
   * @param index
   * @param interactionMethod
   */
  ADD_ITEM: ({
    source,
    index = -1,
    interactionMethod,
    success = () => {
    },
    failure = () => {
    },
    options = {}
  }) => {
    if (isEmpty(source)) {
      failure({
        error: createResponse("error", 0, "No source"),
        file: null
      });
      return;
    }
    if (isFile$1(source) && state2.options.ignoredFiles.includes(source.name.toLowerCase())) {
      return;
    }
    if (!hasRoomForItem(state2)) {
      if (state2.options.allowMultiple || !state2.options.allowMultiple && !state2.options.allowReplace) {
        const error2 = createResponse("warning", 0, "Max files");
        dispatch("DID_THROW_MAX_FILES", {
          source,
          error: error2
        });
        failure({ error: error2, file: null });
        return;
      }
      const item3 = getActiveItems(state2.items)[0];
      if (item3.status === ItemStatus.PROCESSING_COMPLETE || item3.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        const forceRevert = query("GET_FORCE_REVERT");
        item3.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          forceRevert
        ).then(() => {
          if (!forceRevert)
            return;
          dispatch("ADD_ITEM", {
            source,
            index,
            interactionMethod,
            success,
            failure,
            options
          });
        }).catch(() => {
        });
        if (forceRevert)
          return;
      }
      dispatch("REMOVE_ITEM", { query: item3.id });
    }
    const origin = options.type === "local" ? FileOrigin.LOCAL : options.type === "limbo" ? FileOrigin.LIMBO : FileOrigin.INPUT;
    const item2 = createItem(
      // where did this file come from
      origin,
      // an input file never has a server file reference
      origin === FileOrigin.INPUT ? null : source,
      // file mock data, if defined
      options.file
    );
    Object.keys(options.metadata || {}).forEach((key) => {
      item2.setMetadata(key, options.metadata[key]);
    });
    applyFilters("DID_CREATE_ITEM", item2, { query, dispatch });
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (!state2.options.itemInsertLocationFreedom) {
      index = itemInsertLocation === "before" ? -1 : state2.items.length;
    }
    insertItem(state2.items, item2, index);
    if (isFunction$1(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    const id = item2.id;
    item2.on("init", () => {
      dispatch("DID_INIT_ITEM", { id });
    });
    item2.on("load-init", () => {
      dispatch("DID_START_ITEM_LOAD", { id });
    });
    item2.on("load-meta", () => {
      dispatch("DID_UPDATE_ITEM_META", { id });
    });
    item2.on("load-progress", (progress) => {
      dispatch("DID_UPDATE_ITEM_LOAD_PROGRESS", { id, progress });
    });
    item2.on("load-request-error", (error2) => {
      const mainStatus = dynamicLabel(state2.options.labelFileLoadError)(error2);
      if (error2.code >= 400 && error2.code < 500) {
        dispatch("DID_THROW_ITEM_INVALID", {
          id,
          error: error2,
          status: {
            main: mainStatus,
            sub: `${error2.code} (${error2.body})`
          }
        });
        failure({ error: error2, file: createItemAPI(item2) });
        return;
      }
      dispatch("DID_THROW_ITEM_LOAD_ERROR", {
        id,
        error: error2,
        status: {
          main: mainStatus,
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("load-file-error", (error2) => {
      dispatch("DID_THROW_ITEM_INVALID", {
        id,
        error: error2.status,
        status: error2.status
      });
      failure({ error: error2.status, file: createItemAPI(item2) });
    });
    item2.on("load-abort", () => {
      dispatch("REMOVE_ITEM", { query: id });
    });
    item2.on("load-skip", () => {
      dispatch("COMPLETE_LOAD_ITEM", {
        query: id,
        item: item2,
        data: {
          source,
          success
        }
      });
    });
    item2.on("load", () => {
      const handleAdd = (shouldAdd) => {
        if (!shouldAdd) {
          dispatch("REMOVE_ITEM", {
            query: id
          });
          return;
        }
        item2.on("metadata-update", (change) => {
          dispatch("DID_UPDATE_ITEM_METADATA", { id, change });
        });
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, { item: item2, query }).then(
          (shouldPrepareOutput) => {
            const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
            if (beforePrepareFile)
              shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
            const loadComplete = () => {
              dispatch("COMPLETE_LOAD_ITEM", {
                query: id,
                item: item2,
                data: {
                  source,
                  success
                }
              });
              listUpdated(dispatch, state2);
            };
            if (shouldPrepareOutput) {
              dispatch(
                "REQUEST_PREPARE_OUTPUT",
                {
                  query: id,
                  item: item2,
                  success: (file2) => {
                    dispatch("DID_PREPARE_OUTPUT", { id, file: file2 });
                    loadComplete();
                  }
                },
                true
              );
              return;
            }
            loadComplete();
          }
        );
      };
      applyFilterChain("DID_LOAD_ITEM", item2, { query, dispatch }).then(() => {
        optionalPromise(query("GET_BEFORE_ADD_FILE"), createItemAPI(item2)).then(
          handleAdd
        );
      }).catch((e) => {
        if (!e || !e.error || !e.status)
          return handleAdd(false);
        dispatch("DID_THROW_ITEM_INVALID", {
          id,
          error: e.error,
          status: e.status
        });
      });
    });
    item2.on("process-start", () => {
      dispatch("DID_START_ITEM_PROCESSING", { id });
    });
    item2.on("process-progress", (progress) => {
      dispatch("DID_UPDATE_ITEM_PROCESS_PROGRESS", { id, progress });
    });
    item2.on("process-error", (error2) => {
      dispatch("DID_THROW_ITEM_PROCESSING_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-revert-error", (error2) => {
      dispatch("DID_THROW_ITEM_PROCESSING_REVERT_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingRevertError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-complete", (serverFileReference) => {
      dispatch("DID_COMPLETE_ITEM_PROCESSING", {
        id,
        error: null,
        serverFileReference
      });
      dispatch("DID_DEFINE_VALUE", { id, value: serverFileReference });
    });
    item2.on("process-abort", () => {
      dispatch("DID_ABORT_ITEM_PROCESSING", { id });
    });
    item2.on("process-revert", () => {
      dispatch("DID_REVERT_ITEM_PROCESSING", { id });
      dispatch("DID_DEFINE_VALUE", { id, value: null });
    });
    dispatch("DID_ADD_ITEM", { id, index, interactionMethod });
    listUpdated(dispatch, state2);
    const { url, load, restore, fetch: fetch2 } = state2.options.server || {};
    item2.load(
      source,
      // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)
      createFileLoader(
        origin === FileOrigin.INPUT ? (
          // input, if is remote, see if should use custom fetch, else use default fetchBlob
          isString$1(source) && isExternalURL(source) ? fetch2 ? createFetchFunction(url, fetch2) : fetchBlob : fetchBlob
        ) : (
          // limbo or local
          origin === FileOrigin.LIMBO ? createFetchFunction(url, restore) : createFetchFunction(url, load)
        )
        // local
      ),
      // called when the file is loaded so it can be piped through the filters
      (file2, success2, error2) => {
        applyFilterChain("LOAD_FILE", file2, { query }).then(success2).catch(error2);
      }
    );
  },
  REQUEST_PREPARE_OUTPUT: ({ item: item2, success, failure = () => {
  } }) => {
    const err = {
      error: createResponse("error", 0, "Item not found"),
      file: null
    };
    if (item2.archived)
      return failure(err);
    applyFilterChain("PREPARE_OUTPUT", item2.file, { query, item: item2 }).then((result) => {
      applyFilterChain("COMPLETE_PREPARE_OUTPUT", result, { query, item: item2 }).then((result2) => {
        if (item2.archived)
          return failure(err);
        success(result2);
      });
    });
  },
  COMPLETE_LOAD_ITEM: ({ item: item2, data: data2 }) => {
    const { success, source } = data2;
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (isFunction$1(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    dispatch("DID_LOAD_ITEM", {
      id: item2.id,
      error: null,
      serverFileReference: item2.origin === FileOrigin.INPUT ? null : source
    });
    success(createItemAPI(item2));
    if (item2.origin === FileOrigin.LOCAL) {
      dispatch("DID_LOAD_LOCAL_ITEM", { id: item2.id });
      return;
    }
    if (item2.origin === FileOrigin.LIMBO) {
      dispatch("DID_COMPLETE_ITEM_PROCESSING", {
        id: item2.id,
        error: null,
        serverFileReference: source
      });
      dispatch("DID_DEFINE_VALUE", {
        id: item2.id,
        value: item2.serverId || source
      });
      return;
    }
    if (query("IS_ASYNC") && state2.options.instantUpload) {
      dispatch("REQUEST_ITEM_PROCESSING", { query: item2.id });
    }
  },
  RETRY_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.retryLoad();
  }),
  REQUEST_ITEM_PREPARE: getItemByQueryFromState(state2, (item2, success, failure) => {
    dispatch(
      "REQUEST_PREPARE_OUTPUT",
      {
        query: item2.id,
        item: item2,
        success: (file2) => {
          dispatch("DID_PREPARE_OUTPUT", { id: item2.id, file: file2 });
          success({
            file: item2,
            output: file2
          });
        },
        failure
      },
      true
    );
  }),
  REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2, success, failure) => {
    const itemCanBeQueuedForProcessing = (
      // waiting for something
      item2.status === ItemStatus.IDLE || // processing went wrong earlier
      item2.status === ItemStatus.PROCESSING_ERROR
    );
    if (!itemCanBeQueuedForProcessing) {
      const processNow = () => dispatch("REQUEST_ITEM_PROCESSING", { query: item2, success, failure });
      const process = () => document.hidden ? processNow() : setTimeout(processNow, 32);
      if (item2.status === ItemStatus.PROCESSING_COMPLETE || item2.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        ).then(process).catch(() => {
        });
      } else if (item2.status === ItemStatus.PROCESSING) {
        item2.abortProcessing().then(process);
      }
      return;
    }
    if (item2.status === ItemStatus.PROCESSING_QUEUED)
      return;
    item2.requestProcessing();
    dispatch("DID_REQUEST_ITEM_PROCESSING", { id: item2.id });
    dispatch("PROCESS_ITEM", { query: item2, success, failure }, true);
  }),
  PROCESS_ITEM: getItemByQueryFromState(state2, (item2, success, failure) => {
    const maxParallelUploads = query("GET_MAX_PARALLEL_UPLOADS");
    const totalCurrentUploads = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING).length;
    if (totalCurrentUploads === maxParallelUploads) {
      state2.processingQueue.push({
        id: item2.id,
        success,
        failure
      });
      return;
    }
    if (item2.status === ItemStatus.PROCESSING)
      return;
    const processNext = () => {
      const queueEntry = state2.processingQueue.shift();
      if (!queueEntry)
        return;
      const { id, success: success2, failure: failure2 } = queueEntry;
      const itemReference = getItemByQuery(state2.items, id);
      if (!itemReference || itemReference.archived) {
        processNext();
        return;
      }
      dispatch("PROCESS_ITEM", { query: id, success: success2, failure: failure2 }, true);
    };
    item2.onOnce("process-complete", () => {
      success(createItemAPI(item2));
      processNext();
      const server = state2.options.server;
      const instantUpload = state2.options.instantUpload;
      if (instantUpload && item2.origin === FileOrigin.LOCAL && isFunction$1(server.remove)) {
        const noop2 = () => {
        };
        item2.origin = FileOrigin.LIMBO;
        state2.options.server.remove(item2.source, noop2, noop2);
      }
      const allItemsProcessed = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING_COMPLETE).length === state2.items.length;
      if (allItemsProcessed) {
        dispatch("DID_COMPLETE_ITEM_PROCESSING_ALL");
      }
    });
    item2.onOnce("process-error", (error2) => {
      failure({ error: error2, file: createItemAPI(item2) });
      processNext();
    });
    const options = state2.options;
    item2.process(
      createFileProcessor(
        createProcessorFunction(options.server.url, options.server.process, options.name, {
          chunkTransferId: item2.transferId,
          chunkServer: options.server.patch,
          chunkUploads: options.chunkUploads,
          chunkForce: options.chunkForce,
          chunkSize: options.chunkSize,
          chunkRetryDelays: options.chunkRetryDelays
        }),
        {
          allowMinimumUploadDuration: query("GET_ALLOW_MINIMUM_UPLOAD_DURATION")
        }
      ),
      // called when the file is about to be processed so it can be piped through the transform filters
      (file2, success2, error2) => {
        applyFilterChain("PREPARE_OUTPUT", file2, { query, item: item2 }).then((file3) => {
          dispatch("DID_PREPARE_OUTPUT", { id: item2.id, file: file3 });
          success2(file3);
        }).catch(error2);
      }
    );
  }),
  RETRY_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    dispatch("REQUEST_ITEM_PROCESSING", { query: item2 });
  }),
  REQUEST_REMOVE_ITEM: getItemByQueryFromState(state2, (item2) => {
    optionalPromise(query("GET_BEFORE_REMOVE_FILE"), createItemAPI(item2)).then((shouldRemove) => {
      if (!shouldRemove) {
        return;
      }
      dispatch("REMOVE_ITEM", { query: item2 });
    });
  }),
  RELEASE_ITEM: getItemByQueryFromState(state2, (item2) => {
    item2.release();
  }),
  REMOVE_ITEM: getItemByQueryFromState(state2, (item2, success, failure, options) => {
    const removeFromView = () => {
      const id = item2.id;
      getItemById(state2.items, id).archive();
      dispatch("DID_REMOVE_ITEM", { error: null, id, item: item2 });
      listUpdated(dispatch, state2);
      success(createItemAPI(item2));
    };
    const server = state2.options.server;
    if (item2.origin === FileOrigin.LOCAL && server && isFunction$1(server.remove) && options.remove !== false) {
      dispatch("DID_START_ITEM_REMOVE", { id: item2.id });
      server.remove(
        item2.source,
        () => removeFromView(),
        (status) => {
          dispatch("DID_THROW_ITEM_REMOVE_ERROR", {
            id: item2.id,
            error: createResponse("error", 0, status, null),
            status: {
              main: dynamicLabel(state2.options.labelFileRemoveError)(status),
              sub: state2.options.labelTapToRetry
            }
          });
        }
      );
    } else {
      if (options.revert && item2.origin !== FileOrigin.LOCAL && item2.serverId !== null || // if chunked uploads are enabled and we're uploading in chunks for this specific file
      // or if the file isn't big enough for chunked uploads but chunkForce is set then call
      // revert before removing from the view...
      state2.options.chunkUploads && item2.file.size > state2.options.chunkSize || state2.options.chunkUploads && state2.options.chunkForce) {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        );
      }
      removeFromView();
    }
  }),
  ABORT_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.abortLoad();
  }),
  ABORT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (item2.serverId) {
      dispatch("REVERT_ITEM_PROCESSING", { id: item2.id });
      return;
    }
    item2.abortProcessing().then(() => {
      const shouldRemove = state2.options.instantUpload;
      if (shouldRemove) {
        dispatch("REMOVE_ITEM", { query: item2.id });
      }
    });
  }),
  REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (!state2.options.instantUpload) {
      dispatch("REVERT_ITEM_PROCESSING", { query: item2 });
      return;
    }
    const handleRevert2 = (shouldRevert) => {
      if (!shouldRevert)
        return;
      dispatch("REVERT_ITEM_PROCESSING", { query: item2 });
    };
    const fn3 = query("GET_BEFORE_REMOVE_FILE");
    if (!fn3) {
      return handleRevert2(true);
    }
    const requestRemoveResult = fn3(createItemAPI(item2));
    if (requestRemoveResult == null) {
      return handleRevert2(true);
    }
    if (typeof requestRemoveResult === "boolean") {
      return handleRevert2(requestRemoveResult);
    }
    if (typeof requestRemoveResult.then === "function") {
      requestRemoveResult.then(handleRevert2);
    }
  }),
  REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    item2.revert(
      createRevertFunction(state2.options.server.url, state2.options.server.revert),
      query("GET_FORCE_REVERT")
    ).then(() => {
      const shouldRemove = state2.options.instantUpload || isMockItem(item2);
      if (shouldRemove) {
        dispatch("REMOVE_ITEM", { query: item2.id });
      }
    }).catch(() => {
    });
  }),
  SET_OPTIONS: ({ options }) => {
    const optionKeys = Object.keys(options);
    const prioritizedOptionKeys = PrioritizedOptions.filter((key) => optionKeys.includes(key));
    const orderedOptionKeys = [
      // add prioritized first if passed to options, else remove
      ...prioritizedOptionKeys,
      // prevent duplicate keys
      ...Object.keys(options).filter((key) => !prioritizedOptionKeys.includes(key))
    ];
    orderedOptionKeys.forEach((key) => {
      dispatch(`SET_${fromCamels(key, "_").toUpperCase()}`, {
        value: options[key]
      });
    });
  }
});
const PrioritizedOptions = [
  "server"
  // must be processed before "files"
];
const formatFilename = (name2) => name2;
const createElement$1 = (tagName) => {
  return document.createElement(tagName);
};
const text = (node, value) => {
  let textNode = node.childNodes[0];
  if (!textNode) {
    textNode = document.createTextNode(value);
    node.appendChild(textNode);
  } else if (value !== textNode.nodeValue) {
    textNode.nodeValue = value;
  }
};
const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
  const angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
};
const describeArc = (x, y, radius, startAngle, endAngle, arcSweep) => {
  const start2 = polarToCartesian(x, y, radius, endAngle);
  const end2 = polarToCartesian(x, y, radius, startAngle);
  return ["M", start2.x, start2.y, "A", radius, radius, 0, arcSweep, 0, end2.x, end2.y].join(" ");
};
const percentageArc = (x, y, radius, from, to) => {
  let arcSweep = 1;
  if (to > from && to - from <= 0.5) {
    arcSweep = 0;
  }
  if (from > to && from - to >= 0.5) {
    arcSweep = 0;
  }
  return describeArc(
    x,
    y,
    radius,
    Math.min(0.9999, from) * 360,
    Math.min(0.9999, to) * 360,
    arcSweep
  );
};
const create = ({ root: root2, props }) => {
  props.spin = false;
  props.progress = 0;
  props.opacity = 0;
  const svg2 = createElement("svg");
  root2.ref.path = createElement("path", {
    "stroke-width": 2,
    "stroke-linecap": "round"
  });
  svg2.appendChild(root2.ref.path);
  root2.ref.svg = svg2;
  root2.appendChild(svg2);
};
const write$1 = ({ root: root2, props }) => {
  if (props.opacity === 0) {
    return;
  }
  if (props.align) {
    root2.element.dataset.align = props.align;
  }
  const ringStrokeWidth = parseInt(attr(root2.ref.path, "stroke-width"), 10);
  const size = root2.rect.element.width * 0.5;
  let ringFrom = 0;
  let ringTo = 0;
  if (props.spin) {
    ringFrom = 0;
    ringTo = 0.5;
  } else {
    ringFrom = 0;
    ringTo = props.progress;
  }
  const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);
  attr(root2.ref.path, "d", coordinates);
  attr(root2.ref.path, "stroke-opacity", props.spin || props.progress > 0 ? 1 : 0);
};
const progressIndicator = createView({
  tag: "div",
  name: "progress-indicator",
  ignoreRectUpdate: true,
  ignoreRect: true,
  create,
  write: write$1,
  mixins: {
    apis: ["progress", "spin", "align"],
    styles: ["opacity"],
    animations: {
      opacity: { type: "tween", duration: 500 },
      progress: {
        type: "spring",
        stiffness: 0.95,
        damping: 0.65,
        mass: 10
      }
    }
  }
});
const create$1 = ({ root: root2, props }) => {
  root2.element.innerHTML = (props.icon || "") + `<span>${props.label}</span>`;
  props.isDisabled = false;
};
const write$1$1 = ({ root: root2, props }) => {
  const { isDisabled: isDisabled2 } = props;
  const shouldDisable = root2.query("GET_DISABLED") || props.opacity === 0;
  if (shouldDisable && !isDisabled2) {
    props.isDisabled = true;
    attr(root2.element, "disabled", "disabled");
  } else if (!shouldDisable && isDisabled2) {
    props.isDisabled = false;
    root2.element.removeAttribute("disabled");
  }
};
const fileActionButton = createView({
  tag: "button",
  attributes: {
    type: "button"
  },
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "file-action-button",
  mixins: {
    apis: ["label"],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: { type: "tween", duration: 250 }
    },
    listeners: true
  },
  create: create$1,
  write: write$1$1
});
const toNaturalFileSize = (bytes, decimalSeparator = ".", base = 1e3, options = {}) => {
  const {
    labelBytes = "bytes",
    labelKilobytes = "KB",
    labelMegabytes = "MB",
    labelGigabytes = "GB"
  } = options;
  bytes = Math.round(Math.abs(bytes));
  const KB = base;
  const MB = base * base;
  const GB = base * base * base;
  if (bytes < KB) {
    return `${bytes} ${labelBytes}`;
  }
  if (bytes < MB) {
    return `${Math.floor(bytes / KB)} ${labelKilobytes}`;
  }
  if (bytes < GB) {
    return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;
  }
  return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;
};
const removeDecimalsWhenZero = (value, decimalCount, separator) => {
  return value.toFixed(decimalCount).split(".").filter((part) => part !== "0").join(separator);
};
const create$2 = ({ root: root2, props }) => {
  const fileName = createElement$1("span");
  fileName.className = "filepond--file-info-main";
  attr(fileName, "aria-hidden", "true");
  root2.appendChild(fileName);
  root2.ref.fileName = fileName;
  const fileSize = createElement$1("span");
  fileSize.className = "filepond--file-info-sub";
  root2.appendChild(fileSize);
  root2.ref.fileSize = fileSize;
  text(fileSize, root2.query("GET_LABEL_FILE_WAITING_FOR_SIZE"));
  text(fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const updateFile = ({ root: root2, props }) => {
  text(
    root2.ref.fileSize,
    toNaturalFileSize(
      root2.query("GET_ITEM_SIZE", props.id),
      ".",
      root2.query("GET_FILE_SIZE_BASE"),
      root2.query("GET_FILE_SIZE_LABELS", root2.query)
    )
  );
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const updateFileSizeOnError = ({ root: root2, props }) => {
  if (isInt(root2.query("GET_ITEM_SIZE", props.id))) {
    updateFile({ root: root2, props });
    return;
  }
  text(root2.ref.fileSize, root2.query("GET_LABEL_FILE_SIZE_NOT_AVAILABLE"));
};
const fileInfo = createView({
  name: "file-info",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: updateFile,
    DID_UPDATE_ITEM_META: updateFile,
    DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
    DID_THROW_ITEM_INVALID: updateFileSizeOnError
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  create: create$2,
  mixins: {
    styles: ["translateX", "translateY"],
    animations: {
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const toPercentage = (value) => Math.round(value * 100);
const create$3 = ({ root: root2 }) => {
  const main2 = createElement$1("span");
  main2.className = "filepond--file-status-main";
  root2.appendChild(main2);
  root2.ref.main = main2;
  const sub = createElement$1("span");
  sub.className = "filepond--file-status-sub";
  root2.appendChild(sub);
  root2.ref.sub = sub;
  didSetItemLoadProgress({ root: root2, action: { progress: null } });
};
const didSetItemLoadProgress = ({ root: root2, action }) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_LOADING") : `${root2.query("GET_LABEL_FILE_LOADING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didSetItemProcessProgress = ({ root: root2, action }) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_PROCESSING") : `${root2.query("GET_LABEL_FILE_PROCESSING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didRequestItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didAbortItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_ABORTED"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_RETRY"));
};
const didCompleteItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_UNDO"));
};
const clear = ({ root: root2 }) => {
  text(root2.ref.main, "");
  text(root2.ref.sub, "");
};
const error = ({ root: root2, action }) => {
  text(root2.ref.main, action.status.main);
  text(root2.ref.sub, action.status.sub);
};
const fileStatus = createView({
  name: "file-status",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: clear,
    DID_REVERT_ITEM_PROCESSING: clear,
    DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
    DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
    DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
    DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
    DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
    DID_THROW_ITEM_LOAD_ERROR: error,
    DID_THROW_ITEM_INVALID: error,
    DID_THROW_ITEM_PROCESSING_ERROR: error,
    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
    DID_THROW_ITEM_REMOVE_ERROR: error
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  create: create$3,
  mixins: {
    styles: ["translateX", "translateY", "opacity"],
    animations: {
      opacity: { type: "tween", duration: 250 },
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const Buttons = {
  AbortItemLoad: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_LOAD",
    action: "ABORT_ITEM_LOAD",
    className: "filepond--action-abort-item-load",
    align: "LOAD_INDICATOR_POSITION"
    // right
  },
  RetryItemLoad: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_LOAD",
    action: "RETRY_ITEM_LOAD",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-load",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RemoveItem: {
    label: "GET_LABEL_BUTTON_REMOVE_ITEM",
    action: "REQUEST_REMOVE_ITEM",
    icon: "GET_ICON_REMOVE",
    className: "filepond--action-remove-item",
    align: "BUTTON_REMOVE_ITEM_POSITION"
    // left
  },
  ProcessItem: {
    label: "GET_LABEL_BUTTON_PROCESS_ITEM",
    action: "REQUEST_ITEM_PROCESSING",
    icon: "GET_ICON_PROCESS",
    className: "filepond--action-process-item",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  AbortItemProcessing: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING",
    action: "ABORT_ITEM_PROCESSING",
    className: "filepond--action-abort-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RetryItemProcessing: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING",
    action: "RETRY_ITEM_PROCESSING",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RevertItemProcessing: {
    label: "GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING",
    action: "REQUEST_REVERT_ITEM_PROCESSING",
    icon: "GET_ICON_UNDO",
    className: "filepond--action-revert-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  }
};
const ButtonKeys = [];
forin(Buttons, (key) => {
  ButtonKeys.push(key);
});
const calculateFileInfoOffset = (root2) => {
  if (getRemoveIndicatorAligment(root2) === "right")
    return 0;
  const buttonRect = root2.ref.buttonRemoveItem.rect.element;
  return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
};
const calculateButtonWidth = (root2) => {
  const buttonRect = root2.ref.buttonAbortItemLoad.rect.element;
  return buttonRect.width;
};
const calculateFileVerticalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.height / 4);
const calculateFileHorizontalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.left / 2);
const getLoadIndicatorAlignment = (root2) => root2.query("GET_STYLE_LOAD_INDICATOR_POSITION");
const getProcessIndicatorAlignment = (root2) => root2.query("GET_STYLE_PROGRESS_INDICATOR_POSITION");
const getRemoveIndicatorAligment = (root2) => root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_POSITION");
const DefaultStyle = {
  buttonAbortItemLoad: { opacity: 0 },
  buttonRetryItemLoad: { opacity: 0 },
  buttonRemoveItem: { opacity: 0 },
  buttonProcessItem: { opacity: 0 },
  buttonAbortItemProcessing: { opacity: 0 },
  buttonRetryItemProcessing: { opacity: 0 },
  buttonRevertItemProcessing: { opacity: 0 },
  loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },
  processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },
  processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },
  info: { translateX: 0, translateY: 0, opacity: 0 },
  status: { translateX: 0, translateY: 0, opacity: 0 }
};
const IdleStyle = {
  buttonRemoveItem: { opacity: 1 },
  buttonProcessItem: { opacity: 1 },
  info: { translateX: calculateFileInfoOffset },
  status: { translateX: calculateFileInfoOffset }
};
const ProcessingStyle = {
  buttonAbortItemProcessing: { opacity: 1 },
  processProgressIndicator: { opacity: 1 },
  status: { opacity: 1 }
};
const StyleMap = {
  DID_THROW_ITEM_INVALID: {
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { translateX: calculateFileInfoOffset, opacity: 1 }
  },
  DID_START_ITEM_LOAD: {
    buttonAbortItemLoad: { opacity: 1 },
    loadProgressIndicator: { opacity: 1 },
    status: { opacity: 1 }
  },
  DID_THROW_ITEM_LOAD_ERROR: {
    buttonRetryItemLoad: { opacity: 1 },
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1 }
  },
  DID_START_ITEM_REMOVE: {
    processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 0 }
  },
  DID_THROW_ITEM_REMOVE_ERROR: {
    processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1, translateX: calculateFileInfoOffset }
  },
  DID_LOAD_ITEM: IdleStyle,
  DID_LOAD_LOCAL_ITEM: {
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { translateX: calculateFileInfoOffset }
  },
  DID_START_ITEM_PROCESSING: ProcessingStyle,
  DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
  DID_COMPLETE_ITEM_PROCESSING: {
    buttonRevertItemProcessing: { opacity: 1 },
    info: { opacity: 1 },
    status: { opacity: 1 }
  },
  DID_THROW_ITEM_PROCESSING_ERROR: {
    buttonRemoveItem: { opacity: 1 },
    buttonRetryItemProcessing: { opacity: 1 },
    status: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset }
  },
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
    buttonRevertItemProcessing: { opacity: 1 },
    status: { opacity: 1 },
    info: { opacity: 1 }
  },
  DID_ABORT_ITEM_PROCESSING: {
    buttonRemoveItem: { opacity: 1 },
    buttonProcessItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1 }
  },
  DID_REVERT_ITEM_PROCESSING: IdleStyle
};
const processingCompleteIndicatorView = createView({
  create: ({ root: root2 }) => {
    root2.element.innerHTML = root2.query("GET_ICON_DONE");
  },
  name: "processing-complete-indicator",
  ignoreRect: true,
  mixins: {
    styles: ["scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      opacity: { type: "tween", duration: 250 }
    }
  }
});
const create$4 = ({ root: root2, props }) => {
  const LocalButtons = Object.keys(Buttons).reduce((prev, curr) => {
    prev[curr] = { ...Buttons[curr] };
    return prev;
  }, {});
  const { id } = props;
  const allowRevert = root2.query("GET_ALLOW_REVERT");
  const allowRemove = root2.query("GET_ALLOW_REMOVE");
  const allowProcess = root2.query("GET_ALLOW_PROCESS");
  const instantUpload = root2.query("GET_INSTANT_UPLOAD");
  const isAsync2 = root2.query("IS_ASYNC");
  const alignRemoveItemButton = root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN");
  let buttonFilter;
  if (isAsync2) {
    if (allowProcess && !allowRevert) {
      buttonFilter = (key) => !/RevertItemProcessing/.test(key);
    } else if (!allowProcess && allowRevert) {
      buttonFilter = (key) => !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);
    } else if (!allowProcess && !allowRevert) {
      buttonFilter = (key) => !/Process/.test(key);
    }
  } else {
    buttonFilter = (key) => !/Process/.test(key);
  }
  const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();
  if (instantUpload && allowRevert) {
    LocalButtons["RevertItemProcessing"].label = "GET_LABEL_BUTTON_REMOVE_ITEM";
    LocalButtons["RevertItemProcessing"].icon = "GET_ICON_REMOVE";
  }
  if (isAsync2 && !allowRevert) {
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileHorizontalCenterOffset;
    map2.info.translateY = calculateFileVerticalCenterOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
  }
  if (isAsync2 && !allowProcess) {
    [
      "DID_START_ITEM_PROCESSING",
      "DID_REQUEST_ITEM_PROCESSING",
      "DID_UPDATE_ITEM_PROCESS_PROGRESS",
      "DID_THROW_ITEM_PROCESSING_ERROR"
    ].forEach((key) => {
      StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
    });
    StyleMap["DID_THROW_ITEM_PROCESSING_ERROR"].status.translateX = calculateButtonWidth;
  }
  if (alignRemoveItemButton && allowRevert) {
    LocalButtons["RevertItemProcessing"].align = "BUTTON_REMOVE_ITEM_POSITION";
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileInfoOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
  }
  if (!allowRemove) {
    LocalButtons["RemoveItem"].disabled = true;
  }
  forin(LocalButtons, (key, definition) => {
    const buttonView = root2.createChildView(fileActionButton, {
      label: root2.query(definition.label),
      icon: root2.query(definition.icon),
      opacity: 0
    });
    if (enabledButtons.includes(key)) {
      root2.appendChildView(buttonView);
    }
    if (definition.disabled) {
      buttonView.element.setAttribute("disabled", "disabled");
      buttonView.element.setAttribute("hidden", "hidden");
    }
    buttonView.element.dataset.align = root2.query(`GET_STYLE_${definition.align}`);
    buttonView.element.classList.add(definition.className);
    buttonView.on("click", (e) => {
      e.stopPropagation();
      if (definition.disabled)
        return;
      root2.dispatch(definition.action, { query: id });
    });
    root2.ref[`button${key}`] = buttonView;
  });
  root2.ref.processingCompleteIndicator = root2.appendChildView(
    root2.createChildView(processingCompleteIndicatorView)
  );
  root2.ref.processingCompleteIndicator.element.dataset.align = root2.query(
    `GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`
  );
  root2.ref.info = root2.appendChildView(root2.createChildView(fileInfo, { id }));
  root2.ref.status = root2.appendChildView(root2.createChildView(fileStatus, { id }));
  const loadIndicatorView = root2.appendChildView(
    root2.createChildView(progressIndicator, {
      opacity: 0,
      align: root2.query(`GET_STYLE_LOAD_INDICATOR_POSITION`)
    })
  );
  loadIndicatorView.element.classList.add("filepond--load-indicator");
  root2.ref.loadProgressIndicator = loadIndicatorView;
  const progressIndicatorView = root2.appendChildView(
    root2.createChildView(progressIndicator, {
      opacity: 0,
      align: root2.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`)
    })
  );
  progressIndicatorView.element.classList.add("filepond--process-indicator");
  root2.ref.processProgressIndicator = progressIndicatorView;
  root2.ref.activeStyles = [];
};
const write$2 = ({ root: root2, actions: actions2, props }) => {
  route({ root: root2, actions: actions2, props });
  let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StyleMap[action2.type]);
  if (action) {
    root2.ref.activeStyles = [];
    const stylesToApply = StyleMap[action.type];
    forin(DefaultStyle, (name2, defaultStyles) => {
      const control = root2.ref[name2];
      forin(defaultStyles, (key, defaultValue) => {
        const value = stylesToApply[name2] && typeof stylesToApply[name2][key] !== "undefined" ? stylesToApply[name2][key] : defaultValue;
        root2.ref.activeStyles.push({ control, key, value });
      });
    });
  }
  root2.ref.activeStyles.forEach(({ control, key, value }) => {
    control[key] = typeof value === "function" ? value(root2) : value;
  });
};
const route = createRoute({
  DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemProcessing.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemLoad.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemRemoval.label = action.value;
  },
  DID_REQUEST_ITEM_PROCESSING: ({ root: root2 }) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_START_ITEM_LOAD: ({ root: root2 }) => {
    root2.ref.loadProgressIndicator.spin = true;
    root2.ref.loadProgressIndicator.progress = 0;
  },
  DID_START_ITEM_REMOVE: ({ root: root2 }) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_UPDATE_ITEM_LOAD_PROGRESS: ({ root: root2, action }) => {
    root2.ref.loadProgressIndicator.spin = false;
    root2.ref.loadProgressIndicator.progress = action.progress;
  },
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ({ root: root2, action }) => {
    root2.ref.processProgressIndicator.spin = false;
    root2.ref.processProgressIndicator.progress = action.progress;
  }
});
const file = createView({
  create: create$4,
  write: write$2,
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  name: "file"
});
const create$5 = ({ root: root2, props }) => {
  root2.ref.fileName = createElement$1("legend");
  root2.appendChild(root2.ref.fileName);
  root2.ref.file = root2.appendChildView(root2.createChildView(file, { id: props.id }));
  root2.ref.data = false;
};
const didLoadItem = ({ root: root2, props }) => {
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const fileWrapper = createView({
  create: create$5,
  ignoreRect: true,
  write: createRoute({
    DID_LOAD_ITEM: didLoadItem
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  tag: "fieldset",
  name: "file-wrapper"
});
const PANEL_SPRING_PROPS = { type: "spring", damping: 0.6, mass: 7 };
const create$6 = ({ root: root2, props }) => {
  [
    {
      name: "top"
    },
    {
      name: "center",
      props: {
        translateY: null,
        scaleY: null
      },
      mixins: {
        animations: {
          scaleY: PANEL_SPRING_PROPS
        },
        styles: ["translateY", "scaleY"]
      }
    },
    {
      name: "bottom",
      props: {
        translateY: null
      },
      mixins: {
        animations: {
          translateY: PANEL_SPRING_PROPS
        },
        styles: ["translateY"]
      }
    }
  ].forEach((section) => {
    createSection(root2, section, props.name);
  });
  root2.element.classList.add(`filepond--${props.name}`);
  root2.ref.scalable = null;
};
const createSection = (root2, section, className) => {
  const viewConstructor = createView({
    name: `panel-${section.name} filepond--${className}`,
    mixins: section.mixins,
    ignoreRectUpdate: true
  });
  const view = root2.createChildView(viewConstructor, section.props);
  root2.ref[section.name] = root2.appendChildView(view);
};
const write$3 = ({ root: root2, props }) => {
  if (root2.ref.scalable === null || props.scalable !== root2.ref.scalable) {
    root2.ref.scalable = isBoolean$1(props.scalable) ? props.scalable : true;
    root2.element.dataset.scalable = root2.ref.scalable;
  }
  if (!props.height)
    return;
  const topRect = root2.ref.top.rect.element;
  const bottomRect = root2.ref.bottom.rect.element;
  const height2 = Math.max(topRect.height + bottomRect.height, props.height);
  root2.ref.center.translateY = topRect.height;
  root2.ref.center.scaleY = (height2 - topRect.height - bottomRect.height) / 100;
  root2.ref.bottom.translateY = height2 - bottomRect.height;
};
const panel = createView({
  name: "panel",
  read: ({ root: root2, props }) => props.heightCurrent = root2.ref.bottom.translateY,
  write: write$3,
  create: create$6,
  ignoreRect: true,
  mixins: {
    apis: ["height", "heightCurrent", "scalable"]
  }
});
const createDragHelper = (items) => {
  const itemIds = items.map((item2) => item2.id);
  let prevIndex = void 0;
  return {
    setIndex: (index) => {
      prevIndex = index;
    },
    getIndex: () => prevIndex,
    getItemIndex: (item2) => itemIds.indexOf(item2.id)
  };
};
const ITEM_TRANSLATE_SPRING = {
  type: "spring",
  stiffness: 0.75,
  damping: 0.45,
  mass: 10
};
const ITEM_SCALE_SPRING = "spring";
const StateMap = {
  DID_START_ITEM_LOAD: "busy",
  DID_UPDATE_ITEM_LOAD_PROGRESS: "loading",
  DID_THROW_ITEM_INVALID: "load-invalid",
  DID_THROW_ITEM_LOAD_ERROR: "load-error",
  DID_LOAD_ITEM: "idle",
  DID_THROW_ITEM_REMOVE_ERROR: "remove-error",
  DID_START_ITEM_REMOVE: "busy",
  DID_START_ITEM_PROCESSING: "busy processing",
  DID_REQUEST_ITEM_PROCESSING: "busy processing",
  DID_UPDATE_ITEM_PROCESS_PROGRESS: "processing",
  DID_COMPLETE_ITEM_PROCESSING: "processing-complete",
  DID_THROW_ITEM_PROCESSING_ERROR: "processing-error",
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: "processing-revert-error",
  DID_ABORT_ITEM_PROCESSING: "cancelled",
  DID_REVERT_ITEM_PROCESSING: "idle"
};
const create$7 = ({ root: root2, props }) => {
  root2.ref.handleClick = (e) => root2.dispatch("DID_ACTIVATE_ITEM", { id: props.id });
  root2.element.id = `filepond--item-${props.id}`;
  root2.element.addEventListener("click", root2.ref.handleClick);
  root2.ref.container = root2.appendChildView(root2.createChildView(fileWrapper, { id: props.id }));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "item-panel" }));
  root2.ref.panel.height = null;
  props.markedForRemoval = false;
  if (!root2.query("GET_ALLOW_REORDER"))
    return;
  root2.element.dataset.dragState = "idle";
  const grab = (e) => {
    if (!e.isPrimary)
      return;
    let removedActivateListener = false;
    const origin = {
      x: e.pageX,
      y: e.pageY
    };
    props.dragOrigin = {
      x: root2.translateX,
      y: root2.translateY
    };
    props.dragCenter = {
      x: e.offsetX,
      y: e.offsetY
    };
    const dragState = createDragHelper(root2.query("GET_ACTIVE_ITEMS"));
    root2.dispatch("DID_GRAB_ITEM", { id: props.id, dragState });
    const drag = (e2) => {
      if (!e2.isPrimary)
        return;
      e2.stopPropagation();
      e2.preventDefault();
      props.dragOffset = {
        x: e2.pageX - origin.x,
        y: e2.pageY - origin.y
      };
      const dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;
      if (dist > 16 && !removedActivateListener) {
        removedActivateListener = true;
        root2.element.removeEventListener("click", root2.ref.handleClick);
      }
      root2.dispatch("DID_DRAG_ITEM", { id: props.id, dragState });
    };
    const drop2 = (e2) => {
      if (!e2.isPrimary)
        return;
      document.removeEventListener("pointermove", drag);
      document.removeEventListener("pointerup", drop2);
      props.dragOffset = {
        x: e2.pageX - origin.x,
        y: e2.pageY - origin.y
      };
      root2.dispatch("DID_DROP_ITEM", { id: props.id, dragState });
      if (removedActivateListener) {
        setTimeout(() => root2.element.addEventListener("click", root2.ref.handleClick), 0);
      }
    };
    document.addEventListener("pointermove", drag);
    document.addEventListener("pointerup", drop2);
  };
  root2.element.addEventListener("pointerdown", grab);
};
const route$1 = createRoute({
  DID_UPDATE_PANEL_HEIGHT: ({ root: root2, action }) => {
    root2.height = action.height;
  }
});
const write$4 = createRoute(
  {
    DID_GRAB_ITEM: ({ root: root2, props }) => {
      props.dragOrigin = {
        x: root2.translateX,
        y: root2.translateY
      };
    },
    DID_DRAG_ITEM: ({ root: root2 }) => {
      root2.element.dataset.dragState = "drag";
    },
    DID_DROP_ITEM: ({ root: root2, props }) => {
      props.dragOffset = null;
      props.dragOrigin = null;
      root2.element.dataset.dragState = "drop";
    }
  },
  ({ root: root2, actions: actions2, props, shouldOptimize }) => {
    if (root2.element.dataset.dragState === "drop") {
      if (root2.scaleX <= 1) {
        root2.element.dataset.dragState = "idle";
      }
    }
    let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StateMap[action2.type]);
    if (action && action.type !== props.currentState) {
      props.currentState = action.type;
      root2.element.dataset.filepondItemState = StateMap[props.currentState] || "";
    }
    const aspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO") || root2.query("GET_PANEL_ASPECT_RATIO");
    if (!aspectRatio) {
      route$1({ root: root2, actions: actions2, props });
      if (!root2.height && root2.ref.container.rect.element.height > 0) {
        root2.height = root2.ref.container.rect.element.height;
      }
    } else if (!shouldOptimize) {
      root2.height = root2.rect.element.width * aspectRatio;
    }
    if (shouldOptimize) {
      root2.ref.panel.height = null;
    }
    root2.ref.panel.height = root2.height;
  }
);
const item = createView({
  create: create$7,
  write: write$4,
  destroy: ({ root: root2, props }) => {
    root2.element.removeEventListener("click", root2.ref.handleClick);
    root2.dispatch("RELEASE_ITEM", { query: props.id });
  },
  tag: "li",
  name: "item",
  mixins: {
    apis: [
      "id",
      "interactionMethod",
      "markedForRemoval",
      "spawnDate",
      "dragCenter",
      "dragOrigin",
      "dragOffset"
    ],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity", "height"],
    animations: {
      scaleX: ITEM_SCALE_SPRING,
      scaleY: ITEM_SCALE_SPRING,
      translateX: ITEM_TRANSLATE_SPRING,
      translateY: ITEM_TRANSLATE_SPRING,
      opacity: { type: "tween", duration: 150 }
    }
  }
});
var getItemsPerRow = (horizontalSpace, itemWidth) => {
  return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));
};
const getItemIndexByPosition = (view, children, positionInView) => {
  if (!positionInView)
    return;
  const horizontalSpace = view.rect.element.width;
  const l = children.length;
  let last = null;
  if (l === 0 || positionInView.top < children[0].rect.element.top)
    return -1;
  const item2 = children[0];
  const itemRect = item2.rect.element;
  const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
  const itemWidth = itemRect.width + itemHorizontalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    for (let index = 0; index < l; index++) {
      const child = children[index];
      const childMid = child.rect.outer.top + child.rect.element.height * 0.5;
      if (positionInView.top < childMid) {
        return index;
      }
    }
    return l;
  }
  const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
  const itemHeight = itemRect.height + itemVerticalMargin;
  for (let index = 0; index < l; index++) {
    const indexX = index % itemsPerRow;
    const indexY = Math.floor(index / itemsPerRow);
    const offsetX = indexX * itemWidth;
    const offsetY = indexY * itemHeight;
    const itemTop = offsetY - itemRect.marginTop;
    const itemRight = offsetX + itemWidth;
    const itemBottom = offsetY + itemHeight + itemRect.marginBottom;
    if (positionInView.top < itemBottom && positionInView.top > itemTop) {
      if (positionInView.left < itemRight) {
        return index;
      } else if (index !== l - 1) {
        last = index;
      } else {
        last = null;
      }
    }
  }
  if (last !== null) {
    return last;
  }
  return l;
};
const dropAreaDimensions = {
  height: 0,
  width: 0,
  get getHeight() {
    return this.height;
  },
  set setHeight(val) {
    if (this.height === 0 || val === 0)
      this.height = val;
  },
  get getWidth() {
    return this.width;
  },
  set setWidth(val) {
    if (this.width === 0 || val === 0)
      this.width = val;
  },
  setDimensions: function(height2, width2) {
    if (this.height === 0 || height2 === 0)
      this.height = height2;
    if (this.width === 0 || width2 === 0)
      this.width = width2;
  }
};
const create$8 = ({ root: root2 }) => {
  attr(root2.element, "role", "list");
  root2.ref.lastItemSpanwDate = Date.now();
};
const addItemView = ({ root: root2, action }) => {
  const { id, index, interactionMethod } = action;
  root2.ref.addIndex = index;
  const now = Date.now();
  let spawnDate = now;
  let opacity = 1;
  if (interactionMethod !== InteractionMethod.NONE) {
    opacity = 0;
    const cooldown = root2.query("GET_ITEM_INSERT_INTERVAL");
    const dist = now - root2.ref.lastItemSpanwDate;
    spawnDate = dist < cooldown ? now + (cooldown - dist) : now;
  }
  root2.ref.lastItemSpanwDate = spawnDate;
  root2.appendChildView(
    root2.createChildView(
      // view type
      item,
      // props
      {
        spawnDate,
        id,
        opacity,
        interactionMethod
      }
    ),
    index
  );
};
const moveItem = (item2, x, y, vx = 0, vy = 1) => {
  if (item2.dragOffset) {
    item2.translateX = null;
    item2.translateY = null;
    item2.translateX = item2.dragOrigin.x + item2.dragOffset.x;
    item2.translateY = item2.dragOrigin.y + item2.dragOffset.y;
    item2.scaleX = 1.025;
    item2.scaleY = 1.025;
  } else {
    item2.translateX = x;
    item2.translateY = y;
    if (Date.now() > item2.spawnDate) {
      if (item2.opacity === 0) {
        introItemView(item2, x, y, vx, vy);
      }
      item2.scaleX = 1;
      item2.scaleY = 1;
      item2.opacity = 1;
    }
  }
};
const introItemView = (item2, x, y, vx, vy) => {
  if (item2.interactionMethod === InteractionMethod.NONE) {
    item2.translateX = null;
    item2.translateX = x;
    item2.translateY = null;
    item2.translateY = y;
  } else if (item2.interactionMethod === InteractionMethod.DROP) {
    item2.translateX = null;
    item2.translateX = x - vx * 20;
    item2.translateY = null;
    item2.translateY = y - vy * 10;
    item2.scaleX = 0.8;
    item2.scaleY = 0.8;
  } else if (item2.interactionMethod === InteractionMethod.BROWSE) {
    item2.translateY = null;
    item2.translateY = y - 30;
  } else if (item2.interactionMethod === InteractionMethod.API) {
    item2.translateX = null;
    item2.translateX = x - 30;
    item2.translateY = null;
  }
};
const removeItemView = ({ root: root2, action }) => {
  const { id } = action;
  const view = root2.childViews.find((child) => child.id === id);
  if (!view) {
    return;
  }
  view.scaleX = 0.9;
  view.scaleY = 0.9;
  view.opacity = 0;
  view.markedForRemoval = true;
};
const getItemHeight = (child) => child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;
const getItemWidth = (child) => child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;
const dragItem = ({ root: root2, action }) => {
  const { id, dragState } = action;
  const item2 = root2.query("GET_ITEM", { id });
  const view = root2.childViews.find((child) => child.id === id);
  const numItems = root2.childViews.length;
  const oldIndex = dragState.getItemIndex(item2);
  if (!view)
    return;
  const dragPosition = {
    x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
    y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y
  };
  const dragHeight = getItemHeight(view);
  const dragWidth = getItemWidth(view);
  let cols = Math.floor(root2.rect.outer.width / dragWidth);
  if (cols > numItems)
    cols = numItems;
  const rows = Math.floor(numItems / cols + 1);
  dropAreaDimensions.setHeight = dragHeight * rows;
  dropAreaDimensions.setWidth = dragWidth * cols;
  var location2 = {
    y: Math.floor(dragPosition.y / dragHeight),
    x: Math.floor(dragPosition.x / dragWidth),
    getGridIndex: function getGridIndex() {
      if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0)
        return oldIndex;
      return this.y * cols + this.x;
    },
    getColIndex: function getColIndex() {
      const items = root2.query("GET_ACTIVE_ITEMS");
      const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
      const children = items.map(
        (item3) => visibleChildren.find((childView) => childView.id === item3.id)
      );
      const currentIndex2 = children.findIndex((child) => child === view);
      const dragHeight2 = getItemHeight(view);
      const l = children.length;
      let idx = l;
      let childHeight = 0;
      let childBottom = 0;
      let childTop = 0;
      for (let i = 0; i < l; i++) {
        childHeight = getItemHeight(children[i]);
        childTop = childBottom;
        childBottom = childTop + childHeight;
        if (dragPosition.y < childBottom) {
          if (currentIndex2 > i) {
            if (dragPosition.y < childTop + dragHeight2) {
              idx = i;
              break;
            }
            continue;
          }
          idx = i;
          break;
        }
      }
      return idx;
    }
  };
  const index = cols > 1 ? location2.getGridIndex() : location2.getColIndex();
  root2.dispatch("MOVE_ITEM", { query: view, index });
  const currentIndex = dragState.getIndex();
  if (currentIndex === void 0 || currentIndex !== index) {
    dragState.setIndex(index);
    if (currentIndex === void 0)
      return;
    root2.dispatch("DID_REORDER_ITEMS", {
      items: root2.query("GET_ACTIVE_ITEMS"),
      origin: oldIndex,
      target: index
    });
  }
};
const route$2 = createRoute({
  DID_ADD_ITEM: addItemView,
  DID_REMOVE_ITEM: removeItemView,
  DID_DRAG_ITEM: dragItem
});
const write$5 = ({ root: root2, props, actions: actions2, shouldOptimize }) => {
  route$2({ root: root2, props, actions: actions2 });
  const { dragCoordinates } = props;
  const horizontalSpace = root2.rect.element.width;
  const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  const dragIndex = dragCoordinates ? getItemIndexByPosition(root2, children, dragCoordinates) : null;
  const addIndex = root2.ref.addIndex || null;
  root2.ref.addIndex = null;
  let dragIndexOffset = 0;
  let removeIndexOffset = 0;
  let addIndexOffset = 0;
  if (children.length === 0)
    return;
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    let offsetY = 0;
    let dragOffset = 0;
    children.forEach((child, index) => {
      if (dragIndex) {
        let dist = index - dragIndex;
        if (dist === -2) {
          dragOffset = -itemVerticalMargin * 0.25;
        } else if (dist === -1) {
          dragOffset = -itemVerticalMargin * 0.75;
        } else if (dist === 0) {
          dragOffset = itemVerticalMargin * 0.75;
        } else if (dist === 1) {
          dragOffset = itemVerticalMargin * 0.25;
        } else {
          dragOffset = 0;
        }
      }
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      if (!child.markedForRemoval) {
        moveItem(child, 0, offsetY + dragOffset);
      }
      let itemHeight2 = child.rect.element.height + itemVerticalMargin;
      let visualHeight = itemHeight2 * (child.markedForRemoval ? child.opacity : 1);
      offsetY += visualHeight;
    });
  } else {
    let prevX = 0;
    let prevY = 0;
    children.forEach((child, index) => {
      if (index === dragIndex) {
        dragIndexOffset = 1;
      }
      if (index === addIndex) {
        addIndexOffset += 1;
      }
      if (child.markedForRemoval && child.opacity < 0.5) {
        removeIndexOffset -= 1;
      }
      const visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;
      const indexX = visualIndex % itemsPerRow;
      const indexY = Math.floor(visualIndex / itemsPerRow);
      const offsetX = indexX * itemWidth;
      const offsetY = indexY * itemHeight;
      const vectorX = Math.sign(offsetX - prevX);
      const vectorY = Math.sign(offsetY - prevY);
      prevX = offsetX;
      prevY = offsetY;
      if (child.markedForRemoval)
        return;
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      moveItem(child, offsetX, offsetY, vectorX, vectorY);
    });
  }
};
const filterSetItemActions = (child, actions2) => actions2.filter((action) => {
  if (action.data && action.data.id) {
    return child.id === action.data.id;
  }
  return true;
});
const list = createView({
  create: create$8,
  write: write$5,
  tag: "ul",
  name: "list",
  didWriteView: ({ root: root2 }) => {
    root2.childViews.filter((view) => view.markedForRemoval && view.opacity === 0 && view.resting).forEach((view) => {
      view._destroy();
      root2.removeChildView(view);
    });
  },
  filterFrameActionsForChild: filterSetItemActions,
  mixins: {
    apis: ["dragCoordinates"]
  }
});
const create$9 = ({ root: root2, props }) => {
  root2.ref.list = root2.appendChildView(root2.createChildView(list));
  props.dragCoordinates = null;
  props.overflowing = false;
};
const storeDragCoordinates = ({ root: root2, props, action }) => {
  if (!root2.query("GET_ITEM_INSERT_LOCATION_FREEDOM"))
    return;
  props.dragCoordinates = {
    left: action.position.scopeLeft - root2.ref.list.rect.element.left,
    top: action.position.scopeTop - (root2.rect.outer.top + root2.rect.element.marginTop + root2.rect.element.scrollTop)
  };
};
const clearDragCoordinates = ({ props }) => {
  props.dragCoordinates = null;
};
const route$3 = createRoute({
  DID_DRAG: storeDragCoordinates,
  DID_END_DRAG: clearDragCoordinates
});
const write$6 = ({ root: root2, props, actions: actions2 }) => {
  route$3({ root: root2, props, actions: actions2 });
  root2.ref.list.dragCoordinates = props.dragCoordinates;
  if (props.overflowing && !props.overflow) {
    props.overflowing = false;
    root2.element.dataset.state = "";
    root2.height = null;
  }
  if (props.overflow) {
    const newHeight = Math.round(props.overflow);
    if (newHeight !== root2.height) {
      props.overflowing = true;
      root2.element.dataset.state = "overflow";
      root2.height = newHeight;
    }
  }
};
const listScroller = createView({
  create: create$9,
  write: write$6,
  name: "list-scroller",
  mixins: {
    apis: ["overflow", "dragCoordinates"],
    styles: ["height", "translateY"],
    animations: {
      translateY: "spring"
    }
  }
});
const attrToggle = (element, name2, state2, enabledValue = "") => {
  if (state2) {
    attr(element, name2, enabledValue);
  } else {
    element.removeAttribute(name2);
  }
};
const resetFileInput = (input) => {
  if (!input || input.value === "") {
    return;
  }
  try {
    input.value = "";
  } catch (err) {
  }
  if (input.value) {
    const form = createElement$1("form");
    const parentNode = input.parentNode;
    const ref = input.nextSibling;
    form.appendChild(input);
    form.reset();
    if (ref) {
      parentNode.insertBefore(input, ref);
    } else {
      parentNode.appendChild(input);
    }
  }
};
const create$a = ({ root: root2, props }) => {
  root2.element.id = `filepond--browser-${props.id}`;
  attr(root2.element, "name", root2.query("GET_NAME"));
  attr(root2.element, "aria-controls", `filepond--assistant-${props.id}`);
  attr(root2.element, "aria-labelledby", `filepond--drop-label-${props.id}`);
  setAcceptedFileTypes({ root: root2, action: { value: root2.query("GET_ACCEPTED_FILE_TYPES") } });
  toggleAllowMultiple({ root: root2, action: { value: root2.query("GET_ALLOW_MULTIPLE") } });
  toggleDirectoryFilter({ root: root2, action: { value: root2.query("GET_ALLOW_DIRECTORIES_ONLY") } });
  toggleDisabled({ root: root2 });
  toggleRequired({ root: root2, action: { value: root2.query("GET_REQUIRED") } });
  setCaptureMethod({ root: root2, action: { value: root2.query("GET_CAPTURE_METHOD") } });
  root2.ref.handleChange = (e) => {
    if (!root2.element.value) {
      return;
    }
    const files = Array.from(root2.element.files).map((file2) => {
      file2._relativePath = file2.webkitRelativePath;
      return file2;
    });
    setTimeout(() => {
      props.onload(files);
      resetFileInput(root2.element);
    }, 250);
  };
  root2.element.addEventListener("change", root2.ref.handleChange);
};
const setAcceptedFileTypes = ({ root: root2, action }) => {
  if (!root2.query("GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE"))
    return;
  attrToggle(root2.element, "accept", !!action.value, action.value ? action.value.join(",") : "");
};
const toggleAllowMultiple = ({ root: root2, action }) => {
  attrToggle(root2.element, "multiple", action.value);
};
const toggleDirectoryFilter = ({ root: root2, action }) => {
  attrToggle(root2.element, "webkitdirectory", action.value);
};
const toggleDisabled = ({ root: root2 }) => {
  const isDisabled2 = root2.query("GET_DISABLED");
  const doesAllowBrowse = root2.query("GET_ALLOW_BROWSE");
  const disableField = isDisabled2 || !doesAllowBrowse;
  attrToggle(root2.element, "disabled", disableField);
};
const toggleRequired = ({ root: root2, action }) => {
  if (!action.value) {
    attrToggle(root2.element, "required", false);
  } else if (root2.query("GET_TOTAL_ITEMS") === 0) {
    attrToggle(root2.element, "required", true);
  }
};
const setCaptureMethod = ({ root: root2, action }) => {
  attrToggle(root2.element, "capture", !!action.value, action.value === true ? "" : action.value);
};
const updateRequiredStatus = ({ root: root2 }) => {
  const { element } = root2;
  if (root2.query("GET_TOTAL_ITEMS") > 0) {
    attrToggle(element, "required", false);
    attrToggle(element, "name", false);
  } else {
    attrToggle(element, "name", true, root2.query("GET_NAME"));
    const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
    if (shouldCheckValidity) {
      element.setCustomValidity("");
    }
    if (root2.query("GET_REQUIRED")) {
      attrToggle(element, "required", true);
    }
  }
};
const updateFieldValidityStatus = ({ root: root2 }) => {
  const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
  if (!shouldCheckValidity)
    return;
  root2.element.setCustomValidity(root2.query("GET_LABEL_INVALID_FIELD"));
};
const browser = createView({
  tag: "input",
  name: "browser",
  ignoreRect: true,
  ignoreRectUpdate: true,
  attributes: {
    type: "file"
  },
  create: create$a,
  destroy: ({ root: root2 }) => {
    root2.element.removeEventListener("change", root2.ref.handleChange);
  },
  write: createRoute({
    DID_LOAD_ITEM: updateRequiredStatus,
    DID_REMOVE_ITEM: updateRequiredStatus,
    DID_THROW_ITEM_INVALID: updateFieldValidityStatus,
    DID_SET_DISABLED: toggleDisabled,
    DID_SET_ALLOW_BROWSE: toggleDisabled,
    DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
    DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
    DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
    DID_SET_CAPTURE_METHOD: setCaptureMethod,
    DID_SET_REQUIRED: toggleRequired
  })
});
const Key = {
  ENTER: 13,
  SPACE: 32
};
const create$b = ({ root: root2, props }) => {
  const label = createElement$1("label");
  attr(label, "for", `filepond--browser-${props.id}`);
  attr(label, "id", `filepond--drop-label-${props.id}`);
  attr(label, "aria-hidden", "true");
  root2.ref.handleKeyDown = (e) => {
    const isActivationKey = e.keyCode === Key.ENTER || e.keyCode === Key.SPACE;
    if (!isActivationKey)
      return;
    e.preventDefault();
    root2.ref.label.click();
  };
  root2.ref.handleClick = (e) => {
    const isLabelClick = e.target === label || label.contains(e.target);
    if (isLabelClick)
      return;
    root2.ref.label.click();
  };
  label.addEventListener("keydown", root2.ref.handleKeyDown);
  root2.element.addEventListener("click", root2.ref.handleClick);
  updateLabelValue(label, props.caption);
  root2.appendChild(label);
  root2.ref.label = label;
};
const updateLabelValue = (label, value) => {
  label.innerHTML = value;
  const clickable = label.querySelector(".filepond--label-action");
  if (clickable) {
    attr(clickable, "tabindex", "0");
  }
  return value;
};
const dropLabel = createView({
  name: "drop-label",
  ignoreRect: true,
  create: create$b,
  destroy: ({ root: root2 }) => {
    root2.ref.label.addEventListener("keydown", root2.ref.handleKeyDown);
    root2.element.removeEventListener("click", root2.ref.handleClick);
  },
  write: createRoute({
    DID_SET_LABEL_IDLE: ({ root: root2, action }) => {
      updateLabelValue(root2.ref.label, action.value);
    }
  }),
  mixins: {
    styles: ["opacity", "translateX", "translateY"],
    animations: {
      opacity: { type: "tween", duration: 150 },
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const blob = createView({
  name: "drip-blob",
  ignoreRect: true,
  mixins: {
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: { type: "tween", duration: 250 }
    }
  }
});
const addBlob = ({ root: root2 }) => {
  const centerX = root2.rect.element.width * 0.5;
  const centerY = root2.rect.element.height * 0.5;
  root2.ref.blob = root2.appendChildView(
    root2.createChildView(blob, {
      opacity: 0,
      scaleX: 2.5,
      scaleY: 2.5,
      translateX: centerX,
      translateY: centerY
    })
  );
};
const moveBlob = ({ root: root2, action }) => {
  if (!root2.ref.blob) {
    addBlob({ root: root2 });
    return;
  }
  root2.ref.blob.translateX = action.position.scopeLeft;
  root2.ref.blob.translateY = action.position.scopeTop;
  root2.ref.blob.scaleX = 1;
  root2.ref.blob.scaleY = 1;
  root2.ref.blob.opacity = 1;
};
const hideBlob = ({ root: root2 }) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.opacity = 0;
};
const explodeBlob = ({ root: root2 }) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.scaleX = 2.5;
  root2.ref.blob.scaleY = 2.5;
  root2.ref.blob.opacity = 0;
};
const write$7 = ({ root: root2, props, actions: actions2 }) => {
  route$4({ root: root2, props, actions: actions2 });
  const { blob: blob2 } = root2.ref;
  if (actions2.length === 0 && blob2 && blob2.opacity === 0) {
    root2.removeChildView(blob2);
    root2.ref.blob = null;
  }
};
const route$4 = createRoute({
  DID_DRAG: moveBlob,
  DID_DROP: explodeBlob,
  DID_END_DRAG: hideBlob
});
const drip = createView({
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "drip",
  write: write$7
});
const setInputFiles = (element, files) => {
  try {
    const dataTransfer = new DataTransfer();
    files.forEach((file2) => {
      if (file2 instanceof File) {
        dataTransfer.items.add(file2);
      } else {
        dataTransfer.items.add(
          new File([file2], file2.name, {
            type: file2.type
          })
        );
      }
    });
    element.files = dataTransfer.files;
  } catch (err) {
    return false;
  }
  return true;
};
const create$c = ({ root: root2 }) => root2.ref.fields = {};
const getField = (root2, id) => root2.ref.fields[id];
const syncFieldPositionsWithItems = (root2) => {
  root2.query("GET_ACTIVE_ITEMS").forEach((item2) => {
    if (!root2.ref.fields[item2.id])
      return;
    root2.element.appendChild(root2.ref.fields[item2.id]);
  });
};
const didReorderItems = ({ root: root2 }) => syncFieldPositionsWithItems(root2);
const didAddItem = ({ root: root2, action }) => {
  const fileItem = root2.query("GET_ITEM", action.id);
  const isLocalFile = fileItem.origin === FileOrigin.LOCAL;
  const shouldUseFileInput = !isLocalFile && root2.query("SHOULD_UPDATE_FILE_INPUT");
  const dataContainer = createElement$1("input");
  dataContainer.type = shouldUseFileInput ? "file" : "hidden";
  dataContainer.name = root2.query("GET_NAME");
  dataContainer.disabled = root2.query("GET_DISABLED");
  root2.ref.fields[action.id] = dataContainer;
  syncFieldPositionsWithItems(root2);
};
const didLoadItem$1 = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.serverFileReference !== null)
    field.value = action.serverFileReference;
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  const fileItem = root2.query("GET_ITEM", action.id);
  setInputFiles(field, [fileItem.file]);
};
const didPrepareOutput = ({ root: root2, action }) => {
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  setTimeout(() => {
    const field = getField(root2, action.id);
    if (!field)
      return;
    setInputFiles(field, [action.file]);
  }, 0);
};
const didSetDisabled = ({ root: root2 }) => {
  root2.element.disabled = root2.query("GET_DISABLED");
};
const didRemoveItem = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (field.parentNode)
    field.parentNode.removeChild(field);
  delete root2.ref.fields[action.id];
};
const didDefineValue = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.value === null) {
    field.removeAttribute("value");
  } else {
    field.value = action.value;
  }
  syncFieldPositionsWithItems(root2);
};
const write$8 = createRoute({
  DID_SET_DISABLED: didSetDisabled,
  DID_ADD_ITEM: didAddItem,
  DID_LOAD_ITEM: didLoadItem$1,
  DID_REMOVE_ITEM: didRemoveItem,
  DID_DEFINE_VALUE: didDefineValue,
  DID_PREPARE_OUTPUT: didPrepareOutput,
  DID_REORDER_ITEMS: didReorderItems,
  DID_SORT_ITEMS: didReorderItems
});
const data$1 = createView({
  tag: "fieldset",
  name: "data",
  create: create$c,
  write: write$8,
  ignoreRect: true
});
const getRootNode = (element) => "getRootNode" in element ? element.getRootNode() : document;
const images = ["jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff"];
const text$1 = ["css", "csv", "html", "txt"];
const map = {
  zip: "zip|compressed",
  epub: "application/epub+zip"
};
const guesstimateMimeType = (extension = "") => {
  extension = extension.toLowerCase();
  if (images.includes(extension)) {
    return "image/" + (extension === "jpg" ? "jpeg" : extension === "svg" ? "svg+xml" : extension);
  }
  if (text$1.includes(extension)) {
    return "text/" + extension;
  }
  return map[extension] || "";
};
const requestDataTransferItems = (dataTransfer) => new Promise((resolve, reject) => {
  const links = getLinks(dataTransfer);
  if (links.length && !hasFiles(dataTransfer)) {
    return resolve(links);
  }
  getFiles(dataTransfer).then(resolve);
});
const hasFiles = (dataTransfer) => {
  if (dataTransfer.files)
    return dataTransfer.files.length > 0;
  return false;
};
const getFiles = (dataTransfer) => new Promise((resolve, reject) => {
  const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : []).filter((item2) => isFileSystemItem(item2)).map((item2) => getFilesFromItem(item2));
  if (!promisedFiles.length) {
    resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
    return;
  }
  Promise.all(promisedFiles).then((returnedFileGroups) => {
    const files = [];
    returnedFileGroups.forEach((group) => {
      files.push.apply(files, group);
    });
    resolve(
      files.filter((file2) => file2).map((file2) => {
        if (!file2._relativePath)
          file2._relativePath = file2.webkitRelativePath;
        return file2;
      })
    );
  }).catch(console.error);
});
const isFileSystemItem = (item2) => {
  if (isEntry(item2)) {
    const entry = getAsEntry(item2);
    if (entry) {
      return entry.isFile || entry.isDirectory;
    }
  }
  return item2.kind === "file";
};
const getFilesFromItem = (item2) => new Promise((resolve, reject) => {
  if (isDirectoryEntry(item2)) {
    getFilesInDirectory(getAsEntry(item2)).then(resolve).catch(reject);
    return;
  }
  resolve([item2.getAsFile()]);
});
const getFilesInDirectory = (entry) => new Promise((resolve, reject) => {
  const files = [];
  let dirCounter = 0;
  let fileCounter = 0;
  const resolveIfDone = () => {
    if (fileCounter === 0 && dirCounter === 0) {
      resolve(files);
    }
  };
  const readEntries = (dirEntry) => {
    dirCounter++;
    const directoryReader = dirEntry.createReader();
    const readBatch = () => {
      directoryReader.readEntries((entries) => {
        if (entries.length === 0) {
          dirCounter--;
          resolveIfDone();
          return;
        }
        entries.forEach((entry2) => {
          if (entry2.isDirectory) {
            readEntries(entry2);
          } else {
            fileCounter++;
            entry2.file((file2) => {
              const correctedFile = correctMissingFileType(file2);
              if (entry2.fullPath)
                correctedFile._relativePath = entry2.fullPath;
              files.push(correctedFile);
              fileCounter--;
              resolveIfDone();
            });
          }
        });
        readBatch();
      }, reject);
    };
    readBatch();
  };
  readEntries(entry);
});
const correctMissingFileType = (file2) => {
  if (file2.type.length)
    return file2;
  const date = file2.lastModifiedDate;
  const name2 = file2.name;
  const type = guesstimateMimeType(getExtensionFromFilename(file2.name));
  if (!type.length)
    return file2;
  file2 = file2.slice(0, file2.size, type);
  file2.name = name2;
  file2.lastModifiedDate = date;
  return file2;
};
const isDirectoryEntry = (item2) => isEntry(item2) && (getAsEntry(item2) || {}).isDirectory;
const isEntry = (item2) => "webkitGetAsEntry" in item2;
const getAsEntry = (item2) => item2.webkitGetAsEntry();
const getLinks = (dataTransfer) => {
  let links = [];
  try {
    links = getLinksFromTransferMetaData(dataTransfer);
    if (links.length) {
      return links;
    }
    links = getLinksFromTransferURLData(dataTransfer);
  } catch (e) {
  }
  return links;
};
const getLinksFromTransferURLData = (dataTransfer) => {
  let data2 = dataTransfer.getData("url");
  if (typeof data2 === "string" && data2.length) {
    return [data2];
  }
  return [];
};
const getLinksFromTransferMetaData = (dataTransfer) => {
  let data2 = dataTransfer.getData("text/html");
  if (typeof data2 === "string" && data2.length) {
    const matches = data2.match(/src\s*=\s*"(.+?)"/);
    if (matches) {
      return [matches[1]];
    }
  }
  return [];
};
const dragNDropObservers = [];
const eventPosition = (e) => ({
  pageLeft: e.pageX,
  pageTop: e.pageY,
  scopeLeft: e.offsetX || e.layerX,
  scopeTop: e.offsetY || e.layerY
});
const createDragNDropClient = (element, scopeToObserve, filterElement) => {
  const observer = getDragNDropObserver(scopeToObserve);
  const client = {
    element,
    filterElement,
    state: null,
    ondrop: () => {
    },
    onenter: () => {
    },
    ondrag: () => {
    },
    onexit: () => {
    },
    onload: () => {
    },
    allowdrop: () => {
    }
  };
  client.destroy = observer.addListener(client);
  return client;
};
const getDragNDropObserver = (element) => {
  const observer = dragNDropObservers.find((item2) => item2.element === element);
  if (observer) {
    return observer;
  }
  const newObserver = createDragNDropObserver(element);
  dragNDropObservers.push(newObserver);
  return newObserver;
};
const createDragNDropObserver = (element) => {
  const clients = [];
  const routes = {
    dragenter,
    dragover,
    dragleave,
    drop
  };
  const handlers = {};
  forin(routes, (event, createHandler) => {
    handlers[event] = createHandler(element, clients);
    element.addEventListener(event, handlers[event], false);
  });
  const observer = {
    element,
    addListener: (client) => {
      clients.push(client);
      return () => {
        clients.splice(clients.indexOf(client), 1);
        if (clients.length === 0) {
          dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);
          forin(routes, (event) => {
            element.removeEventListener(event, handlers[event], false);
          });
        }
      };
    }
  };
  return observer;
};
const elementFromPoint = (root2, point) => {
  if (!("elementFromPoint" in root2)) {
    root2 = document;
  }
  return root2.elementFromPoint(point.x, point.y);
};
const isEventTarget = (e, target) => {
  const root2 = getRootNode(target);
  const elementAtPosition = elementFromPoint(root2, {
    x: e.pageX - window.pageXOffset,
    y: e.pageY - window.pageYOffset
  });
  return elementAtPosition === target || target.contains(elementAtPosition);
};
let initialTarget = null;
const setDropEffect = (dataTransfer, effect2) => {
  try {
    dataTransfer.dropEffect = effect2;
  } catch (e) {
  }
};
const dragenter = (root2, clients) => (e) => {
  e.preventDefault();
  initialTarget = e.target;
  clients.forEach((client) => {
    const { element, onenter } = client;
    if (isEventTarget(e, element)) {
      client.state = "enter";
      onenter(eventPosition(e));
    }
  });
};
const dragover = (root2, clients) => (e) => {
  e.preventDefault();
  const dataTransfer = e.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    let overDropTarget = false;
    clients.some((client) => {
      const { filterElement, element, onenter, onexit, ondrag, allowdrop } = client;
      setDropEffect(dataTransfer, "copy");
      const allowsTransfer = allowdrop(items);
      if (!allowsTransfer) {
        setDropEffect(dataTransfer, "none");
        return;
      }
      if (isEventTarget(e, element)) {
        overDropTarget = true;
        if (client.state === null) {
          client.state = "enter";
          onenter(eventPosition(e));
          return;
        }
        client.state = "over";
        if (filterElement && !allowsTransfer) {
          setDropEffect(dataTransfer, "none");
          return;
        }
        ondrag(eventPosition(e));
      } else {
        if (filterElement && !overDropTarget) {
          setDropEffect(dataTransfer, "none");
        }
        if (client.state) {
          client.state = null;
          onexit(eventPosition(e));
        }
      }
    });
  });
};
const drop = (root2, clients) => (e) => {
  e.preventDefault();
  const dataTransfer = e.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    clients.forEach((client) => {
      const { filterElement, element, ondrop, onexit, allowdrop } = client;
      client.state = null;
      if (filterElement && !isEventTarget(e, element))
        return;
      if (!allowdrop(items))
        return onexit(eventPosition(e));
      ondrop(eventPosition(e), items);
    });
  });
};
const dragleave = (root2, clients) => (e) => {
  if (initialTarget !== e.target) {
    return;
  }
  clients.forEach((client) => {
    const { onexit } = client;
    client.state = null;
    onexit(eventPosition(e));
  });
};
const createHopper = (scope, validateItems, options) => {
  scope.classList.add("filepond--hopper");
  const { catchesDropsOnPage, requiresDropOnElement, filterItems = (items) => items } = options;
  const client = createDragNDropClient(
    scope,
    catchesDropsOnPage ? document.documentElement : scope,
    requiresDropOnElement
  );
  let lastState = "";
  let currentState = "";
  client.allowdrop = (items) => {
    return validateItems(filterItems(items));
  };
  client.ondrop = (position, items) => {
    const filteredItems = filterItems(items);
    if (!validateItems(filteredItems)) {
      api.ondragend(position);
      return;
    }
    currentState = "drag-drop";
    api.onload(filteredItems, position);
  };
  client.ondrag = (position) => {
    api.ondrag(position);
  };
  client.onenter = (position) => {
    currentState = "drag-over";
    api.ondragstart(position);
  };
  client.onexit = (position) => {
    currentState = "drag-exit";
    api.ondragend(position);
  };
  const api = {
    updateHopperState: () => {
      if (lastState !== currentState) {
        scope.dataset.hopperState = currentState;
        lastState = currentState;
      }
    },
    onload: () => {
    },
    ondragstart: () => {
    },
    ondrag: () => {
    },
    ondragend: () => {
    },
    destroy: () => {
      client.destroy();
    }
  };
  return api;
};
let listening = false;
const listeners$1 = [];
const handlePaste = (e) => {
  const activeEl = document.activeElement;
  if (activeEl && /textarea|input/i.test(activeEl.nodeName)) {
    let inScope = false;
    let element = activeEl;
    while (element !== document.body) {
      if (element.classList.contains("filepond--root")) {
        inScope = true;
        break;
      }
      element = element.parentNode;
    }
    if (!inScope)
      return;
  }
  requestDataTransferItems(e.clipboardData).then((files) => {
    if (!files.length) {
      return;
    }
    listeners$1.forEach((listener) => listener(files));
  });
};
const listen = (cb) => {
  if (listeners$1.includes(cb)) {
    return;
  }
  listeners$1.push(cb);
  if (listening) {
    return;
  }
  listening = true;
  document.addEventListener("paste", handlePaste);
};
const unlisten = (listener) => {
  arrayRemove(listeners$1, listeners$1.indexOf(listener));
  if (listeners$1.length === 0) {
    document.removeEventListener("paste", handlePaste);
    listening = false;
  }
};
const createPaster = () => {
  const cb = (files) => {
    api.onload(files);
  };
  const api = {
    destroy: () => {
      unlisten(cb);
    },
    onload: () => {
    }
  };
  listen(cb);
  return api;
};
const create$d = ({ root: root2, props }) => {
  root2.element.id = `filepond--assistant-${props.id}`;
  attr(root2.element, "role", "status");
  attr(root2.element, "aria-live", "polite");
  attr(root2.element, "aria-relevant", "additions");
};
let addFilesNotificationTimeout = null;
let notificationClearTimeout = null;
const filenames = [];
const assist = (root2, message) => {
  root2.element.textContent = message;
};
const clear$1 = (root2) => {
  root2.element.textContent = "";
};
const listModified = (root2, filename, label) => {
  const total = root2.query("GET_TOTAL_ITEMS");
  assist(
    root2,
    `${label} ${filename}, ${total} ${total === 1 ? root2.query("GET_LABEL_FILE_COUNT_SINGULAR") : root2.query("GET_LABEL_FILE_COUNT_PLURAL")}`
  );
  clearTimeout(notificationClearTimeout);
  notificationClearTimeout = setTimeout(() => {
    clear$1(root2);
  }, 1500);
};
const isUsingFilePond = (root2) => root2.element.parentNode.contains(document.activeElement);
const itemAdded = ({ root: root2, action }) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  root2.element.textContent = "";
  const item2 = root2.query("GET_ITEM", action.id);
  filenames.push(item2.filename);
  clearTimeout(addFilesNotificationTimeout);
  addFilesNotificationTimeout = setTimeout(() => {
    listModified(root2, filenames.join(", "), root2.query("GET_LABEL_FILE_ADDED"));
    filenames.length = 0;
  }, 750);
};
const itemRemoved = ({ root: root2, action }) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  const item2 = action.item;
  listModified(root2, item2.filename, root2.query("GET_LABEL_FILE_REMOVED"));
};
const itemProcessed = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE");
  assist(root2, `${filename} ${label}`);
};
const itemProcessedUndo = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_ABORTED");
  assist(root2, `${filename} ${label}`);
};
const itemError = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  assist(root2, `${action.status.main} ${filename} ${action.status.sub}`);
};
const assistant = createView({
  create: create$d,
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: itemAdded,
    DID_REMOVE_ITEM: itemRemoved,
    DID_COMPLETE_ITEM_PROCESSING: itemProcessed,
    DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
    DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,
    DID_THROW_ITEM_REMOVE_ERROR: itemError,
    DID_THROW_ITEM_LOAD_ERROR: itemError,
    DID_THROW_ITEM_INVALID: itemError,
    DID_THROW_ITEM_PROCESSING_ERROR: itemError
  }),
  tag: "span",
  name: "assistant"
});
const toCamels = (string, separator = "-") => string.replace(new RegExp(`${separator}.`, "g"), (sub) => sub.charAt(1).toUpperCase());
const debounce$1 = (func, interval = 16, immidiateOnly = true) => {
  let last = Date.now();
  let timeout = null;
  return (...args) => {
    clearTimeout(timeout);
    const dist = Date.now() - last;
    const fn3 = () => {
      last = Date.now();
      func(...args);
    };
    if (dist < interval) {
      if (!immidiateOnly) {
        timeout = setTimeout(fn3, interval - dist);
      }
    } else {
      fn3();
    }
  };
};
const MAX_FILES_LIMIT = 1e6;
const prevent = (e) => e.preventDefault();
const create$e = ({ root: root2, props }) => {
  const id = root2.query("GET_ID");
  if (id) {
    root2.element.id = id;
  }
  const className = root2.query("GET_CLASS_NAME");
  if (className) {
    className.split(" ").filter((name2) => name2.length).forEach((name2) => {
      root2.element.classList.add(name2);
    });
  }
  root2.ref.label = root2.appendChildView(
    root2.createChildView(dropLabel, {
      ...props,
      translateY: null,
      caption: root2.query("GET_LABEL_IDLE")
    })
  );
  root2.ref.list = root2.appendChildView(root2.createChildView(listScroller, { translateY: null }));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "panel-root" }));
  root2.ref.assistant = root2.appendChildView(root2.createChildView(assistant, { ...props }));
  root2.ref.data = root2.appendChildView(root2.createChildView(data$1, { ...props }));
  root2.ref.measure = createElement$1("div");
  root2.ref.measure.style.height = "100%";
  root2.element.appendChild(root2.ref.measure);
  root2.ref.bounds = null;
  root2.query("GET_STYLES").filter((style) => !isEmpty(style.value)).map(({ name: name2, value }) => {
    root2.element.dataset[name2] = value;
  });
  root2.ref.widthPrevious = null;
  root2.ref.widthUpdated = debounce$1(() => {
    root2.ref.updateHistory = [];
    root2.dispatch("DID_RESIZE_ROOT");
  }, 250);
  root2.ref.previousAspectRatio = null;
  root2.ref.updateHistory = [];
  const canHover = window.matchMedia("(pointer: fine) and (hover: hover)").matches;
  const hasPointerEvents = "PointerEvent" in window;
  if (root2.query("GET_ALLOW_REORDER") && hasPointerEvents && !canHover) {
    root2.element.addEventListener("touchmove", prevent, { passive: false });
    root2.element.addEventListener("gesturestart", prevent);
  }
  const credits = root2.query("GET_CREDITS");
  const hasCredits = credits.length === 2;
  if (hasCredits) {
    const frag = document.createElement("a");
    frag.className = "filepond--credits";
    frag.setAttribute("aria-hidden", "true");
    frag.href = credits[0];
    frag.tabindex = -1;
    frag.target = "_blank";
    frag.rel = "noopener noreferrer";
    frag.textContent = credits[1];
    root2.element.appendChild(frag);
    root2.ref.credits = frag;
  }
};
const write$9 = ({ root: root2, props, actions: actions2 }) => {
  route$5({ root: root2, props, actions: actions2 });
  actions2.filter((action) => /^DID_SET_STYLE_/.test(action.type)).filter((action) => !isEmpty(action.data.value)).map(({ type, data: data2 }) => {
    const name2 = toCamels(type.substring(8).toLowerCase(), "_");
    root2.element.dataset[name2] = data2.value;
    root2.invalidateLayout();
  });
  if (root2.rect.element.hidden)
    return;
  if (root2.rect.element.width !== root2.ref.widthPrevious) {
    root2.ref.widthPrevious = root2.rect.element.width;
    root2.ref.widthUpdated();
  }
  let bounds = root2.ref.bounds;
  if (!bounds) {
    bounds = root2.ref.bounds = calculateRootBoundingBoxHeight(root2);
    root2.element.removeChild(root2.ref.measure);
    root2.ref.measure = null;
  }
  const { hopper, label, list: list2, panel: panel2 } = root2.ref;
  if (hopper) {
    hopper.updateHopperState();
  }
  const aspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
  const isMultiItem = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  const maxItems = isMultiItem ? root2.query("GET_MAX_FILES") || MAX_FILES_LIMIT : 1;
  const atMaxCapacity = totalItems === maxItems;
  const addAction = actions2.find((action) => action.type === "DID_ADD_ITEM");
  if (atMaxCapacity && addAction) {
    const interactionMethod = addAction.data.interactionMethod;
    label.opacity = 0;
    if (isMultiItem) {
      label.translateY = -40;
    } else {
      if (interactionMethod === InteractionMethod.API) {
        label.translateX = 40;
      } else if (interactionMethod === InteractionMethod.BROWSE) {
        label.translateY = 40;
      } else {
        label.translateY = 30;
      }
    }
  } else if (!atMaxCapacity) {
    label.opacity = 1;
    label.translateX = 0;
    label.translateY = 0;
  }
  const listItemMargin = calculateListItemMargin(root2);
  const listHeight = calculateListHeight(root2);
  const labelHeight = label.rect.element.height;
  const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;
  const listMarginTop = atMaxCapacity ? list2.rect.element.marginTop : 0;
  const listMarginBottom = totalItems === 0 ? 0 : list2.rect.element.marginBottom;
  const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
  const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;
  list2.translateY = Math.max(0, currentLabelHeight - list2.rect.element.marginTop) - listItemMargin.top;
  if (aspectRatio) {
    const width2 = root2.rect.element.width;
    const height2 = width2 * aspectRatio;
    if (aspectRatio !== root2.ref.previousAspectRatio) {
      root2.ref.previousAspectRatio = aspectRatio;
      root2.ref.updateHistory = [];
    }
    const history = root2.ref.updateHistory;
    history.push(width2);
    const MAX_BOUNCES = 2;
    if (history.length > MAX_BOUNCES * 2) {
      const l = history.length;
      const bottom2 = l - 10;
      let bounces = 0;
      for (let i = l; i >= bottom2; i--) {
        if (history[i] === history[i - 2]) {
          bounces++;
        }
        if (bounces >= MAX_BOUNCES) {
          return;
        }
      }
    }
    panel2.scalable = false;
    panel2.height = height2;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      height2 - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = height2;
  } else if (bounds.fixedHeight) {
    panel2.scalable = false;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      bounds.fixedHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
  } else if (bounds.cappedHeight) {
    const isCappedHeight = visualHeight >= bounds.cappedHeight;
    const panelHeight = Math.min(bounds.cappedHeight, visualHeight);
    panel2.scalable = true;
    panel2.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      panelHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = Math.min(
      bounds.cappedHeight,
      boundsHeight - listItemMargin.top - listItemMargin.bottom
    );
  } else {
    const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
    panel2.scalable = true;
    panel2.height = Math.max(labelHeight, visualHeight - itemMargin);
    root2.height = Math.max(labelHeight, boundsHeight - itemMargin);
  }
  if (root2.ref.credits && panel2.heightCurrent)
    root2.ref.credits.style.transform = `translateY(${panel2.heightCurrent}px)`;
};
const calculateListItemMargin = (root2) => {
  const item2 = root2.ref.list.childViews[0].childViews[0];
  return item2 ? {
    top: item2.rect.element.marginTop,
    bottom: item2.rect.element.marginBottom
  } : {
    top: 0,
    bottom: 0
  };
};
const calculateListHeight = (root2) => {
  let visual = 0;
  let bounds = 0;
  const scrollList = root2.ref.list;
  const itemList = scrollList.childViews[0];
  const visibleChildren = itemList.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  if (children.length === 0)
    return { visual, bounds };
  const horizontalSpace = itemList.rect.element.width;
  const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const newItem = typeof dragIndex !== "undefined" && dragIndex >= 0 ? 1 : 0;
  const removedItem = children.find((child) => child.markedForRemoval && child.opacity < 0.45) ? -1 : 0;
  const verticalItemCount = children.length + newItem + removedItem;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    children.forEach((item2) => {
      const height2 = item2.rect.element.height + itemVerticalMargin;
      bounds += height2;
      visual += height2 * item2.opacity;
    });
  } else {
    bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
    visual = bounds;
  }
  return { visual, bounds };
};
const calculateRootBoundingBoxHeight = (root2) => {
  const height2 = root2.ref.measureHeight || null;
  const cappedHeight = parseInt(root2.style.maxHeight, 10) || null;
  const fixedHeight = height2 === 0 ? null : height2;
  return {
    cappedHeight,
    fixedHeight
  };
};
const exceedsMaxFiles = (root2, items) => {
  const allowReplace = root2.query("GET_ALLOW_REPLACE");
  const allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  let maxItems = root2.query("GET_MAX_FILES");
  const totalBrowseItems = items.length;
  if (!allowMultiple && totalBrowseItems > 1) {
    root2.dispatch("DID_THROW_MAX_FILES", {
      source: items,
      error: createResponse("warning", 0, "Max files")
    });
    return true;
  }
  maxItems = allowMultiple ? maxItems : 1;
  if (!allowMultiple && allowReplace) {
    return false;
  }
  const hasMaxItems = isInt(maxItems);
  if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
    root2.dispatch("DID_THROW_MAX_FILES", {
      source: items,
      error: createResponse("warning", 0, "Max files")
    });
    return true;
  }
  return false;
};
const getDragIndex = (list2, children, position) => {
  const itemList = list2.childViews[0];
  return getItemIndexByPosition(itemList, children, {
    left: position.scopeLeft - itemList.rect.element.left,
    top: position.scopeTop - (list2.rect.outer.top + list2.rect.element.marginTop + list2.rect.element.scrollTop)
  });
};
const toggleDrop = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_DROP");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.hopper) {
    const hopper = createHopper(
      root2.element,
      (items) => {
        const beforeDropFile = root2.query("GET_BEFORE_DROP_FILE") || (() => true);
        const dropValidation = root2.query("GET_DROP_VALIDATION");
        return dropValidation ? items.every(
          (item2) => applyFilters("ALLOW_HOPPER_ITEM", item2, {
            query: root2.query
          }).every((result) => result === true) && beforeDropFile(item2)
        ) : true;
      },
      {
        filterItems: (items) => {
          const ignoredFiles = root2.query("GET_IGNORED_FILES");
          return items.filter((item2) => {
            if (isFile$1(item2)) {
              return !ignoredFiles.includes(item2.name.toLowerCase());
            }
            return true;
          });
        },
        catchesDropsOnPage: root2.query("GET_DROP_ON_PAGE"),
        requiresDropOnElement: root2.query("GET_DROP_ON_ELEMENT")
      }
    );
    hopper.onload = (items, position) => {
      const list2 = root2.ref.list.childViews[0];
      const visibleChildren = list2.childViews.filter((child) => child.rect.element.height);
      const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
      applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: getDragIndex(root2.ref.list, children, position),
          interactionMethod: InteractionMethod.DROP
        });
      });
      root2.dispatch("DID_DROP", { position });
      root2.dispatch("DID_END_DRAG", { position });
    };
    hopper.ondragstart = (position) => {
      root2.dispatch("DID_START_DRAG", { position });
    };
    hopper.ondrag = debounce$1((position) => {
      root2.dispatch("DID_DRAG", { position });
    });
    hopper.ondragend = (position) => {
      root2.dispatch("DID_END_DRAG", { position });
    };
    root2.ref.hopper = hopper;
    root2.ref.drip = root2.appendChildView(root2.createChildView(drip));
  } else if (!enabled && root2.ref.hopper) {
    root2.ref.hopper.destroy();
    root2.ref.hopper = null;
    root2.removeChildView(root2.ref.drip);
  }
};
const toggleBrowse = (root2, props) => {
  const isAllowed = root2.query("GET_ALLOW_BROWSE");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.browser) {
    root2.ref.browser = root2.appendChildView(
      root2.createChildView(browser, {
        ...props,
        onload: (items) => {
          applyFilterChain("ADD_ITEMS", items, {
            dispatch: root2.dispatch
          }).then((queue) => {
            if (exceedsMaxFiles(root2, queue))
              return false;
            root2.dispatch("ADD_ITEMS", {
              items: queue,
              index: -1,
              interactionMethod: InteractionMethod.BROWSE
            });
          });
        }
      }),
      0
    );
  } else if (!enabled && root2.ref.browser) {
    root2.removeChildView(root2.ref.browser);
    root2.ref.browser = null;
  }
};
const togglePaste = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_PASTE");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.paster) {
    root2.ref.paster = createPaster();
    root2.ref.paster.onload = (items) => {
      applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: -1,
          interactionMethod: InteractionMethod.PASTE
        });
      });
    };
  } else if (!enabled && root2.ref.paster) {
    root2.ref.paster.destroy();
    root2.ref.paster = null;
  }
};
const route$5 = createRoute({
  DID_SET_ALLOW_BROWSE: ({ root: root2, props }) => {
    toggleBrowse(root2, props);
  },
  DID_SET_ALLOW_DROP: ({ root: root2 }) => {
    toggleDrop(root2);
  },
  DID_SET_ALLOW_PASTE: ({ root: root2 }) => {
    togglePaste(root2);
  },
  DID_SET_DISABLED: ({ root: root2, props }) => {
    toggleDrop(root2);
    togglePaste(root2);
    toggleBrowse(root2, props);
    const isDisabled2 = root2.query("GET_DISABLED");
    if (isDisabled2) {
      root2.element.dataset.disabled = "disabled";
    } else {
      root2.element.removeAttribute("data-disabled");
    }
  }
});
const root = createView({
  name: "root",
  read: ({ root: root2 }) => {
    if (root2.ref.measure) {
      root2.ref.measureHeight = root2.ref.measure.offsetHeight;
    }
  },
  create: create$e,
  write: write$9,
  destroy: ({ root: root2 }) => {
    if (root2.ref.paster) {
      root2.ref.paster.destroy();
    }
    if (root2.ref.hopper) {
      root2.ref.hopper.destroy();
    }
    root2.element.removeEventListener("touchmove", prevent);
    root2.element.removeEventListener("gesturestart", prevent);
  },
  mixins: {
    styles: ["height"]
  }
});
const createApp = (initialOptions = {}) => {
  let originalElement = null;
  const defaultOptions2 = getOptions();
  const store = createStore(
    // initial state (should be serializable)
    createInitialState(defaultOptions2),
    // queries
    [queries, createOptionQueries(defaultOptions2)],
    // action handlers
    [actions, createOptionActions(defaultOptions2)]
  );
  store.dispatch("SET_OPTIONS", { options: initialOptions });
  const visibilityHandler = () => {
    if (document.hidden)
      return;
    store.dispatch("KICK");
  };
  document.addEventListener("visibilitychange", visibilityHandler);
  let resizeDoneTimer = null;
  let isResizing = false;
  let isResizingHorizontally = false;
  let initialWindowWidth = null;
  let currentWindowWidth = null;
  const resizeHandler = () => {
    if (!isResizing) {
      isResizing = true;
    }
    clearTimeout(resizeDoneTimer);
    resizeDoneTimer = setTimeout(() => {
      isResizing = false;
      initialWindowWidth = null;
      currentWindowWidth = null;
      if (isResizingHorizontally) {
        isResizingHorizontally = false;
        store.dispatch("DID_STOP_RESIZE");
      }
    }, 500);
  };
  window.addEventListener("resize", resizeHandler);
  const view = root(store, { id: getUniqueId$1() });
  let isResting = false;
  let isHidden = false;
  const readWriteApi = {
    // necessary for update loop
    /**
     * Reads from dom (never call manually)
     * @private
     */
    _read: () => {
      if (isResizing) {
        currentWindowWidth = window.innerWidth;
        if (!initialWindowWidth) {
          initialWindowWidth = currentWindowWidth;
        }
        if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {
          store.dispatch("DID_START_RESIZE");
          isResizingHorizontally = true;
        }
      }
      if (isHidden && isResting) {
        isResting = view.element.offsetParent === null;
      }
      if (isResting)
        return;
      view._read();
      isHidden = view.rect.element.hidden;
    },
    /**
     * Writes to dom (never call manually)
     * @private
     */
    _write: (ts) => {
      const actions2 = store.processActionQueue().filter((action) => !/^SET_/.test(action.type));
      if (isResting && !actions2.length)
        return;
      routeActionsToEvents(actions2);
      isResting = view._write(ts, actions2, isResizingHorizontally);
      removeReleasedItems(store.query("GET_ITEMS"));
      if (isResting) {
        store.processDispatchQueue();
      }
    }
  };
  const createEvent = (name2) => (data2) => {
    const event = {
      type: name2
    };
    if (!data2) {
      return event;
    }
    if (data2.hasOwnProperty("error")) {
      event.error = data2.error ? { ...data2.error } : null;
    }
    if (data2.status) {
      event.status = { ...data2.status };
    }
    if (data2.file) {
      event.output = data2.file;
    }
    if (data2.source) {
      event.file = data2.source;
    } else if (data2.item || data2.id) {
      const item2 = data2.item ? data2.item : store.query("GET_ITEM", data2.id);
      event.file = item2 ? createItemAPI(item2) : null;
    }
    if (data2.items) {
      event.items = data2.items.map(createItemAPI);
    }
    if (/progress/.test(name2)) {
      event.progress = data2.progress;
    }
    if (data2.hasOwnProperty("origin") && data2.hasOwnProperty("target")) {
      event.origin = data2.origin;
      event.target = data2.target;
    }
    return event;
  };
  const eventRoutes = {
    DID_DESTROY: createEvent("destroy"),
    DID_INIT: createEvent("init"),
    DID_THROW_MAX_FILES: createEvent("warning"),
    DID_INIT_ITEM: createEvent("initfile"),
    DID_START_ITEM_LOAD: createEvent("addfilestart"),
    DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent("addfileprogress"),
    DID_LOAD_ITEM: createEvent("addfile"),
    DID_THROW_ITEM_INVALID: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_LOAD_ERROR: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_REMOVE_ERROR: [createEvent("error"), createEvent("removefile")],
    DID_PREPARE_OUTPUT: createEvent("preparefile"),
    DID_START_ITEM_PROCESSING: createEvent("processfilestart"),
    DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent("processfileprogress"),
    DID_ABORT_ITEM_PROCESSING: createEvent("processfileabort"),
    DID_COMPLETE_ITEM_PROCESSING: createEvent("processfile"),
    DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent("processfiles"),
    DID_REVERT_ITEM_PROCESSING: createEvent("processfilerevert"),
    DID_THROW_ITEM_PROCESSING_ERROR: [createEvent("error"), createEvent("processfile")],
    DID_REMOVE_ITEM: createEvent("removefile"),
    DID_UPDATE_ITEMS: createEvent("updatefiles"),
    DID_ACTIVATE_ITEM: createEvent("activatefile"),
    DID_REORDER_ITEMS: createEvent("reorderfiles")
  };
  const exposeEvent = (event) => {
    const detail = { pond: exports, ...event };
    delete detail.type;
    view.element.dispatchEvent(
      new CustomEvent(`FilePond:${event.type}`, {
        // event info
        detail,
        // event behaviour
        bubbles: true,
        cancelable: true,
        composed: true
        // triggers listeners outside of shadow root
      })
    );
    const params = [];
    if (event.hasOwnProperty("error")) {
      params.push(event.error);
    }
    if (event.hasOwnProperty("file")) {
      params.push(event.file);
    }
    const filtered = ["type", "error", "file"];
    Object.keys(event).filter((key) => !filtered.includes(key)).forEach((key) => params.push(event[key]));
    exports.fire(event.type, ...params);
    const handler = store.query(`GET_ON${event.type.toUpperCase()}`);
    if (handler) {
      handler(...params);
    }
  };
  const routeActionsToEvents = (actions2) => {
    if (!actions2.length)
      return;
    actions2.filter((action) => eventRoutes[action.type]).forEach((action) => {
      const routes = eventRoutes[action.type];
      (Array.isArray(routes) ? routes : [routes]).forEach((route2) => {
        if (action.type === "DID_INIT_ITEM") {
          exposeEvent(route2(action.data));
        } else {
          setTimeout(() => {
            exposeEvent(route2(action.data));
          }, 0);
        }
      });
    });
  };
  const setOptions2 = (options) => store.dispatch("SET_OPTIONS", { options });
  const getFile = (query) => store.query("GET_ACTIVE_ITEM", query);
  const prepareFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PREPARE", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const addFile = (source, options = {}) => new Promise((resolve, reject) => {
    addFiles([{ source, options }], { index: options.index }).then((items) => resolve(items && items[0])).catch(reject);
  });
  const isFilePondFile = (obj) => obj.file && obj.id;
  const removeFile = (query, options) => {
    if (typeof query === "object" && !isFilePondFile(query) && !options) {
      options = query;
      query = void 0;
    }
    store.dispatch("REMOVE_ITEM", { ...options, query });
    return store.query("GET_ACTIVE_ITEM", query) === null;
  };
  const addFiles = (...args) => new Promise((resolve, reject) => {
    const sources = [];
    const options = {};
    if (isArray$1(args[0])) {
      sources.push.apply(sources, args[0]);
      Object.assign(options, args[1] || {});
    } else {
      const lastArgument = args[args.length - 1];
      if (typeof lastArgument === "object" && !(lastArgument instanceof Blob)) {
        Object.assign(options, args.pop());
      }
      sources.push(...args);
    }
    store.dispatch("ADD_ITEMS", {
      items: sources,
      index: options.index,
      interactionMethod: InteractionMethod.API,
      success: resolve,
      failure: reject
    });
  });
  const getFiles2 = () => store.query("GET_ACTIVE_ITEMS");
  const processFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PROCESSING", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const prepareFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    const items = queries2.length ? queries2 : getFiles2();
    return Promise.all(items.map(prepareFile));
  };
  const processFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    if (!queries2.length) {
      const files = getFiles2().filter(
        (item2) => !(item2.status === ItemStatus.IDLE && item2.origin === FileOrigin.LOCAL) && item2.status !== ItemStatus.PROCESSING && item2.status !== ItemStatus.PROCESSING_COMPLETE && item2.status !== ItemStatus.PROCESSING_REVERT_ERROR
      );
      return Promise.all(files.map(processFile));
    }
    return Promise.all(queries2.map(processFile));
  };
  const removeFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    let options;
    if (typeof queries2[queries2.length - 1] === "object") {
      options = queries2.pop();
    } else if (Array.isArray(args[0])) {
      options = args[1];
    }
    const files = getFiles2();
    if (!queries2.length)
      return Promise.all(files.map((file2) => removeFile(file2, options)));
    const mappedQueries = queries2.map((query) => isNumber$1(query) ? files[query] ? files[query].id : null : query).filter((query) => query);
    return mappedQueries.map((q) => removeFile(q, options));
  };
  const exports = {
    // supports events
    ...on(),
    // inject private api methods
    ...readWriteApi,
    // inject all getters and setters
    ...createOptionAPI(store, defaultOptions2),
    /**
     * Override options defined in options object
     * @param options
     */
    setOptions: setOptions2,
    /**
     * Load the given file
     * @param source - the source of the file (either a File, base64 data uri or url)
     * @param options - object, { index: 0 }
     */
    addFile,
    /**
     * Load the given files
     * @param sources - the sources of the files to load
     * @param options - object, { index: 0 }
     */
    addFiles,
    /**
     * Returns the file objects matching the given query
     * @param query { string, number, null }
     */
    getFile,
    /**
     * Upload file with given name
     * @param query { string, number, null  }
     */
    processFile,
    /**
     * Request prepare output for file with given name
     * @param query { string, number, null  }
     */
    prepareFile,
    /**
     * Removes a file by its name
     * @param query { string, number, null  }
     */
    removeFile,
    /**
     * Moves a file to a new location in the files list
     */
    moveFile: (query, index) => store.dispatch("MOVE_ITEM", { query, index }),
    /**
     * Returns all files (wrapped in public api)
     */
    getFiles: getFiles2,
    /**
     * Starts uploading all files
     */
    processFiles,
    /**
     * Clears all files from the files list
     */
    removeFiles,
    /**
     * Starts preparing output of all files
     */
    prepareFiles,
    /**
     * Sort list of files
     */
    sort: (compare) => store.dispatch("SORT", { compare }),
    /**
     * Browse the file system for a file
     */
    browse: () => {
      var input = view.element.querySelector("input[type=file]");
      if (input) {
        input.click();
      }
    },
    /**
     * Destroys the app
     */
    destroy: () => {
      exports.fire("destroy", view.element);
      store.dispatch("ABORT_ALL");
      view._destroy();
      window.removeEventListener("resize", resizeHandler);
      document.removeEventListener("visibilitychange", visibilityHandler);
      store.dispatch("DID_DESTROY");
    },
    /**
     * Inserts the plugin before the target element
     */
    insertBefore: (element) => insertBefore(view.element, element),
    /**
     * Inserts the plugin after the target element
     */
    insertAfter: (element) => insertAfter(view.element, element),
    /**
     * Appends the plugin to the target element
     */
    appendTo: (element) => element.appendChild(view.element),
    /**
     * Replaces an element with the app
     */
    replaceElement: (element) => {
      insertBefore(view.element, element);
      element.parentNode.removeChild(element);
      originalElement = element;
    },
    /**
     * Restores the original element
     */
    restoreElement: () => {
      if (!originalElement) {
        return;
      }
      insertAfter(originalElement, view.element);
      view.element.parentNode.removeChild(view.element);
      originalElement = null;
    },
    /**
     * Returns true if the app root is attached to given element
     * @param element
     */
    isAttachedTo: (element) => view.element === element || originalElement === element,
    /**
     * Returns the root element
     */
    element: {
      get: () => view.element
    },
    /**
     * Returns the current pond status
     */
    status: {
      get: () => store.query("GET_STATUS")
    }
  };
  store.dispatch("DID_INIT");
  return createObject(exports);
};
const createAppObject = (customOptions = {}) => {
  const defaultOptions2 = {};
  forin(getOptions(), (key, value) => {
    defaultOptions2[key] = value[0];
  });
  const app = createApp({
    // default options
    ...defaultOptions2,
    // custom options
    ...customOptions
  });
  return app;
};
const lowerCaseFirstLetter = (string) => string.charAt(0).toLowerCase() + string.slice(1);
const attributeNameToPropertyName = (attributeName) => toCamels(attributeName.replace(/^data-/, ""));
const mapObject = (object, propertyMap) => {
  forin(propertyMap, (selector, mapping) => {
    forin(object, (property, value) => {
      const selectorRegExp = new RegExp(selector);
      const matches = selectorRegExp.test(property);
      if (!matches) {
        return;
      }
      delete object[property];
      if (mapping === false) {
        return;
      }
      if (isString$1(mapping)) {
        object[mapping] = value;
        return;
      }
      const group = mapping.group;
      if (isObject$1(mapping) && !object[group]) {
        object[group] = {};
      }
      object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ""))] = value;
    });
    if (mapping.mapping) {
      mapObject(object[mapping.group], mapping.mapping);
    }
  });
};
const getAttributesAsObject = (node, attributeMapping = {}) => {
  const attributes = [];
  forin(node.attributes, (index) => {
    attributes.push(node.attributes[index]);
  });
  const output = attributes.filter((attribute) => attribute.name).reduce((obj, attribute) => {
    const value = attr(node, attribute.name);
    obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;
    return obj;
  }, {});
  mapObject(output, attributeMapping);
  return output;
};
const createAppAtElement = (element, options = {}) => {
  const attributeMapping = {
    // translate to other name
    "^class$": "className",
    "^multiple$": "allowMultiple",
    "^capture$": "captureMethod",
    "^webkitdirectory$": "allowDirectoriesOnly",
    // group under single property
    "^server": {
      group: "server",
      mapping: {
        "^process": {
          group: "process"
        },
        "^revert": {
          group: "revert"
        },
        "^fetch": {
          group: "fetch"
        },
        "^restore": {
          group: "restore"
        },
        "^load": {
          group: "load"
        }
      }
    },
    // don't include in object
    "^type$": false,
    "^files$": false
  };
  applyFilters("SET_ATTRIBUTE_TO_OPTION_MAP", attributeMapping);
  const mergedOptions = {
    ...options
  };
  const attributeOptions = getAttributesAsObject(
    element.nodeName === "FIELDSET" ? element.querySelector("input[type=file]") : element,
    attributeMapping
  );
  Object.keys(attributeOptions).forEach((key) => {
    if (isObject$1(attributeOptions[key])) {
      if (!isObject$1(mergedOptions[key])) {
        mergedOptions[key] = {};
      }
      Object.assign(mergedOptions[key], attributeOptions[key]);
    } else {
      mergedOptions[key] = attributeOptions[key];
    }
  });
  mergedOptions.files = (options.files || []).concat(
    Array.from(element.querySelectorAll("input:not([type=file])")).map((input) => ({
      source: input.value,
      options: {
        type: input.dataset.type
      }
    }))
  );
  const app = createAppObject(mergedOptions);
  if (element.files) {
    Array.from(element.files).forEach((file2) => {
      app.addFile(file2);
    });
  }
  app.replaceElement(element);
  return app;
};
const createApp$1 = (...args) => isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);
const PRIVATE_METHODS = ["fire", "_read", "_write"];
const createAppAPI = (app) => {
  const api = {};
  copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);
  return api;
};
const replaceInString = (string, replacements) => string.replace(/(?:{([a-zA-Z]+)})/g, (match, group) => replacements[group]);
const createWorker$1 = (fn3) => {
  const workerBlob = new Blob(["(", fn3.toString(), ")()"], {
    type: "application/javascript"
  });
  const workerURL = URL.createObjectURL(workerBlob);
  const worker = new Worker(workerURL);
  return {
    transfer: (message, cb) => {
    },
    post: (message, cb, transferList) => {
      const id = getUniqueId$1();
      worker.onmessage = (e) => {
        if (e.data.id === id) {
          cb(e.data.message);
        }
      };
      worker.postMessage(
        {
          id,
          message
        },
        transferList
      );
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(workerURL);
    }
  };
};
const loadImage$3 = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
const renameFile = (file2, name2) => {
  const renamedFile = file2.slice(0, file2.size, file2.type);
  renamedFile.lastModifiedDate = file2.lastModifiedDate;
  renamedFile.name = name2;
  return renamedFile;
};
const copyFile = (file2) => renameFile(file2, file2.name);
const registeredPlugins = [];
const createAppPlugin = (plugin2) => {
  if (registeredPlugins.includes(plugin2)) {
    return;
  }
  registeredPlugins.push(plugin2);
  const pluginOutline = plugin2({
    addFilter,
    utils: {
      Type,
      forin,
      isString: isString$1,
      isFile: isFile$1,
      toNaturalFileSize,
      replaceInString,
      getExtensionFromFilename,
      getFilenameWithoutExtension: getFilenameWithoutExtension$1,
      guesstimateMimeType,
      getFileFromBlob,
      getFilenameFromURL,
      createRoute,
      createWorker: createWorker$1,
      createView,
      createItemAPI,
      loadImage: loadImage$3,
      copyFile,
      renameFile,
      createBlob: createBlob$1,
      applyFilterChain,
      text,
      getNumericAspectRatioFromString
    },
    views: {
      fileActionButton
    }
  });
  extendDefaultOptions(pluginOutline.options);
};
const isOperaMini = () => Object.prototype.toString.call(window.operamini) === "[object OperaMini]";
const hasPromises = () => "Promise" in window;
const hasBlobSlice = () => "slice" in Blob.prototype;
const hasCreateObjectURL = () => "URL" in window && "createObjectURL" in window.URL;
const hasVisibility = () => "visibilityState" in document;
const hasTiming = () => "performance" in window;
const hasCSSSupports = () => "supports" in (window.CSS || {});
const isIE11 = () => /MSIE|Trident/.test(window.navigator.userAgent);
const supported = (() => {
  const isSupported = (
    // Has to be a browser
    isBrowser$9() && // Can't run on Opera Mini due to lack of everything
    !isOperaMini() && // Require these APIs to feature detect a modern browser
    hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)
    (hasCSSSupports() || isIE11())
  );
  return () => isSupported;
})();
const state = {
  // active app instances, used to redraw the apps and to find the later
  apps: []
};
const name = "filepond";
const fn = () => {
};
let Status$1 = {};
let FileStatus = {};
let FileOrigin$1 = {};
let OptionTypes = {};
let create$f = fn;
let destroy = fn;
let parse = fn;
let find = fn;
let registerPlugin = fn;
let getOptions$1 = fn;
let setOptions$1 = fn;
if (supported()) {
  createPainter(
    () => {
      state.apps.forEach((app) => app._read());
    },
    (ts) => {
      state.apps.forEach((app) => app._write(ts));
    }
  );
  const dispatch = () => {
    document.dispatchEvent(
      new CustomEvent("FilePond:loaded", {
        detail: {
          supported,
          create: create$f,
          destroy,
          parse,
          find,
          registerPlugin,
          setOptions: setOptions$1
        }
      })
    );
    document.removeEventListener("DOMContentLoaded", dispatch);
  };
  if (document.readyState !== "loading") {
    setTimeout(() => dispatch(), 0);
  } else {
    document.addEventListener("DOMContentLoaded", dispatch);
  }
  const updateOptionTypes = () => forin(getOptions(), (key, value) => {
    OptionTypes[key] = value[1];
  });
  Status$1 = { ...Status };
  FileOrigin$1 = { ...FileOrigin };
  FileStatus = { ...ItemStatus };
  OptionTypes = {};
  updateOptionTypes();
  create$f = (...args) => {
    const app = createApp$1(...args);
    app.on("destroy", destroy);
    state.apps.push(app);
    return createAppAPI(app);
  };
  destroy = (hook) => {
    const indexToRemove = state.apps.findIndex((app) => app.isAttachedTo(hook));
    if (indexToRemove >= 0) {
      const app = state.apps.splice(indexToRemove, 1)[0];
      app.restoreElement();
      return true;
    }
    return false;
  };
  parse = (context) => {
    const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));
    const newHooks = matchedHooks.filter(
      (newHook) => !state.apps.find((app) => app.isAttachedTo(newHook))
    );
    return newHooks.map((hook) => create$f(hook));
  };
  find = (hook) => {
    const app = state.apps.find((app2) => app2.isAttachedTo(hook));
    if (!app) {
      return null;
    }
    return createAppAPI(app);
  };
  registerPlugin = (...plugins) => {
    plugins.forEach(createAppPlugin);
    updateOptionTypes();
  };
  getOptions$1 = () => {
    const opts = {};
    forin(getOptions(), (key, value) => {
      opts[key] = value[0];
    });
    return opts;
  };
  setOptions$1 = (opts) => {
    if (isObject$1(opts)) {
      state.apps.forEach((app) => {
        app.setOptions(opts);
      });
      setOptions(opts);
    }
    return getOptions$1();
  };
}
const FilePond = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get FileOrigin() {
    return FileOrigin$1;
  },
  get FileStatus() {
    return FileStatus;
  },
  get OptionTypes() {
    return OptionTypes;
  },
  get Status() {
    return Status$1;
  },
  get create() {
    return create$f;
  },
  get destroy() {
    return destroy;
  },
  get find() {
    return find;
  },
  get getOptions() {
    return getOptions$1;
  },
  get parse() {
    return parse;
  },
  get registerPlugin() {
    return registerPlugin;
  },
  get setOptions() {
    return setOptions$1;
  },
  supported
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * FilePondPluginFileValidateType 1.2.8
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const plugin$8 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const {
    Type: Type2,
    isString: isString2,
    replaceInString: replaceInString2,
    guesstimateMimeType: guesstimateMimeType2,
    getExtensionFromFilename: getExtensionFromFilename2,
    getFilenameFromURL: getFilenameFromURL2
  } = utils2;
  const mimeTypeMatchesWildCard = (mimeType, wildcard) => {
    const mimeTypeGroup = (/^[^/]+/.exec(mimeType) || []).pop();
    const wildcardGroup = wildcard.slice(0, -2);
    return mimeTypeGroup === wildcardGroup;
  };
  const isValidMimeType = (acceptedTypes, userInputType) => acceptedTypes.some((acceptedType) => {
    if (/\*$/.test(acceptedType)) {
      return mimeTypeMatchesWildCard(userInputType, acceptedType);
    }
    return acceptedType === userInputType;
  });
  const getItemType = (item2) => {
    let type = "";
    if (isString2(item2)) {
      const filename = getFilenameFromURL2(item2);
      const extension = getExtensionFromFilename2(filename);
      if (extension) {
        type = guesstimateMimeType2(extension);
      }
    } else {
      type = item2.type;
    }
    return type;
  };
  const validateFile = (item2, acceptedFileTypes, typeDetector) => {
    if (acceptedFileTypes.length === 0) {
      return true;
    }
    const type = getItemType(item2);
    if (!typeDetector) {
      return isValidMimeType(acceptedFileTypes, type);
    }
    return new Promise((resolve, reject) => {
      typeDetector(item2, type).then((detectedType) => {
        if (isValidMimeType(acceptedFileTypes, detectedType)) {
          resolve();
        } else {
          reject();
        }
      }).catch(reject);
    });
  };
  const applyMimeTypeMap = (map2) => (acceptedFileType) => map2[acceptedFileType] === null ? false : map2[acceptedFileType] || acceptedFileType;
  addFilter2(
    "SET_ATTRIBUTE_TO_OPTION_MAP",
    (map2) => Object.assign(map2, {
      accept: "acceptedFileTypes"
    })
  );
  addFilter2("ALLOW_HOPPER_ITEM", (file2, { query }) => {
    if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
      return true;
    }
    return validateFile(file2, query("GET_ACCEPTED_FILE_TYPES"));
  });
  addFilter2(
    "LOAD_FILE",
    (file2, { query }) => new Promise((resolve, reject) => {
      if (!query("GET_ALLOW_FILE_TYPE_VALIDATION")) {
        resolve(file2);
        return;
      }
      const acceptedFileTypes = query("GET_ACCEPTED_FILE_TYPES");
      const typeDetector = query("GET_FILE_VALIDATE_TYPE_DETECT_TYPE");
      const validationResult = validateFile(
        file2,
        acceptedFileTypes,
        typeDetector
      );
      const handleRejection = () => {
        const acceptedFileTypesMapped = acceptedFileTypes.map(
          applyMimeTypeMap(
            query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP")
          )
        ).filter((label) => label !== false);
        const acceptedFileTypesMapped_unique = acceptedFileTypesMapped.filter(
          function(item2, index) {
            return acceptedFileTypesMapped.indexOf(item2) === index;
          }
        );
        reject({
          status: {
            main: query("GET_LABEL_FILE_TYPE_NOT_ALLOWED"),
            sub: replaceInString2(
              query("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES"),
              {
                allTypes: acceptedFileTypesMapped_unique.join(", "),
                allButLastType: acceptedFileTypesMapped_unique.slice(0, -1).join(", "),
                lastType: acceptedFileTypesMapped_unique[acceptedFileTypesMapped.length - 1]
              }
            )
          }
        });
      };
      if (typeof validationResult === "boolean") {
        if (!validationResult) {
          return handleRejection();
        }
        return resolve(file2);
      }
      validationResult.then(() => {
        resolve(file2);
      }).catch(handleRejection);
    })
  );
  return {
    // default options
    options: {
      // Enable or disable file type validation
      allowFileTypeValidation: [true, Type2.BOOLEAN],
      // What file types to accept
      acceptedFileTypes: [[], Type2.ARRAY],
      // - must be comma separated
      // - mime types: image/png, image/jpeg, image/gif
      // - extensions: .png, .jpg, .jpeg ( not enabled yet )
      // - wildcards: image/*
      // label to show when a type is not allowed
      labelFileTypeNotAllowed: ["File is of invalid type", Type2.STRING],
      // nicer label
      fileValidateTypeLabelExpectedTypes: [
        "Expects {allButLastType} or {lastType}",
        Type2.STRING
      ],
      // map mime types to extensions
      fileValidateTypeLabelExpectedTypesMap: [{}, Type2.OBJECT],
      // Custom function to detect type of file
      fileValidateTypeDetectType: [null, Type2.FUNCTION]
    }
  };
};
const isBrowser$8 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$8) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$8 })
  );
}
/*!
 * FilePondPluginImagePreview 4.6.11
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isPreviewableImage$1 = (file2) => /^image/.test(file2.type);
const vectorMultiply$1 = (v, amount) => createVector$2(v.x * amount, v.y * amount);
const vectorAdd$1 = (a, b) => createVector$2(a.x + b.x, a.y + b.y);
const vectorNormalize$1 = (v) => {
  const l = Math.sqrt(v.x * v.x + v.y * v.y);
  if (l === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  return createVector$2(v.x / l, v.y / l);
};
const vectorRotate$1 = (v, radians, origin) => {
  const cos = Math.cos(radians);
  const sin = Math.sin(radians);
  const t = createVector$2(v.x - origin.x, v.y - origin.y);
  return createVector$2(
    origin.x + cos * t.x - sin * t.y,
    origin.y + sin * t.x + cos * t.y
  );
};
const createVector$2 = (x = 0, y = 0) => ({ x, y });
const getMarkupValue$1 = (value, size, scalar = 1, axis) => {
  if (typeof value === "string") {
    return parseFloat(value) * scalar;
  }
  if (typeof value === "number") {
    return value * (axis ? size[axis] : Math.min(size.width, size.height));
  }
  return;
};
const getMarkupStyles$1 = (markup, size, scale) => {
  const lineStyle = markup.borderStyle || markup.lineStyle || "solid";
  const fill = markup.backgroundColor || markup.fontColor || "transparent";
  const stroke = markup.borderColor || markup.lineColor || "transparent";
  const strokeWidth = getMarkupValue$1(
    markup.borderWidth || markup.lineWidth,
    size,
    scale
  );
  const lineCap = markup.lineCap || "round";
  const lineJoin = markup.lineJoin || "round";
  const dashes = typeof lineStyle === "string" ? "" : lineStyle.map((v) => getMarkupValue$1(v, size, scale)).join(",");
  const opacity = markup.opacity || 1;
  return {
    "stroke-linecap": lineCap,
    "stroke-linejoin": lineJoin,
    "stroke-width": strokeWidth || 0,
    "stroke-dasharray": dashes,
    stroke,
    fill,
    opacity
  };
};
const isDefined$1 = (value) => value != null;
const getMarkupRect$1 = (rect, size, scalar = 1) => {
  let left2 = getMarkupValue$1(rect.x, size, scalar, "width") || getMarkupValue$1(rect.left, size, scalar, "width");
  let top2 = getMarkupValue$1(rect.y, size, scalar, "height") || getMarkupValue$1(rect.top, size, scalar, "height");
  let width2 = getMarkupValue$1(rect.width, size, scalar, "width");
  let height2 = getMarkupValue$1(rect.height, size, scalar, "height");
  let right2 = getMarkupValue$1(rect.right, size, scalar, "width");
  let bottom2 = getMarkupValue$1(rect.bottom, size, scalar, "height");
  if (!isDefined$1(top2)) {
    if (isDefined$1(height2) && isDefined$1(bottom2)) {
      top2 = size.height - height2 - bottom2;
    } else {
      top2 = bottom2;
    }
  }
  if (!isDefined$1(left2)) {
    if (isDefined$1(width2) && isDefined$1(right2)) {
      left2 = size.width - width2 - right2;
    } else {
      left2 = right2;
    }
  }
  if (!isDefined$1(width2)) {
    if (isDefined$1(left2) && isDefined$1(right2)) {
      width2 = size.width - left2 - right2;
    } else {
      width2 = 0;
    }
  }
  if (!isDefined$1(height2)) {
    if (isDefined$1(top2) && isDefined$1(bottom2)) {
      height2 = size.height - top2 - bottom2;
    } else {
      height2 = 0;
    }
  }
  return {
    x: left2 || 0,
    y: top2 || 0,
    width: width2 || 0,
    height: height2 || 0
  };
};
const pointsToPathShape$1 = (points) => points.map((point, index) => `${index === 0 ? "M" : "L"} ${point.x} ${point.y}`).join(" ");
const setAttributes$1 = (element, attr2) => Object.keys(attr2).forEach((key) => element.setAttribute(key, attr2[key]));
const ns$1 = "http://www.w3.org/2000/svg";
const svg$1 = (tag, attr2) => {
  const element = document.createElementNS(ns$1, tag);
  if (attr2) {
    setAttributes$1(element, attr2);
  }
  return element;
};
const updateRect$1 = (element) => setAttributes$1(element, {
  ...element.rect,
  ...element.styles
});
const updateEllipse$1 = (element) => {
  const cx = element.rect.x + element.rect.width * 0.5;
  const cy = element.rect.y + element.rect.height * 0.5;
  const rx = element.rect.width * 0.5;
  const ry = element.rect.height * 0.5;
  return setAttributes$1(element, {
    cx,
    cy,
    rx,
    ry,
    ...element.styles
  });
};
const IMAGE_FIT_STYLE$1 = {
  contain: "xMidYMid meet",
  cover: "xMidYMid slice"
};
const updateImage$1 = (element, markup) => {
  setAttributes$1(element, {
    ...element.rect,
    ...element.styles,
    preserveAspectRatio: IMAGE_FIT_STYLE$1[markup.fit] || "none"
  });
};
const TEXT_ANCHOR$1 = {
  left: "start",
  center: "middle",
  right: "end"
};
const updateText$1 = (element, markup, size, scale) => {
  const fontSize = getMarkupValue$1(markup.fontSize, size, scale);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = TEXT_ANCHOR$1[markup.textAlign] || "start";
  setAttributes$1(element, {
    ...element.rect,
    ...element.styles,
    "stroke-width": 0,
    "font-weight": fontWeight,
    "font-size": fontSize,
    "font-family": fontFamily,
    "text-anchor": textAlign
  });
  if (element.text !== markup.text) {
    element.text = markup.text;
    element.textContent = markup.text.length ? markup.text : " ";
  }
};
const updateLine$1 = (element, markup, size, scale) => {
  setAttributes$1(element, {
    ...element.rect,
    ...element.styles,
    fill: "none"
  });
  const line = element.childNodes[0];
  const begin = element.childNodes[1];
  const end2 = element.childNodes[2];
  const origin = element.rect;
  const target = {
    x: element.rect.x + element.rect.width,
    y: element.rect.y + element.rect.height
  };
  setAttributes$1(line, {
    x1: origin.x,
    y1: origin.y,
    x2: target.x,
    y2: target.y
  });
  if (!markup.lineDecoration)
    return;
  begin.style.display = "none";
  end2.style.display = "none";
  const v = vectorNormalize$1({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = getMarkupValue$1(0.05, size, scale);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply$1(v, l);
    const arrowBeginCenter = vectorAdd$1(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate$1(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate$1(origin, -2, arrowBeginCenter);
    setAttributes$1(begin, {
      style: "display:block;",
      d: `M${arrowBeginA.x},${arrowBeginA.y} L${origin.x},${origin.y} L${arrowBeginB.x},${arrowBeginB.y}`
    });
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply$1(v, -l);
    const arrowEndCenter = vectorAdd$1(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate$1(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate$1(target, -2, arrowEndCenter);
    setAttributes$1(end2, {
      style: "display:block;",
      d: `M${arrowEndA.x},${arrowEndA.y} L${target.x},${target.y} L${arrowEndB.x},${arrowEndB.y}`
    });
  }
};
const updatePath$1 = (element, markup, size, scale) => {
  setAttributes$1(element, {
    ...element.styles,
    fill: "none",
    d: pointsToPathShape$1(
      markup.points.map((point) => ({
        x: getMarkupValue$1(point.x, size, scale, "width"),
        y: getMarkupValue$1(point.y, size, scale, "height")
      }))
    )
  });
};
const createShape$1 = (node) => (markup) => svg$1(node, { id: markup.id });
const createImage$1 = (markup) => {
  const shape = svg$1("image", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: "0"
  });
  shape.onload = () => {
    shape.setAttribute("opacity", markup.opacity || 1);
  };
  shape.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "xlink:href",
    markup.src
  );
  return shape;
};
const createLine$1 = (markup) => {
  const shape = svg$1("g", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  });
  const line = svg$1("line");
  shape.appendChild(line);
  const begin = svg$1("path");
  shape.appendChild(begin);
  const end2 = svg$1("path");
  shape.appendChild(end2);
  return shape;
};
const CREATE_TYPE_ROUTES$1 = {
  image: createImage$1,
  rect: createShape$1("rect"),
  ellipse: createShape$1("ellipse"),
  text: createShape$1("text"),
  path: createShape$1("path"),
  line: createLine$1
};
const UPDATE_TYPE_ROUTES$1 = {
  rect: updateRect$1,
  ellipse: updateEllipse$1,
  image: updateImage$1,
  text: updateText$1,
  path: updatePath$1,
  line: updateLine$1
};
const createMarkupByType$1 = (type, markup) => CREATE_TYPE_ROUTES$1[type](markup);
const updateMarkupByType$1 = (element, type, markup, size, scale) => {
  if (type !== "path") {
    element.rect = getMarkupRect$1(markup, size, scale);
  }
  element.styles = getMarkupStyles$1(markup, size, scale);
  UPDATE_TYPE_ROUTES$1[type](element, markup, size, scale);
};
const MARKUP_RECT$1 = [
  "x",
  "y",
  "left",
  "top",
  "right",
  "bottom",
  "width",
  "height"
];
const toOptionalFraction$1 = (value) => typeof value === "string" && /%/.test(value) ? parseFloat(value) / 100 : value;
const prepareMarkup$1 = (markup) => {
  const [type, props] = markup;
  const rect = props.points ? {} : MARKUP_RECT$1.reduce((prev, curr) => {
    prev[curr] = toOptionalFraction$1(props[curr]);
    return prev;
  }, {});
  return [
    type,
    {
      zIndex: 0,
      ...props,
      ...rect
    }
  ];
};
const sortMarkupByZIndex$1 = (a, b) => {
  if (a[1].zIndex > b[1].zIndex) {
    return 1;
  }
  if (a[1].zIndex < b[1].zIndex) {
    return -1;
  }
  return 0;
};
const createMarkupView = (_2) => _2.utils.createView({
  name: "image-preview-markup",
  tag: "svg",
  ignoreRect: true,
  mixins: {
    apis: ["width", "height", "crop", "markup", "resize", "dirty"]
  },
  write: ({ root: root2, props }) => {
    if (!props.dirty)
      return;
    const { crop, resize, markup } = props;
    const viewWidth = props.width;
    const viewHeight = props.height;
    let cropWidth = crop.width;
    let cropHeight = crop.height;
    if (resize) {
      const { size: size2 } = resize;
      let outputWidth = size2 && size2.width;
      let outputHeight = size2 && size2.height;
      const outputFit = resize.mode;
      const outputUpscale = resize.upscale;
      if (outputWidth && !outputHeight)
        outputHeight = outputWidth;
      if (outputHeight && !outputWidth)
        outputWidth = outputHeight;
      const shouldUpscale = cropWidth < outputWidth && cropHeight < outputHeight;
      if (!shouldUpscale || shouldUpscale && outputUpscale) {
        let scalarWidth = outputWidth / cropWidth;
        let scalarHeight = outputHeight / cropHeight;
        if (outputFit === "force") {
          cropWidth = outputWidth;
          cropHeight = outputHeight;
        } else {
          let scalar;
          if (outputFit === "cover") {
            scalar = Math.max(scalarWidth, scalarHeight);
          } else if (outputFit === "contain") {
            scalar = Math.min(scalarWidth, scalarHeight);
          }
          cropWidth = cropWidth * scalar;
          cropHeight = cropHeight * scalar;
        }
      }
    }
    const size = {
      width: viewWidth,
      height: viewHeight
    };
    root2.element.setAttribute("width", size.width);
    root2.element.setAttribute("height", size.height);
    const scale = Math.min(viewWidth / cropWidth, viewHeight / cropHeight);
    root2.element.innerHTML = "";
    const markupFilter = root2.query("GET_IMAGE_PREVIEW_MARKUP_FILTER");
    markup.filter(markupFilter).map(prepareMarkup$1).sort(sortMarkupByZIndex$1).forEach((markup2) => {
      const [type, settings] = markup2;
      const element = createMarkupByType$1(type, settings);
      updateMarkupByType$1(element, type, settings, size, scale);
      root2.element.appendChild(element);
    });
  }
});
const createVector$1$1 = (x, y) => ({ x, y });
const vectorDot$1 = (a, b) => a.x * b.x + a.y * b.y;
const vectorSubtract$1 = (a, b) => createVector$1$1(a.x - b.x, a.y - b.y);
const vectorDistanceSquared$1 = (a, b) => vectorDot$1(vectorSubtract$1(a, b), vectorSubtract$1(a, b));
const vectorDistance$1 = (a, b) => Math.sqrt(vectorDistanceSquared$1(a, b));
const getOffsetPointOnEdge$1 = (length, rotation) => {
  const a = length;
  const A = 1.5707963267948966;
  const B = rotation;
  const C = 1.5707963267948966 - rotation;
  const sinA = Math.sin(A);
  const sinB = Math.sin(B);
  const sinC = Math.sin(C);
  const cosC = Math.cos(C);
  const ratio = a / sinA;
  const b = ratio * sinB;
  const c = ratio * sinC;
  return createVector$1$1(cosC * b, cosC * c);
};
const getRotatedRectSize$1 = (rect, rotation) => {
  const w = rect.width;
  const h = rect.height;
  const hor = getOffsetPointOnEdge$1(w, rotation);
  const ver = getOffsetPointOnEdge$1(h, rotation);
  const tl = createVector$1$1(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));
  const tr = createVector$1$1(
    rect.x + rect.width + Math.abs(ver.y),
    rect.y + Math.abs(ver.x)
  );
  const bl = createVector$1$1(
    rect.x - Math.abs(ver.y),
    rect.y + rect.height - Math.abs(ver.x)
  );
  return {
    width: vectorDistance$1(tl, tr),
    height: vectorDistance$1(tl, bl)
  };
};
const calculateCanvasSize$1 = (image, canvasAspectRatio, zoom = 1) => {
  const imageAspectRatio = image.height / image.width;
  let canvasWidth = 1;
  let canvasHeight = canvasAspectRatio;
  let imgWidth = 1;
  let imgHeight = imageAspectRatio;
  if (imgHeight > canvasHeight) {
    imgHeight = canvasHeight;
    imgWidth = imgHeight / imageAspectRatio;
  }
  const scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);
  const width2 = image.width / (zoom * scalar * imgWidth);
  const height2 = width2 * canvasAspectRatio;
  return {
    width: width2,
    height: height2
  };
};
const getImageRectZoomFactor$1 = (imageRect, cropRect, rotation, center2) => {
  const cx = center2.x > 0.5 ? 1 - center2.x : center2.x;
  const cy = center2.y > 0.5 ? 1 - center2.y : center2.y;
  const imageWidth = cx * 2 * imageRect.width;
  const imageHeight = cy * 2 * imageRect.height;
  const rotatedCropSize = getRotatedRectSize$1(cropRect, rotation);
  return Math.max(
    rotatedCropSize.width / imageWidth,
    rotatedCropSize.height / imageHeight
  );
};
const getCenteredCropRect$1 = (container, aspectRatio) => {
  let width2 = container.width;
  let height2 = width2 * aspectRatio;
  if (height2 > container.height) {
    height2 = container.height;
    width2 = height2 / aspectRatio;
  }
  const x = (container.width - width2) * 0.5;
  const y = (container.height - height2) * 0.5;
  return {
    x,
    y,
    width: width2,
    height: height2
  };
};
const getCurrentCropSize = (imageSize, crop = {}) => {
  let { zoom, rotation, center: center2, aspectRatio } = crop;
  if (!aspectRatio)
    aspectRatio = imageSize.height / imageSize.width;
  const canvasSize = calculateCanvasSize$1(imageSize, aspectRatio, zoom);
  const canvasCenter = {
    x: canvasSize.width * 0.5,
    y: canvasSize.height * 0.5
  };
  const stage = {
    x: 0,
    y: 0,
    width: canvasSize.width,
    height: canvasSize.height,
    center: canvasCenter
  };
  const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
  const stageZoomFactor = getImageRectZoomFactor$1(
    imageSize,
    getCenteredCropRect$1(stage, aspectRatio),
    rotation,
    shouldLimit ? center2 : { x: 0.5, y: 0.5 }
  );
  const scale = zoom * stageZoomFactor;
  return {
    widthFloat: canvasSize.width / scale,
    heightFloat: canvasSize.height / scale,
    width: Math.round(canvasSize.width / scale),
    height: Math.round(canvasSize.height / scale)
  };
};
const IMAGE_SCALE_SPRING_PROPS$1 = {
  type: "spring",
  stiffness: 0.5,
  damping: 0.45,
  mass: 10
};
const createBitmapView = (_2) => _2.utils.createView({
  name: "image-bitmap",
  ignoreRect: true,
  mixins: { styles: ["scaleX", "scaleY"] },
  create: ({ root: root2, props }) => {
    root2.appendChild(props.image);
  }
});
const createImageCanvasWrapper = (_2) => _2.utils.createView({
  name: "image-canvas-wrapper",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: ["crop", "width", "height"],
    styles: [
      "originX",
      "originY",
      "translateX",
      "translateY",
      "scaleX",
      "scaleY",
      "rotateZ"
    ],
    animations: {
      originX: IMAGE_SCALE_SPRING_PROPS$1,
      originY: IMAGE_SCALE_SPRING_PROPS$1,
      scaleX: IMAGE_SCALE_SPRING_PROPS$1,
      scaleY: IMAGE_SCALE_SPRING_PROPS$1,
      translateX: IMAGE_SCALE_SPRING_PROPS$1,
      translateY: IMAGE_SCALE_SPRING_PROPS$1,
      rotateZ: IMAGE_SCALE_SPRING_PROPS$1
    }
  },
  create: ({ root: root2, props }) => {
    props.width = props.image.width;
    props.height = props.image.height;
    root2.ref.bitmap = root2.appendChildView(
      root2.createChildView(createBitmapView(_2), { image: props.image })
    );
  },
  write: ({ root: root2, props }) => {
    const { flip: flip2 } = props.crop;
    const { bitmap } = root2.ref;
    bitmap.scaleX = flip2.horizontal ? -1 : 1;
    bitmap.scaleY = flip2.vertical ? -1 : 1;
  }
});
const createClipView = (_2) => _2.utils.createView({
  name: "image-clip",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: [
      "crop",
      "markup",
      "resize",
      "width",
      "height",
      "dirty",
      "background"
    ],
    styles: ["width", "height", "opacity"],
    animations: {
      opacity: { type: "tween", duration: 250 }
    }
  },
  didWriteView: function({ root: root2, props }) {
    if (!props.background)
      return;
    root2.element.style.backgroundColor = props.background;
  },
  create: ({ root: root2, props }) => {
    root2.ref.image = root2.appendChildView(
      root2.createChildView(
        createImageCanvasWrapper(_2),
        Object.assign({}, props)
      )
    );
    root2.ref.createMarkup = () => {
      if (root2.ref.markup)
        return;
      root2.ref.markup = root2.appendChildView(
        root2.createChildView(createMarkupView(_2), Object.assign({}, props))
      );
    };
    root2.ref.destroyMarkup = () => {
      if (!root2.ref.markup)
        return;
      root2.removeChildView(root2.ref.markup);
      root2.ref.markup = null;
    };
    const transparencyIndicator = root2.query(
      "GET_IMAGE_PREVIEW_TRANSPARENCY_INDICATOR"
    );
    if (transparencyIndicator === null)
      return;
    if (transparencyIndicator === "grid") {
      root2.element.dataset.transparencyIndicator = transparencyIndicator;
    } else {
      root2.element.dataset.transparencyIndicator = "color";
    }
  },
  write: ({ root: root2, props, shouldOptimize }) => {
    const { crop, markup, resize, dirty, width: width2, height: height2 } = props;
    root2.ref.image.crop = crop;
    const stage = {
      x: 0,
      y: 0,
      width: width2,
      height: height2,
      center: {
        x: width2 * 0.5,
        y: height2 * 0.5
      }
    };
    const image = {
      width: root2.ref.image.width,
      height: root2.ref.image.height
    };
    const origin = {
      x: crop.center.x * image.width,
      y: crop.center.y * image.height
    };
    const translation = {
      x: stage.center.x - image.width * crop.center.x,
      y: stage.center.y - image.height * crop.center.y
    };
    const rotation = Math.PI * 2 + crop.rotation % (Math.PI * 2);
    const cropAspectRatio = crop.aspectRatio || image.height / image.width;
    const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
    const stageZoomFactor = getImageRectZoomFactor$1(
      image,
      getCenteredCropRect$1(stage, cropAspectRatio),
      rotation,
      shouldLimit ? crop.center : { x: 0.5, y: 0.5 }
    );
    const scale = crop.zoom * stageZoomFactor;
    if (markup && markup.length) {
      root2.ref.createMarkup();
      root2.ref.markup.width = width2;
      root2.ref.markup.height = height2;
      root2.ref.markup.resize = resize;
      root2.ref.markup.dirty = dirty;
      root2.ref.markup.markup = markup;
      root2.ref.markup.crop = getCurrentCropSize(image, crop);
    } else if (root2.ref.markup) {
      root2.ref.destroyMarkup();
    }
    const imageView = root2.ref.image;
    if (shouldOptimize) {
      imageView.originX = null;
      imageView.originY = null;
      imageView.translateX = null;
      imageView.translateY = null;
      imageView.rotateZ = null;
      imageView.scaleX = null;
      imageView.scaleY = null;
      return;
    }
    imageView.originX = origin.x;
    imageView.originY = origin.y;
    imageView.translateX = translation.x;
    imageView.translateY = translation.y;
    imageView.rotateZ = rotation;
    imageView.scaleX = scale;
    imageView.scaleY = scale;
  }
});
const createImageView = (_2) => _2.utils.createView({
  name: "image-preview",
  tag: "div",
  ignoreRect: true,
  mixins: {
    apis: ["image", "crop", "markup", "resize", "dirty", "background"],
    styles: ["translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: IMAGE_SCALE_SPRING_PROPS$1,
      scaleY: IMAGE_SCALE_SPRING_PROPS$1,
      translateY: IMAGE_SCALE_SPRING_PROPS$1,
      opacity: { type: "tween", duration: 400 }
    }
  },
  create: ({ root: root2, props }) => {
    root2.ref.clip = root2.appendChildView(
      root2.createChildView(createClipView(_2), {
        id: props.id,
        image: props.image,
        crop: props.crop,
        markup: props.markup,
        resize: props.resize,
        dirty: props.dirty,
        background: props.background
      })
    );
  },
  write: ({ root: root2, props, shouldOptimize }) => {
    const { clip } = root2.ref;
    const { image, crop, markup, resize, dirty } = props;
    clip.crop = crop;
    clip.markup = markup;
    clip.resize = resize;
    clip.dirty = dirty;
    clip.opacity = shouldOptimize ? 0 : 1;
    if (shouldOptimize || root2.rect.element.hidden)
      return;
    const imageAspectRatio = image.height / image.width;
    let aspectRatio = crop.aspectRatio || imageAspectRatio;
    const containerWidth = root2.rect.inner.width;
    const containerHeight = root2.rect.inner.height;
    let fixedPreviewHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
    const minPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MIN_HEIGHT");
    const maxPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MAX_HEIGHT");
    const panelAspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
    const allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
    if (panelAspectRatio && !allowMultiple) {
      fixedPreviewHeight = containerWidth * panelAspectRatio;
      aspectRatio = panelAspectRatio;
    }
    let clipHeight = fixedPreviewHeight !== null ? fixedPreviewHeight : Math.max(
      minPreviewHeight,
      Math.min(containerWidth * aspectRatio, maxPreviewHeight)
    );
    let clipWidth = clipHeight / aspectRatio;
    if (clipWidth > containerWidth) {
      clipWidth = containerWidth;
      clipHeight = clipWidth * aspectRatio;
    }
    if (clipHeight > containerHeight) {
      clipHeight = containerHeight;
      clipWidth = containerHeight / aspectRatio;
    }
    clip.width = clipWidth;
    clip.height = clipHeight;
  }
});
let SVG_MASK = `<svg width="500" height="200" viewBox="0 0 500 200" preserveAspectRatio="none">
    <defs>
        <radialGradient id="gradient-__UID__" cx=".5" cy="1.25" r="1.15">
            <stop offset='50%' stop-color='#000000'/>
            <stop offset='56%' stop-color='#0a0a0a'/>
            <stop offset='63%' stop-color='#262626'/>
            <stop offset='69%' stop-color='#4f4f4f'/>
            <stop offset='75%' stop-color='#808080'/>
            <stop offset='81%' stop-color='#b1b1b1'/>
            <stop offset='88%' stop-color='#dadada'/>
            <stop offset='94%' stop-color='#f6f6f6'/>
            <stop offset='100%' stop-color='#ffffff'/>
        </radialGradient>
        <mask id="mask-__UID__">
            <rect x="0" y="0" width="500" height="200" fill="url(#gradient-__UID__)"></rect>
        </mask>
    </defs>
    <rect x="0" width="500" height="200" fill="currentColor" mask="url(#mask-__UID__)"></rect>
</svg>`;
let SVGMaskUniqueId = 0;
const createImageOverlayView = (fpAPI) => fpAPI.utils.createView({
  name: "image-preview-overlay",
  tag: "div",
  ignoreRect: true,
  create: ({ root: root2, props }) => {
    let mask = SVG_MASK;
    if (document.querySelector("base")) {
      const url = new URL(
        window.location.href.replace(window.location.hash, "")
      ).href;
      mask = mask.replace(/url\(\#/g, "url(" + url + "#");
    }
    SVGMaskUniqueId++;
    root2.element.classList.add(
      `filepond--image-preview-overlay-${props.status}`
    );
    root2.element.innerHTML = mask.replace(/__UID__/g, SVGMaskUniqueId);
  },
  mixins: {
    styles: ["opacity"],
    animations: {
      opacity: { type: "spring", mass: 25 }
    }
  }
});
const BitmapWorker = function() {
  self.onmessage = (e) => {
    createImageBitmap(e.data.message.file).then((bitmap) => {
      self.postMessage({ id: e.data.id, message: bitmap }, [bitmap]);
    });
  };
};
const ColorMatrixWorker = function() {
  self.onmessage = (e) => {
    const imageData = e.data.message.imageData;
    const matrix = e.data.message.colorMatrix;
    const data2 = imageData.data;
    const l = data2.length;
    const m11 = matrix[0];
    const m12 = matrix[1];
    const m13 = matrix[2];
    const m14 = matrix[3];
    const m15 = matrix[4];
    const m21 = matrix[5];
    const m22 = matrix[6];
    const m23 = matrix[7];
    const m24 = matrix[8];
    const m25 = matrix[9];
    const m31 = matrix[10];
    const m32 = matrix[11];
    const m33 = matrix[12];
    const m34 = matrix[13];
    const m35 = matrix[14];
    const m41 = matrix[15];
    const m42 = matrix[16];
    const m43 = matrix[17];
    const m44 = matrix[18];
    const m45 = matrix[19];
    let index = 0, r = 0, g = 0, b = 0, a = 0;
    for (; index < l; index += 4) {
      r = data2[index] / 255;
      g = data2[index + 1] / 255;
      b = data2[index + 2] / 255;
      a = data2[index + 3] / 255;
      data2[index] = Math.max(
        0,
        Math.min((r * m11 + g * m12 + b * m13 + a * m14 + m15) * 255, 255)
      );
      data2[index + 1] = Math.max(
        0,
        Math.min((r * m21 + g * m22 + b * m23 + a * m24 + m25) * 255, 255)
      );
      data2[index + 2] = Math.max(
        0,
        Math.min((r * m31 + g * m32 + b * m33 + a * m34 + m35) * 255, 255)
      );
      data2[index + 3] = Math.max(
        0,
        Math.min((r * m41 + g * m42 + b * m43 + a * m44 + m45) * 255, 255)
      );
    }
    self.postMessage({ id: e.data.id, message: imageData }, [
      imageData.data.buffer
    ]);
  };
};
const getImageSize$3 = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width2 = image.naturalWidth;
    const height2 = image.naturalHeight;
    image = null;
    cb(width2, height2);
  };
  image.src = url;
};
const transforms = {
  1: () => [1, 0, 0, 1, 0, 0],
  2: (width2) => [-1, 0, 0, 1, width2, 0],
  3: (width2, height2) => [-1, 0, 0, -1, width2, height2],
  4: (width2, height2) => [1, 0, 0, -1, 0, height2],
  5: () => [0, 1, 1, 0, 0, 0],
  6: (width2, height2) => [0, 1, -1, 0, height2, 0],
  7: (width2, height2) => [0, -1, -1, 0, height2, width2],
  8: (width2) => [0, -1, 1, 0, 0, width2]
};
const fixImageOrientation = (ctx, width2, height2, orientation) => {
  if (orientation === -1) {
    return;
  }
  ctx.transform.apply(ctx, transforms[orientation](width2, height2));
};
const createPreviewImage = (data2, width2, height2, orientation) => {
  width2 = Math.round(width2);
  height2 = Math.round(height2);
  const canvas = document.createElement("canvas");
  canvas.width = width2;
  canvas.height = height2;
  const ctx = canvas.getContext("2d");
  if (orientation >= 5 && orientation <= 8) {
    [width2, height2] = [height2, width2];
  }
  fixImageOrientation(ctx, width2, height2, orientation);
  ctx.drawImage(data2, 0, 0, width2, height2);
  return canvas;
};
const isBitmap = (file2) => /^image/.test(file2.type) && !/svg/.test(file2.type);
const MAX_WIDTH$1 = 10;
const MAX_HEIGHT$1 = 10;
const calculateAverageColor$1 = (image) => {
  const scalar = Math.min(MAX_WIDTH$1 / image.width, MAX_HEIGHT$1 / image.height);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const width2 = canvas.width = Math.ceil(image.width * scalar);
  const height2 = canvas.height = Math.ceil(image.height * scalar);
  ctx.drawImage(image, 0, 0, width2, height2);
  let data2 = null;
  try {
    data2 = ctx.getImageData(0, 0, width2, height2).data;
  } catch (e) {
    return null;
  }
  const l = data2.length;
  let r = 0;
  let g = 0;
  let b = 0;
  let i = 0;
  for (; i < l; i += 4) {
    r += data2[i] * data2[i];
    g += data2[i + 1] * data2[i + 1];
    b += data2[i + 2] * data2[i + 2];
  }
  r = averageColor$1(r, l);
  g = averageColor$1(g, l);
  b = averageColor$1(b, l);
  return { r, g, b };
};
const averageColor$1 = (c, l) => Math.floor(Math.sqrt(c / (l / 4)));
const cloneCanvas = (origin, target) => {
  target = target || document.createElement("canvas");
  target.width = origin.width;
  target.height = origin.height;
  const ctx = target.getContext("2d");
  ctx.drawImage(origin, 0, 0);
  return target;
};
const cloneImageData = (imageData) => {
  let id;
  try {
    id = new ImageData(imageData.width, imageData.height);
  } catch (e) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    id = ctx.createImageData(imageData.width, imageData.height);
  }
  id.data.set(new Uint8ClampedArray(imageData.data));
  return id;
};
const loadImage$2 = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.crossOrigin = "Anonymous";
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
const createImageWrapperView = (_2) => {
  const OverlayView = createImageOverlayView(_2);
  const ImageView = createImageView(_2);
  const { createWorker: createWorker2 } = _2.utils;
  const applyFilter = (root2, filter2, target) => new Promise((resolve) => {
    if (!root2.ref.imageData) {
      root2.ref.imageData = target.getContext("2d").getImageData(0, 0, target.width, target.height);
    }
    const imageData = cloneImageData(root2.ref.imageData);
    if (!filter2 || filter2.length !== 20) {
      target.getContext("2d").putImageData(imageData, 0, 0);
      return resolve();
    }
    const worker = createWorker2(ColorMatrixWorker);
    worker.post(
      {
        imageData,
        colorMatrix: filter2
      },
      (response) => {
        target.getContext("2d").putImageData(response, 0, 0);
        worker.terminate();
        resolve();
      },
      [imageData.data.buffer]
    );
  });
  const removeImageView = (root2, imageView) => {
    root2.removeChildView(imageView);
    imageView.image.width = 1;
    imageView.image.height = 1;
    imageView._destroy();
  };
  const shiftImage = ({ root: root2 }) => {
    const imageView = root2.ref.images.shift();
    imageView.opacity = 0;
    imageView.translateY = -15;
    root2.ref.imageViewBin.push(imageView);
    return imageView;
  };
  const pushImage = ({ root: root2, props, image }) => {
    const id = props.id;
    const item2 = root2.query("GET_ITEM", { id });
    if (!item2)
      return;
    const crop = item2.getMetadata("crop") || {
      center: {
        x: 0.5,
        y: 0.5
      },
      flip: {
        horizontal: false,
        vertical: false
      },
      zoom: 1,
      rotation: 0,
      aspectRatio: null
    };
    const background = root2.query(
      "GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR"
    );
    let markup;
    let resize;
    let dirty = false;
    if (root2.query("GET_IMAGE_PREVIEW_MARKUP_SHOW")) {
      markup = item2.getMetadata("markup") || [];
      resize = item2.getMetadata("resize");
      dirty = true;
    }
    const imageView = root2.appendChildView(
      root2.createChildView(ImageView, {
        id,
        image,
        crop,
        resize,
        markup,
        dirty,
        background,
        opacity: 0,
        scaleX: 1.15,
        scaleY: 1.15,
        translateY: 15
      }),
      root2.childViews.length
    );
    root2.ref.images.push(imageView);
    imageView.opacity = 1;
    imageView.scaleX = 1;
    imageView.scaleY = 1;
    imageView.translateY = 0;
    setTimeout(() => {
      root2.dispatch("DID_IMAGE_PREVIEW_SHOW", { id });
    }, 250);
  };
  const updateImage2 = ({ root: root2, props }) => {
    const item2 = root2.query("GET_ITEM", { id: props.id });
    if (!item2)
      return;
    const imageView = root2.ref.images[root2.ref.images.length - 1];
    imageView.crop = item2.getMetadata("crop");
    imageView.background = root2.query(
      "GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR"
    );
    if (root2.query("GET_IMAGE_PREVIEW_MARKUP_SHOW")) {
      imageView.dirty = true;
      imageView.resize = item2.getMetadata("resize");
      imageView.markup = item2.getMetadata("markup");
    }
  };
  const didUpdateItemMetadata = ({ root: root2, props, action }) => {
    if (!/crop|filter|markup|resize/.test(action.change.key))
      return;
    if (!root2.ref.images.length)
      return;
    const item2 = root2.query("GET_ITEM", { id: props.id });
    if (!item2)
      return;
    if (/filter/.test(action.change.key)) {
      const imageView = root2.ref.images[root2.ref.images.length - 1];
      applyFilter(root2, action.change.value, imageView.image);
      return;
    }
    if (/crop|markup|resize/.test(action.change.key)) {
      const crop = item2.getMetadata("crop");
      const image = root2.ref.images[root2.ref.images.length - 1];
      if (crop && crop.aspectRatio && image.crop && image.crop.aspectRatio && Math.abs(crop.aspectRatio - image.crop.aspectRatio) > 1e-5) {
        const imageView = shiftImage({ root: root2 });
        pushImage({ root: root2, props, image: cloneCanvas(imageView.image) });
      } else {
        updateImage2({ root: root2, props });
      }
    }
  };
  const canCreateImageBitmap = (file2) => {
    const userAgent = window.navigator.userAgent;
    const isFirefox = userAgent.match(/Firefox\/([0-9]+)\./);
    const firefoxVersion = isFirefox ? parseInt(isFirefox[1]) : null;
    if (firefoxVersion <= 58)
      return false;
    return "createImageBitmap" in window && isBitmap(file2);
  };
  const didCreatePreviewContainer = ({ root: root2, props }) => {
    const { id } = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    const fileURL = URL.createObjectURL(item2.file);
    getImageSize$3(fileURL, (width2, height2) => {
      root2.dispatch("DID_IMAGE_PREVIEW_CALCULATE_SIZE", {
        id,
        width: width2,
        height: height2
      });
    });
  };
  const drawPreview = ({ root: root2, props }) => {
    const { id } = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    const fileURL = URL.createObjectURL(item2.file);
    const loadPreviewFallback = () => {
      loadImage$2(fileURL).then(previewImageLoaded);
    };
    const previewImageLoaded = (imageData) => {
      URL.revokeObjectURL(fileURL);
      const exif = item2.getMetadata("exif") || {};
      const orientation = exif.orientation || -1;
      let { width: width2, height: height2 } = imageData;
      if (!width2 || !height2)
        return;
      if (orientation >= 5 && orientation <= 8) {
        [width2, height2] = [height2, width2];
      }
      const pixelDensityFactor = Math.max(1, window.devicePixelRatio * 0.75);
      const zoomFactor = root2.query("GET_IMAGE_PREVIEW_ZOOM_FACTOR");
      const scaleFactor = zoomFactor * pixelDensityFactor;
      const previewImageRatio = height2 / width2;
      const previewContainerWidth = root2.rect.element.width;
      const previewContainerHeight = root2.rect.element.height;
      let imageWidth = previewContainerWidth;
      let imageHeight = imageWidth * previewImageRatio;
      if (previewImageRatio > 1) {
        imageWidth = Math.min(width2, previewContainerWidth * scaleFactor);
        imageHeight = imageWidth * previewImageRatio;
      } else {
        imageHeight = Math.min(height2, previewContainerHeight * scaleFactor);
        imageWidth = imageHeight / previewImageRatio;
      }
      const previewImage = createPreviewImage(
        imageData,
        imageWidth,
        imageHeight,
        orientation
      );
      const done = () => {
        const averageColor2 = root2.query(
          "GET_IMAGE_PREVIEW_CALCULATE_AVERAGE_IMAGE_COLOR"
        ) ? calculateAverageColor$1(data) : null;
        item2.setMetadata("color", averageColor2, true);
        if ("close" in imageData) {
          imageData.close();
        }
        root2.ref.overlayShadow.opacity = 1;
        pushImage({ root: root2, props, image: previewImage });
      };
      const filter2 = item2.getMetadata("filter");
      if (filter2) {
        applyFilter(root2, filter2, previewImage).then(done);
      } else {
        done();
      }
    };
    if (canCreateImageBitmap(item2.file)) {
      const worker = createWorker2(BitmapWorker);
      worker.post(
        {
          file: item2.file
        },
        (imageBitmap) => {
          worker.terminate();
          if (!imageBitmap) {
            loadPreviewFallback();
            return;
          }
          previewImageLoaded(imageBitmap);
        }
      );
    } else {
      loadPreviewFallback();
    }
  };
  const didDrawPreview = ({ root: root2 }) => {
    const image = root2.ref.images[root2.ref.images.length - 1];
    image.translateY = 0;
    image.scaleX = 1;
    image.scaleY = 1;
    image.opacity = 1;
  };
  const restoreOverlay = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 1;
    root2.ref.overlayError.opacity = 0;
    root2.ref.overlaySuccess.opacity = 0;
  };
  const didThrowError = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlayError.opacity = 1;
  };
  const didCompleteProcessing = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlaySuccess.opacity = 1;
  };
  const create2 = ({ root: root2 }) => {
    root2.ref.images = [];
    root2.ref.imageData = null;
    root2.ref.imageViewBin = [];
    root2.ref.overlayShadow = root2.appendChildView(
      root2.createChildView(OverlayView, {
        opacity: 0,
        status: "idle"
      })
    );
    root2.ref.overlaySuccess = root2.appendChildView(
      root2.createChildView(OverlayView, {
        opacity: 0,
        status: "success"
      })
    );
    root2.ref.overlayError = root2.appendChildView(
      root2.createChildView(OverlayView, {
        opacity: 0,
        status: "failure"
      })
    );
  };
  return _2.utils.createView({
    name: "image-preview-wrapper",
    create: create2,
    styles: ["height"],
    apis: ["height"],
    destroy: ({ root: root2 }) => {
      root2.ref.images.forEach((imageView) => {
        imageView.image.width = 1;
        imageView.image.height = 1;
      });
    },
    didWriteView: ({ root: root2 }) => {
      root2.ref.images.forEach((imageView) => {
        imageView.dirty = false;
      });
    },
    write: _2.utils.createRoute(
      {
        // image preview stated
        DID_IMAGE_PREVIEW_DRAW: didDrawPreview,
        DID_IMAGE_PREVIEW_CONTAINER_CREATE: didCreatePreviewContainer,
        DID_FINISH_CALCULATE_PREVIEWSIZE: drawPreview,
        DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata,
        // file states
        DID_THROW_ITEM_LOAD_ERROR: didThrowError,
        DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,
        DID_THROW_ITEM_INVALID: didThrowError,
        DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,
        DID_START_ITEM_PROCESSING: restoreOverlay,
        DID_REVERT_ITEM_PROCESSING: restoreOverlay
      },
      ({ root: root2 }) => {
        const viewsToRemove = root2.ref.imageViewBin.filter(
          (imageView) => imageView.opacity === 0
        );
        root2.ref.imageViewBin = root2.ref.imageViewBin.filter(
          (imageView) => imageView.opacity > 0
        );
        viewsToRemove.forEach((imageView) => removeImageView(root2, imageView));
        viewsToRemove.length = 0;
      }
    )
  });
};
const plugin$7 = (fpAPI) => {
  const { addFilter: addFilter2, utils: utils2 } = fpAPI;
  const { Type: Type2, createRoute: createRoute2, isFile: isFile2 } = utils2;
  const imagePreviewView = createImageWrapperView(fpAPI);
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const { is, view, query } = viewAPI;
    if (!is("file") || !query("GET_ALLOW_IMAGE_PREVIEW"))
      return;
    const didLoadItem2 = ({ root: root2, props }) => {
      const { id } = props;
      const item2 = query("GET_ITEM", id);
      if (!item2 || !isFile2(item2.file) || item2.archived)
        return;
      const file2 = item2.file;
      if (!isPreviewableImage$1(file2))
        return;
      if (!query("GET_IMAGE_PREVIEW_FILTER_ITEM")(item2))
        return;
      const supportsCreateImageBitmap = "createImageBitmap" in (window || {});
      const maxPreviewFileSize = query("GET_IMAGE_PREVIEW_MAX_FILE_SIZE");
      if (!supportsCreateImageBitmap && (maxPreviewFileSize && file2.size > maxPreviewFileSize))
        return;
      root2.ref.imagePreview = view.appendChildView(
        view.createChildView(imagePreviewView, { id })
      );
      const fixedPreviewHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
      if (fixedPreviewHeight) {
        root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
          id: item2.id,
          height: fixedPreviewHeight
        });
      }
      const queue = !supportsCreateImageBitmap && file2.size > query("GET_IMAGE_PREVIEW_MAX_INSTANT_PREVIEW_FILE_SIZE");
      root2.dispatch("DID_IMAGE_PREVIEW_CONTAINER_CREATE", { id }, queue);
    };
    const rescaleItem = (root2, props) => {
      if (!root2.ref.imagePreview)
        return;
      let { id } = props;
      const item2 = root2.query("GET_ITEM", { id });
      if (!item2)
        return;
      const panelAspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
      const itemPanelAspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO");
      const fixedHeight = root2.query("GET_IMAGE_PREVIEW_HEIGHT");
      if (panelAspectRatio || itemPanelAspectRatio || fixedHeight)
        return;
      let { imageWidth, imageHeight } = root2.ref;
      if (!imageWidth || !imageHeight)
        return;
      const minPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MIN_HEIGHT");
      const maxPreviewHeight = root2.query("GET_IMAGE_PREVIEW_MAX_HEIGHT");
      const exif = item2.getMetadata("exif") || {};
      const orientation = exif.orientation || -1;
      if (orientation >= 5 && orientation <= 8)
        [imageWidth, imageHeight] = [imageHeight, imageWidth];
      if (!isBitmap(item2.file) || root2.query("GET_IMAGE_PREVIEW_UPSCALE")) {
        const scalar = 2048 / imageWidth;
        imageWidth *= scalar;
        imageHeight *= scalar;
      }
      const imageAspectRatio = imageHeight / imageWidth;
      const previewAspectRatio = (item2.getMetadata("crop") || {}).aspectRatio || imageAspectRatio;
      let previewHeightMax = Math.max(
        minPreviewHeight,
        Math.min(imageHeight, maxPreviewHeight)
      );
      const itemWidth = root2.rect.element.width;
      const previewHeight = Math.min(
        itemWidth * previewAspectRatio,
        previewHeightMax
      );
      root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
        id: item2.id,
        height: previewHeight
      });
    };
    const didResizeView = ({ root: root2 }) => {
      root2.ref.shouldRescale = true;
    };
    const didUpdateItemMetadata = ({ root: root2, action }) => {
      if (action.change.key !== "crop")
        return;
      root2.ref.shouldRescale = true;
    };
    const didCalculatePreviewSize = ({ root: root2, action }) => {
      root2.ref.imageWidth = action.width;
      root2.ref.imageHeight = action.height;
      root2.ref.shouldRescale = true;
      root2.ref.shouldDrawPreview = true;
      root2.dispatch("KICK");
    };
    view.registerWriter(
      createRoute2(
        {
          DID_RESIZE_ROOT: didResizeView,
          DID_STOP_RESIZE: didResizeView,
          DID_LOAD_ITEM: didLoadItem2,
          DID_IMAGE_PREVIEW_CALCULATE_SIZE: didCalculatePreviewSize,
          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata
        },
        ({ root: root2, props }) => {
          if (!root2.ref.imagePreview)
            return;
          if (root2.rect.element.hidden)
            return;
          if (root2.ref.shouldRescale) {
            rescaleItem(root2, props);
            root2.ref.shouldRescale = false;
          }
          if (root2.ref.shouldDrawPreview) {
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                root2.dispatch("DID_FINISH_CALCULATE_PREVIEWSIZE", {
                  id: props.id
                });
              });
            });
            root2.ref.shouldDrawPreview = false;
          }
        }
      )
    );
  });
  return {
    options: {
      // Enable or disable image preview
      allowImagePreview: [true, Type2.BOOLEAN],
      // filters file items to determine which are shown as preview
      imagePreviewFilterItem: [() => true, Type2.FUNCTION],
      // Fixed preview height
      imagePreviewHeight: [null, Type2.INT],
      // Min image height
      imagePreviewMinHeight: [44, Type2.INT],
      // Max image height
      imagePreviewMaxHeight: [256, Type2.INT],
      // Max size of preview file for when createImageBitmap is not supported
      imagePreviewMaxFileSize: [null, Type2.INT],
      // The amount of extra pixels added to the image preview to allow comfortable zooming
      imagePreviewZoomFactor: [2, Type2.INT],
      // Should we upscale small images to fit the max bounding box of the preview area
      imagePreviewUpscale: [false, Type2.BOOLEAN],
      // Max size of preview file that we allow to try to instant preview if createImageBitmap is not supported, else image is queued for loading
      imagePreviewMaxInstantPreviewFileSize: [1e6, Type2.INT],
      // Style of the transparancy indicator used behind images
      imagePreviewTransparencyIndicator: [null, Type2.STRING],
      // Enables or disables reading average image color
      imagePreviewCalculateAverageImageColor: [false, Type2.BOOLEAN],
      // Enables or disables the previewing of markup
      imagePreviewMarkupShow: [true, Type2.BOOLEAN],
      // Allows filtering of markup to only show certain shapes
      imagePreviewMarkupFilter: [() => true, Type2.FUNCTION]
    }
  };
};
const isBrowser$7 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$7) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$7 })
  );
}
/*!
 * FilePondPluginImageExifOrientation 1.0.11
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isJPEG = (file2) => /^image\/jpeg/.test(file2.type);
const Marker = {
  JPEG: 65496,
  APP1: 65505,
  EXIF: 1165519206,
  TIFF: 18761,
  Orientation: 274,
  Unknown: 65280
};
const getUint16 = (view, offset2, little = false) => view.getUint16(offset2, little);
const getUint32 = (view, offset2, little = false) => view.getUint32(offset2, little);
const getImageOrientation = (file2) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = function(e) {
    const view = new DataView(e.target.result);
    if (getUint16(view, 0) !== Marker.JPEG) {
      resolve(-1);
      return;
    }
    const length = view.byteLength;
    let offset2 = 2;
    while (offset2 < length) {
      const marker = getUint16(view, offset2);
      offset2 += 2;
      if (marker === Marker.APP1) {
        if (getUint32(view, offset2 += 2) !== Marker.EXIF) {
          break;
        }
        const little = getUint16(view, offset2 += 6) === Marker.TIFF;
        offset2 += getUint32(view, offset2 + 4, little);
        const tags = getUint16(view, offset2, little);
        offset2 += 2;
        for (let i = 0; i < tags; i++) {
          if (getUint16(view, offset2 + i * 12, little) === Marker.Orientation) {
            resolve(getUint16(view, offset2 + i * 12 + 8, little));
            return;
          }
        }
      } else if ((marker & Marker.Unknown) !== Marker.Unknown) {
        break;
      } else {
        offset2 += getUint16(view, offset2);
      }
    }
    resolve(-1);
  };
  reader.readAsArrayBuffer(file2.slice(0, 64 * 1024));
});
const IS_BROWSER$1 = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
const isBrowser$6 = () => IS_BROWSER$1;
const testSrc = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4QA6RXhpZgAATU0AKgAAAAgAAwESAAMAAAABAAYAAAEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAD/2wBDAP//////////////////////////////////////////////////////////////////////////////////////wAALCAABAAIBASIA/8QAJgABAAAAAAAAAAAAAAAAAAAAAxABAAAAAAAAAAAAAAAAAAAAAP/aAAgBAQAAPwBH/9k=";
let shouldCorrect = void 0;
const testImage = isBrowser$6() ? new Image() : {};
testImage.onload = () => shouldCorrect = testImage.naturalWidth > testImage.naturalHeight;
testImage.src = testSrc;
const shouldCorrectImageExifOrientation = () => shouldCorrect;
const plugin$6 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const { Type: Type2, isFile: isFile2 } = utils2;
  addFilter2(
    "DID_LOAD_ITEM",
    (item2, { query }) => new Promise((resolve, reject) => {
      const file2 = item2.file;
      if (!isFile2(file2) || !isJPEG(file2) || !query("GET_ALLOW_IMAGE_EXIF_ORIENTATION") || !shouldCorrectImageExifOrientation()) {
        return resolve(item2);
      }
      getImageOrientation(file2).then((orientation) => {
        item2.setMetadata("exif", { orientation });
        resolve(item2);
      });
    })
  );
  return {
    options: {
      // Enable or disable image orientation reading
      allowImageExifOrientation: [true, Type2.BOOLEAN]
    }
  };
};
const isBrowser$1$1 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$1$1) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$6 })
  );
}
/*!
 * FilePondPluginImageCrop 2.0.6
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isImage$3 = (file2) => /^image/.test(file2.type);
const plugin$5 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const { Type: Type2, isFile: isFile2, getNumericAspectRatioFromString: getNumericAspectRatioFromString2 } = utils2;
  const allowCrop = (item2, query) => !(!isImage$3(item2.file) || !query("GET_ALLOW_IMAGE_CROP"));
  const isObject2 = (value) => typeof value === "object";
  const isNumber2 = (value) => typeof value === "number";
  const updateCrop = (item2, obj) => item2.setMetadata("crop", Object.assign({}, item2.getMetadata("crop"), obj));
  addFilter2("DID_CREATE_ITEM", (item2, { query }) => {
    item2.extend("setImageCrop", (crop) => {
      if (!allowCrop(item2, query) || !isObject2(center))
        return;
      item2.setMetadata("crop", crop);
      return crop;
    });
    item2.extend("setImageCropCenter", (center2) => {
      if (!allowCrop(item2, query) || !isObject2(center2))
        return;
      return updateCrop(item2, { center: center2 });
    });
    item2.extend("setImageCropZoom", (zoom) => {
      if (!allowCrop(item2, query) || !isNumber2(zoom))
        return;
      return updateCrop(item2, { zoom: Math.max(1, zoom) });
    });
    item2.extend("setImageCropRotation", (rotation) => {
      if (!allowCrop(item2, query) || !isNumber2(rotation))
        return;
      return updateCrop(item2, { rotation });
    });
    item2.extend("setImageCropFlip", (flip2) => {
      if (!allowCrop(item2, query) || !isObject2(flip2))
        return;
      return updateCrop(item2, { flip: flip2 });
    });
    item2.extend("setImageCropAspectRatio", (newAspectRatio) => {
      if (!allowCrop(item2, query) || typeof newAspectRatio === "undefined")
        return;
      const currentCrop = item2.getMetadata("crop");
      const aspectRatio = getNumericAspectRatioFromString2(newAspectRatio);
      const newCrop = {
        center: {
          x: 0.5,
          y: 0.5
        },
        flip: currentCrop ? Object.assign({}, currentCrop.flip) : {
          horizontal: false,
          vertical: false
        },
        rotation: 0,
        zoom: 1,
        aspectRatio
      };
      item2.setMetadata("crop", newCrop);
      return newCrop;
    });
  });
  addFilter2(
    "DID_LOAD_ITEM",
    (item2, { query }) => new Promise((resolve, reject) => {
      const file2 = item2.file;
      if (!isFile2(file2) || !isImage$3(file2) || !query("GET_ALLOW_IMAGE_CROP")) {
        return resolve(item2);
      }
      const crop = item2.getMetadata("crop");
      if (crop) {
        return resolve(item2);
      }
      const humanAspectRatio = query("GET_IMAGE_CROP_ASPECT_RATIO");
      item2.setMetadata("crop", {
        center: {
          x: 0.5,
          y: 0.5
        },
        flip: {
          horizontal: false,
          vertical: false
        },
        rotation: 0,
        zoom: 1,
        aspectRatio: humanAspectRatio ? getNumericAspectRatioFromString2(humanAspectRatio) : null
      });
      resolve(item2);
    })
  );
  return {
    options: {
      // enable or disable image cropping
      allowImageCrop: [true, Type2.BOOLEAN],
      // the aspect ratio of the crop ('1:1', '16:9', etc)
      imageCropAspectRatio: [null, Type2.STRING]
    }
  };
};
const isBrowser$5 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$5) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$5 })
  );
}
/*!
 * FilePondPluginImageResize 2.0.10
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isImage$2 = (file2) => /^image/.test(file2.type);
const getImageSize$2 = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width2 = image.naturalWidth;
    const height2 = image.naturalHeight;
    image = null;
    cb({ width: width2, height: height2 });
  };
  image.onerror = () => cb(null);
  image.src = url;
};
const plugin$4 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const { Type: Type2 } = utils2;
  addFilter2(
    "DID_LOAD_ITEM",
    (item2, { query }) => new Promise((resolve, reject) => {
      const file2 = item2.file;
      if (!isImage$2(file2) || !query("GET_ALLOW_IMAGE_RESIZE")) {
        return resolve(item2);
      }
      const mode = query("GET_IMAGE_RESIZE_MODE");
      const width2 = query("GET_IMAGE_RESIZE_TARGET_WIDTH");
      const height2 = query("GET_IMAGE_RESIZE_TARGET_HEIGHT");
      const upscale = query("GET_IMAGE_RESIZE_UPSCALE");
      if (width2 === null && height2 === null)
        return resolve(item2);
      const targetWidth = width2 === null ? height2 : width2;
      const targetHeight = height2 === null ? targetWidth : height2;
      const fileURL = URL.createObjectURL(file2);
      getImageSize$2(fileURL, (size) => {
        URL.revokeObjectURL(fileURL);
        if (!size)
          return resolve(item2);
        let { width: imageWidth, height: imageHeight } = size;
        const orientation = (item2.getMetadata("exif") || {}).orientation || -1;
        if (orientation >= 5 && orientation <= 8) {
          [imageWidth, imageHeight] = [imageHeight, imageWidth];
        }
        if (imageWidth === targetWidth && imageHeight === targetHeight)
          return resolve(item2);
        if (!upscale) {
          if (mode === "cover") {
            if (imageWidth <= targetWidth || imageHeight <= targetHeight)
              return resolve(item2);
          } else if (imageWidth <= targetWidth && imageHeight <= targetWidth) {
            return resolve(item2);
          }
        }
        item2.setMetadata("resize", {
          mode,
          upscale,
          size: {
            width: targetWidth,
            height: targetHeight
          }
        });
        resolve(item2);
      });
    })
  );
  return {
    options: {
      // Enable or disable image resizing
      allowImageResize: [true, Type2.BOOLEAN],
      // the method of rescaling
      // - force => force set size
      // - cover => pick biggest dimension
      // - contain => pick smaller dimension
      imageResizeMode: ["cover", Type2.STRING],
      // set to false to disable upscaling of image smaller than the target width / height
      imageResizeUpscale: [true, Type2.BOOLEAN],
      // target width
      imageResizeTargetWidth: [null, Type2.INT],
      // target height
      imageResizeTargetHeight: [null, Type2.INT]
    }
  };
};
const isBrowser$4 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$4) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", { detail: plugin$4 }));
}
/*!
 * FilePondPluginImageTransform 3.8.7
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isImage = (file2) => /^image/.test(file2.type);
const getFilenameWithoutExtension = (name2) => name2.substr(0, name2.lastIndexOf(".")) || name2;
const ExtensionMap = {
  jpeg: "jpg",
  "svg+xml": "svg"
};
const renameFileToMatchMimeType = (filename, mimeType) => {
  const name2 = getFilenameWithoutExtension(filename);
  const type = mimeType.split("/")[1];
  const extension = ExtensionMap[type] || type;
  return `${name2}.${extension}`;
};
const getValidOutputMimeType = (type) => /jpeg|png|svg\+xml/.test(type) ? type : "image/jpeg";
const isImage$1 = (file2) => /^image/.test(file2.type);
const MATRICES = {
  1: () => [1, 0, 0, 1, 0, 0],
  2: (width2) => [-1, 0, 0, 1, width2, 0],
  3: (width2, height2) => [-1, 0, 0, -1, width2, height2],
  4: (width2, height2) => [1, 0, 0, -1, 0, height2],
  5: () => [0, 1, 1, 0, 0, 0],
  6: (width2, height2) => [0, 1, -1, 0, height2, 0],
  7: (width2, height2) => [0, -1, -1, 0, height2, width2],
  8: (width2) => [0, -1, 1, 0, 0, width2]
};
const getImageOrientationMatrix = (width2, height2, orientation) => {
  if (orientation === -1) {
    orientation = 1;
  }
  return MATRICES[orientation](width2, height2);
};
const createVector = (x, y) => ({ x, y });
const vectorDot = (a, b) => a.x * b.x + a.y * b.y;
const vectorSubtract = (a, b) => createVector(a.x - b.x, a.y - b.y);
const vectorDistanceSquared = (a, b) => vectorDot(vectorSubtract(a, b), vectorSubtract(a, b));
const vectorDistance = (a, b) => Math.sqrt(vectorDistanceSquared(a, b));
const getOffsetPointOnEdge = (length, rotation) => {
  const a = length;
  const A = 1.5707963267948966;
  const B = rotation;
  const C = 1.5707963267948966 - rotation;
  const sinA = Math.sin(A);
  const sinB = Math.sin(B);
  const sinC = Math.sin(C);
  const cosC = Math.cos(C);
  const ratio = a / sinA;
  const b = ratio * sinB;
  const c = ratio * sinC;
  return createVector(cosC * b, cosC * c);
};
const getRotatedRectSize = (rect, rotation) => {
  const w = rect.width;
  const h = rect.height;
  const hor = getOffsetPointOnEdge(w, rotation);
  const ver = getOffsetPointOnEdge(h, rotation);
  const tl = createVector(rect.x + Math.abs(hor.x), rect.y - Math.abs(hor.y));
  const tr = createVector(rect.x + rect.width + Math.abs(ver.y), rect.y + Math.abs(ver.x));
  const bl = createVector(rect.x - Math.abs(ver.y), rect.y + rect.height - Math.abs(ver.x));
  return {
    width: vectorDistance(tl, tr),
    height: vectorDistance(tl, bl)
  };
};
const getImageRectZoomFactor = (imageRect, cropRect, rotation = 0, center2 = { x: 0.5, y: 0.5 }) => {
  const cx = center2.x > 0.5 ? 1 - center2.x : center2.x;
  const cy = center2.y > 0.5 ? 1 - center2.y : center2.y;
  const imageWidth = cx * 2 * imageRect.width;
  const imageHeight = cy * 2 * imageRect.height;
  const rotatedCropSize = getRotatedRectSize(cropRect, rotation);
  return Math.max(rotatedCropSize.width / imageWidth, rotatedCropSize.height / imageHeight);
};
const getCenteredCropRect = (container, aspectRatio) => {
  let width2 = container.width;
  let height2 = width2 * aspectRatio;
  if (height2 > container.height) {
    height2 = container.height;
    width2 = height2 / aspectRatio;
  }
  const x = (container.width - width2) * 0.5;
  const y = (container.height - height2) * 0.5;
  return {
    x,
    y,
    width: width2,
    height: height2
  };
};
const calculateCanvasSize = (image, canvasAspectRatio, zoom = 1) => {
  const imageAspectRatio = image.height / image.width;
  let canvasWidth = 1;
  let canvasHeight = canvasAspectRatio;
  let imgWidth = 1;
  let imgHeight = imageAspectRatio;
  if (imgHeight > canvasHeight) {
    imgHeight = canvasHeight;
    imgWidth = imgHeight / imageAspectRatio;
  }
  const scalar = Math.max(canvasWidth / imgWidth, canvasHeight / imgHeight);
  const width2 = image.width / (zoom * scalar * imgWidth);
  const height2 = width2 * canvasAspectRatio;
  return {
    width: width2,
    height: height2
  };
};
const canvasRelease = (canvas) => {
  canvas.width = 1;
  canvas.height = 1;
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, 1, 1);
};
const isFlipped = (flip2) => flip2 && (flip2.horizontal || flip2.vertical);
const getBitmap = (image, orientation, flip2) => {
  if (orientation <= 1 && !isFlipped(flip2)) {
    image.width = image.naturalWidth;
    image.height = image.naturalHeight;
    return image;
  }
  const canvas = document.createElement("canvas");
  const width2 = image.naturalWidth;
  const height2 = image.naturalHeight;
  const swapped = orientation >= 5 && orientation <= 8;
  if (swapped) {
    canvas.width = height2;
    canvas.height = width2;
  } else {
    canvas.width = width2;
    canvas.height = height2;
  }
  const ctx = canvas.getContext("2d");
  if (orientation) {
    ctx.transform.apply(ctx, getImageOrientationMatrix(width2, height2, orientation));
  }
  if (isFlipped(flip2)) {
    const matrix = [1, 0, 0, 1, 0, 0];
    if (!swapped && flip2.horizontal || swapped & flip2.vertical) {
      matrix[0] = -1;
      matrix[4] = width2;
    }
    if (!swapped && flip2.vertical || swapped && flip2.horizontal) {
      matrix[3] = -1;
      matrix[5] = height2;
    }
    ctx.transform(...matrix);
  }
  ctx.drawImage(image, 0, 0, width2, height2);
  return canvas;
};
const imageToImageData = (imageElement, orientation, crop = {}, options = {}) => {
  const { canvasMemoryLimit, background = null } = options;
  const zoom = crop.zoom || 1;
  const bitmap = getBitmap(imageElement, orientation, crop.flip);
  const imageSize = {
    width: bitmap.width,
    height: bitmap.height
  };
  const aspectRatio = crop.aspectRatio || imageSize.height / imageSize.width;
  let canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);
  if (canvasMemoryLimit) {
    const requiredMemory = canvasSize.width * canvasSize.height;
    if (requiredMemory > canvasMemoryLimit) {
      const scalar = Math.sqrt(canvasMemoryLimit) / Math.sqrt(requiredMemory);
      imageSize.width = Math.floor(imageSize.width * scalar);
      imageSize.height = Math.floor(imageSize.height * scalar);
      canvasSize = calculateCanvasSize(imageSize, aspectRatio, zoom);
    }
  }
  const canvas = document.createElement("canvas");
  const canvasCenter = {
    x: canvasSize.width * 0.5,
    y: canvasSize.height * 0.5
  };
  const stage = {
    x: 0,
    y: 0,
    width: canvasSize.width,
    height: canvasSize.height,
    center: canvasCenter
  };
  const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
  const scale = zoom * getImageRectZoomFactor(
    imageSize,
    getCenteredCropRect(stage, aspectRatio),
    crop.rotation,
    shouldLimit ? crop.center : { x: 0.5, y: 0.5 }
  );
  canvas.width = Math.round(canvasSize.width / scale);
  canvas.height = Math.round(canvasSize.height / scale);
  canvasCenter.x /= scale;
  canvasCenter.y /= scale;
  const imageOffset = {
    x: canvasCenter.x - imageSize.width * (crop.center ? crop.center.x : 0.5),
    y: canvasCenter.y - imageSize.height * (crop.center ? crop.center.y : 0.5)
  };
  const ctx = canvas.getContext("2d");
  if (background) {
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
  ctx.translate(canvasCenter.x, canvasCenter.y);
  ctx.rotate(crop.rotation || 0);
  ctx.drawImage(
    bitmap,
    imageOffset.x - canvasCenter.x,
    imageOffset.y - canvasCenter.y,
    imageSize.width,
    imageSize.height
  );
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  canvasRelease(canvas);
  return imageData;
};
const IS_BROWSER = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
if (IS_BROWSER) {
  if (!HTMLCanvasElement.prototype.toBlob) {
    Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
      value: function(callback, type, quality) {
        var dataURL = this.toDataURL(type, quality).split(",")[1];
        setTimeout(function() {
          var binStr = atob(dataURL);
          var len = binStr.length;
          var arr = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr], { type: type || "image/png" }));
        });
      }
    });
  }
}
const canvasToBlob = (canvas, options, beforeCreateBlob = null) => new Promise((resolve) => {
  const promisedImage = beforeCreateBlob ? beforeCreateBlob(canvas) : canvas;
  Promise.resolve(promisedImage).then((canvas2) => {
    canvas2.toBlob(resolve, options.type, options.quality);
  });
});
const vectorMultiply = (v, amount) => createVector$1(v.x * amount, v.y * amount);
const vectorAdd = (a, b) => createVector$1(a.x + b.x, a.y + b.y);
const vectorNormalize = (v) => {
  const l = Math.sqrt(v.x * v.x + v.y * v.y);
  if (l === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  return createVector$1(v.x / l, v.y / l);
};
const vectorRotate = (v, radians, origin) => {
  const cos = Math.cos(radians);
  const sin = Math.sin(radians);
  const t = createVector$1(v.x - origin.x, v.y - origin.y);
  return createVector$1(origin.x + cos * t.x - sin * t.y, origin.y + sin * t.x + cos * t.y);
};
const createVector$1 = (x = 0, y = 0) => ({ x, y });
const getMarkupValue = (value, size, scalar = 1, axis) => {
  if (typeof value === "string") {
    return parseFloat(value) * scalar;
  }
  if (typeof value === "number") {
    return value * (axis ? size[axis] : Math.min(size.width, size.height));
  }
  return;
};
const getMarkupStyles = (markup, size, scale) => {
  const lineStyle = markup.borderStyle || markup.lineStyle || "solid";
  const fill = markup.backgroundColor || markup.fontColor || "transparent";
  const stroke = markup.borderColor || markup.lineColor || "transparent";
  const strokeWidth = getMarkupValue(markup.borderWidth || markup.lineWidth, size, scale);
  const lineCap = markup.lineCap || "round";
  const lineJoin = markup.lineJoin || "round";
  const dashes = typeof lineStyle === "string" ? "" : lineStyle.map((v) => getMarkupValue(v, size, scale)).join(",");
  const opacity = markup.opacity || 1;
  return {
    "stroke-linecap": lineCap,
    "stroke-linejoin": lineJoin,
    "stroke-width": strokeWidth || 0,
    "stroke-dasharray": dashes,
    stroke,
    fill,
    opacity
  };
};
const isDefined = (value) => value != null;
const getMarkupRect = (rect, size, scalar = 1) => {
  let left2 = getMarkupValue(rect.x, size, scalar, "width") || getMarkupValue(rect.left, size, scalar, "width");
  let top2 = getMarkupValue(rect.y, size, scalar, "height") || getMarkupValue(rect.top, size, scalar, "height");
  let width2 = getMarkupValue(rect.width, size, scalar, "width");
  let height2 = getMarkupValue(rect.height, size, scalar, "height");
  let right2 = getMarkupValue(rect.right, size, scalar, "width");
  let bottom2 = getMarkupValue(rect.bottom, size, scalar, "height");
  if (!isDefined(top2)) {
    if (isDefined(height2) && isDefined(bottom2)) {
      top2 = size.height - height2 - bottom2;
    } else {
      top2 = bottom2;
    }
  }
  if (!isDefined(left2)) {
    if (isDefined(width2) && isDefined(right2)) {
      left2 = size.width - width2 - right2;
    } else {
      left2 = right2;
    }
  }
  if (!isDefined(width2)) {
    if (isDefined(left2) && isDefined(right2)) {
      width2 = size.width - left2 - right2;
    } else {
      width2 = 0;
    }
  }
  if (!isDefined(height2)) {
    if (isDefined(top2) && isDefined(bottom2)) {
      height2 = size.height - top2 - bottom2;
    } else {
      height2 = 0;
    }
  }
  return {
    x: left2 || 0,
    y: top2 || 0,
    width: width2 || 0,
    height: height2 || 0
  };
};
const pointsToPathShape = (points) => points.map((point, index) => `${index === 0 ? "M" : "L"} ${point.x} ${point.y}`).join(" ");
const setAttributes = (element, attr2) => Object.keys(attr2).forEach((key) => element.setAttribute(key, attr2[key]));
const ns = "http://www.w3.org/2000/svg";
const svg = (tag, attr2) => {
  const element = document.createElementNS(ns, tag);
  if (attr2) {
    setAttributes(element, attr2);
  }
  return element;
};
const updateRect = (element) => setAttributes(element, {
  ...element.rect,
  ...element.styles
});
const updateEllipse = (element) => {
  const cx = element.rect.x + element.rect.width * 0.5;
  const cy = element.rect.y + element.rect.height * 0.5;
  const rx = element.rect.width * 0.5;
  const ry = element.rect.height * 0.5;
  return setAttributes(element, {
    cx,
    cy,
    rx,
    ry,
    ...element.styles
  });
};
const IMAGE_FIT_STYLE = {
  contain: "xMidYMid meet",
  cover: "xMidYMid slice"
};
const updateImage = (element, markup) => {
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    preserveAspectRatio: IMAGE_FIT_STYLE[markup.fit] || "none"
  });
};
const TEXT_ANCHOR = {
  left: "start",
  center: "middle",
  right: "end"
};
const updateText = (element, markup, size, scale) => {
  const fontSize = getMarkupValue(markup.fontSize, size, scale);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = TEXT_ANCHOR[markup.textAlign] || "start";
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    "stroke-width": 0,
    "font-weight": fontWeight,
    "font-size": fontSize,
    "font-family": fontFamily,
    "text-anchor": textAlign
  });
  if (element.text !== markup.text) {
    element.text = markup.text;
    element.textContent = markup.text.length ? markup.text : " ";
  }
};
const updateLine = (element, markup, size, scale) => {
  setAttributes(element, {
    ...element.rect,
    ...element.styles,
    fill: "none"
  });
  const line = element.childNodes[0];
  const begin = element.childNodes[1];
  const end2 = element.childNodes[2];
  const origin = element.rect;
  const target = {
    x: element.rect.x + element.rect.width,
    y: element.rect.y + element.rect.height
  };
  setAttributes(line, {
    x1: origin.x,
    y1: origin.y,
    x2: target.x,
    y2: target.y
  });
  if (!markup.lineDecoration)
    return;
  begin.style.display = "none";
  end2.style.display = "none";
  const v = vectorNormalize({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = getMarkupValue(0.05, size, scale);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply(v, l);
    const arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);
    setAttributes(begin, {
      style: "display:block;",
      d: `M${arrowBeginA.x},${arrowBeginA.y} L${origin.x},${origin.y} L${arrowBeginB.x},${arrowBeginB.y}`
    });
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply(v, -l);
    const arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate(target, -2, arrowEndCenter);
    setAttributes(end2, {
      style: "display:block;",
      d: `M${arrowEndA.x},${arrowEndA.y} L${target.x},${target.y} L${arrowEndB.x},${arrowEndB.y}`
    });
  }
};
const updatePath = (element, markup, size, scale) => {
  setAttributes(element, {
    ...element.styles,
    fill: "none",
    d: pointsToPathShape(
      markup.points.map((point) => ({
        x: getMarkupValue(point.x, size, scale, "width"),
        y: getMarkupValue(point.y, size, scale, "height")
      }))
    )
  });
};
const createShape = (node) => (markup) => svg(node, { id: markup.id });
const createImage = (markup) => {
  const shape = svg("image", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: "0"
  });
  shape.onload = () => {
    shape.setAttribute("opacity", markup.opacity || 1);
  };
  shape.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", markup.src);
  return shape;
};
const createLine = (markup) => {
  const shape = svg("g", {
    id: markup.id,
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  });
  const line = svg("line");
  shape.appendChild(line);
  const begin = svg("path");
  shape.appendChild(begin);
  const end2 = svg("path");
  shape.appendChild(end2);
  return shape;
};
const CREATE_TYPE_ROUTES = {
  image: createImage,
  rect: createShape("rect"),
  ellipse: createShape("ellipse"),
  text: createShape("text"),
  path: createShape("path"),
  line: createLine
};
const UPDATE_TYPE_ROUTES = {
  rect: updateRect,
  ellipse: updateEllipse,
  image: updateImage,
  text: updateText,
  path: updatePath,
  line: updateLine
};
const createMarkupByType = (type, markup) => CREATE_TYPE_ROUTES[type](markup);
const updateMarkupByType = (element, type, markup, size, scale) => {
  if (type !== "path") {
    element.rect = getMarkupRect(markup, size, scale);
  }
  element.styles = getMarkupStyles(markup, size, scale);
  UPDATE_TYPE_ROUTES[type](element, markup, size, scale);
};
const sortMarkupByZIndex = (a, b) => {
  if (a[1].zIndex > b[1].zIndex) {
    return 1;
  }
  if (a[1].zIndex < b[1].zIndex) {
    return -1;
  }
  return 0;
};
const cropSVG = (blob2, crop = {}, markup, options) => new Promise((resolve) => {
  const { background = null } = options;
  const fr = new FileReader();
  fr.onloadend = () => {
    const text2 = fr.result;
    const original = document.createElement("div");
    original.style.cssText = `position:absolute;pointer-events:none;width:0;height:0;visibility:hidden;`;
    original.innerHTML = text2;
    const originalNode = original.querySelector("svg");
    document.body.appendChild(original);
    const bBox = originalNode.getBBox();
    original.parentNode.removeChild(original);
    const titleNode = original.querySelector("title");
    const viewBoxAttribute = originalNode.getAttribute("viewBox") || "";
    const widthAttribute = originalNode.getAttribute("width") || "";
    const heightAttribute = originalNode.getAttribute("height") || "";
    let width2 = parseFloat(widthAttribute) || null;
    let height2 = parseFloat(heightAttribute) || null;
    const widthUnits = (widthAttribute.match(/[a-z]+/) || [])[0] || "";
    const heightUnits = (heightAttribute.match(/[a-z]+/) || [])[0] || "";
    const viewBoxList = viewBoxAttribute.split(" ").map(parseFloat);
    const viewBox = viewBoxList.length ? {
      x: viewBoxList[0],
      y: viewBoxList[1],
      width: viewBoxList[2],
      height: viewBoxList[3]
    } : bBox;
    let imageWidth = width2 != null ? width2 : viewBox.width;
    let imageHeight = height2 != null ? height2 : viewBox.height;
    originalNode.style.overflow = "visible";
    originalNode.setAttribute("width", imageWidth);
    originalNode.setAttribute("height", imageHeight);
    let markupSVG = "";
    if (markup && markup.length) {
      const size = {
        width: imageWidth,
        height: imageHeight
      };
      markupSVG = markup.sort(sortMarkupByZIndex).reduce((prev, shape) => {
        const el = createMarkupByType(shape[0], shape[1]);
        updateMarkupByType(el, shape[0], shape[1], size);
        el.removeAttribute("id");
        if (el.getAttribute("opacity") === 1) {
          el.removeAttribute("opacity");
        }
        return prev + "\n" + el.outerHTML + "\n";
      }, "");
      markupSVG = `

<g>${markupSVG.replace(/&nbsp;/g, " ")}</g>

`;
    }
    const aspectRatio = crop.aspectRatio || imageHeight / imageWidth;
    const canvasWidth = imageWidth;
    const canvasHeight = canvasWidth * aspectRatio;
    const shouldLimit = typeof crop.scaleToFit === "undefined" || crop.scaleToFit;
    const cropCenterX = crop.center ? crop.center.x : 0.5;
    const cropCenterY = crop.center ? crop.center.y : 0.5;
    const canvasZoomFactor = getImageRectZoomFactor(
      {
        width: imageWidth,
        height: imageHeight
      },
      getCenteredCropRect(
        {
          width: canvasWidth,
          height: canvasHeight
        },
        aspectRatio
      ),
      crop.rotation,
      shouldLimit ? { x: cropCenterX, y: cropCenterY } : {
        x: 0.5,
        y: 0.5
      }
    );
    const scale = crop.zoom * canvasZoomFactor;
    const rotation = crop.rotation * (180 / Math.PI);
    const canvasCenter = {
      x: canvasWidth * 0.5,
      y: canvasHeight * 0.5
    };
    const imageOffset = {
      x: canvasCenter.x - imageWidth * cropCenterX,
      y: canvasCenter.y - imageHeight * cropCenterY
    };
    const cropTransforms = [
      // rotate
      `rotate(${rotation} ${canvasCenter.x} ${canvasCenter.y})`,
      // scale
      `translate(${canvasCenter.x} ${canvasCenter.y})`,
      `scale(${scale})`,
      `translate(${-canvasCenter.x} ${-canvasCenter.y})`,
      // offset
      `translate(${imageOffset.x} ${imageOffset.y})`
    ];
    const cropFlipHorizontal = crop.flip && crop.flip.horizontal;
    const cropFlipVertical = crop.flip && crop.flip.vertical;
    const flipTransforms = [
      `scale(${cropFlipHorizontal ? -1 : 1} ${cropFlipVertical ? -1 : 1})`,
      `translate(${cropFlipHorizontal ? -imageWidth : 0} ${cropFlipVertical ? -imageHeight : 0})`
    ];
    const transformed = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}${widthUnits}" height="${canvasHeight}${heightUnits}" 
viewBox="0 0 ${canvasWidth} ${canvasHeight}" ${background ? 'style="background:' + background + '" ' : ""}
preserveAspectRatio="xMinYMin"
xmlns:xlink="http://www.w3.org/1999/xlink"
xmlns="http://www.w3.org/2000/svg">
<!-- Generated by PQINA - https://pqina.nl/ -->
<title>${titleNode ? titleNode.textContent : ""}</title>
<g transform="${cropTransforms.join(" ")}">
<g transform="${flipTransforms.join(" ")}">
${originalNode.outerHTML}${markupSVG}
</g>
</g>
</svg>`;
    resolve(transformed);
  };
  fr.readAsText(blob2);
});
const objectToImageData = (obj) => {
  let imageData;
  try {
    imageData = new ImageData(obj.width, obj.height);
  } catch (e) {
    const canvas = document.createElement("canvas");
    imageData = canvas.getContext("2d").createImageData(obj.width, obj.height);
  }
  imageData.data.set(obj.data);
  return imageData;
};
const TransformWorker = () => {
  const TRANSFORMS = { resize, filter: filter2 };
  const applyTransforms = (transforms2, imageData) => {
    transforms2.forEach((transform2) => {
      imageData = TRANSFORMS[transform2.type](imageData, transform2.data);
    });
    return imageData;
  };
  const transform = (data2, cb) => {
    let transforms2 = data2.transforms;
    let filterTransform = null;
    transforms2.forEach((transform2) => {
      if (transform2.type === "filter") {
        filterTransform = transform2;
      }
    });
    if (filterTransform) {
      let resizeTransform = null;
      transforms2.forEach((transform2) => {
        if (transform2.type === "resize") {
          resizeTransform = transform2;
        }
      });
      if (resizeTransform) {
        resizeTransform.data.matrix = filterTransform.data;
        transforms2 = transforms2.filter((transform2) => transform2.type !== "filter");
      }
    }
    cb(applyTransforms(transforms2, data2.imageData));
  };
  self.onmessage = (e) => {
    transform(e.data.message, (response) => {
      self.postMessage({ id: e.data.id, message: response }, [response.data.buffer]);
    });
  };
  const br = 1;
  const bg = 1;
  const bb = 1;
  function applyFilterMatrix(index, data2, m) {
    const ir = data2[index] / 255;
    const ig = data2[index + 1] / 255;
    const ib = data2[index + 2] / 255;
    const ia = data2[index + 3] / 255;
    const mr = ir * m[0] + ig * m[1] + ib * m[2] + ia * m[3] + m[4];
    const mg = ir * m[5] + ig * m[6] + ib * m[7] + ia * m[8] + m[9];
    const mb = ir * m[10] + ig * m[11] + ib * m[12] + ia * m[13] + m[14];
    const ma = ir * m[15] + ig * m[16] + ib * m[17] + ia * m[18] + m[19];
    const or = Math.max(0, mr * ma) + br * (1 - ma);
    const og = Math.max(0, mg * ma) + bg * (1 - ma);
    const ob = Math.max(0, mb * ma) + bb * (1 - ma);
    data2[index] = Math.max(0, Math.min(1, or)) * 255;
    data2[index + 1] = Math.max(0, Math.min(1, og)) * 255;
    data2[index + 2] = Math.max(0, Math.min(1, ob)) * 255;
  }
  const identityMatrix = self.JSON.stringify([
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    0
  ]);
  function isIdentityMatrix(filter3) {
    return self.JSON.stringify(filter3 || []) === identityMatrix;
  }
  function filter2(imageData, matrix) {
    if (!matrix || isIdentityMatrix(matrix))
      return imageData;
    const data2 = imageData.data;
    const l = data2.length;
    const m11 = matrix[0];
    const m12 = matrix[1];
    const m13 = matrix[2];
    const m14 = matrix[3];
    const m15 = matrix[4];
    const m21 = matrix[5];
    const m22 = matrix[6];
    const m23 = matrix[7];
    const m24 = matrix[8];
    const m25 = matrix[9];
    const m31 = matrix[10];
    const m32 = matrix[11];
    const m33 = matrix[12];
    const m34 = matrix[13];
    const m35 = matrix[14];
    const m41 = matrix[15];
    const m42 = matrix[16];
    const m43 = matrix[17];
    const m44 = matrix[18];
    const m45 = matrix[19];
    let index = 0, r = 0, g = 0, b = 0, a = 0, mr = 0, mg = 0, mb = 0, ma = 0, or = 0, og = 0, ob = 0;
    for (; index < l; index += 4) {
      r = data2[index] / 255;
      g = data2[index + 1] / 255;
      b = data2[index + 2] / 255;
      a = data2[index + 3] / 255;
      mr = r * m11 + g * m12 + b * m13 + a * m14 + m15;
      mg = r * m21 + g * m22 + b * m23 + a * m24 + m25;
      mb = r * m31 + g * m32 + b * m33 + a * m34 + m35;
      ma = r * m41 + g * m42 + b * m43 + a * m44 + m45;
      or = Math.max(0, mr * ma) + br * (1 - ma);
      og = Math.max(0, mg * ma) + bg * (1 - ma);
      ob = Math.max(0, mb * ma) + bb * (1 - ma);
      data2[index] = Math.max(0, Math.min(1, or)) * 255;
      data2[index + 1] = Math.max(0, Math.min(1, og)) * 255;
      data2[index + 2] = Math.max(0, Math.min(1, ob)) * 255;
    }
    return imageData;
  }
  function resize(imageData, data2) {
    let { mode = "contain", upscale = false, width: width2, height: height2, matrix } = data2;
    matrix = !matrix || isIdentityMatrix(matrix) ? null : matrix;
    if (!width2 && !height2) {
      return filter2(imageData, matrix);
    }
    if (width2 === null) {
      width2 = height2;
    } else if (height2 === null) {
      height2 = width2;
    }
    if (mode !== "force") {
      let scalarWidth = width2 / imageData.width;
      let scalarHeight = height2 / imageData.height;
      let scalar = 1;
      if (mode === "cover") {
        scalar = Math.max(scalarWidth, scalarHeight);
      } else if (mode === "contain") {
        scalar = Math.min(scalarWidth, scalarHeight);
      }
      if (scalar > 1 && upscale === false) {
        return filter2(imageData, matrix);
      }
      width2 = imageData.width * scalar;
      height2 = imageData.height * scalar;
    }
    const originWidth = imageData.width;
    const originHeight = imageData.height;
    const targetWidth = Math.round(width2);
    const targetHeight = Math.round(height2);
    const inputData = imageData.data;
    const outputData = new Uint8ClampedArray(targetWidth * targetHeight * 4);
    const ratioWidth = originWidth / targetWidth;
    const ratioHeight = originHeight / targetHeight;
    const ratioWidthHalf = Math.ceil(ratioWidth * 0.5);
    const ratioHeightHalf = Math.ceil(ratioHeight * 0.5);
    for (let j = 0; j < targetHeight; j++) {
      for (let i = 0; i < targetWidth; i++) {
        let x2 = (i + j * targetWidth) * 4;
        let weight = 0;
        let weights = 0;
        let weightsAlpha = 0;
        let r = 0;
        let g = 0;
        let b = 0;
        let a = 0;
        let centerY = (j + 0.5) * ratioHeight;
        for (let yy = Math.floor(j * ratioHeight); yy < (j + 1) * ratioHeight; yy++) {
          let dy = Math.abs(centerY - (yy + 0.5)) / ratioHeightHalf;
          let centerX = (i + 0.5) * ratioWidth;
          let w0 = dy * dy;
          for (let xx = Math.floor(i * ratioWidth); xx < (i + 1) * ratioWidth; xx++) {
            let dx = Math.abs(centerX - (xx + 0.5)) / ratioWidthHalf;
            let w = Math.sqrt(w0 + dx * dx);
            if (w >= -1 && w <= 1) {
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * originWidth);
                let ref = inputData[dx + 3];
                a += weight * ref;
                weightsAlpha += weight;
                if (ref < 255) {
                  weight = weight * ref / 250;
                }
                r += weight * inputData[dx];
                g += weight * inputData[dx + 1];
                b += weight * inputData[dx + 2];
                weights += weight;
              }
            }
          }
        }
        outputData[x2] = r / weights;
        outputData[x2 + 1] = g / weights;
        outputData[x2 + 2] = b / weights;
        outputData[x2 + 3] = a / weightsAlpha;
        matrix && applyFilterMatrix(x2, outputData, matrix);
      }
    }
    return {
      data: outputData,
      width: targetWidth,
      height: targetHeight
    };
  }
};
const correctOrientation = (view, offset2) => {
  if (view.getUint32(offset2 + 4, false) !== 1165519206)
    return;
  offset2 += 4;
  const intelByteAligned = view.getUint16(offset2 += 6, false) === 18761;
  offset2 += view.getUint32(offset2 + 4, intelByteAligned);
  const tags = view.getUint16(offset2, intelByteAligned);
  offset2 += 2;
  for (let i = 0; i < tags; i++) {
    if (view.getUint16(offset2 + i * 12, intelByteAligned) === 274) {
      view.setUint16(offset2 + i * 12 + 8, 1, intelByteAligned);
      return true;
    }
  }
  return false;
};
const readData = (data2) => {
  const view = new DataView(data2);
  if (view.getUint16(0) !== 65496)
    return null;
  let offset2 = 2;
  let marker;
  let markerLength;
  let orientationCorrected = false;
  while (offset2 < view.byteLength) {
    marker = view.getUint16(offset2, false);
    markerLength = view.getUint16(offset2 + 2, false) + 2;
    const isData = marker >= 65504 && marker <= 65519 || marker === 65534;
    if (!isData) {
      break;
    }
    if (!orientationCorrected) {
      orientationCorrected = correctOrientation(view, offset2);
    }
    if (offset2 + markerLength > view.byteLength) {
      break;
    }
    offset2 += markerLength;
  }
  return data2.slice(0, offset2);
};
const getImageHead = (file2) => new Promise((resolve) => {
  const reader = new FileReader();
  reader.onload = () => resolve(readData(reader.result) || null);
  reader.readAsArrayBuffer(file2.slice(0, 256 * 1024));
});
const getBlobBuilder = () => {
  return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
};
const createBlob = (arrayBuffer, mimeType) => {
  const BB = getBlobBuilder();
  if (BB) {
    const bb = new BB();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeType);
  }
  return new Blob([arrayBuffer], {
    type: mimeType
  });
};
const getUniqueId = () => Math.random().toString(36).substr(2, 9);
const createWorker = (fn3) => {
  const workerBlob = new Blob(["(", fn3.toString(), ")()"], { type: "application/javascript" });
  const workerURL = URL.createObjectURL(workerBlob);
  const worker = new Worker(workerURL);
  const trips = [];
  return {
    transfer: () => {
    },
    // (message, cb) => {}
    post: (message, cb, transferList) => {
      const id = getUniqueId();
      trips[id] = cb;
      worker.onmessage = (e) => {
        const cb2 = trips[e.data.id];
        if (!cb2)
          return;
        cb2(e.data.message);
        delete trips[e.data.id];
      };
      worker.postMessage(
        {
          id,
          message
        },
        transferList
      );
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(workerURL);
    }
  };
};
const loadImage$1 = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
const chain = (funcs) => funcs.reduce(
  (promise, func) => promise.then((result) => func().then(Array.prototype.concat.bind(result))),
  Promise.resolve([])
);
const canvasApplyMarkup = (canvas, markup) => new Promise((resolve) => {
  const size = {
    width: canvas.width,
    height: canvas.height
  };
  const ctx = canvas.getContext("2d");
  const drawers = markup.sort(sortMarkupByZIndex).map(
    (item2) => () => new Promise((resolve2) => {
      const result = TYPE_DRAW_ROUTES[item2[0]](ctx, size, item2[1], resolve2);
      if (result)
        resolve2();
    })
  );
  chain(drawers).then(() => resolve(canvas));
});
const applyMarkupStyles = (ctx, styles2) => {
  ctx.beginPath();
  ctx.lineCap = styles2["stroke-linecap"];
  ctx.lineJoin = styles2["stroke-linejoin"];
  ctx.lineWidth = styles2["stroke-width"];
  if (styles2["stroke-dasharray"].length) {
    ctx.setLineDash(styles2["stroke-dasharray"].split(","));
  }
  ctx.fillStyle = styles2["fill"];
  ctx.strokeStyle = styles2["stroke"];
  ctx.globalAlpha = styles2.opacity || 1;
};
const drawMarkupStyles = (ctx) => {
  ctx.fill();
  ctx.stroke();
  ctx.globalAlpha = 1;
};
const drawRect = (ctx, size, markup) => {
  const rect = getMarkupRect(markup, size);
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.rect(rect.x, rect.y, rect.width, rect.height);
  drawMarkupStyles(ctx);
  return true;
};
const drawEllipse = (ctx, size, markup) => {
  const rect = getMarkupRect(markup, size);
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  const x = rect.x, y = rect.y, w = rect.width, h = rect.height, kappa = 0.5522848, ox = w / 2 * kappa, oy = h / 2 * kappa, xe = x + w, ye = y + h, xm = x + w / 2, ym = y + h / 2;
  ctx.moveTo(x, ym);
  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  drawMarkupStyles(ctx);
  return true;
};
const drawImage = (ctx, size, markup, done) => {
  const rect = getMarkupRect(markup, size);
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  const image = new Image();
  const isCrossOriginImage = new URL(markup.src, window.location.href).origin !== window.location.origin;
  if (isCrossOriginImage)
    image.crossOrigin = "";
  image.onload = () => {
    if (markup.fit === "cover") {
      const ar = rect.width / rect.height;
      const width2 = ar > 1 ? image.width : image.height * ar;
      const height2 = ar > 1 ? image.width / ar : image.height;
      const x = image.width * 0.5 - width2 * 0.5;
      const y = image.height * 0.5 - height2 * 0.5;
      ctx.drawImage(image, x, y, width2, height2, rect.x, rect.y, rect.width, rect.height);
    } else if (markup.fit === "contain") {
      const scalar = Math.min(rect.width / image.width, rect.height / image.height);
      const width2 = scalar * image.width;
      const height2 = scalar * image.height;
      const x = rect.x + rect.width * 0.5 - width2 * 0.5;
      const y = rect.y + rect.height * 0.5 - height2 * 0.5;
      ctx.drawImage(image, 0, 0, image.width, image.height, x, y, width2, height2);
    } else {
      ctx.drawImage(
        image,
        0,
        0,
        image.width,
        image.height,
        rect.x,
        rect.y,
        rect.width,
        rect.height
      );
    }
    drawMarkupStyles(ctx);
    done();
  };
  image.src = markup.src;
};
const drawText = (ctx, size, markup) => {
  const rect = getMarkupRect(markup, size);
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  const fontSize = getMarkupValue(markup.fontSize, size);
  const fontFamily = markup.fontFamily || "sans-serif";
  const fontWeight = markup.fontWeight || "normal";
  const textAlign = markup.textAlign || "left";
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.textAlign = textAlign;
  ctx.fillText(markup.text, rect.x, rect.y);
  drawMarkupStyles(ctx);
  return true;
};
const drawPath = (ctx, size, markup) => {
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.beginPath();
  const points = markup.points.map((point) => ({
    x: getMarkupValue(point.x, size, 1, "width"),
    y: getMarkupValue(point.y, size, 1, "height")
  }));
  ctx.moveTo(points[0].x, points[0].y);
  const l = points.length;
  for (let i = 1; i < l; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  drawMarkupStyles(ctx);
  return true;
};
const drawLine = (ctx, size, markup) => {
  const rect = getMarkupRect(markup, size);
  const styles2 = getMarkupStyles(markup, size);
  applyMarkupStyles(ctx, styles2);
  ctx.beginPath();
  const origin = {
    x: rect.x,
    y: rect.y
  };
  const target = {
    x: rect.x + rect.width,
    y: rect.y + rect.height
  };
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(target.x, target.y);
  const v = vectorNormalize({
    x: target.x - origin.x,
    y: target.y - origin.y
  });
  const l = 0.04 * Math.min(size.width, size.height);
  if (markup.lineDecoration.indexOf("arrow-begin") !== -1) {
    const arrowBeginRotationPoint = vectorMultiply(v, l);
    const arrowBeginCenter = vectorAdd(origin, arrowBeginRotationPoint);
    const arrowBeginA = vectorRotate(origin, 2, arrowBeginCenter);
    const arrowBeginB = vectorRotate(origin, -2, arrowBeginCenter);
    ctx.moveTo(arrowBeginA.x, arrowBeginA.y);
    ctx.lineTo(origin.x, origin.y);
    ctx.lineTo(arrowBeginB.x, arrowBeginB.y);
  }
  if (markup.lineDecoration.indexOf("arrow-end") !== -1) {
    const arrowEndRotationPoint = vectorMultiply(v, -l);
    const arrowEndCenter = vectorAdd(target, arrowEndRotationPoint);
    const arrowEndA = vectorRotate(target, 2, arrowEndCenter);
    const arrowEndB = vectorRotate(target, -2, arrowEndCenter);
    ctx.moveTo(arrowEndA.x, arrowEndA.y);
    ctx.lineTo(target.x, target.y);
    ctx.lineTo(arrowEndB.x, arrowEndB.y);
  }
  drawMarkupStyles(ctx);
  return true;
};
const TYPE_DRAW_ROUTES = {
  rect: drawRect,
  ellipse: drawEllipse,
  image: drawImage,
  text: drawText,
  line: drawLine,
  path: drawPath
};
const imageDataToCanvas = (imageData) => {
  const image = document.createElement("canvas");
  image.width = imageData.width;
  image.height = imageData.height;
  const ctx = image.getContext("2d");
  ctx.putImageData(imageData, 0, 0);
  return image;
};
const transformImage = (file2, instructions, options = {}) => new Promise((resolve, reject) => {
  if (!file2 || !isImage$1(file2))
    return reject({ status: "not an image file", file: file2 });
  const { stripImageHead, beforeCreateBlob, afterCreateBlob, canvasMemoryLimit } = options;
  const { crop, size, filter: filter2, markup, output } = instructions;
  const orientation = instructions.image && instructions.image.orientation ? Math.max(1, Math.min(8, instructions.image.orientation)) : null;
  const qualityAsPercentage = output && output.quality;
  const quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;
  const type = output && output.type || null;
  const background = output && output.background || null;
  const transforms2 = [];
  if (size && (typeof size.width === "number" || typeof size.height === "number")) {
    transforms2.push({ type: "resize", data: size });
  }
  if (filter2 && filter2.length === 20) {
    transforms2.push({ type: "filter", data: filter2 });
  }
  const resolveWithBlob = (blob2) => {
    const promisedBlob = afterCreateBlob ? afterCreateBlob(blob2) : blob2;
    Promise.resolve(promisedBlob).then(resolve);
  };
  const toBlob = (imageData, options2) => {
    const canvas = imageDataToCanvas(imageData);
    const promisedCanvas = markup.length ? canvasApplyMarkup(canvas, markup) : canvas;
    Promise.resolve(promisedCanvas).then((canvas2) => {
      canvasToBlob(canvas2, options2, beforeCreateBlob).then((blob2) => {
        canvasRelease(canvas2);
        if (stripImageHead)
          return resolveWithBlob(blob2);
        getImageHead(file2).then((imageHead) => {
          if (imageHead !== null) {
            blob2 = new Blob([imageHead, blob2.slice(20)], { type: blob2.type });
          }
          resolveWithBlob(blob2);
        });
      }).catch(reject);
    });
  };
  if (/svg/.test(file2.type) && type === null) {
    return cropSVG(file2, crop, markup, { background }).then((text2) => {
      resolve(createBlob(text2, "image/svg+xml"));
    });
  }
  const url = URL.createObjectURL(file2);
  loadImage$1(url).then((image) => {
    URL.revokeObjectURL(url);
    const imageData = imageToImageData(image, orientation, crop, {
      canvasMemoryLimit,
      background
    });
    const outputFormat = {
      quality,
      type: type || file2.type
    };
    if (!transforms2.length) {
      return toBlob(imageData, outputFormat);
    }
    const worker = createWorker(TransformWorker);
    worker.post(
      {
        transforms: transforms2,
        imageData
      },
      (response) => {
        toBlob(objectToImageData(response), outputFormat);
        worker.terminate();
      },
      [imageData.data.buffer]
    );
  }).catch(reject);
});
const MARKUP_RECT = ["x", "y", "left", "top", "right", "bottom", "width", "height"];
const toOptionalFraction = (value) => typeof value === "string" && /%/.test(value) ? parseFloat(value) / 100 : value;
const prepareMarkup = (markup) => {
  const [type, props] = markup;
  const rect = props.points ? {} : MARKUP_RECT.reduce((prev, curr) => {
    prev[curr] = toOptionalFraction(props[curr]);
    return prev;
  }, {});
  return [
    type,
    {
      zIndex: 0,
      ...props,
      ...rect
    }
  ];
};
const getImageSize$1 = (file2) => new Promise((resolve, reject) => {
  const imageElement = new Image();
  imageElement.src = URL.createObjectURL(file2);
  const measure = () => {
    const width2 = imageElement.naturalWidth;
    const height2 = imageElement.naturalHeight;
    const hasSize = width2 && height2;
    if (!hasSize)
      return;
    URL.revokeObjectURL(imageElement.src);
    clearInterval(intervalId);
    resolve({ width: width2, height: height2 });
  };
  imageElement.onerror = (err) => {
    URL.revokeObjectURL(imageElement.src);
    clearInterval(intervalId);
    reject(err);
  };
  const intervalId = setInterval(measure, 1);
  measure();
});
if (typeof window !== "undefined" && typeof window.document !== "undefined") {
  if (!HTMLCanvasElement.prototype.toBlob) {
    Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
      value: function(cb, type, quality) {
        const canvas = this;
        setTimeout(() => {
          const dataURL = canvas.toDataURL(type, quality).split(",")[1];
          const binStr = atob(dataURL);
          let index = binStr.length;
          const data2 = new Uint8Array(index);
          while (index--) {
            data2[index] = binStr.charCodeAt(index);
          }
          cb(new Blob([data2], { type: type || "image/png" }));
        });
      }
    });
  }
}
const isBrowser$3 = typeof window !== "undefined" && typeof window.document !== "undefined";
const isIOS = isBrowser$3 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const plugin$3 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const { Type: Type2, forin: forin2, getFileFromBlob: getFileFromBlob2, isFile: isFile2 } = utils2;
  const TRANSFORM_LIST = ["crop", "resize", "filter", "markup", "output"];
  const createVariantCreator = (updateMetadata) => (transform, file2, metadata) => transform(file2, updateMetadata ? updateMetadata(metadata) : metadata);
  const isDefaultCrop = (crop) => crop.aspectRatio === null && crop.rotation === 0 && crop.zoom === 1 && crop.center && crop.center.x === 0.5 && crop.center.y === 0.5 && crop.flip && crop.flip.horizontal === false && crop.flip.vertical === false;
  addFilter2(
    "SHOULD_PREPARE_OUTPUT",
    (shouldPrepareOutput, { query }) => new Promise((resolve) => {
      resolve(!query("IS_ASYNC"));
    })
  );
  const shouldTransformFile = (query, file2, item2) => new Promise((resolve) => {
    if (!query("GET_ALLOW_IMAGE_TRANSFORM") || item2.archived || !isFile2(file2) || !isImage(file2)) {
      return resolve(false);
    }
    getImageSize$1(file2).then(() => {
      const fn3 = query("GET_IMAGE_TRANSFORM_IMAGE_FILTER");
      if (fn3) {
        const filterResult = fn3(file2);
        if (filterResult == null) {
          return handleRevert(true);
        }
        if (typeof filterResult === "boolean") {
          return resolve(filterResult);
        }
        if (typeof filterResult.then === "function") {
          return filterResult.then(resolve);
        }
      }
      resolve(true);
    }).catch((err) => {
      resolve(false);
    });
  });
  addFilter2("DID_CREATE_ITEM", (item2, { query, dispatch }) => {
    if (!query("GET_ALLOW_IMAGE_TRANSFORM"))
      return;
    item2.extend(
      "requestPrepare",
      () => new Promise((resolve, reject) => {
        dispatch(
          "REQUEST_PREPARE_OUTPUT",
          {
            query: item2.id,
            item: item2,
            success: resolve,
            failure: reject
          },
          true
        );
      })
    );
  });
  addFilter2(
    "PREPARE_OUTPUT",
    (file2, { query, item: item2 }) => new Promise((resolve) => {
      shouldTransformFile(query, file2, item2).then((shouldTransform) => {
        if (!shouldTransform)
          return resolve(file2);
        const variants = [];
        if (query("GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_ORIGINAL")) {
          variants.push(
            () => new Promise((resolve2) => {
              resolve2({
                name: query("GET_IMAGE_TRANSFORM_VARIANTS_ORIGINAL_NAME"),
                file: file2
              });
            })
          );
        }
        if (query("GET_IMAGE_TRANSFORM_VARIANTS_INCLUDE_DEFAULT")) {
          variants.push(
            (transform2, file3, metadata) => new Promise((resolve2) => {
              transform2(file3, metadata).then(
                (file4) => resolve2({
                  name: query(
                    "GET_IMAGE_TRANSFORM_VARIANTS_DEFAULT_NAME"
                  ),
                  file: file4
                })
              );
            })
          );
        }
        const variantsDefinition = query("GET_IMAGE_TRANSFORM_VARIANTS") || {};
        forin2(variantsDefinition, (key, fn3) => {
          const createVariant = createVariantCreator(fn3);
          variants.push(
            (transform2, file3, metadata) => new Promise((resolve2) => {
              createVariant(transform2, file3, metadata).then(
                (file4) => resolve2({ name: key, file: file4 })
              );
            })
          );
        });
        const qualityAsPercentage = query("GET_IMAGE_TRANSFORM_OUTPUT_QUALITY");
        const qualityMode = query("GET_IMAGE_TRANSFORM_OUTPUT_QUALITY_MODE");
        const quality = qualityAsPercentage === null ? null : qualityAsPercentage / 100;
        const type = query("GET_IMAGE_TRANSFORM_OUTPUT_MIME_TYPE");
        const clientTransforms = query("GET_IMAGE_TRANSFORM_CLIENT_TRANSFORMS") || TRANSFORM_LIST;
        item2.setMetadata(
          "output",
          {
            type,
            quality,
            client: clientTransforms
          },
          true
        );
        const transform = (file3, metadata) => new Promise((resolve2, reject) => {
          const filteredMetadata = { ...metadata };
          Object.keys(filteredMetadata).filter((instruction) => instruction !== "exif").forEach((instruction) => {
            if (clientTransforms.indexOf(instruction) === -1) {
              delete filteredMetadata[instruction];
            }
          });
          const { resize, exif, output, crop, filter: filter2, markup } = filteredMetadata;
          const instructions = {
            image: {
              orientation: exif ? exif.orientation : null
            },
            output: output && (output.type || typeof output.quality === "number" || output.background) ? {
              type: output.type,
              quality: typeof output.quality === "number" ? output.quality * 100 : null,
              background: output.background || query(
                "GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR"
              ) || null
            } : void 0,
            size: resize && (resize.size.width || resize.size.height) ? {
              mode: resize.mode,
              upscale: resize.upscale,
              ...resize.size
            } : void 0,
            crop: crop && !isDefaultCrop(crop) ? {
              ...crop
            } : void 0,
            markup: markup && markup.length ? markup.map(prepareMarkup) : [],
            filter: filter2
          };
          if (instructions.output) {
            const willChangeType = output.type ? (
              // type set
              output.type !== file3.type
            ) : (
              // type not set
              false
            );
            const canChangeQuality = /\/jpe?g$/.test(file3.type);
            const willChangeQuality = output.quality !== null ? (
              // quality set
              canChangeQuality && qualityMode === "always"
            ) : (
              // quality not set
              false
            );
            const willModifyImageData = !!(instructions.size || instructions.crop || instructions.filter || willChangeType || willChangeQuality);
            if (!willModifyImageData)
              return resolve2(file3);
          }
          const options = {
            beforeCreateBlob: query("GET_IMAGE_TRANSFORM_BEFORE_CREATE_BLOB"),
            afterCreateBlob: query("GET_IMAGE_TRANSFORM_AFTER_CREATE_BLOB"),
            canvasMemoryLimit: query("GET_IMAGE_TRANSFORM_CANVAS_MEMORY_LIMIT"),
            stripImageHead: query(
              "GET_IMAGE_TRANSFORM_OUTPUT_STRIP_IMAGE_HEAD"
            )
          };
          transformImage(file3, instructions, options).then((blob2) => {
            const out = getFileFromBlob2(
              blob2,
              // rename the original filename to match the mime type of the output image
              renameFileToMatchMimeType(
                file3.name,
                getValidOutputMimeType(blob2.type)
              )
            );
            resolve2(out);
          }).catch(reject);
        });
        const variantPromises = variants.map(
          (create2) => create2(transform, file2, item2.getMetadata())
        );
        Promise.all(variantPromises).then((files) => {
          resolve(
            files.length === 1 && files[0].name === null ? (
              // return the File object
              files[0].file
            ) : (
              // return an array of files { name:'name', file:File }
              files
            )
          );
        });
      });
    })
  );
  return {
    options: {
      allowImageTransform: [true, Type2.BOOLEAN],
      // filter images to transform
      imageTransformImageFilter: [null, Type2.FUNCTION],
      // null, 'image/jpeg', 'image/png'
      imageTransformOutputMimeType: [null, Type2.STRING],
      // null, 0 - 100
      imageTransformOutputQuality: [null, Type2.INT],
      // set to false to copy image exif data to output
      imageTransformOutputStripImageHead: [true, Type2.BOOLEAN],
      // only apply transforms in this list
      imageTransformClientTransforms: [null, Type2.ARRAY],
      // only apply output quality when a transform is required
      imageTransformOutputQualityMode: ["always", Type2.STRING],
      // 'always'
      // 'optional'
      // 'mismatch' (future feature, only applied if quality differs from input)
      // get image transform variants
      imageTransformVariants: [null, Type2.OBJECT],
      // should we post the default transformed file
      imageTransformVariantsIncludeDefault: [true, Type2.BOOLEAN],
      // which name to prefix the default transformed file with
      imageTransformVariantsDefaultName: [null, Type2.STRING],
      // should we post the original file
      imageTransformVariantsIncludeOriginal: [false, Type2.BOOLEAN],
      // which name to prefix the original file with
      imageTransformVariantsOriginalName: ["original_", Type2.STRING],
      // called before creating the blob, receives canvas, expects promise resolve with canvas
      imageTransformBeforeCreateBlob: [null, Type2.FUNCTION],
      // expects promise resolved with blob
      imageTransformAfterCreateBlob: [null, Type2.FUNCTION],
      // canvas memory limit
      imageTransformCanvasMemoryLimit: [isBrowser$3 && isIOS ? 4096 * 4096 : null, Type2.INT],
      // background image of the output canvas
      imageTransformCanvasBackgroundColor: [null, Type2.STRING]
    }
  };
};
if (isBrowser$3) {
  document.dispatchEvent(new CustomEvent("FilePond:pluginloaded", { detail: plugin$3 }));
}
/*!
 * FilePondPluginImageEdit 1.6.3
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isPreviewableImage = (file2) => /^image/.test(file2.type);
const plugin$2 = (_2) => {
  const { addFilter: addFilter2, utils: utils2, views } = _2;
  const { Type: Type2, createRoute: createRoute2, createItemAPI: createItemAPI2 = (item2) => item2 } = utils2;
  const { fileActionButton: fileActionButton2 } = views;
  addFilter2(
    "SHOULD_REMOVE_ON_REVERT",
    (shouldRemove, { item: item2, query }) => new Promise((resolve) => {
      const { file: file2 } = item2;
      const canEdit = query("GET_ALLOW_IMAGE_EDIT") && query("GET_IMAGE_EDIT_ALLOW_EDIT") && isPreviewableImage(file2);
      resolve(!canEdit);
    })
  );
  addFilter2(
    "DID_LOAD_ITEM",
    (item2, { query, dispatch }) => new Promise((resolve, reject) => {
      if (item2.origin > 1) {
        resolve(item2);
        return;
      }
      const { file: file2 } = item2;
      if (!query("GET_ALLOW_IMAGE_EDIT") || !query("GET_IMAGE_EDIT_INSTANT_EDIT")) {
        resolve(item2);
        return;
      }
      if (!isPreviewableImage(file2)) {
        resolve(item2);
        return;
      }
      const createEditorResponseHandler = (item3, resolve2, reject2) => (userDidConfirm) => {
        editRequestQueue.shift();
        if (userDidConfirm) {
          resolve2(item3);
        } else {
          reject2(item3);
        }
        dispatch("KICK");
        requestEdit();
      };
      const requestEdit = () => {
        if (!editRequestQueue.length)
          return;
        const { item: item3, resolve: resolve2, reject: reject2 } = editRequestQueue[0];
        dispatch("EDIT_ITEM", {
          id: item3.id,
          handleEditorResponse: createEditorResponseHandler(
            item3,
            resolve2,
            reject2
          )
        });
      };
      queueEditRequest({ item: item2, resolve, reject });
      if (editRequestQueue.length === 1) {
        requestEdit();
      }
    })
  );
  addFilter2("DID_CREATE_ITEM", (item2, { query, dispatch }) => {
    item2.extend("edit", () => {
      dispatch("EDIT_ITEM", { id: item2.id });
    });
  });
  const editRequestQueue = [];
  const queueEditRequest = (editRequest) => {
    editRequestQueue.push(editRequest);
    return editRequest;
  };
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const { is, view, query } = viewAPI;
    if (!query("GET_ALLOW_IMAGE_EDIT"))
      return;
    const canShowImagePreview = query("GET_ALLOW_IMAGE_PREVIEW");
    const shouldExtendView = is("file-info") && !canShowImagePreview || is("file") && canShowImagePreview;
    if (!shouldExtendView)
      return;
    const editor = query("GET_IMAGE_EDIT_EDITOR");
    if (!editor)
      return;
    if (!editor.filepondCallbackBridge) {
      editor.outputData = true;
      editor.outputFile = false;
      editor.filepondCallbackBridge = {
        onconfirm: editor.onconfirm || (() => {
        }),
        oncancel: editor.oncancel || (() => {
        })
      };
    }
    const openEditor = ({ root: root2, props, action }) => {
      const { id } = props;
      const { handleEditorResponse } = action;
      editor.cropAspectRatio = root2.query("GET_IMAGE_CROP_ASPECT_RATIO") || editor.cropAspectRatio;
      editor.outputCanvasBackgroundColor = root2.query("GET_IMAGE_TRANSFORM_CANVAS_BACKGROUND_COLOR") || editor.outputCanvasBackgroundColor;
      const item2 = root2.query("GET_ITEM", id);
      if (!item2)
        return;
      const file2 = item2.file;
      const crop = item2.getMetadata("crop");
      const cropDefault = {
        center: {
          x: 0.5,
          y: 0.5
        },
        flip: {
          horizontal: false,
          vertical: false
        },
        zoom: 1,
        rotation: 0,
        aspectRatio: null
      };
      const resize = item2.getMetadata("resize");
      const filter2 = item2.getMetadata("filter") || null;
      const filters2 = item2.getMetadata("filters") || null;
      const colors = item2.getMetadata("colors") || null;
      const markup = item2.getMetadata("markup") || null;
      const imageParameters = {
        crop: crop || cropDefault,
        size: resize ? {
          upscale: resize.upscale,
          mode: resize.mode,
          width: resize.size.width,
          height: resize.size.height
        } : null,
        filter: filters2 ? filters2.id || filters2.matrix : root2.query("GET_ALLOW_IMAGE_FILTER") && root2.query("GET_IMAGE_FILTER_COLOR_MATRIX") && !colors ? filter2 : null,
        color: colors,
        markup
      };
      editor.onconfirm = ({ data: data2 }) => {
        const { crop: crop2, size, filter: filter3, color, colorMatrix, markup: markup2 } = data2;
        const metadata = {};
        if (crop2) {
          metadata.crop = crop2;
        }
        if (size) {
          const initialSize = (item2.getMetadata("resize") || {}).size;
          const targetSize = {
            width: size.width,
            height: size.height
          };
          if (!(targetSize.width && targetSize.height) && initialSize) {
            targetSize.width = initialSize.width;
            targetSize.height = initialSize.height;
          }
          if (targetSize.width || targetSize.height) {
            metadata.resize = {
              upscale: size.upscale,
              mode: size.mode,
              size: targetSize
            };
          }
        }
        if (markup2) {
          metadata.markup = markup2;
        }
        metadata.colors = color;
        metadata.filters = filter3;
        metadata.filter = colorMatrix;
        item2.setMetadata(metadata);
        editor.filepondCallbackBridge.onconfirm(data2, createItemAPI2(item2));
        if (!handleEditorResponse)
          return;
        editor.onclose = () => {
          handleEditorResponse(true);
          editor.onclose = null;
        };
      };
      editor.oncancel = () => {
        editor.filepondCallbackBridge.oncancel(createItemAPI2(item2));
        if (!handleEditorResponse)
          return;
        editor.onclose = () => {
          handleEditorResponse(false);
          editor.onclose = null;
        };
      };
      editor.open(file2, imageParameters);
    };
    const didLoadItem2 = ({ root: root2, props }) => {
      if (!query("GET_IMAGE_EDIT_ALLOW_EDIT"))
        return;
      const { id } = props;
      const item2 = query("GET_ITEM", id);
      if (!item2)
        return;
      const file2 = item2.file;
      if (!isPreviewableImage(file2))
        return;
      root2.ref.handleEdit = (e) => {
        e.stopPropagation();
        root2.dispatch("EDIT_ITEM", { id });
      };
      if (canShowImagePreview) {
        const buttonView = view.createChildView(fileActionButton2, {
          label: "edit",
          icon: query("GET_IMAGE_EDIT_ICON_EDIT"),
          opacity: 0
        });
        buttonView.element.classList.add("filepond--action-edit-item");
        buttonView.element.dataset.align = query(
          "GET_STYLE_IMAGE_EDIT_BUTTON_EDIT_ITEM_POSITION"
        );
        buttonView.on("click", root2.ref.handleEdit);
        root2.ref.buttonEditItem = view.appendChildView(buttonView);
      } else {
        const filenameElement = view.element.querySelector(
          ".filepond--file-info-main"
        );
        const editButton = document.createElement("button");
        editButton.className = "filepond--action-edit-item-alt";
        editButton.innerHTML = query("GET_IMAGE_EDIT_ICON_EDIT") + "<span>edit</span>";
        editButton.addEventListener("click", root2.ref.handleEdit);
        filenameElement.appendChild(editButton);
        root2.ref.editButton = editButton;
      }
    };
    view.registerDestroyer(({ root: root2 }) => {
      if (root2.ref.buttonEditItem) {
        root2.ref.buttonEditItem.off("click", root2.ref.handleEdit);
      }
      if (root2.ref.editButton) {
        root2.ref.editButton.removeEventListener("click", root2.ref.handleEdit);
      }
    });
    const routes = {
      EDIT_ITEM: openEditor,
      DID_LOAD_ITEM: didLoadItem2
    };
    if (canShowImagePreview) {
      const didPreviewUpdate = ({ root: root2 }) => {
        if (!root2.ref.buttonEditItem)
          return;
        root2.ref.buttonEditItem.opacity = 1;
      };
      routes.DID_IMAGE_PREVIEW_SHOW = didPreviewUpdate;
    }
    view.registerWriter(createRoute2(routes));
  });
  return {
    options: {
      // enable or disable image editing
      allowImageEdit: [true, Type2.BOOLEAN],
      // location of processing button
      styleImageEditButtonEditItemPosition: ["bottom center", Type2.STRING],
      // open editor when image is dropped
      imageEditInstantEdit: [false, Type2.BOOLEAN],
      // allow editing
      imageEditAllowEdit: [true, Type2.BOOLEAN],
      // the icon to use for the edit button
      imageEditIconEdit: [
        '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><path d="M8.5 17h1.586l7-7L15.5 8.414l-7 7V17zm-1.707-2.707l8-8a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1 0 1.414l-8 8A1 1 0 0 1 10.5 19h-3a1 1 0 0 1-1-1v-3a1 1 0 0 1 .293-.707z" fill="currentColor" fill-rule="nonzero"/></svg>',
        Type2.STRING
      ],
      // editor object
      imageEditEditor: [null, Type2.OBJECT]
    }
  };
};
const isBrowser$2 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$2) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$2 })
  );
}
/*!
 * FilePondPluginFileEncode 2.1.10
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const DataURIWorker = function() {
  self.onmessage = (e) => {
    convert(e.data.message, (response) => {
      self.postMessage({ id: e.data.id, message: response });
    });
  };
  const convert = (options, cb) => {
    const { file: file2 } = options;
    const reader = new FileReader();
    reader.onloadend = () => {
      cb(reader.result.replace("data:", "").replace(/^.+,/, ""));
    };
    reader.readAsDataURL(file2);
  };
};
const plugin$1 = ({ addFilter: addFilter2, utils: utils2 }) => {
  const { Type: Type2, createWorker: createWorker2, createRoute: createRoute2, isFile: isFile2 } = utils2;
  const encode2 = ({ name: name2, file: file2 }) => new Promise((resolve) => {
    const worker = createWorker2(DataURIWorker);
    worker.post({ file: file2 }, (data2) => {
      resolve({ name: name2, data: data2 });
      worker.terminate();
    });
  });
  const base64Cache = [];
  addFilter2("DID_CREATE_ITEM", (item2, { query }) => {
    if (!query("GET_ALLOW_FILE_ENCODE"))
      return;
    item2.extend(
      "getFileEncodeBase64String",
      () => base64Cache[item2.id] && base64Cache[item2.id].data
    );
    item2.extend(
      "getFileEncodeDataURL",
      () => `data:${item2.fileType};base64,${base64Cache[item2.id].data}`
    );
  });
  addFilter2(
    "SHOULD_PREPARE_OUTPUT",
    (shouldPrepareOutput, { query }) => new Promise((resolve) => {
      resolve(query("GET_ALLOW_FILE_ENCODE"));
    })
  );
  addFilter2(
    "COMPLETE_PREPARE_OUTPUT",
    (file2, { item: item2, query }) => new Promise((resolve) => {
      if (!query("GET_ALLOW_FILE_ENCODE") || !isFile2(file2) && !Array.isArray(file2)) {
        return resolve(file2);
      }
      base64Cache[item2.id] = {
        metadata: item2.getMetadata(),
        data: null
      };
      Promise.all(
        (file2 instanceof Blob ? [{ name: null, file: file2 }] : file2).map(encode2)
      ).then((dataItems) => {
        base64Cache[item2.id].data = file2 instanceof Blob ? dataItems[0].data : dataItems;
        resolve(file2);
      });
    })
  );
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const { is, view, query } = viewAPI;
    if (!is("file-wrapper") || !query("GET_ALLOW_FILE_ENCODE")) {
      return;
    }
    view.registerWriter(
      createRoute2({
        DID_PREPARE_OUTPUT: ({ root: root2, action }) => {
          if (query("IS_ASYNC")) {
            return;
          }
          const item2 = query("GET_ITEM", action.id);
          if (!item2)
            return;
          const cache = base64Cache[item2.id];
          const metadata = cache.metadata;
          const data2 = cache.data;
          const value = JSON.stringify({
            id: item2.id,
            name: item2.file.name,
            type: item2.file.type,
            size: item2.file.size,
            metadata,
            data: data2
          });
          if (root2.ref.data) {
            root2.ref.data.value = value;
          } else {
            root2.dispatch("DID_DEFINE_VALUE", {
              id: item2.id,
              value
            });
          }
        },
        DID_REMOVE_ITEM: ({ action }) => {
          const item2 = query("GET_ITEM", action.id);
          if (!item2)
            return;
          delete base64Cache[item2.id];
        }
      })
    );
  });
  return {
    options: {
      // Enable or disable file encoding
      allowFileEncode: [true, Type2.BOOLEAN]
    }
  };
};
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser$1) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin$1 })
  );
}
/*!
 * FilePondPluginFilePoster 2.5.1
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const IMAGE_SCALE_SPRING_PROPS = {
  type: "spring",
  stiffness: 0.5,
  damping: 0.45,
  mass: 10
};
const createPosterView = (_2) => _2.utils.createView({
  name: "file-poster",
  tag: "div",
  ignoreRect: true,
  create: ({ root: root2 }) => {
    root2.ref.image = document.createElement("img");
    root2.element.appendChild(root2.ref.image);
  },
  write: _2.utils.createRoute({
    DID_FILE_POSTER_LOAD: ({ root: root2, props }) => {
      const { id } = props;
      const item2 = root2.query("GET_ITEM", { id: props.id });
      if (!item2)
        return;
      const poster = item2.getMetadata("poster");
      root2.ref.image.src = poster;
      root2.dispatch("DID_FILE_POSTER_DRAW", { id });
    }
  }),
  mixins: {
    styles: ["scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: IMAGE_SCALE_SPRING_PROPS,
      scaleY: IMAGE_SCALE_SPRING_PROPS,
      opacity: { type: "tween", duration: 750 }
    }
  }
});
const applyTemplate = (source, target) => {
  target.width = source.width;
  target.height = source.height;
  const ctx = target.getContext("2d");
  ctx.drawImage(source, 0, 0);
};
const createPosterOverlayView = (fpAPI) => fpAPI.utils.createView({
  name: "file-poster-overlay",
  tag: "canvas",
  ignoreRect: true,
  create: ({ root: root2, props }) => {
    applyTemplate(props.template, root2.element);
  },
  mixins: {
    styles: ["opacity"],
    animations: {
      opacity: { type: "spring", mass: 25 }
    }
  }
});
const getImageSize = (url, cb) => {
  let image = new Image();
  image.onload = () => {
    const width2 = image.naturalWidth;
    const height2 = image.naturalHeight;
    image = null;
    cb(width2, height2);
  };
  image.src = url;
};
const easeInOutSine = (t) => -0.5 * (Math.cos(Math.PI * t) - 1);
const addGradientSteps = (gradient, color, alpha = 1, easeFn = easeInOutSine, steps = 10, offset2 = 0) => {
  const range = 1 - offset2;
  const rgb = color.join(",");
  for (let i = 0; i <= steps; i++) {
    const p = i / steps;
    const stop = offset2 + range * p;
    gradient.addColorStop(stop, `rgba(${rgb}, ${easeFn(p) * alpha})`);
  }
};
const MAX_WIDTH = 10;
const MAX_HEIGHT = 10;
const calculateAverageColor = (image) => {
  const scalar = Math.min(MAX_WIDTH / image.width, MAX_HEIGHT / image.height);
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  const width2 = canvas.width = Math.ceil(image.width * scalar);
  const height2 = canvas.height = Math.ceil(image.height * scalar);
  ctx.drawImage(image, 0, 0, width2, height2);
  let data2 = null;
  try {
    data2 = ctx.getImageData(0, 0, width2, height2).data;
  } catch (e) {
    return null;
  }
  const l = data2.length;
  let r = 0;
  let g = 0;
  let b = 0;
  let i = 0;
  for (; i < l; i += 4) {
    r += data2[i] * data2[i];
    g += data2[i + 1] * data2[i + 1];
    b += data2[i + 2] * data2[i + 2];
  }
  r = averageColor(r, l);
  g = averageColor(g, l);
  b = averageColor(b, l);
  return { r, g, b };
};
const averageColor = (c, l) => Math.floor(Math.sqrt(c / (l / 4)));
const drawTemplate = (canvas, width2, height2, color, alphaTarget) => {
  canvas.width = width2;
  canvas.height = height2;
  const ctx = canvas.getContext("2d");
  const horizontalCenter = width2 * 0.5;
  const grad = ctx.createRadialGradient(
    horizontalCenter,
    height2 + 110,
    height2 - 100,
    horizontalCenter,
    height2 + 110,
    height2 + 100
  );
  addGradientSteps(grad, color, alphaTarget, void 0, 8, 0.4);
  ctx.save();
  ctx.translate(-width2 * 0.5, 0);
  ctx.scale(2, 1);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, width2, height2);
  ctx.restore();
};
const hasNavigator = typeof navigator !== "undefined";
const width = 500;
const height = 200;
const overlayTemplateShadow = hasNavigator && document.createElement("canvas");
const overlayTemplateError = hasNavigator && document.createElement("canvas");
const overlayTemplateSuccess = hasNavigator && document.createElement("canvas");
let itemShadowColor = [40, 40, 40];
let itemErrorColor = [196, 78, 71];
let itemSuccessColor = [54, 151, 99];
if (hasNavigator) {
  drawTemplate(overlayTemplateShadow, width, height, itemShadowColor, 0.85);
  drawTemplate(overlayTemplateError, width, height, itemErrorColor, 1);
  drawTemplate(overlayTemplateSuccess, width, height, itemSuccessColor, 1);
}
const loadImage = (url, crossOriginValue) => new Promise((resolve, reject) => {
  const img = new Image();
  if (typeof crossOrigin === "string") {
    img.crossOrigin = crossOriginValue;
  }
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e) => {
    reject(e);
  };
  img.src = url;
});
const createPosterWrapperView = (_2) => {
  const overlay = createPosterOverlayView(_2);
  const didCreatePreviewContainer = ({ root: root2, props }) => {
    const { id } = props;
    const item2 = root2.query("GET_ITEM", id);
    if (!item2)
      return;
    const fileURL = item2.getMetadata("poster");
    const previewImageLoaded = (data2) => {
      const averageColor2 = root2.query(
        "GET_FILE_POSTER_CALCULATE_AVERAGE_IMAGE_COLOR"
      ) ? calculateAverageColor(data2) : null;
      item2.setMetadata("color", averageColor2, true);
      root2.dispatch("DID_FILE_POSTER_LOAD", {
        id,
        data: data2
      });
    };
    getImageSize(fileURL, (width2, height2) => {
      root2.dispatch("DID_FILE_POSTER_CALCULATE_SIZE", {
        id,
        width: width2,
        height: height2
      });
      loadImage(
        fileURL,
        root2.query("GET_FILE_POSTER_CROSS_ORIGIN_ATTRIBUTE_VALUE")
      ).then(previewImageLoaded);
    });
  };
  const didLoadPreview = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 1;
  };
  const didDrawPreview = ({ root: root2 }) => {
    const { image } = root2.ref;
    image.scaleX = 1;
    image.scaleY = 1;
    image.opacity = 1;
  };
  const restoreOverlay = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 1;
    root2.ref.overlayError.opacity = 0;
    root2.ref.overlaySuccess.opacity = 0;
  };
  const didThrowError = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlayError.opacity = 1;
  };
  const didCompleteProcessing = ({ root: root2 }) => {
    root2.ref.overlayShadow.opacity = 0.25;
    root2.ref.overlaySuccess.opacity = 1;
  };
  const create2 = ({ root: root2, props }) => {
    const itemShadowColorProp = root2.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_SHADOW_COLOR"
    );
    const itemErrorColorProp = root2.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_ERROR_COLOR"
    );
    const itemSuccessColorProp = root2.query(
      "GET_FILE_POSTER_ITEM_OVERLAY_SUCCESS_COLOR"
    );
    if (itemShadowColorProp && itemShadowColorProp !== itemShadowColor) {
      itemShadowColor = itemShadowColorProp;
      drawTemplate(overlayTemplateShadow, width, height, itemShadowColor, 0.85);
    }
    if (itemErrorColorProp && itemErrorColorProp !== itemErrorColor) {
      itemErrorColor = itemErrorColorProp;
      drawTemplate(overlayTemplateError, width, height, itemErrorColor, 1);
    }
    if (itemSuccessColorProp && itemSuccessColorProp !== itemSuccessColor) {
      itemSuccessColor = itemSuccessColorProp;
      drawTemplate(overlayTemplateSuccess, width, height, itemSuccessColor, 1);
    }
    const image = createPosterView(_2);
    root2.ref.image = root2.appendChildView(
      root2.createChildView(image, {
        id: props.id,
        scaleX: 1.25,
        scaleY: 1.25,
        opacity: 0
      })
    );
    root2.ref.overlayShadow = root2.appendChildView(
      root2.createChildView(overlay, {
        template: overlayTemplateShadow,
        opacity: 0
      })
    );
    root2.ref.overlaySuccess = root2.appendChildView(
      root2.createChildView(overlay, {
        template: overlayTemplateSuccess,
        opacity: 0
      })
    );
    root2.ref.overlayError = root2.appendChildView(
      root2.createChildView(overlay, {
        template: overlayTemplateError,
        opacity: 0
      })
    );
  };
  return _2.utils.createView({
    name: "file-poster-wrapper",
    create: create2,
    write: _2.utils.createRoute({
      // image preview stated
      DID_FILE_POSTER_LOAD: didLoadPreview,
      DID_FILE_POSTER_DRAW: didDrawPreview,
      DID_FILE_POSTER_CONTAINER_CREATE: didCreatePreviewContainer,
      // file states
      DID_THROW_ITEM_LOAD_ERROR: didThrowError,
      DID_THROW_ITEM_PROCESSING_ERROR: didThrowError,
      DID_THROW_ITEM_INVALID: didThrowError,
      DID_COMPLETE_ITEM_PROCESSING: didCompleteProcessing,
      DID_START_ITEM_PROCESSING: restoreOverlay,
      DID_REVERT_ITEM_PROCESSING: restoreOverlay
    })
  });
};
const plugin = (fpAPI) => {
  const { addFilter: addFilter2, utils: utils2 } = fpAPI;
  const { Type: Type2, createRoute: createRoute2 } = utils2;
  const filePosterView = createPosterWrapperView(fpAPI);
  addFilter2("CREATE_VIEW", (viewAPI) => {
    const { is, view, query } = viewAPI;
    if (!is("file") || !query("GET_ALLOW_FILE_POSTER"))
      return;
    const didLoadItem2 = ({ root: root2, props }) => {
      updateItemPoster(root2, props);
    };
    const didUpdateItemMetadata = ({ root: root2, props, action }) => {
      if (!/poster/.test(action.change.key))
        return;
      updateItemPoster(root2, props);
    };
    const updateItemPoster = (root2, props) => {
      const { id } = props;
      const item2 = query("GET_ITEM", id);
      if (!item2 || !item2.getMetadata("poster") || item2.archived)
        return;
      if (root2.ref.previousPoster === item2.getMetadata("poster"))
        return;
      root2.ref.previousPoster = item2.getMetadata("poster");
      if (!query("GET_FILE_POSTER_FILTER_ITEM")(item2))
        return;
      if (root2.ref.filePoster) {
        view.removeChildView(root2.ref.filePoster);
      }
      root2.ref.filePoster = view.appendChildView(
        view.createChildView(filePosterView, { id })
      );
      root2.dispatch("DID_FILE_POSTER_CONTAINER_CREATE", { id });
    };
    const didCalculatePreviewSize = ({ root: root2, action }) => {
      if (!root2.ref.filePoster)
        return;
      root2.ref.imageWidth = action.width;
      root2.ref.imageHeight = action.height;
      root2.ref.shouldUpdatePanelHeight = true;
      root2.dispatch("KICK");
    };
    const getPosterHeight = ({ root: root2 }) => {
      let fixedPosterHeight = root2.query("GET_FILE_POSTER_HEIGHT");
      if (fixedPosterHeight) {
        return fixedPosterHeight;
      }
      const minPosterHeight = root2.query("GET_FILE_POSTER_MIN_HEIGHT");
      const maxPosterHeight = root2.query("GET_FILE_POSTER_MAX_HEIGHT");
      if (minPosterHeight && root2.ref.imageHeight < minPosterHeight) {
        return minPosterHeight;
      }
      let height2 = root2.rect.element.width * (root2.ref.imageHeight / root2.ref.imageWidth);
      if (minPosterHeight && height2 < minPosterHeight) {
        return minPosterHeight;
      }
      if (maxPosterHeight && height2 > maxPosterHeight) {
        return maxPosterHeight;
      }
      return height2;
    };
    view.registerWriter(
      createRoute2(
        {
          DID_LOAD_ITEM: didLoadItem2,
          DID_FILE_POSTER_CALCULATE_SIZE: didCalculatePreviewSize,
          DID_UPDATE_ITEM_METADATA: didUpdateItemMetadata
        },
        ({ root: root2, props }) => {
          if (!root2.ref.filePoster)
            return;
          if (root2.rect.element.hidden)
            return;
          if (root2.ref.shouldUpdatePanelHeight) {
            root2.dispatch("DID_UPDATE_PANEL_HEIGHT", {
              id: props.id,
              height: getPosterHeight({ root: root2 })
            });
            root2.ref.shouldUpdatePanelHeight = false;
          }
        }
      )
    );
  });
  return {
    options: {
      // Enable or disable file poster
      allowFilePoster: [true, Type2.BOOLEAN],
      // Fixed preview height
      filePosterHeight: [null, Type2.INT],
      // Min image height
      filePosterMinHeight: [null, Type2.INT],
      // Max image height
      filePosterMaxHeight: [null, Type2.INT],
      // filters file items to determine which are shown as poster
      filePosterFilterItem: [() => true, Type2.FUNCTION],
      // Enables or disables reading average image color
      filePosterCalculateAverageImageColor: [false, Type2.BOOLEAN],
      // Allows setting the value of the CORS attribute (null is don't set attribute)
      filePosterCrossOriginAttributeValue: ["Anonymous", Type2.STRING],
      // Colors used for item overlay gradient
      filePosterItemOverlayShadowColor: [null, Type2.ARRAY],
      filePosterItemOverlayErrorColor: [null, Type2.ARRAY],
      filePosterItemOverlaySuccessColor: [null, Type2.ARRAY]
    }
  };
};
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
if (isBrowser) {
  document.dispatchEvent(
    new CustomEvent("FilePond:pluginloaded", { detail: plugin })
  );
}
const filepond = "";
const filepondPluginImagePreview = "";
function bind(fn3, thisArg) {
  return function wrap() {
    return fn3.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn3, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn3.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn3.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn3) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn3.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$1 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option2, source) {
    return !utils.isUndefined(source[option2]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn3) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn3(h);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data2);
    if (isObjectPayload && utils.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils.isFormData(data2);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data2;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils.isArrayBuffer(data2) || utils.isBuffer(data2) || utils.isStream(data2) || utils.isFile(data2) || utils.isBlob(data2)) {
      return data2;
    }
    if (utils.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data2 && utils.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data2 = context.data;
  utils.forEach(fns, function transform(fn3) {
    data2 = fn3.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write2(name2, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value));
        if (utils.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e
    };
    data2[isDownloadStream ? "download" : "upload"] = true;
    listener(data2);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn3, value) => {
  if (fn3) {
    try {
      Object.defineProperty(fn3, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn3, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION$1 = "1.3.5";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i < len) {
        promise = promise.then(chain2[i++], chain2[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
window._ = _;
window.axios = axios$1;
window.$ = window.jQuery = $$1;
window.tinymce = tinymce$1;
window.FilePond = FilePond;
window.bootstrap = bootstrap;
registerPlugin(
  plugin$1,
  plugin$4,
  // validates the size of the file
  // FilePondPluginFileValidateSize,
  // corrects mobile image orientation
  plugin$6,
  plugin,
  // previews dropped images
  plugin$7
);
window.axios.defaults.headers.common["X-Requested-With"] = "XMLHttpRequest";
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name2) {
    var style = state2.styles[name2] || {};
    var attributes = state2.attributes[name2] || {};
    var element = state2.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name2) {
      var element = state2.elements[name2];
      var attributes = state2.attributes[name2] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item2) {
      return item2.brand + "/" + item2.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height2 = clientRect.height / scaleY;
  return {
    width: width2,
    height: height2,
    top: y,
    right: x + width2,
    bottom: y + height2,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width2 = element.offsetWidth;
  var height2 = element.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height2) <= 1) {
    height2 = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width2,
    height: height2
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center2 = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center2, max2);
  var axisProp = axis;
  state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center2, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height2 = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height2 = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height: height2,
    x: x + getWindowScrollBarX(element),
    y
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height: height2,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state2.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name2]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x;
    state2.modifiersData.popperOffsets.y += y;
  }
  state2.modifiersData[name2] = data2;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  state2.modifiersData[name2] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name2] = data2;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions2(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options2);
        state2.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state2.orderedModifiers.length; index++) {
          if (state2.reset === true) {
            state2.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state2 = fn3({
              state: state2,
              options: _options,
              name: name2,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state3) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper$2 = /* @__PURE__ */ popperGenerator();
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers$1
});
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const Popper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain,
  afterRead,
  afterWrite,
  applyStyles: applyStyles$1,
  arrow: arrow$1,
  auto,
  basePlacements,
  beforeMain,
  beforeRead,
  beforeWrite,
  bottom,
  clippingParents,
  computeStyles: computeStyles$1,
  createPopper,
  createPopperBase: createPopper$2,
  createPopperLite: createPopper$1,
  detectOverflow,
  end,
  eventListeners,
  flip: flip$1,
  hide: hide$1,
  left,
  main,
  modifierPhases,
  offset: offset$1,
  placements,
  popper,
  popperGenerator,
  popperOffsets: popperOffsets$1,
  preventOverflow: preventOverflow$1,
  read,
  reference,
  right,
  start,
  top,
  variationPlacements,
  viewport,
  write
}, Symbol.toStringTag, { value: "Module" }));
/*!
  * Bootstrap v5.3.0-alpha3 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const elementMap = /* @__PURE__ */ new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, /* @__PURE__ */ new Map());
    }
    const instanceMap = elementMap.get(element);
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};
const MAX_UID = 1e6;
const MILLISECONDS_MULTIPLIER = 1e3;
const TRANSITION_END = "transitionend";
const parseSelector = (selector) => {
  if (selector && window.CSS && window.CSS.escape) {
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};
const toType = (object) => {
  if (object === null || object === void 0) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
const getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
const getTransitionDurationFromElement = (element) => {
  if (!element) {
    return 0;
  }
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element) => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (object) => {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (typeof object.jquery !== "undefined") {
    object = object[0];
  }
  return typeof object.nodeType !== "undefined";
};
const getElement = (object) => {
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === "string" && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
const isVisible = (element) => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
  const closedDetails = element.closest("details:not([open])");
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest("summary");
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
const isDisabled = (element) => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains("disabled")) {
    return true;
  }
  if (typeof element.disabled !== "undefined") {
    return element.disabled;
  }
  return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
const findShadowRoot = (element) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element.getRootNode === "function") {
    const root2 = element.getRootNode();
    return root2 instanceof ShadowRoot ? root2 : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
const noop = () => {
};
const reflow = (element) => {
  element.offsetHeight;
};
const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
    return window.jQuery;
  }
  return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        for (const callback2 of DOMContentLoadedCallbacks) {
          callback2();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
const isRTL = () => document.documentElement.dir === "rtl";
const defineJQueryPlugin = (plugin2) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery();
    if ($2) {
      const name2 = plugin2.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name2];
      $2.fn[name2] = plugin2.jQueryInterface;
      $2.fn[name2].Constructor = plugin2;
      $2.fn[name2].noConflict = () => {
        $2.fn[name2] = JQUERY_NO_CONFLICT;
        return plugin2.jQueryInterface;
      };
    }
  });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
const getNextActiveElement = (list2, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list2.length;
  let index = list2.indexOf(activeElement);
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list2[listLength - 1] : list2[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list2[Math.max(0, Math.min(index, listLength - 1))];
};
const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {};
let uidEvent = 1;
const customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
const nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn3) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn3);
    }
    return fn3.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn3) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn3);
        }
        return fn3.apply(target, [event]);
      }
    }
  };
}
function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === "string";
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
  if (originalTypeEvent in customEvents) {
    const wrapFunction = (fn4) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn4.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
  const fn3 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn3.delegationSelector = isDelegated ? handler : null;
  fn3.callable = callable;
  fn3.oneOff = oneOff;
  fn3.uidEvent = uid;
  handlers[uid] = fn3;
  element.addEventListener(typeEvent, fn3, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn3 = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn3) {
    return;
  }
  element.removeEventListener(typeEvent, fn3, Boolean(delegationSelector));
  delete events[typeEvent][fn3.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
}
const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof callable !== "undefined") {
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== "string" || !element) {
      return null;
    }
    const $2 = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $2) {
      jQueryEvent = $2.Event(event, args);
      $2(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}
function normalizeData(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === "" || value === "null") {
    return null;
  }
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};
class Config {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    return config;
  }
  _mergeConfigObj(config, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof jsonConfig === "object" ? jsonConfig : {},
      ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
      ...typeof config === "object" ? config : {}
    };
  }
  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config[property];
      const valueType = isElement(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}
const VERSION = "5.3.0-alpha2";
class BaseComponent extends Config {
  constructor(element, config) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }
  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config, this._element);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name2) {
    return `${name2}${this.EVENT_KEY}`;
  }
}
const getSelector = (element) => {
  let selector = element.getAttribute("data-bs-target");
  if (!selector || selector === "#") {
    let hrefAttribute = element.getAttribute("href");
    if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
      return null;
    }
    if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
      hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
  }
  return parseSelector(selector);
};
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter((child) => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
    return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};
const enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name2 = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name2}"]`, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name2}`);
    const instance = component.getOrCreateInstance(target);
    instance[method]();
  });
};
const NAME$f = "alert";
const DATA_KEY$a = "bs.alert";
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = "fade";
const CLASS_NAME_SHOW$8 = "show";
class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }
  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }
  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Alert.getOrCreateInstance(this);
      if (typeof config !== "string") {
        return;
      }
      if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config](this);
    });
  }
}
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
const NAME$e = "button";
const DATA_KEY$9 = "bs.button";
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = ".data-api";
const CLASS_NAME_ACTIVE$3 = "active";
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Button.getOrCreateInstance(this);
      if (config === "toggle") {
        data2[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data2 = Button.getOrCreateInstance(button);
  data2.toggle();
});
defineJQueryPlugin(Button);
const NAME$d = "swipe";
const EVENT_KEY$9 = ".bs.swipe";
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = "touch";
const POINTER_TYPE_PEN = "pen";
const CLASS_NAME_POINTER_EVENT = "pointer-event";
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
class Swipe extends Config {
  constructor(element, config) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }
  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }
  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }
  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
}
const NAME$c = "carousel";
const DATA_KEY$8 = "bs.carousel";
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = ".data-api";
const ARROW_LEFT_KEY$1 = "ArrowLeft";
const ARROW_RIGHT_KEY$1 = "ArrowRight";
const TOUCHEVENT_COMPAT_WAIT = 500;
const ORDER_NEXT = "next";
const ORDER_PREV = "prev";
const DIRECTION_LEFT = "left";
const DIRECTION_RIGHT = "right";
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = "carousel";
const CLASS_NAME_ACTIVE$2 = "active";
const CLASS_NAME_SLIDE = "slide";
const CLASS_NAME_END = "carousel-item-end";
const CLASS_NAME_START = "carousel-item-start";
const CLASS_NAME_NEXT = "carousel-item-next";
const CLASS_NAME_PREV = "carousel-item-prev";
const SELECTOR_ACTIVE = ".active";
const SELECTOR_ITEM = ".carousel-item";
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = ".carousel-item img";
const SELECTOR_INDICATORS = ".carousel-indicators";
const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5e3,
  keyboard: true,
  pause: "hover",
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }
  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }
  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }
  // Private
  _configAfterMerge(config) {
    config.defaultInterval = config.interval;
    return config;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
    }
    if (this._config.pause === "hover") {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== "hover") {
        return;
      }
      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute("aria-current");
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute("aria-current", "true");
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order2, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order2 === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = (eventName) => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order2),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Carousel.getOrCreateInstance(this, config);
      if (typeof config === "number") {
        data2.to(config);
        return;
      }
      if (typeof config === "string") {
        if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data2[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute("data-bs-slide-to");
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, "slide") === "next") {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
defineJQueryPlugin(Carousel);
const NAME$b = "collapse";
const DATA_KEY$7 = "bs.collapse";
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = ".data-api";
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = "show";
const CLASS_NAME_COLLAPSE = "collapse";
const CLASS_NAME_COLLAPSING = "collapsing";
const CLASS_NAME_COLLAPSED = "collapsed";
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
const WIDTH = "width";
const HEIGHT = "height";
const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: "(null|element)",
  toggle: "boolean"
};
class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }
  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = "";
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  // Private
  _configAfterMerge(config) {
    config.toggle = Boolean(config.toggle);
    config.parent = getElement(config.parent);
    return config;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute("aria-expanded", isOpen);
    }
  }
  // Static
  static jQueryInterface(config) {
    const _config = {};
    if (typeof config === "string" && /show|hide/.test(config)) {
      _config.toggle = false;
    }
    return this.each(function() {
      const data2 = Collapse.getOrCreateInstance(this, _config);
      if (typeof config === "string") {
        if (typeof data2[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data2[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
  if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
defineJQueryPlugin(Collapse);
const NAME$a = "dropdown";
const DATA_KEY$6 = "bs.dropdown";
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = ".data-api";
const ESCAPE_KEY$2 = "Escape";
const TAB_KEY$1 = "Tab";
const ARROW_UP_KEY$1 = "ArrowUp";
const ARROW_DOWN_KEY$1 = "ArrowDown";
const RIGHT_MOUSE_BUTTON = 2;
const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = "show";
const CLASS_NAME_DROPUP = "dropup";
const CLASS_NAME_DROPEND = "dropend";
const CLASS_NAME_DROPSTART = "dropstart";
const CLASS_NAME_DROPUP_CENTER = "dropup-center";
const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = ".dropdown-menu";
const SELECTOR_NAVBAR = ".navbar";
const SELECTOR_NAVBAR_NAV = ".navbar-nav";
const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
const PLACEMENT_TOPCENTER = "top";
const PLACEMENT_BOTTOMCENTER = "bottom";
const Default$9 = {
  autoClose: true,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
};
const DefaultType$9 = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._popper = null;
    this._parent = this._element.parentNode;
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();
    if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute("aria-expanded", "false");
    Manipulator.removeDataAttribute(this._menu, "popper");
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config) {
    config = super._getConfig(config);
    if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config;
  }
  _createPopper() {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = createPopper(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }]
    };
    if (this._inNavbar || this._config.display === "static") {
      Manipulator.setDataAttribute(this._menu, "popper", "static");
      defaultBsPopperConfig.modifiers = [{
        name: "applyStyles",
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
    if (!items.length) {
      return;
    }
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Dropdown.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data2[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
        continue;
      }
      if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === "click") {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
defineJQueryPlugin(Dropdown);
const NAME$9 = "backdrop";
const CLASS_NAME_FADE$4 = "fade";
const CLASS_NAME_SHOW$5 = "show";
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
class Backdrop extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }
  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }
  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config) {
    config.rootElement = getElement(config.rootElement);
    return config;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}
const NAME$8 = "focustrap";
const DATA_KEY$5 = "bs.focustrap";
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = "Tab";
const TAB_NAV_FORWARD = "forward";
const TAB_NAV_BACKWARD = "backward";
const Default$7 = {
  autofocus: true,
  trapElement: null
  // The element to trap focus inside of
};
const DefaultType$7 = {
  autofocus: "boolean",
  trapElement: "element"
};
class FocusTrap extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }
  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5);
    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }
  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
}
const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
const SELECTOR_STICKY_CONTENT = ".sticky-top";
const PROPERTY_PADDING = "padding-right";
const PROPERTY_MARGIN = "margin-right";
class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width2 = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width2);
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width2);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width2);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element) => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = (element) => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}
const NAME$7 = "modal";
const DATA_KEY$4 = "bs.modal";
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = ".data-api";
const ESCAPE_KEY$1 = "Escape";
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = "modal-open";
const CLASS_NAME_FADE$3 = "fade";
const CLASS_NAME_SHOW$4 = "show";
const CLASS_NAME_STATIC = "modal-static";
const OPEN_SELECTOR$1 = ".modal.show";
const SELECTOR_DIALOG = ".modal-dialog";
const SELECTOR_MODAL_BODY = ".modal-body";
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
class Modal extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? "paddingLeft" : "paddingRight";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? "paddingRight" : "paddingLeft";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(config, relatedTarget) {
    return this.each(function() {
      const data2 = Modal.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data2[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config](relatedTarget);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
    if (showEvent.defaultPrevented) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data2 = Modal.getOrCreateInstance(target);
  data2.toggle(this);
});
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
const NAME$6 = "offcanvas";
const DATA_KEY$3 = "bs.offcanvas";
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = ".data-api";
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = "Escape";
const CLASS_NAME_SHOW$3 = "show";
const CLASS_NAME_SHOWING$1 = "showing";
const CLASS_NAME_HIDING = "hiding";
const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
const OPEN_SELECTOR = ".offcanvas.show";
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === "static") {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };
    const isVisible2 = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: isVisible2,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible2 ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Offcanvas.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config](this);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    if (isVisible(this)) {
      this.focus();
    }
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data2 = Offcanvas.getOrCreateInstance(target);
  data2.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
    if (getComputedStyle(element).position !== "fixed") {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
const uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }
  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === "function") {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}
const NAME$5 = "TemplateFactory";
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: "<div></div>"
};
const DefaultType$4 = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
};
const DefaultContentType = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
class TemplateFactory extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
  }
  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement("div");
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text2] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text2, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(" "));
    }
    return template;
  }
  // Private
  _typeCheckConfig(config) {
    super._typeCheckConfig(config);
    this._checkContent(config.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = "";
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}
const NAME$4 = "tooltip";
const DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
const CLASS_NAME_FADE$2 = "fade";
const CLASS_NAME_MODAL = "modal";
const CLASS_NAME_SHOW$2 = "show";
const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = "hide.bs.modal";
const TRIGGER_HOVER = "hover";
const TRIGGER_FOCUS = "focus";
const TRIGGER_CLICK = "click";
const TRIGGER_MANUAL = "manual";
const EVENT_HIDE$2 = "hide";
const EVENT_HIDDEN$2 = "hidden";
const EVENT_SHOW$2 = "show";
const EVENT_SHOWN$2 = "shown";
const EVENT_INSERTED = "inserted";
const EVENT_CLICK$1 = "click";
const EVENT_FOCUSIN$1 = "focusin";
const EVENT_FOCUSOUT$1 = "focusout";
const EVENT_MOUSEENTER = "mouseenter";
const EVENT_MOUSELEAVE = "mouseleave";
const AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: "clippingParents",
  container: false,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: false,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
};
const DefaultType$3 = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    }
    super(element, config);
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }
  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }
  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute("data-bs-original-title")) {
      this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null;
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute("aria-describedby");
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }
  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute("id", tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return createPopper(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: "flip",
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }, {
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "arrow",
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: "preSetPlacement",
        enabled: true,
        phase: "beforeMain",
        fn: (data2) => {
          this._getTipElement().setAttribute("data-popper-placement", data2.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    for (const trigger of triggers) {
      if (trigger === "click") {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    if (!title) {
      return;
    }
    if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
      this._element.setAttribute("aria-label", title);
    }
    this._element.setAttribute("data-bs-original-title", title);
    this._element.removeAttribute("title");
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config = {
      ...dataAttributes,
      ...typeof config === "object" && config ? config : {}
    };
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    config.container = config.container === false ? document.body : getElement(config.container);
    if (typeof config.delay === "number") {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }
    if (typeof config.title === "number") {
      config.title = config.title.toString();
    }
    if (typeof config.content === "number") {
      config.content = config.content.toString();
    }
    return config;
  }
  _getDelegateConfig() {
    const config = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config[key] = value;
      }
    }
    config.selector = false;
    config.trigger = "manual";
    return config;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Tooltip.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data2[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config]();
    });
  }
}
defineJQueryPlugin(Tooltip);
const NAME$3 = "popover";
const SELECTOR_TITLE = ".popover-header";
const SELECTOR_CONTENT = ".popover-body";
const Default$2 = {
  ...Tooltip.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
};
const DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: "(null|string|element|function)"
};
class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Popover.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data2[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config]();
    });
  }
}
defineJQueryPlugin(Popover);
const NAME$2 = "scrollspy";
const DATA_KEY$2 = "bs.scrollspy";
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = ".data-api";
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
const CLASS_NAME_ACTIVE$1 = "active";
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = "[href]";
const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
const SELECTOR_NAV_LINKS = ".nav-link";
const SELECTOR_NAV_ITEMS = ".nav-item";
const SELECTOR_LIST_ITEMS = ".list-group-item";
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = ".dropdown";
const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
const DefaultType$1 = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh();
  }
  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }
  // Private
  _configAfterMerge(config) {
    config.target = getElement(config.target) || document.body;
    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
    if (typeof config.threshold === "string") {
      config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
    }
    return config;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root2 = this._rootElement || window;
        const height2 = observableSection.offsetTop - this._element.offsetTop;
        if (root2.scrollTo) {
          root2.scrollTo({
            top: height2,
            behavior: "smooth"
          });
          return;
        }
        root2.scrollTop = height2;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((entries) => this._observerCallback(entries), options);
  }
  // The logic of selection
  _observerCallback(entries) {
    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
    const activate = (entry) => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        if (!parentScrollTop) {
          return;
        }
        continue;
      }
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(anchor.hash, this._element);
      if (isVisible(observableSection)) {
        this._targetLinks.set(anchor.hash, anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      for (const item2 of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item2.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = ScrollSpy.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config]();
    });
  }
}
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
defineJQueryPlugin(ScrollSpy);
const NAME$1 = "tab";
const DATA_KEY$1 = "bs.tab";
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = "ArrowLeft";
const ARROW_RIGHT_KEY = "ArrowRight";
const ARROW_UP_KEY = "ArrowUp";
const ARROW_DOWN_KEY = "ArrowDown";
const CLASS_NAME_ACTIVE = "active";
const CLASS_NAME_FADE$1 = "fade";
const CLASS_NAME_SHOW$1 = "show";
const CLASS_DROPDOWN = "dropdown";
const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
const NOT_SELECTOR_DROPDOWN_TOGGLE = ":not(.dropdown-toggle)";
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = ".nav-item, .list-group-item";
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
    }
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
  }
  // Getters
  static get NAME() {
    return NAME$1;
  }
  // Public
  show() {
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }
  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute("tabindex");
      element.setAttribute("aria-selected", true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute("aria-selected", false);
      element.setAttribute("tabindex", "-1");
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
    const nextActiveElement = getNextActiveElement(this._getChildren().filter((element) => !isDisabled(element)), event.target, isNext, true);
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((child) => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, "role", "tablist");
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute("aria-selected", isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, "role", "presentation");
    }
    if (!isActive) {
      child.setAttribute("tabindex", "-1");
    }
    this._setAttributeIfNotExists(child, "role", "tab");
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, "role", "tabpanel");
    if (child.id) {
      this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element2 = SelectorEngine.findOne(selector, outerElem);
      if (element2) {
        element2.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute("aria-expanded", open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Tab.getOrCreateInstance(this);
      if (typeof config !== "string") {
        return;
      }
      if (data2[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data2[config]();
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
defineJQueryPlugin(Tab);
const NAME = "toast";
const DATA_KEY = "bs.toast";
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = "fade";
const CLASS_NAME_HIDE = "hide";
const CLASS_NAME_SHOW = "show";
const CLASS_NAME_SHOWING = "showing";
const DefaultType = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5e3
};
class Toast extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }
  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE);
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE);
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }
  // Private
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = isInteracting;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = isInteracting;
        break;
      }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data2 = Toast.getOrCreateInstance(this, config);
      if (typeof config === "string") {
        if (typeof data2[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data2[config](this);
      }
    });
  }
}
enableDismissTrigger(Toast);
defineJQueryPlugin(Toast);
(function($2, window2, document2, undefined$1) {
  function Owl(element, options) {
    this.settings = null;
    this.options = $2.extend({}, Owl.Defaults, options);
    this.$element = $2(element);
    this._handlers = {};
    this._plugins = {};
    this._supress = {};
    this._current = null;
    this._speed = null;
    this._coordinates = [];
    this._breakpoint = null;
    this._width = null;
    this._items = [];
    this._clones = [];
    this._mergers = [];
    this._widths = [];
    this._invalidated = {};
    this._pipe = [];
    this._drag = {
      time: null,
      target: null,
      pointer: null,
      stage: {
        start: null,
        current: null
      },
      direction: null
    };
    this._states = {
      current: {},
      tags: {
        "initializing": ["busy"],
        "animating": ["busy"],
        "dragging": ["interacting"]
      }
    };
    $2.each(["onResize", "onThrottledResize"], $2.proxy(function(i, handler) {
      this._handlers[handler] = $2.proxy(this[handler], this);
    }, this));
    $2.each(Owl.Plugins, $2.proxy(function(key, plugin2) {
      this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin2(this);
    }, this));
    $2.each(Owl.Workers, $2.proxy(function(priority, worker) {
      this._pipe.push({
        "filter": worker.filter,
        "run": $2.proxy(worker.run, this)
      });
    }, this));
    this.setup();
    this.initialize();
  }
  Owl.Defaults = {
    items: 3,
    loop: false,
    center: false,
    rewind: false,
    checkVisibility: true,
    mouseDrag: true,
    touchDrag: true,
    pullDrag: true,
    freeDrag: false,
    margin: 0,
    stagePadding: 0,
    merge: false,
    mergeFit: true,
    autoWidth: false,
    startPosition: 0,
    rtl: false,
    smartSpeed: 250,
    fluidSpeed: false,
    dragEndSpeed: false,
    responsive: {},
    responsiveRefreshRate: 200,
    responsiveBaseElement: window2,
    fallbackEasing: "swing",
    slideTransition: "",
    info: false,
    nestedItemSelector: false,
    itemElement: "div",
    stageElement: "div",
    refreshClass: "owl-refresh",
    loadedClass: "owl-loaded",
    loadingClass: "owl-loading",
    rtlClass: "owl-rtl",
    responsiveClass: "owl-responsive",
    dragClass: "owl-drag",
    itemClass: "owl-item",
    stageClass: "owl-stage",
    stageOuterClass: "owl-stage-outer",
    grabClass: "owl-grab"
  };
  Owl.Width = {
    Default: "default",
    Inner: "inner",
    Outer: "outer"
  };
  Owl.Type = {
    Event: "event",
    State: "state"
  };
  Owl.Plugins = {};
  Owl.Workers = [{
    filter: ["width", "settings"],
    run: function() {
      this._width = this.$element.width();
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function(cache) {
      cache.current = this._items && this._items[this.relative(this._current)];
    }
  }, {
    filter: ["items", "settings"],
    run: function() {
      this.$stage.children(".cloned").remove();
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function(cache) {
      var margin = this.settings.margin || "", grid = !this.settings.autoWidth, rtl = this.settings.rtl, css = {
        "width": "auto",
        "margin-left": rtl ? margin : "",
        "margin-right": rtl ? "" : margin
      };
      !grid && this.$stage.children().css(css);
      cache.css = css;
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function(cache) {
      var width2 = (this.width() / this.settings.items).toFixed(3) - this.settings.margin, merge2 = null, iterator = this._items.length, grid = !this.settings.autoWidth, widths = [];
      cache.items = {
        merge: false,
        width: width2
      };
      while (iterator--) {
        merge2 = this._mergers[iterator];
        merge2 = this.settings.mergeFit && Math.min(merge2, this.settings.items) || merge2;
        cache.items.merge = merge2 > 1 || cache.items.merge;
        widths[iterator] = !grid ? this._items[iterator].width() : width2 * merge2;
      }
      this._widths = widths;
    }
  }, {
    filter: ["items", "settings"],
    run: function() {
      var clones = [], items = this._items, settings = this.settings, view = Math.max(settings.items * 2, 4), size = Math.ceil(items.length / 2) * 2, repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0, append2 = "", prepend = "";
      repeat /= 2;
      while (repeat > 0) {
        clones.push(this.normalize(clones.length / 2, true));
        append2 = append2 + items[clones[clones.length - 1]][0].outerHTML;
        clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
        prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
        repeat -= 1;
      }
      this._clones = clones;
      $2(append2).addClass("cloned").appendTo(this.$stage);
      $2(prepend).addClass("cloned").prependTo(this.$stage);
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function() {
      var rtl = this.settings.rtl ? 1 : -1, size = this._clones.length + this._items.length, iterator = -1, previous = 0, current = 0, coordinates = [];
      while (++iterator < size) {
        previous = coordinates[iterator - 1] || 0;
        current = this._widths[this.relative(iterator)] + this.settings.margin;
        coordinates.push(previous + current * rtl);
      }
      this._coordinates = coordinates;
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function() {
      var padding = this.settings.stagePadding, coordinates = this._coordinates, css = {
        "width": Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
        "padding-left": padding || "",
        "padding-right": padding || ""
      };
      this.$stage.css(css);
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function(cache) {
      var iterator = this._coordinates.length, grid = !this.settings.autoWidth, items = this.$stage.children();
      if (grid && cache.items.merge) {
        while (iterator--) {
          cache.css.width = this._widths[this.relative(iterator)];
          items.eq(iterator).css(cache.css);
        }
      } else if (grid) {
        cache.css.width = cache.items.width;
        items.css(cache.css);
      }
    }
  }, {
    filter: ["items"],
    run: function() {
      this._coordinates.length < 1 && this.$stage.removeAttr("style");
    }
  }, {
    filter: ["width", "items", "settings"],
    run: function(cache) {
      cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
      cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
      this.reset(cache.current);
    }
  }, {
    filter: ["position"],
    run: function() {
      this.animate(this.coordinates(this._current));
    }
  }, {
    filter: ["width", "position", "items", "settings"],
    run: function() {
      var rtl = this.settings.rtl ? 1 : -1, padding = this.settings.stagePadding * 2, begin = this.coordinates(this.current()) + padding, end2 = begin + this.width() * rtl, inner, outer, matches = [], i, n;
      for (i = 0, n = this._coordinates.length; i < n; i++) {
        inner = this._coordinates[i - 1] || 0;
        outer = Math.abs(this._coordinates[i]) + padding * rtl;
        if (this.op(inner, "<=", begin) && this.op(inner, ">", end2) || this.op(outer, "<", begin) && this.op(outer, ">", end2)) {
          matches.push(i);
        }
      }
      this.$stage.children(".active").removeClass("active");
      this.$stage.children(":eq(" + matches.join("), :eq(") + ")").addClass("active");
      this.$stage.children(".center").removeClass("center");
      if (this.settings.center) {
        this.$stage.children().eq(this.current()).addClass("center");
      }
    }
  }];
  Owl.prototype.initializeStage = function() {
    this.$stage = this.$element.find("." + this.settings.stageClass);
    if (this.$stage.length) {
      return;
    }
    this.$element.addClass(this.options.loadingClass);
    this.$stage = $2("<" + this.settings.stageElement + ">", {
      "class": this.settings.stageClass
    }).wrap($2("<div/>", {
      "class": this.settings.stageOuterClass
    }));
    this.$element.append(this.$stage.parent());
  };
  Owl.prototype.initializeItems = function() {
    var $items = this.$element.find(".owl-item");
    if ($items.length) {
      this._items = $items.get().map(function(item2) {
        return $2(item2);
      });
      this._mergers = this._items.map(function() {
        return 1;
      });
      this.refresh();
      return;
    }
    this.replace(this.$element.children().not(this.$stage.parent()));
    if (this.isVisible()) {
      this.refresh();
    } else {
      this.invalidate("width");
    }
    this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);
  };
  Owl.prototype.initialize = function() {
    this.enter("initializing");
    this.trigger("initialize");
    this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);
    if (this.settings.autoWidth && !this.is("pre-loading")) {
      var imgs, nestedSelector, width2;
      imgs = this.$element.find("img");
      nestedSelector = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : undefined$1;
      width2 = this.$element.children(nestedSelector).width();
      if (imgs.length && width2 <= 0) {
        this.preloadAutoWidthImages(imgs);
      }
    }
    this.initializeStage();
    this.initializeItems();
    this.registerEventHandlers();
    this.leave("initializing");
    this.trigger("initialized");
  };
  Owl.prototype.isVisible = function() {
    return this.settings.checkVisibility ? this.$element.is(":visible") : true;
  };
  Owl.prototype.setup = function() {
    var viewport2 = this.viewport(), overwrites = this.options.responsive, match = -1, settings = null;
    if (!overwrites) {
      settings = $2.extend({}, this.options);
    } else {
      $2.each(overwrites, function(breakpoint) {
        if (breakpoint <= viewport2 && breakpoint > match) {
          match = Number(breakpoint);
        }
      });
      settings = $2.extend({}, this.options, overwrites[match]);
      if (typeof settings.stagePadding === "function") {
        settings.stagePadding = settings.stagePadding();
      }
      delete settings.responsive;
      if (settings.responsiveClass) {
        this.$element.attr(
          "class",
          this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\S+\\s", "g"), "$1" + match)
        );
      }
    }
    this.trigger("change", { property: { name: "settings", value: settings } });
    this._breakpoint = match;
    this.settings = settings;
    this.invalidate("settings");
    this.trigger("changed", { property: { name: "settings", value: this.settings } });
  };
  Owl.prototype.optionsLogic = function() {
    if (this.settings.autoWidth) {
      this.settings.stagePadding = false;
      this.settings.merge = false;
    }
  };
  Owl.prototype.prepare = function(item2) {
    var event = this.trigger("prepare", { content: item2 });
    if (!event.data) {
      event.data = $2("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(item2);
    }
    this.trigger("prepared", { content: event.data });
    return event.data;
  };
  Owl.prototype.update = function() {
    var i = 0, n = this._pipe.length, filter2 = $2.proxy(function(p) {
      return this[p];
    }, this._invalidated), cache = {};
    while (i < n) {
      if (this._invalidated.all || $2.grep(this._pipe[i].filter, filter2).length > 0) {
        this._pipe[i].run(cache);
      }
      i++;
    }
    this._invalidated = {};
    !this.is("valid") && this.enter("valid");
  };
  Owl.prototype.width = function(dimension) {
    dimension = dimension || Owl.Width.Default;
    switch (dimension) {
      case Owl.Width.Inner:
      case Owl.Width.Outer:
        return this._width;
      default:
        return this._width - this.settings.stagePadding * 2 + this.settings.margin;
    }
  };
  Owl.prototype.refresh = function() {
    this.enter("refreshing");
    this.trigger("refresh");
    this.setup();
    this.optionsLogic();
    this.$element.addClass(this.options.refreshClass);
    this.update();
    this.$element.removeClass(this.options.refreshClass);
    this.leave("refreshing");
    this.trigger("refreshed");
  };
  Owl.prototype.onThrottledResize = function() {
    window2.clearTimeout(this.resizeTimer);
    this.resizeTimer = window2.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
  };
  Owl.prototype.onResize = function() {
    if (!this._items.length) {
      return false;
    }
    if (this._width === this.$element.width()) {
      return false;
    }
    if (!this.isVisible()) {
      return false;
    }
    this.enter("resizing");
    if (this.trigger("resize").isDefaultPrevented()) {
      this.leave("resizing");
      return false;
    }
    this.invalidate("width");
    this.refresh();
    this.leave("resizing");
    this.trigger("resized");
  };
  Owl.prototype.registerEventHandlers = function() {
    if ($2.support.transition) {
      this.$stage.on($2.support.transition.end + ".owl.core", $2.proxy(this.onTransitionEnd, this));
    }
    if (this.settings.responsive !== false) {
      this.on(window2, "resize", this._handlers.onThrottledResize);
    }
    if (this.settings.mouseDrag) {
      this.$element.addClass(this.options.dragClass);
      this.$stage.on("mousedown.owl.core", $2.proxy(this.onDragStart, this));
      this.$stage.on("dragstart.owl.core selectstart.owl.core", function() {
        return false;
      });
    }
    if (this.settings.touchDrag) {
      this.$stage.on("touchstart.owl.core", $2.proxy(this.onDragStart, this));
      this.$stage.on("touchcancel.owl.core", $2.proxy(this.onDragEnd, this));
    }
  };
  Owl.prototype.onDragStart = function(event) {
    var stage = null;
    if (event.which === 3) {
      return;
    }
    if ($2.support.transform) {
      stage = this.$stage.css("transform").replace(/.*\(|\)| /g, "").split(",");
      stage = {
        x: stage[stage.length === 16 ? 12 : 4],
        y: stage[stage.length === 16 ? 13 : 5]
      };
    } else {
      stage = this.$stage.position();
      stage = {
        x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
        y: stage.top
      };
    }
    if (this.is("animating")) {
      $2.support.transform ? this.animate(stage.x) : this.$stage.stop();
      this.invalidate("position");
    }
    this.$element.toggleClass(this.options.grabClass, event.type === "mousedown");
    this.speed(0);
    this._drag.time = (/* @__PURE__ */ new Date()).getTime();
    this._drag.target = $2(event.target);
    this._drag.stage.start = stage;
    this._drag.stage.current = stage;
    this._drag.pointer = this.pointer(event);
    $2(document2).on("mouseup.owl.core touchend.owl.core", $2.proxy(this.onDragEnd, this));
    $2(document2).one("mousemove.owl.core touchmove.owl.core", $2.proxy(function(event2) {
      var delta = this.difference(this._drag.pointer, this.pointer(event2));
      $2(document2).on("mousemove.owl.core touchmove.owl.core", $2.proxy(this.onDragMove, this));
      if (Math.abs(delta.x) < Math.abs(delta.y) && this.is("valid")) {
        return;
      }
      event2.preventDefault();
      this.enter("dragging");
      this.trigger("drag");
    }, this));
  };
  Owl.prototype.onDragMove = function(event) {
    var minimum = null, maximum = null, pull = null, delta = this.difference(this._drag.pointer, this.pointer(event)), stage = this.difference(this._drag.stage.start, delta);
    if (!this.is("dragging")) {
      return;
    }
    event.preventDefault();
    if (this.settings.loop) {
      minimum = this.coordinates(this.minimum());
      maximum = this.coordinates(this.maximum() + 1) - minimum;
      stage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum;
    } else {
      minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
      maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
      pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
      stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
    }
    this._drag.stage.current = stage;
    this.animate(stage.x);
  };
  Owl.prototype.onDragEnd = function(event) {
    var delta = this.difference(this._drag.pointer, this.pointer(event)), stage = this._drag.stage.current, direction = delta.x > 0 ^ this.settings.rtl ? "left" : "right";
    $2(document2).off(".owl.core");
    this.$element.removeClass(this.options.grabClass);
    if (delta.x !== 0 && this.is("dragging") || !this.is("valid")) {
      this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
      this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
      this.invalidate("position");
      this.update();
      this._drag.direction = direction;
      if (Math.abs(delta.x) > 3 || (/* @__PURE__ */ new Date()).getTime() - this._drag.time > 300) {
        this._drag.target.one("click.owl.core", function() {
          return false;
        });
      }
    }
    if (!this.is("dragging")) {
      return;
    }
    this.leave("dragging");
    this.trigger("dragged");
  };
  Owl.prototype.closest = function(coordinate, direction) {
    var position = -1, pull = 30, width2 = this.width(), coordinates = this.coordinates();
    if (!this.settings.freeDrag) {
      $2.each(coordinates, $2.proxy(function(index, value) {
        if (direction === "left" && coordinate > value - pull && coordinate < value + pull) {
          position = index;
        } else if (direction === "right" && coordinate > value - width2 - pull && coordinate < value - width2 + pull) {
          position = index + 1;
        } else if (this.op(coordinate, "<", value) && this.op(coordinate, ">", coordinates[index + 1] !== undefined$1 ? coordinates[index + 1] : value - width2)) {
          position = direction === "left" ? index + 1 : index;
        }
        return position === -1;
      }, this));
    }
    if (!this.settings.loop) {
      if (this.op(coordinate, ">", coordinates[this.minimum()])) {
        position = coordinate = this.minimum();
      } else if (this.op(coordinate, "<", coordinates[this.maximum()])) {
        position = coordinate = this.maximum();
      }
    }
    return position;
  };
  Owl.prototype.animate = function(coordinate) {
    var animate = this.speed() > 0;
    this.is("animating") && this.onTransitionEnd();
    if (animate) {
      this.enter("animating");
      this.trigger("translate");
    }
    if ($2.support.transform3d && $2.support.transition) {
      this.$stage.css({
        transform: "translate3d(" + coordinate + "px,0px,0px)",
        transition: this.speed() / 1e3 + "s" + (this.settings.slideTransition ? " " + this.settings.slideTransition : "")
      });
    } else if (animate) {
      this.$stage.animate({
        left: coordinate + "px"
      }, this.speed(), this.settings.fallbackEasing, $2.proxy(this.onTransitionEnd, this));
    } else {
      this.$stage.css({
        left: coordinate + "px"
      });
    }
  };
  Owl.prototype.is = function(state2) {
    return this._states.current[state2] && this._states.current[state2] > 0;
  };
  Owl.prototype.current = function(position) {
    if (position === undefined$1) {
      return this._current;
    }
    if (this._items.length === 0) {
      return undefined$1;
    }
    position = this.normalize(position);
    if (this._current !== position) {
      var event = this.trigger("change", { property: { name: "position", value: position } });
      if (event.data !== undefined$1) {
        position = this.normalize(event.data);
      }
      this._current = position;
      this.invalidate("position");
      this.trigger("changed", { property: { name: "position", value: this._current } });
    }
    return this._current;
  };
  Owl.prototype.invalidate = function(part) {
    if ($2.type(part) === "string") {
      this._invalidated[part] = true;
      this.is("valid") && this.leave("valid");
    }
    return $2.map(this._invalidated, function(v, i) {
      return i;
    });
  };
  Owl.prototype.reset = function(position) {
    position = this.normalize(position);
    if (position === undefined$1) {
      return;
    }
    this._speed = 0;
    this._current = position;
    this.suppress(["translate", "translated"]);
    this.animate(this.coordinates(position));
    this.release(["translate", "translated"]);
  };
  Owl.prototype.normalize = function(position, relative) {
    var n = this._items.length, m = relative ? 0 : this._clones.length;
    if (!this.isNumeric(position) || n < 1) {
      position = undefined$1;
    } else if (position < 0 || position >= n + m) {
      position = ((position - m / 2) % n + n) % n + m / 2;
    }
    return position;
  };
  Owl.prototype.relative = function(position) {
    position -= this._clones.length / 2;
    return this.normalize(position, true);
  };
  Owl.prototype.maximum = function(relative) {
    var settings = this.settings, maximum = this._coordinates.length, iterator, reciprocalItemsWidth, elementWidth;
    if (settings.loop) {
      maximum = this._clones.length / 2 + this._items.length - 1;
    } else if (settings.autoWidth || settings.merge) {
      iterator = this._items.length;
      if (iterator) {
        reciprocalItemsWidth = this._items[--iterator].width();
        elementWidth = this.$element.width();
        while (iterator--) {
          reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
          if (reciprocalItemsWidth > elementWidth) {
            break;
          }
        }
      }
      maximum = iterator + 1;
    } else if (settings.center) {
      maximum = this._items.length - 1;
    } else {
      maximum = this._items.length - settings.items;
    }
    if (relative) {
      maximum -= this._clones.length / 2;
    }
    return Math.max(maximum, 0);
  };
  Owl.prototype.minimum = function(relative) {
    return relative ? 0 : this._clones.length / 2;
  };
  Owl.prototype.items = function(position) {
    if (position === undefined$1) {
      return this._items.slice();
    }
    position = this.normalize(position, true);
    return this._items[position];
  };
  Owl.prototype.mergers = function(position) {
    if (position === undefined$1) {
      return this._mergers.slice();
    }
    position = this.normalize(position, true);
    return this._mergers[position];
  };
  Owl.prototype.clones = function(position) {
    var odd = this._clones.length / 2, even = odd + this._items.length, map2 = function(index) {
      return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2;
    };
    if (position === undefined$1) {
      return $2.map(this._clones, function(v, i) {
        return map2(i);
      });
    }
    return $2.map(this._clones, function(v, i) {
      return v === position ? map2(i) : null;
    });
  };
  Owl.prototype.speed = function(speed) {
    if (speed !== undefined$1) {
      this._speed = speed;
    }
    return this._speed;
  };
  Owl.prototype.coordinates = function(position) {
    var multiplier = 1, newPosition = position - 1, coordinate;
    if (position === undefined$1) {
      return $2.map(this._coordinates, $2.proxy(function(coordinate2, index) {
        return this.coordinates(index);
      }, this));
    }
    if (this.settings.center) {
      if (this.settings.rtl) {
        multiplier = -1;
        newPosition = position + 1;
      }
      coordinate = this._coordinates[position];
      coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
    } else {
      coordinate = this._coordinates[newPosition] || 0;
    }
    coordinate = Math.ceil(coordinate);
    return coordinate;
  };
  Owl.prototype.duration = function(from, to, factor) {
    if (factor === 0) {
      return 0;
    }
    return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed);
  };
  Owl.prototype.to = function(position, speed) {
    var current = this.current(), revert = null, distance = position - this.relative(current), direction = (distance > 0) - (distance < 0), items = this._items.length, minimum = this.minimum(), maximum = this.maximum();
    if (this.settings.loop) {
      if (!this.settings.rewind && Math.abs(distance) > items / 2) {
        distance += direction * -1 * items;
      }
      position = current + distance;
      revert = ((position - minimum) % items + items) % items + minimum;
      if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
        current = revert - distance;
        position = revert;
        this.reset(current);
      }
    } else if (this.settings.rewind) {
      maximum += 1;
      position = (position % maximum + maximum) % maximum;
    } else {
      position = Math.max(minimum, Math.min(maximum, position));
    }
    this.speed(this.duration(current, position, speed));
    this.current(position);
    if (this.isVisible()) {
      this.update();
    }
  };
  Owl.prototype.next = function(speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) + 1, speed);
  };
  Owl.prototype.prev = function(speed) {
    speed = speed || false;
    this.to(this.relative(this.current()) - 1, speed);
  };
  Owl.prototype.onTransitionEnd = function(event) {
    if (event !== undefined$1) {
      event.stopPropagation();
      if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
        return false;
      }
    }
    this.leave("animating");
    this.trigger("translated");
  };
  Owl.prototype.viewport = function() {
    var width2;
    if (this.options.responsiveBaseElement !== window2) {
      width2 = $2(this.options.responsiveBaseElement).width();
    } else if (window2.innerWidth) {
      width2 = window2.innerWidth;
    } else if (document2.documentElement && document2.documentElement.clientWidth) {
      width2 = document2.documentElement.clientWidth;
    } else {
      console.warn("Can not detect viewport width.");
    }
    return width2;
  };
  Owl.prototype.replace = function(content) {
    this.$stage.empty();
    this._items = [];
    if (content) {
      content = content instanceof jQuery ? content : $2(content);
    }
    if (this.settings.nestedItemSelector) {
      content = content.find("." + this.settings.nestedItemSelector);
    }
    content.filter(function() {
      return this.nodeType === 1;
    }).each($2.proxy(function(index, item2) {
      item2 = this.prepare(item2);
      this.$stage.append(item2);
      this._items.push(item2);
      this._mergers.push(item2.find("[data-merge]").addBack("[data-merge]").attr("data-merge") * 1 || 1);
    }, this));
    this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);
    this.invalidate("items");
  };
  Owl.prototype.add = function(content, position) {
    var current = this.relative(this._current);
    position = position === undefined$1 ? this._items.length : this.normalize(position, true);
    content = content instanceof jQuery ? content : $2(content);
    this.trigger("add", { content, position });
    content = this.prepare(content);
    if (this._items.length === 0 || position === this._items.length) {
      this._items.length === 0 && this.$stage.append(content);
      this._items.length !== 0 && this._items[position - 1].after(content);
      this._items.push(content);
      this._mergers.push(content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") * 1 || 1);
    } else {
      this._items[position].before(content);
      this._items.splice(position, 0, content);
      this._mergers.splice(position, 0, content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") * 1 || 1);
    }
    this._items[current] && this.reset(this._items[current].index());
    this.invalidate("items");
    this.trigger("added", { content, position });
  };
  Owl.prototype.remove = function(position) {
    position = this.normalize(position, true);
    if (position === undefined$1) {
      return;
    }
    this.trigger("remove", { content: this._items[position], position });
    this._items[position].remove();
    this._items.splice(position, 1);
    this._mergers.splice(position, 1);
    this.invalidate("items");
    this.trigger("removed", { content: null, position });
  };
  Owl.prototype.preloadAutoWidthImages = function(images2) {
    images2.each($2.proxy(function(i, element) {
      this.enter("pre-loading");
      element = $2(element);
      $2(new Image()).one("load", $2.proxy(function(e) {
        element.attr("src", e.target.src);
        element.css("opacity", 1);
        this.leave("pre-loading");
        !this.is("pre-loading") && !this.is("initializing") && this.refresh();
      }, this)).attr("src", element.attr("src") || element.attr("data-src") || element.attr("data-src-retina"));
    }, this));
  };
  Owl.prototype.destroy = function() {
    this.$element.off(".owl.core");
    this.$stage.off(".owl.core");
    $2(document2).off(".owl.core");
    if (this.settings.responsive !== false) {
      window2.clearTimeout(this.resizeTimer);
      this.off(window2, "resize", this._handlers.onThrottledResize);
    }
    for (var i in this._plugins) {
      this._plugins[i].destroy();
    }
    this.$stage.children(".cloned").remove();
    this.$stage.unwrap();
    this.$stage.children().contents().unwrap();
    this.$stage.children().unwrap();
    this.$stage.remove();
    this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\S+\\s", "g"), "")).removeData("owl.carousel");
  };
  Owl.prototype.op = function(a, o, b) {
    var rtl = this.settings.rtl;
    switch (o) {
      case "<":
        return rtl ? a > b : a < b;
      case ">":
        return rtl ? a < b : a > b;
      case ">=":
        return rtl ? a <= b : a >= b;
      case "<=":
        return rtl ? a >= b : a <= b;
    }
  };
  Owl.prototype.on = function(element, event, listener, capture) {
    if (element.addEventListener) {
      element.addEventListener(event, listener, capture);
    } else if (element.attachEvent) {
      element.attachEvent("on" + event, listener);
    }
  };
  Owl.prototype.off = function(element, event, listener, capture) {
    if (element.removeEventListener) {
      element.removeEventListener(event, listener, capture);
    } else if (element.detachEvent) {
      element.detachEvent("on" + event, listener);
    }
  };
  Owl.prototype.trigger = function(name2, data2, namespace, state2, enter) {
    var status = {
      item: { count: this._items.length, index: this.current() }
    }, handler = $2.camelCase(
      $2.grep(["on", name2, namespace], function(v) {
        return v;
      }).join("-").toLowerCase()
    ), event = $2.Event(
      [name2, "owl", namespace || "carousel"].join(".").toLowerCase(),
      $2.extend({ relatedTarget: this }, status, data2)
    );
    if (!this._supress[name2]) {
      $2.each(this._plugins, function(name3, plugin2) {
        if (plugin2.onTrigger) {
          plugin2.onTrigger(event);
        }
      });
      this.register({ type: Owl.Type.Event, name: name2 });
      this.$element.trigger(event);
      if (this.settings && typeof this.settings[handler] === "function") {
        this.settings[handler].call(this, event);
      }
    }
    return event;
  };
  Owl.prototype.enter = function(name2) {
    $2.each([name2].concat(this._states.tags[name2] || []), $2.proxy(function(i, name3) {
      if (this._states.current[name3] === undefined$1) {
        this._states.current[name3] = 0;
      }
      this._states.current[name3]++;
    }, this));
  };
  Owl.prototype.leave = function(name2) {
    $2.each([name2].concat(this._states.tags[name2] || []), $2.proxy(function(i, name3) {
      this._states.current[name3]--;
    }, this));
  };
  Owl.prototype.register = function(object) {
    if (object.type === Owl.Type.Event) {
      if (!$2.event.special[object.name]) {
        $2.event.special[object.name] = {};
      }
      if (!$2.event.special[object.name].owl) {
        var _default = $2.event.special[object.name]._default;
        $2.event.special[object.name]._default = function(e) {
          if (_default && _default.apply && (!e.namespace || e.namespace.indexOf("owl") === -1)) {
            return _default.apply(this, arguments);
          }
          return e.namespace && e.namespace.indexOf("owl") > -1;
        };
        $2.event.special[object.name].owl = true;
      }
    } else if (object.type === Owl.Type.State) {
      if (!this._states.tags[object.name]) {
        this._states.tags[object.name] = object.tags;
      } else {
        this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
      }
      this._states.tags[object.name] = $2.grep(this._states.tags[object.name], $2.proxy(function(tag, i) {
        return $2.inArray(tag, this._states.tags[object.name]) === i;
      }, this));
    }
  };
  Owl.prototype.suppress = function(events) {
    $2.each(events, $2.proxy(function(index, event) {
      this._supress[event] = true;
    }, this));
  };
  Owl.prototype.release = function(events) {
    $2.each(events, $2.proxy(function(index, event) {
      delete this._supress[event];
    }, this));
  };
  Owl.prototype.pointer = function(event) {
    var result = { x: null, y: null };
    event = event.originalEvent || event || window2.event;
    event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;
    if (event.pageX) {
      result.x = event.pageX;
      result.y = event.pageY;
    } else {
      result.x = event.clientX;
      result.y = event.clientY;
    }
    return result;
  };
  Owl.prototype.isNumeric = function(number) {
    return !isNaN(parseFloat(number));
  };
  Owl.prototype.difference = function(first, second) {
    return {
      x: first.x - second.x,
      y: first.y - second.y
    };
  };
  $2.fn.owlCarousel = function(option2) {
    var args = Array.prototype.slice.call(arguments, 1);
    return this.each(function() {
      var $this = $2(this), data2 = $this.data("owl.carousel");
      if (!data2) {
        data2 = new Owl(this, typeof option2 == "object" && option2);
        $this.data("owl.carousel", data2);
        $2.each([
          "next",
          "prev",
          "to",
          "destroy",
          "refresh",
          "replace",
          "add",
          "remove"
        ], function(i, event) {
          data2.register({ type: Owl.Type.Event, name: event });
          data2.$element.on(event + ".owl.carousel.core", $2.proxy(function(e) {
            if (e.namespace && e.relatedTarget !== this) {
              this.suppress([event]);
              data2[event].apply(this, [].slice.call(arguments, 1));
              this.release([event]);
            }
          }, data2));
        });
      }
      if (typeof option2 == "string" && option2.charAt(0) !== "_") {
        data2[option2].apply(data2, args);
      }
    });
  };
  $2.fn.owlCarousel.Constructor = Owl;
})(window.Zepto || window.jQuery, window, document);
(function($2, window2, document2, undefined$1) {
  var AutoRefresh = function(carousel) {
    this._core = carousel;
    this._interval = null;
    this._visible = null;
    this._handlers = {
      "initialized.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.autoRefresh) {
          this.watch();
        }
      }, this)
    };
    this._core.options = $2.extend({}, AutoRefresh.Defaults, this._core.options);
    this._core.$element.on(this._handlers);
  };
  AutoRefresh.Defaults = {
    autoRefresh: true,
    autoRefreshInterval: 500
  };
  AutoRefresh.prototype.watch = function() {
    if (this._interval) {
      return;
    }
    this._visible = this._core.isVisible();
    this._interval = window2.setInterval($2.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
  };
  AutoRefresh.prototype.refresh = function() {
    if (this._core.isVisible() === this._visible) {
      return;
    }
    this._visible = !this._visible;
    this._core.$element.toggleClass("owl-hidden", !this._visible);
    this._visible && (this._core.invalidate("width") && this._core.refresh());
  };
  AutoRefresh.prototype.destroy = function() {
    var handler, property;
    window2.clearInterval(this._interval);
    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;
})(window.Zepto || window.jQuery, window);
(function($2, window2, document2, undefined$1) {
  var Lazy = function(carousel) {
    this._core = carousel;
    this._loaded = [];
    this._handlers = {
      "initialized.owl.carousel change.owl.carousel resized.owl.carousel": $2.proxy(function(e) {
        if (!e.namespace) {
          return;
        }
        if (!this._core.settings || !this._core.settings.lazyLoad) {
          return;
        }
        if (e.property && e.property.name == "position" || e.type == "initialized") {
          var settings = this._core.settings, n = settings.center && Math.ceil(settings.items / 2) || settings.items, i = settings.center && n * -1 || 0, position = (e.property && e.property.value !== undefined$1 ? e.property.value : this._core.current()) + i, clones = this._core.clones().length, load = $2.proxy(function(i2, v) {
            this.load(v);
          }, this);
          if (settings.lazyLoadEager > 0) {
            n += settings.lazyLoadEager;
            if (settings.loop) {
              position -= settings.lazyLoadEager;
              n++;
            }
          }
          while (i++ < n) {
            this.load(clones / 2 + this._core.relative(position));
            clones && $2.each(this._core.clones(this._core.relative(position)), load);
            position++;
          }
        }
      }, this)
    };
    this._core.options = $2.extend({}, Lazy.Defaults, this._core.options);
    this._core.$element.on(this._handlers);
  };
  Lazy.Defaults = {
    lazyLoad: false,
    lazyLoadEager: 0
  };
  Lazy.prototype.load = function(position) {
    var $item = this._core.$stage.children().eq(position), $elements = $item && $item.find(".owl-lazy");
    if (!$elements || $2.inArray($item.get(0), this._loaded) > -1) {
      return;
    }
    $elements.each($2.proxy(function(index, element) {
      var $element = $2(element), image, url = window2.devicePixelRatio > 1 && $element.attr("data-src-retina") || $element.attr("data-src") || $element.attr("data-srcset");
      this._core.trigger("load", { element: $element, url }, "lazy");
      if ($element.is("img")) {
        $element.one("load.owl.lazy", $2.proxy(function() {
          $element.css("opacity", 1);
          this._core.trigger("loaded", { element: $element, url }, "lazy");
        }, this)).attr("src", url);
      } else if ($element.is("source")) {
        $element.one("load.owl.lazy", $2.proxy(function() {
          this._core.trigger("loaded", { element: $element, url }, "lazy");
        }, this)).attr("srcset", url);
      } else {
        image = new Image();
        image.onload = $2.proxy(function() {
          $element.css({
            "background-image": 'url("' + url + '")',
            "opacity": "1"
          });
          this._core.trigger("loaded", { element: $element, url }, "lazy");
        }, this);
        image.src = url;
      }
    }, this));
    this._loaded.push($item.get(0));
  };
  Lazy.prototype.destroy = function() {
    var handler, property;
    for (handler in this.handlers) {
      this._core.$element.off(handler, this.handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;
})(window.Zepto || window.jQuery, window);
(function($2, window2, document2, undefined$1) {
  var AutoHeight = function(carousel) {
    this._core = carousel;
    this._previousHeight = null;
    this._handlers = {
      "initialized.owl.carousel refreshed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.autoHeight) {
          this.update();
        }
      }, this),
      "changed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.autoHeight && e.property.name === "position") {
          this.update();
        }
      }, this),
      "loaded.owl.lazy": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.autoHeight && e.element.closest("." + this._core.settings.itemClass).index() === this._core.current()) {
          this.update();
        }
      }, this)
    };
    this._core.options = $2.extend({}, AutoHeight.Defaults, this._core.options);
    this._core.$element.on(this._handlers);
    this._intervalId = null;
    var refThis = this;
    $2(window2).on("load", function() {
      if (refThis._core.settings.autoHeight) {
        refThis.update();
      }
    });
    $2(window2).resize(function() {
      if (refThis._core.settings.autoHeight) {
        if (refThis._intervalId != null) {
          clearTimeout(refThis._intervalId);
        }
        refThis._intervalId = setTimeout(function() {
          refThis.update();
        }, 250);
      }
    });
  };
  AutoHeight.Defaults = {
    autoHeight: false,
    autoHeightClass: "owl-height"
  };
  AutoHeight.prototype.update = function() {
    var start2 = this._core._current, end2 = start2 + this._core.settings.items, lazyLoadEnabled = this._core.settings.lazyLoad, visible = this._core.$stage.children().toArray().slice(start2, end2), heights = [], maxheight = 0;
    $2.each(visible, function(index, item2) {
      heights.push($2(item2).height());
    });
    maxheight = Math.max.apply(null, heights);
    if (maxheight <= 1 && lazyLoadEnabled && this._previousHeight) {
      maxheight = this._previousHeight;
    }
    this._previousHeight = maxheight;
    this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);
  };
  AutoHeight.prototype.destroy = function() {
    var handler, property;
    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] !== "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;
})(window.Zepto || window.jQuery, window);
(function($2, window2, document2, undefined$1) {
  var Video = function(carousel) {
    this._core = carousel;
    this._videos = {};
    this._playing = null;
    this._handlers = {
      "initialized.owl.carousel": $2.proxy(function(e) {
        if (e.namespace) {
          this._core.register({ type: "state", name: "playing", tags: ["interacting"] });
        }
      }, this),
      "resize.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
          e.preventDefault();
        }
      }, this),
      "refreshed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.is("resizing")) {
          this._core.$stage.find(".cloned .owl-video-frame").remove();
        }
      }, this),
      "changed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && e.property.name === "position" && this._playing) {
          this.stop();
        }
      }, this),
      "prepared.owl.carousel": $2.proxy(function(e) {
        if (!e.namespace) {
          return;
        }
        var $element = $2(e.content).find(".owl-video");
        if ($element.length) {
          $element.css("display", "none");
          this.fetch($element, $2(e.content));
        }
      }, this)
    };
    this._core.options = $2.extend({}, Video.Defaults, this._core.options);
    this._core.$element.on(this._handlers);
    this._core.$element.on("click.owl.video", ".owl-video-play-icon", $2.proxy(function(e) {
      this.play(e);
    }, this));
  };
  Video.Defaults = {
    video: false,
    videoHeight: false,
    videoWidth: false
  };
  Video.prototype.fetch = function(target, item2) {
    var type = function() {
      if (target.attr("data-vimeo-id")) {
        return "vimeo";
      } else if (target.attr("data-vzaar-id")) {
        return "vzaar";
      } else {
        return "youtube";
      }
    }(), id = target.attr("data-vimeo-id") || target.attr("data-youtube-id") || target.attr("data-vzaar-id"), width2 = target.attr("data-width") || this._core.settings.videoWidth, height2 = target.attr("data-height") || this._core.settings.videoHeight, url = target.attr("href");
    if (url) {
      id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com|be\-nocookie\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);
      if (id[3].indexOf("youtu") > -1) {
        type = "youtube";
      } else if (id[3].indexOf("vimeo") > -1) {
        type = "vimeo";
      } else if (id[3].indexOf("vzaar") > -1) {
        type = "vzaar";
      } else {
        throw new Error("Video URL not supported.");
      }
      id = id[6];
    } else {
      throw new Error("Missing video URL.");
    }
    this._videos[url] = {
      type,
      id,
      width: width2,
      height: height2
    };
    item2.attr("data-video", url);
    this.thumbnail(target, this._videos[url]);
  };
  Video.prototype.thumbnail = function(target, video) {
    var tnLink, icon, path, dimensions = video.width && video.height ? "width:" + video.width + "px;height:" + video.height + "px;" : "", customTn = target.find("img"), srcType = "src", lazyClass = "", settings = this._core.settings, create2 = function(path2) {
      icon = '<div class="owl-video-play-icon"></div>';
      if (settings.lazyLoad) {
        tnLink = $2("<div/>", {
          "class": "owl-video-tn " + lazyClass,
          "srcType": path2
        });
      } else {
        tnLink = $2("<div/>", {
          "class": "owl-video-tn",
          "style": "opacity:1;background-image:url(" + path2 + ")"
        });
      }
      target.after(tnLink);
      target.after(icon);
    };
    target.wrap($2("<div/>", {
      "class": "owl-video-wrapper",
      "style": dimensions
    }));
    if (this._core.settings.lazyLoad) {
      srcType = "data-src";
      lazyClass = "owl-lazy";
    }
    if (customTn.length) {
      create2(customTn.attr(srcType));
      customTn.remove();
      return false;
    }
    if (video.type === "youtube") {
      path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
      create2(path);
    } else if (video.type === "vimeo") {
      $2.ajax({
        type: "GET",
        url: "//vimeo.com/api/v2/video/" + video.id + ".json",
        jsonp: "callback",
        dataType: "jsonp",
        success: function(data2) {
          path = data2[0].thumbnail_large;
          create2(path);
        }
      });
    } else if (video.type === "vzaar") {
      $2.ajax({
        type: "GET",
        url: "//vzaar.com/api/videos/" + video.id + ".json",
        jsonp: "callback",
        dataType: "jsonp",
        success: function(data2) {
          path = data2.framegrab_url;
          create2(path);
        }
      });
    }
  };
  Video.prototype.stop = function() {
    this._core.trigger("stop", null, "video");
    this._playing.find(".owl-video-frame").remove();
    this._playing.removeClass("owl-video-playing");
    this._playing = null;
    this._core.leave("playing");
    this._core.trigger("stopped", null, "video");
  };
  Video.prototype.play = function(event) {
    var target = $2(event.target), item2 = target.closest("." + this._core.settings.itemClass), video = this._videos[item2.attr("data-video")], width2 = video.width || "100%", height2 = video.height || this._core.$stage.height(), html;
    if (this._playing) {
      return;
    }
    this._core.enter("playing");
    this._core.trigger("play", null, "video");
    item2 = this._core.items(this._core.relative(item2.index()));
    this._core.reset(item2.index());
    html = $2('<iframe frameborder="0" allowfullscreen mozallowfullscreen webkitAllowFullScreen ></iframe>');
    html.attr("height", height2);
    html.attr("width", width2);
    if (video.type === "youtube") {
      html.attr("src", "//www.youtube.com/embed/" + video.id + "?autoplay=1&rel=0&v=" + video.id);
    } else if (video.type === "vimeo") {
      html.attr("src", "//player.vimeo.com/video/" + video.id + "?autoplay=1");
    } else if (video.type === "vzaar") {
      html.attr("src", "//view.vzaar.com/" + video.id + "/player?autoplay=true");
    }
    $2(html).wrap('<div class="owl-video-frame" />').insertAfter(item2.find(".owl-video"));
    this._playing = item2.addClass("owl-video-playing");
  };
  Video.prototype.isInFullScreen = function() {
    var element = document2.fullscreenElement || document2.mozFullScreenElement || document2.webkitFullscreenElement;
    return element && $2(element).parent().hasClass("owl-video-frame");
  };
  Video.prototype.destroy = function() {
    var handler, property;
    this._core.$element.off("click.owl.video");
    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.Video = Video;
})(window.Zepto || window.jQuery, window, document);
(function($2, window2, document2, undefined$1) {
  var Animate = function(scope) {
    this.core = scope;
    this.core.options = $2.extend({}, Animate.Defaults, this.core.options);
    this.swapping = true;
    this.previous = undefined$1;
    this.next = undefined$1;
    this.handlers = {
      "change.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && e.property.name == "position") {
          this.previous = this.core.current();
          this.next = e.property.value;
        }
      }, this),
      "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": $2.proxy(function(e) {
        if (e.namespace) {
          this.swapping = e.type == "translated";
        }
      }, this),
      "translate.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
          this.swap();
        }
      }, this)
    };
    this.core.$element.on(this.handlers);
  };
  Animate.Defaults = {
    animateOut: false,
    animateIn: false
  };
  Animate.prototype.swap = function() {
    if (this.core.settings.items !== 1) {
      return;
    }
    if (!$2.support.animation || !$2.support.transition) {
      return;
    }
    this.core.speed(0);
    var left2, clear2 = $2.proxy(this.clear, this), previous = this.core.$stage.children().eq(this.previous), next = this.core.$stage.children().eq(this.next), incoming = this.core.settings.animateIn, outgoing = this.core.settings.animateOut;
    if (this.core.current() === this.previous) {
      return;
    }
    if (outgoing) {
      left2 = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
      previous.one($2.support.animation.end, clear2).css({ "left": left2 + "px" }).addClass("animated owl-animated-out").addClass(outgoing);
    }
    if (incoming) {
      next.one($2.support.animation.end, clear2).addClass("animated owl-animated-in").addClass(incoming);
    }
  };
  Animate.prototype.clear = function(e) {
    $2(e.target).css({ "left": "" }).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);
    this.core.onTransitionEnd();
  };
  Animate.prototype.destroy = function() {
    var handler, property;
    for (handler in this.handlers) {
      this.core.$element.off(handler, this.handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.Animate = Animate;
})(window.Zepto || window.jQuery);
(function($2, window2, document2, undefined$1) {
  var Autoplay = function(carousel) {
    this._core = carousel;
    this._call = null;
    this._time = 0;
    this._timeout = 0;
    this._paused = true;
    this._handlers = {
      "changed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && e.property.name === "settings") {
          if (this._core.settings.autoplay) {
            this.play();
          } else {
            this.stop();
          }
        } else if (e.namespace && e.property.name === "position" && this._paused) {
          this._time = 0;
        }
      }, this),
      "initialized.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.autoplay) {
          this.play();
        }
      }, this),
      "play.owl.autoplay": $2.proxy(function(e, t, s) {
        if (e.namespace) {
          this.play(t, s);
        }
      }, this),
      "stop.owl.autoplay": $2.proxy(function(e) {
        if (e.namespace) {
          this.stop();
        }
      }, this),
      "mouseover.owl.autoplay": $2.proxy(function() {
        if (this._core.settings.autoplayHoverPause && this._core.is("rotating")) {
          this.pause();
        }
      }, this),
      "mouseleave.owl.autoplay": $2.proxy(function() {
        if (this._core.settings.autoplayHoverPause && this._core.is("rotating")) {
          this.play();
        }
      }, this),
      "touchstart.owl.core": $2.proxy(function() {
        if (this._core.settings.autoplayHoverPause && this._core.is("rotating")) {
          this.pause();
        }
      }, this),
      "touchend.owl.core": $2.proxy(function() {
        if (this._core.settings.autoplayHoverPause) {
          this.play();
        }
      }, this)
    };
    this._core.$element.on(this._handlers);
    this._core.options = $2.extend({}, Autoplay.Defaults, this._core.options);
  };
  Autoplay.Defaults = {
    autoplay: false,
    autoplayTimeout: 5e3,
    autoplayHoverPause: false,
    autoplaySpeed: false
  };
  Autoplay.prototype._next = function(speed) {
    this._call = window2.setTimeout(
      $2.proxy(this._next, this, speed),
      this._timeout * (Math.round(this.read() / this._timeout) + 1) - this.read()
    );
    if (this._core.is("interacting") || document2.hidden) {
      return;
    }
    this._core.next(speed || this._core.settings.autoplaySpeed);
  };
  Autoplay.prototype.read = function() {
    return (/* @__PURE__ */ new Date()).getTime() - this._time;
  };
  Autoplay.prototype.play = function(timeout, speed) {
    var elapsed;
    if (!this._core.is("rotating")) {
      this._core.enter("rotating");
    }
    timeout = timeout || this._core.settings.autoplayTimeout;
    elapsed = Math.min(this._time % (this._timeout || timeout), timeout);
    if (this._paused) {
      this._time = this.read();
      this._paused = false;
    } else {
      window2.clearTimeout(this._call);
    }
    this._time += this.read() % timeout - elapsed;
    this._timeout = timeout;
    this._call = window2.setTimeout($2.proxy(this._next, this, speed), timeout - elapsed);
  };
  Autoplay.prototype.stop = function() {
    if (this._core.is("rotating")) {
      this._time = 0;
      this._paused = true;
      window2.clearTimeout(this._call);
      this._core.leave("rotating");
    }
  };
  Autoplay.prototype.pause = function() {
    if (this._core.is("rotating") && !this._paused) {
      this._time = this.read();
      this._paused = true;
      window2.clearTimeout(this._call);
    }
  };
  Autoplay.prototype.destroy = function() {
    var handler, property;
    this.stop();
    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;
})(window.Zepto || window.jQuery, window, document);
(function($2, window2, document2, undefined$1) {
  var Navigation = function(carousel) {
    this._core = carousel;
    this._initialized = false;
    this._pages = [];
    this._controls = {};
    this._templates = [];
    this.$element = this._core.$element;
    this._overrides = {
      next: this._core.next,
      prev: this._core.prev,
      to: this._core.to
    };
    this._handlers = {
      "prepared.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $2(e.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>");
        }
      }, this),
      "added.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 0, this._templates.pop());
        }
      }, this),
      "remove.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.dotsData) {
          this._templates.splice(e.position, 1);
        }
      }, this),
      "changed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && e.property.name == "position") {
          this.draw();
        }
      }, this),
      "initialized.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && !this._initialized) {
          this._core.trigger("initialize", null, "navigation");
          this.initialize();
          this.update();
          this.draw();
          this._initialized = true;
          this._core.trigger("initialized", null, "navigation");
        }
      }, this),
      "refreshed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._initialized) {
          this._core.trigger("refresh", null, "navigation");
          this.update();
          this.draw();
          this._core.trigger("refreshed", null, "navigation");
        }
      }, this)
    };
    this._core.options = $2.extend({}, Navigation.Defaults, this._core.options);
    this.$element.on(this._handlers);
  };
  Navigation.Defaults = {
    nav: false,
    navText: [
      '<span aria-label="Previous">&#x2039;</span>',
      '<span aria-label="Next">&#x203a;</span>'
    ],
    navSpeed: false,
    navElement: 'button type="button" role="presentation"',
    navContainer: false,
    navContainerClass: "owl-nav",
    navClass: [
      "owl-prev",
      "owl-next"
    ],
    slideBy: 1,
    dotClass: "owl-dot",
    dotsClass: "owl-dots",
    dots: true,
    dotsEach: false,
    dotsData: false,
    dotsSpeed: false,
    dotsContainer: false
  };
  Navigation.prototype.initialize = function() {
    var override, settings = this._core.settings;
    this._controls.$relative = (settings.navContainer ? $2(settings.navContainer) : $2("<div>").addClass(settings.navContainerClass).appendTo(this.$element)).addClass("disabled");
    this._controls.$previous = $2("<" + settings.navElement + ">").addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on("click", $2.proxy(function(e) {
      this.prev(settings.navSpeed);
    }, this));
    this._controls.$next = $2("<" + settings.navElement + ">").addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on("click", $2.proxy(function(e) {
      this.next(settings.navSpeed);
    }, this));
    if (!settings.dotsData) {
      this._templates = [$2('<button role="button">').addClass(settings.dotClass).append($2("<span>")).prop("outerHTML")];
    }
    this._controls.$absolute = (settings.dotsContainer ? $2(settings.dotsContainer) : $2("<div>").addClass(settings.dotsClass).appendTo(this.$element)).addClass("disabled");
    this._controls.$absolute.on("click", "button", $2.proxy(function(e) {
      var index = $2(e.target).parent().is(this._controls.$absolute) ? $2(e.target).index() : $2(e.target).parent().index();
      e.preventDefault();
      this.to(index, settings.dotsSpeed);
    }, this));
    for (override in this._overrides) {
      this._core[override] = $2.proxy(this[override], this);
    }
  };
  Navigation.prototype.destroy = function() {
    var handler, control, property, override, settings;
    settings = this._core.settings;
    for (handler in this._handlers) {
      this.$element.off(handler, this._handlers[handler]);
    }
    for (control in this._controls) {
      if (control === "$relative" && settings.navContainer) {
        this._controls[control].html("");
      } else {
        this._controls[control].remove();
      }
    }
    for (override in this.overides) {
      this._core[override] = this._overrides[override];
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  Navigation.prototype.update = function() {
    var i, j, lower = this._core.clones().length / 2, upper = lower + this._core.items().length, maximum = this._core.maximum(true), settings = this._core.settings, size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;
    if (settings.slideBy !== "page") {
      settings.slideBy = Math.min(settings.slideBy, settings.items);
    }
    if (settings.dots || settings.slideBy == "page") {
      this._pages = [];
      for (i = lower, j = 0, 0; i < upper; i++) {
        if (j >= size || j === 0) {
          this._pages.push({
            start: Math.min(maximum, i - lower),
            end: i - lower + size - 1
          });
          if (Math.min(maximum, i - lower) === maximum) {
            break;
          }
          j = 0;
        }
        j += this._core.mergers(this._core.relative(i));
      }
    }
  };
  Navigation.prototype.draw = function() {
    var difference, settings = this._core.settings, disabled = this._core.items().length <= settings.items, index = this._core.relative(this._core.current()), loop = settings.loop || settings.rewind;
    this._controls.$relative.toggleClass("disabled", !settings.nav || disabled);
    if (settings.nav) {
      this._controls.$previous.toggleClass("disabled", !loop && index <= this._core.minimum(true));
      this._controls.$next.toggleClass("disabled", !loop && index >= this._core.maximum(true));
    }
    this._controls.$absolute.toggleClass("disabled", !settings.dots || disabled);
    if (settings.dots) {
      difference = this._pages.length - this._controls.$absolute.children().length;
      if (settings.dotsData && difference !== 0) {
        this._controls.$absolute.html(this._templates.join(""));
      } else if (difference > 0) {
        this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
      } else if (difference < 0) {
        this._controls.$absolute.children().slice(difference).remove();
      }
      this._controls.$absolute.find(".active").removeClass("active");
      this._controls.$absolute.children().eq($2.inArray(this.current(), this._pages)).addClass("active");
    }
  };
  Navigation.prototype.onTrigger = function(event) {
    var settings = this._core.settings;
    event.page = {
      index: $2.inArray(this.current(), this._pages),
      count: this._pages.length,
      size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
    };
  };
  Navigation.prototype.current = function() {
    var current = this._core.relative(this._core.current());
    return $2.grep(this._pages, $2.proxy(function(page, index) {
      return page.start <= current && page.end >= current;
    }, this)).pop();
  };
  Navigation.prototype.getPosition = function(successor) {
    var position, length, settings = this._core.settings;
    if (settings.slideBy == "page") {
      position = $2.inArray(this.current(), this._pages);
      length = this._pages.length;
      successor ? ++position : --position;
      position = this._pages[(position % length + length) % length].start;
    } else {
      position = this._core.relative(this._core.current());
      length = this._core.items().length;
      successor ? position += settings.slideBy : position -= settings.slideBy;
    }
    return position;
  };
  Navigation.prototype.next = function(speed) {
    $2.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
  };
  Navigation.prototype.prev = function(speed) {
    $2.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
  };
  Navigation.prototype.to = function(position, speed, standard) {
    var length;
    if (!standard && this._pages.length) {
      length = this._pages.length;
      $2.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed);
    } else {
      $2.proxy(this._overrides.to, this._core)(position, speed);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;
})(window.Zepto || window.jQuery);
(function($2, window2, document2, undefined$1) {
  var Hash = function(carousel) {
    this._core = carousel;
    this._hashes = {};
    this.$element = this._core.$element;
    this._handlers = {
      "initialized.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && this._core.settings.startPosition === "URLHash") {
          $2(window2).trigger("hashchange.owl.navigation");
        }
      }, this),
      "prepared.owl.carousel": $2.proxy(function(e) {
        if (e.namespace) {
          var hash2 = $2(e.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");
          if (!hash2) {
            return;
          }
          this._hashes[hash2] = e.content;
        }
      }, this),
      "changed.owl.carousel": $2.proxy(function(e) {
        if (e.namespace && e.property.name === "position") {
          var current = this._core.items(this._core.relative(this._core.current())), hash2 = $2.map(this._hashes, function(item2, hash3) {
            return item2 === current ? hash3 : null;
          }).join();
          if (!hash2 || window2.location.hash.slice(1) === hash2) {
            return;
          }
          window2.location.hash = hash2;
        }
      }, this)
    };
    this._core.options = $2.extend({}, Hash.Defaults, this._core.options);
    this.$element.on(this._handlers);
    $2(window2).on("hashchange.owl.navigation", $2.proxy(function(e) {
      var hash2 = window2.location.hash.substring(1), items = this._core.$stage.children(), position = this._hashes[hash2] && items.index(this._hashes[hash2]);
      if (position === undefined$1 || position === this._core.current()) {
        return;
      }
      this._core.to(this._core.relative(position), false, true);
    }, this));
  };
  Hash.Defaults = {
    URLhashListener: false
  };
  Hash.prototype.destroy = function() {
    var handler, property;
    $2(window2).off("hashchange.owl.navigation");
    for (handler in this._handlers) {
      this._core.$element.off(handler, this._handlers[handler]);
    }
    for (property in Object.getOwnPropertyNames(this)) {
      typeof this[property] != "function" && (this[property] = null);
    }
  };
  $2.fn.owlCarousel.Constructor.Plugins.Hash = Hash;
})(window.Zepto || window.jQuery, window);
(function($2, window2, document2, undefined$1) {
  var style = $2("<support>").get(0).style, prefixes = "Webkit Moz O ms".split(" "), events = {
    transition: {
      end: {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
      }
    },
    animation: {
      end: {
        WebkitAnimation: "webkitAnimationEnd",
        MozAnimation: "animationend",
        OAnimation: "oAnimationEnd",
        animation: "animationend"
      }
    }
  }, tests = {
    csstransforms: function() {
      return !!test("transform");
    },
    csstransforms3d: function() {
      return !!test("perspective");
    },
    csstransitions: function() {
      return !!test("transition");
    },
    cssanimations: function() {
      return !!test("animation");
    }
  };
  function test(property, prefixed2) {
    var result = false, upper = property.charAt(0).toUpperCase() + property.slice(1);
    $2.each((property + " " + prefixes.join(upper + " ") + upper).split(" "), function(i, property2) {
      if (style[property2] !== undefined$1) {
        result = prefixed2 ? property2 : true;
        return false;
      }
    });
    return result;
  }
  function prefixed(property) {
    return test(property, true);
  }
  if (tests.csstransitions()) {
    $2.support.transition = new String(prefixed("transition"));
    $2.support.transition.end = events.transition.end[$2.support.transition];
  }
  if (tests.cssanimations()) {
    $2.support.animation = new String(prefixed("animation"));
    $2.support.animation.end = events.animation.end[$2.support.animation];
  }
  if (tests.csstransforms()) {
    $2.support.transform = new String(prefixed("transform"));
    $2.support.transform3d = tests.csstransforms3d();
  }
})(window.Zepto || window.jQuery);
const owl_carousel = "";
$(document).ready(function() {
  $("#footerCarousel").owlCarousel({
    loop: true,
    autoplay: true,
    nav: false,
    slideTransition: "linear",
    autoplayTimeout: 3e3,
    autoplaySpeed: 3e3,
    autoWidth: true,
    margin: 25,
    autoplayHoverPause: true,
    responsive: {
      0: {
        items: 1
      },
      600: {
        items: 3
      },
      1e3: {
        items: 8
      }
    }
  });
});
